<!DOCTYPE html>
<html lang="en-us"><head>
  <meta charset="utf-8">
  
  <title>Service Mesh - Jimmy Song</title>
  

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta name="description" content="Jimmy Song&#39;s Blog">
  <meta name="author" content="Jimmy Song">
  <meta name="generator" content="Hugo 0.129.0">

  <!-- CSS plugins -->
  
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
  
  <link rel="preload" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" as="style">
  <link rel="stylesheet" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" media="screen">
  

  <!-- Main Stylesheet -->
  
  <link rel="preload" href="/scss/style.min.595949bd12db88434115e2a1e70965cf2928cc646e73acc6437c4cbbc323f585.css" as="style">
  <link rel="stylesheet" href="/scss/style.min.595949bd12db88434115e2a1e70965cf2928cc646e73acc6437c4cbbc323f585.css" media="screen">

  <!-- Bigger picture css -->
  
  <link rel="stylesheet" href="/plugins/bigger-picture/bigger-picture.min.css" media="print" onload="this.media='all'">
  <!--Favicon generate by https://realfavicongenerator.net-->
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="200x200" href="/images/favicon.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">

  <link href='/opensearchdescription.xml' rel='search' title='Content search' type='application/opensearchdescription+xml'/>

  <!--Twitter card-->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="jimmysong.io" />
  <meta name="twitter:creator" content="@jimmysongio" />
  <meta property="og:url" content="https://jimmysong.io/en/tags/service-mesh/" />
  <meta property="og:title" content="Service Mesh | Jimmy Song" />
  <meta property="twitter:title" content="Service Mesh | Jimmy Song" />

  
  <meta property="og:description" content="Jimmy Song&#39;s Blog" />
  <meta property="twitter:description" content="Jimmy Song&#39;s Blog" />

  
  <meta property="og:image" content="https://jimmysong.io/images/banner/default.jpg" />
  <meta property="twitter:image" content="https://jimmysong.io/images/banner/default.jpg" />

  
  
</head>
<body>
<header class="fixed-top header">
  
  
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa fa-arrow-circle-up" aria-hidden="true"></i></button>
  
  <div class="navigation w-100 ">
    <div class="container-xl">
      <nav class="navbar navbar-expand-lg navbar-light p-0">
        <a class="navbar-brand" href="/en">
            
            <b>JIMMY SONG</b>
            
        </a>
        <button class="navbar-toggler rounded-0" type="button" data-toggle="collapse" data-target="#navigation"
          aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse text-center" id="navigation">
          <ul class="navbar-nav ml-auto">
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/blog">Blog</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/book">Book</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/tags">Tags</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/notice">Notice</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/contact">Contact</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/about">About</a>
              
            </li>
            
            

          
          
          <li class="nav-item">
            
            
            
              
              
                
                
                
                  
                    
                    
                  
                
              
              
              
                
                  
                    
                    <a class="nav-link" href="/tags/service-mesh/">中文</a>
                    
                  
                
                
                
              
          </li>
          
          
          <!-- search -->
           <button type="button" class="search-btn js-search" id="searchOpen" aria-label="Search">
              <div class="search-container d-flex justify-content-center">
              <span class="search-content">
                  <i class="fa fa-search"></i>
                  <span>Search</span>
              </span>
              <span class="search-shortcuts d-none d-sm-block">
                  <kbd class="cmd-key">⌘</kbd>
                  <kbd class="k-key">K</kbd>
              </span>
              </div>
          </button>
          
          </ul>
        </div>
      </nav>
    </div>
  </div>
</header>


            <aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between">
        <div class="col-6 search-title">
          <p>Search</p> 
        </div>
        <div class="col-6 col-search-close">
          <div class="js-search" aria-label="Close"><i class="fa-solid fa-circle-xmark text-muted" aria-hidden="true"></i></div>
        </div>
      </div>

      <div id="search-box">
        <i class="fa-solid fa-magnifying-glass" id="search-icon" aria-hidden="true"></i>
        <input name="q" id="search-query" placeholder="Input the keyword" autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control" aria-label="Input the keyword">
        
        <div class="mt-4">
          <span>Search type: </span>
          <span>
            <input type="radio" id="all" name="search_type" value="all" checked>
            <label for="all">All</label>
            
              <input type="radio" id="blog" name="search_type" value="blog">
              <label for="blog">Blog</label>
            
            <input type="radio" id="book" name="search_type" value="book">
            <label for="book">Book</label>
            <input type="radio" id="notice" name="search_type" value="notice">
            <label for="notice">Notice</label>
          </span>
        </div>
      </div>
      
    </section>
    <section class="section-search-results">
      <div id="search-results-count" class="search-results-count"></div>
      <div id="search-hits">
        
      </div>
    </section>
  </div>
</aside>

        
        
            

<section class="bg-cover page-title-section overlay" style="background-image: url('/images/backgrounds/circle.svg'),url('/images/backgrounds/page-title.webp');background-size: cover;">
    <div class="container-xl">
        <div class="row">
            <div class="col-12">
                <p class="h1">
                    Service Mesh
                </p>
                <p class="page-description">
                    
                </p>
                
            </div>
        </div>
    </div>
</section>

        


<section class="section-sm book-list-section bg-gray">
  <div class="container-xl">
    <div class="row">
      <div class="col-lg-8 order-2 order-lg-1">
        <div class="row">
          
          
          
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/what-is-new-in-istio-1-22/">Deep Dive into Istio 1.22: New Features and Practical Application Advice</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Jun 21, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Deep Dive into Istio 1.22: New Features and Practical Application Advice', 'Explore the new features and practical advice of Istio 1.22, including the delta xDS, path template support, and API upgrades, to optimize service mesh management.', '\nThe recent [release of Istio 1.22](https:\/\/istio.io\/latest\/news\/releases\/1.22.x\/announcing-1.22\/) includes a plethora of significant updates. This article shares the new features and application recommendations brought by this release.\n\n## Ambient Mode Enters Beta Phase\n\nAlthough Ambient mode has now entered the Beta phase, this does not mean we can completely do away with Sidecars. While the Istio official claims that Ambient mode simplifies operations and significantly reduces memory and CPU usage, it still has limitations and potential complexity issues. For example, while Sidecars are eliminated, the introduction of new ztunnel and waypoint components may pose new challenges. For more detailed information about Ambient mode entering Beta, refer to the [Istio official blog](https:\/\/istio.io\/latest\/blog\/2024\/ambient-reaches-beta\/).\n\n**Challenges Introduced by Ambient Mode**\n\n- Management of L7 traffic in Ambient mode is not yet mature\n- mTLS is forced to be enabled at the namespace level, meaning you cannot disable mTLS in Ambient mode\n- Zero-downtime upgrades in Ambient mode have not been resolved\n- Lack of best practices for coexistence and migration from Sidecar mode\n\nFor a comparison of Sidecar mode and Ambient mode, see [Analysis of Limitations in Istio Ambient Mode](\/blog\/istio-ambient-mode-limitations\/).\n\n{{\u003c callout note \u0022Recommendation\u0022\u003e}}\nIf you are just starting with Istio, especially if you only need to automatically enable mTLS for services, you can consider using Ambient mode at this stage. However, for L7 functionalities, it is recommended to wait until Ambient mode is fully mature before considering it for production use.\n{{\u003c\/callout\u003e}}\n\n## Istio API Upgrades\n\nIn the Istio 1.22 release, key APIs related to traffic management, security, and telemetry have officially been upgraded to the \u0060v1\u0060 version. You only need to change the API version of your existing configuration to \u0060v1\u0060, with no other changes needed. These APIs are already mature, and you can safely use the \u0060v1\u0060 version. For environments requiring high stability, Istio has added [validating admission policies](https:\/\/kubernetes.io\/docs\/reference\/access-authn-authz\/validating-admission-policy\/) to ensure that only \u0060v1\u0060 APIs and fields can be used in the Istio API.\n\nFor example, the following AuthorizationPolicy example.\n\n\u0060\u0060\u0060yaml {linenos=table,hl_lines=1}\napiVersion: security.istio.io\/v1beta1\nkind: AuthorizationPolicy\nmetadata:\n  name: finance-to-supply-chain\n  namespace: finance\nspec:\n  selector:\n    matchLabels:\n      app: finance-app\n  action: ALLOW\n  rules:\n  - from:\n    - source:\n        namespaces: [\u0022finance\u0022]\n    to:\n    - operation:\n        methods: [\u0022GET\u0022, \u0022POST\u0022]\n        paths: [\u0022\/api\/supply1\u0022, \u0022\/api\/supply2\u0022]\n    when:\n    - key: request.headers[:authority]\n      values: [\u0022supply-chain-service.supply-chain.svc.cluster.local\u0022]\n\u0060\u0060\u0060\n\nOther extension-type APIs such as \u0060EnvoyFilter\u0060, \u0060WasmPlugin\u0060, \u0060ProxyConfig\u0060 are still in alpha or beta stages. For more information on API upgrades, please refer to the [v1 API blog](https:\/\/istio.io\/latest\/blog\/2024\/v1-apis\/).\n\n{{\u003c callout note \u0022Recommendation\u0022\u003e}}\nFor commonly used functionalities, you can confidently use the \u0060v1\u0060 API. For extension-type APIs that are not yet stable, enabling validating admission policies is recommended to ensure system stability.\n{{\u003c\/callout\u003e}}\n\n## Gateway API Upgrade\n\n[Gateway API](\/blog\/why-gateway-api-is-the-future-of-ingress-and-mesh\/) has been updated to version 1.1.0 and is now widely available. This update extends Istio\u0027s traffic management capabilities, but it is important to be cautious of compatibility issues between Istio\u0027s native APIs and the Gateway API when migrating to the new API to avoid relying on features that are not fully mature yet. For more details, check out the [Gateway API v1.1 blog](https:\/\/istio.io\/latest\/blog\/2024\/gateway-mesh-ga\/).\n\n{{\u003c callout note \u0022Recommendation\u0022\u003e}}\nFor existing deployments that are already stable using Istio API, continue using them, especially in scenarios requiring advanced features. For new deployments, consider using the stable version of the Gateway API to take advantage of its modern traffic management capabilities. Due to existing compatibility issues, do not rashly migrate to the Gateway API, as it may not be worth the risk.\n{{\u003c\/ callout\u003e}}\n\n## Delta xDS Enabled by Default\n\nIstio 1.22 version now has delta xDS enabled by default, which is a mechanism to optimize configuration distribution. Compared to the traditional State of the World (SotW) mode, delta xDS only sends changed configurations to the Envoy proxies, thereby significantly reducing the amount of data transmitted over the network and the resource consumption of the control plane. This change is particularly suitable for large-scale deployment environments with frequent configuration updates, improving the efficiency and performance of configuration updates. Additionally, delta xDS also helps manage configuration updates more efficiently in complex network environments or dynamically changing configurations.\n\n{{\u003c callout note \u0022Recommendation\u0022\u003e}}\nThe delta xDS has been developed several versions ago but was not enabled by default. Now that this feature is stable, you can use it with confidence.\n{{\u003c\/callout\u003e}}\n\nFor more on xDS, refer to the [Introduction to Envoy xDS and Configuration Distribution Process in Istio](\/blog\/istio-delta-xds-for-envoy\/).\n\n### Path Template Support with Wildcards for AuthorizationPolicy\n\nIn Istio 1.22, \u0060AuthorizationPolicy\u0060 has added support for [path templates](https:\/\/istio.io\/latest\/docs\/reference\/config\/security\/authorization-policy\/#Operation), greatly enhancing the flexibility and precision of path matching. Prior to this, \u0060AuthorizationPolicy\u0060 did not support wildcards in path configurations. This feature allows for defining paths in HTTP requests using URI templates based on Envoy, including simple wildcards (\u0060*\u0060 and \u0060**\u0060) or named variables, enabling precise matching of single or multiple path components. For example, the path template \u0060\/foo\/{*}\u0060 can match \u0060\/foo\/bar\u0060 but not \u0060\/foo\/bar\/baz\u0060, while \u0060\/foo\/{**}\/\u0060 can match any path starting with \u0060\/foo\/\u0060. This flexible path template design is particularly suitable for dynamic and complex routing rules, further strengthening Istio\u0027s security policy toolbox.\n\nThe diagram below illustrates the wildcard rules for path matching in AuthorizationPolicy.\n\n\u0060\u0060\u0060mermaid \u0022AuthorizationPolicy Path Matching Wildcard Rules\u0022\ngraph LR\n    A[AuthorizationPolicy Path Matching] --\u003e B(Define Path Templates)\n    B --\u003e C{Path Template Operators}\n    C --\u003e D[\u0022* (Match single segment)\u0022]\n    C --\u003e E[\u0022** (Match multiple segments)\u0022]\n    C --\u003e F[\u0022{name} (Named variable matching one segment)\u0022]\n    C --\u003e G[\u0022{name=**} (Named variable matching multiple segments)\u0022]\n\n    D --\u003e H[\u0022\/foo\/{*} matches \/foo\/bar\u0022]\n    E --\u003e I[\u0022\/foo\/{**}\/ matches \/foo\/bar\/, \/foo\/bar\/baz.txt\u0022]\n    F --\u003e J[\u0022\/videos\/{file} matches \/videos\/1080p5000_00001.m4s\u0022]\n    G --\u003e K[\u0022\/**.mpd matches \/content\/123\/india\/dash\/55\/manifest.mpd\u0022]\n\u0060\u0060\u0060\n\n![AuthorizationPolicy Path Matching Wildcard Rules](dfe9a5d5e2bc91e91e7e24017f56a3db.svg)\n\nFor more on the specific applications and rules of path templates, you can refer to [Envoy\u0027s official documentation](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-v3\/extensions\/path\/match\/uri_template\/v3\/uri_template_match.proto).\n\n{{\u003c callout note \u0022Tip\u0022\u003e}}\n\u0060AuthorizationPolicy\u0060 finally supports templates in path matching, so you no longer need to manually add paths one by one in your configurations.\n{{\u003c\/callout\u003e}}\n\n## Summary\n\nThe Istio 1.22 release introduces several important updates and improvements. Although some features are widely publicized, they require detailed assessment and appropriate testing in practical use. Hopefully, this blog post helps you understand and apply these new features more deeply to achieve the best results in practice.\n\n## References\n\n- [Gateway API v1.1: Service mesh, GRPCRoute, and a whole lot more - kubernetes.io](https:\/\/kubernetes.io\/blog\/2024\/05\/09\/gateway-api-v1-1\/)\n\n---\n\nThis blog was initially published at [tetrate.io](https:\/\/tetrate.io\/blog\/istio-service-mesh-new-features-v1_22\/).', '\/en\/blog\/what-is-new-in-istio-1-22\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">Explore the new features and practical advice of Istio 1.22, including the delta xDS, path template support, and API upgrades, to optimize service mesh management.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/envoy-gateway-introduction/">Envoy Gateway Overview: Modern Kubernetes Ingress with Envoy Gateway and the Gateway API</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               May 16, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/envoy"> 
             Envoy
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Envoy Gateway Overview: Modern Kubernetes Ingress with Envoy Gateway and the Gateway API', 'This article explores the advantages of deploying Envoy Gateway on Kubernetes, its relationship with other service mesh components, and why it\u0027s the ideal choice for exposing services to the public internet.', '\nSelecting the right networking tool in a Kubernetes environment is crucial. According to [Tetrate\u0027s discussion](https:\/\/tetrate.io\/blog\/do-i-need-a-gateway-or-a-service-mesh\/), the choice depends on the type of network traffic: north-south or east-west. For services primarily handling external requests, Envoy Gateway is the ideal choice. It not only efficiently manages traffic but also seamlessly integrates as you transition to a microservices architecture.\n\nThis article explores the advantages of deploying Envoy Gateway on Kubernetes, its relationship with other service mesh components, and why it\u0027s the ideal choice for exposing services to the public internet.\n\n## Overview of Envoy Gateway and its Role in Service Mesh\n\nEnvoy Gateway is a Kubernetes-native API gateway built around Envoy Proxy. It aims to lower the barrier for users adopting Envoy as an API gateway and lays the foundation for vendors to build value-added products like [Tetrate Enterprise Gateway for Envoy](https:\/\/tetrate.io\/tetrate-enterprise-gateway-for-envoy\/).\n\nEnvoy Gateway is not only an ideal choice for managing north-south traffic but also serves as a crucial component for connecting and securing services within the service mesh. It enhances communication efficiency and security among microservices by providing features such as secure data transmission, traffic routing, load balancing, and fault recovery. Leveraging its built-in Envoy Proxy technology, Envoy Gateway can handle a large number of concurrent connections and complex traffic management policies while maintaining low latency and high throughput.\n\nFurthermore, the tight integration of Envoy Gateway with the Kubernetes Gateway API allows for declarative configuration and management, significantly simplifying the deployment and update processes of gateways within the service mesh. This integration not only improves operational efficiency but also enables Envoy Gateway to seamlessly collaborate with solutions like Istio without adding extra complexity.\n\nThe figure below illustrates the relationship between Envoy Gateway and the service mesh.\n\n\u0060\u0060\u0060mermaid\ngraph TB\n    subgraph Kubernetes[\u0022Kubernetes Cluster\u0022]\n        eg[\u0022Envoy Gateway\u0022]\n        svcs[\u0022Services\u0022]\n        pods[\u0022Pods\u0022]\n        gwapi[\u0022Kubernetes Gateway API\u0022]\n        eg -- \u0022Manages North-South Traffic\u0022 --\u003e svcs\n        eg -- \u0022Configured by\u0022 --\u003e gwapi\n        gwapi -. \u0022Defines routing specs\u0022 .-\u003e svcs\n    end\n\n    subgraph SM[\u0022Service Mesh\u0022]\n        smc[\u0022Service Mesh Control Plane (e.g., Istio, Linkerd)\u0022]\n        smp[\u0022Service Mesh Data Plane (Envoy Sidecars)\u0022]\n        smc -- \u0022Configures\u0022 --\u003e smp\n        smp -- \u0022Handles East-West Traffic\u0022 --\u003e pods\n    end\n\n    eg -.-\u003e smp\n    svcs -. \u0022Part of\u0022 .-\u003e SM\n    svcs -- \u0022Connects to\u0022 --\u003e pods\n\u0060\u0060\u0060\n\n![Mermaid Diagram](17a407873a0c96afbde9bb6b252814d4.svg)\n\n\n\nIn a Kubernetes cluster, Envoy Gateway is responsible for managing north-south traffic, i.e., traffic entering and leaving the cluster, and is configured through the Kubernetes Gateway API, which defines routing specifications for services. Services within the cluster directly connect to pods. In the service mesh, the control plane (e.g., Istio or Linkerd) configures Envoy sidecars in the data plane, which handles east-west traffic within the cluster. In this system, Envoy Gateway can collaborate with the service mesh, but they independently manage traffic in different directions.\n\nThink of Envoy Gateway as the main entry point to a city (e.g., customs), where all traffic (like various vehicles) must pass through. It acts as a strict gatekeeper, responsible for inspection and guidance, ensuring each packet (like each passenger) is accurately delivered to its destination. In the city of Kubernetes, Envoy Gateway manages all inbound traffic, ensuring data flows securely and efficiently into the city and is accurately delivered to services within the city.\n\nOnce inside the city, the service mesh takes over, acting as a series of transportation networks within the city. Envoy sidecars in the service mesh are like taxis or buses within the city, responsible for transporting packets from the port to their specific destinations within the city. Envoy Gateway ensures smooth entry for external requests, and then the service mesh efficiently handles these requests within the cluster.\n\nThe support for Kubernetes Gateway API by Envoy Gateway can be seen as a significant upgrade to our city\u0027s traffic signal system. It not only provides clearer and more personalized guidance for incoming data flows but also makes the entire city\u0027s traffic operations more intelligent.\n\n## Core Features and Advantages of Envoy Gateway\n\nEnvoy Gateway offers several core features that make it a prominent choice for an API gateway:\n\n- **Simplified Configuration**: Through direct integration with the Kubernetes Gateway API, Envoy Gateway allows developers to use Kubernetes custom resources to declaratively configure routing rules, security policies, and traffic management.\n- **Performance and Scalability**: Built on battle-tested Envoy Proxy, it delivers outstanding performance and scalability, effortlessly handling thousands of services and millions of requests per second.\n- **Security Features**: Built-in support for various security measures such as SSL\/TLS termination, OAuth2, OIDC authentication, and fine-grained access control.\n- **Observability**: Provides comprehensive monitoring capabilities including detailed metrics, logs, and tracing, crucial for diagnosing and understanding traffic behavior.\n\n## Relationship with Gateway API\n\nThe introduction of the Gateway API in Kubernetes provides a powerful new way to integrate and configure ingress gateways, offering higher flexibility and functionality compared to traditional ingress. As discussed in [this blog](https:\/\/tetrate.io\/blog\/introducing-the-gateway-api\/), the Gateway API simplifies gateway management, allowing developers to define custom routing rules, TLS termination policies, and traffic policies using Kubernetes-native resources.\n\nThe Kubernetes Gateway API serves as the cornerstone of Envoy Gateway, providing a more expressive, flexible, and role-based approach to configuring gateways and routes within the Kubernetes ecosystem. This API offers custom resource definitions (CRDs) such as GatewayClass, Gateway, HTTPRoute, etc. Envoy Gateway utilizes these resources to create a user-friendly and consistent configuration model that aligns with Kubernetes\u0027 native principles.\n\n{{\u003ccallout note \u0022What is an API Gateway?\u0022\u003e}}\n\nAn API Gateway is a comprehensive management and hosting service for APIs. Serving as an intermediary layer between applications and backend services, it not only handles lifecycle events like creation, maintenance, deployment, running, and retiring but also performs additional critical functions. A robust API Gateway should provide the following features to enhance and extend its basic definition:\n\n1. **Traffic Control**: Ability to manage and control traffic to backend services, including request routing, load balancing, circuit breaking, and rate limiting, ensuring the stability and high availability of backend services.\n2. **Security Assurance**: Authentication, authorization, and encryption capabilities to effectively manage and protect API security. This involves authentication mechanisms, API key management, OAuth, JWT, mTLS, etc., ensuring that only authorized users and services can access the API.\n3. **Monitoring and Analytics**: Real-time monitoring and logging functionalities to track API usage, performance metrics, anomaly detection, and traffic pattern analysis, optimizing API performance and responsiveness.\n4. **Change Management**: Support for managing API changes, including version control and progressive deployment (such as blue-green or canary release), for seamless transition to new versions while minimizing impact on end users.\n5. **Request and Response Transformation**: Allow transformation of incoming and outgoing API calls, such as from REST to GraphQL, or adding, removing, and modifying request and response headers.\n6. **Cross-Origin Resource Sharing (CORS) Support**: Manage and control cross-origin requests, allowing frontend applications from different domains to securely call backend APIs.\n7. **Quotas and Billing**: Set quota limits for API usage, while also supporting billing functionalities for commercialized API offerings.\n8. **Developer-Friendly Developer Portal**: Provide a developer-facing portal, enabling third-party developers to easily discover, test, and integrate APIs.\n9. **Protocol Support**: Support for various network protocols, including HTTP\/HTTPS, WebSocket, gRPC, etc., ensuring compatibility with a variety of clients and services.\n10. **Plug-ability and Extensibility**: Allow extension of API Gateway functionality through plugins or middleware, enabling flexible adaptation to various middleware services based on business requirements.\n11. **Service Governance**: Integration with service registration and discovery mechanisms to accommodate the dynamics of services in a microservices architecture.\n\nIn conclusion, the role of an API Gateway extends far beyond simple API lifecycle management. It is a key component in realizing microservices architecture, ensuring service security, improving operational efficiency, and optimizing user experience. Through these extensive functionalities, the API Gateway becomes an indispensable part of modern cloud-native applications.\n\n{{\u003c\/callout\u003e}}\n\n## Overview of Envoy Gateway Architecture\n\nThe architecture of Envoy Gateway is designed to be lightweight and concise. It consists of a control plane that dynamically configures an Envoy proxy running as the data plane. This separation of concerns ensures that the gateway can scale with increasing traffic without affecting the efficiency of the control plane.\n\nThe architecture diagram of Envoy Gateway is shown below.\n\n![Envoy Gateway Architecture Diagram](envoy-gateway-arch.svg)\n\nAt the core of this architecture is the Envoy Gateway, which is an instance of the Envoy proxy responsible for handling all traffic in and out of the Kubernetes cluster. Upon initial startup, Envoy Gateway provides static configuration through configuration files, establishing the basic parameters of its operation.\n\nThe dynamic aspect of Envoy Gateway configuration is handled by providers, which define the interaction between the gateway and Kubernetes or other dynamic configuration input sources. The resource monitor is responsible for monitoring changes to Kubernetes resources, with particular attention to CRUD operations related to custom resource definitions (CRDs).\n\nAs changes occur, resource transformers intervene to translate these external resources into a form understandable by Envoy Gateway. This transformation process is further facilitated by provider-specific infrastructure managers, which are responsible for managing resources related to specific clouds or infrastructure providers, shaping the infrastructure into an intermediate representation crucial for the gateway\u0027s functionality.\n\nThis intermediate representation then transforms into the xDS intermediate representation, serving as the precursor to the final xDS configuration understood and executed by Envoy. The xDS translator plays the role of converting this intermediate representation into specific xDS configurations.\n\nThese configurations are delivered and executed by xDS servers, which act as services diligently managing Envoy instances based on the xDS configurations they receive. As the actual running proxy, Envoy ultimately receives these configurations from xDS servers, interprets them, and implements them to effectively manage traffic requests.\n\nUltimately, all requests are redirected to the final destination of Envoy Gateway routes for traffic, which are the backend services.\n\n## Comparison with Other Gateways\n\nCompared to other popular solutions such as Istio\u0027s Ingress Gateway or NGINX Ingress, Envoy Gateway stands out with its native integration with Kubernetes and its focus on leveraging the full potential of Envoy. The table below compares various open-source API gateways from multiple aspects.\n\n| **API Gateway** | **Supported Authentication \u0026 Authorization Strategies**      | **Supported Service Discovery Components** | **Supported Protocols**          | **Control Plane Configuration Distribution Method** | **Supported Plugin Extension Mechanism** | **Foundation Affiliation** |\n| --------------- | ------------------------------------------------------------ | ------------------------------------------ | -------------------------------- | --------------------------------------------------- | ---------------------------------------- | -------------------------- |\n| Envoy Gateway   | OAuth2, JWT, mTLS, OIDC                                      | Kubernetes, EDS                            | HTTP, HTTPS, gRPC                | xDS                                                 | Envoy Filter Based                       | CNCF                       |\n| Kuma            | mTLS, JWT                                                    | Kubernetes, Consul                         | HTTP, HTTPS, gRPC, TCP           | REST, gRPC                                          | Lua, Go Based                            | CNCF                       |\n| NGINX Ingress   | RBAC                                                         | Kubernetes                                 | HTTP, HTTPS, TCP, UDP            | Kubernetes CRD                                      | Nginx Module Based                       | N\/A                        |\n| APISIX          | OAuth2, JWT, Key Auth, Basic Auth, mTLS, OIDC, LDAP, OpenID, and others | Kubernetes, DNS, Consul, Nacos, Eureka     | HTTP, HTTPS, TCP, UDP, WebSocket | REST, CLI, Web UI                                   | Lua, Wasm Based                          | Apache Software Foundation |\n| Kong            | OAuth2, JWT, Basic Auth, Key Auth                            | Kubernetes, DNS, Consul                    | HTTP, HTTPS, gRPC, WebSocket     | REST, gRPC, Web UI                                  | Lua Based                                | N\/A                        |\n| Emissary        | Basic Auth                                                   | Kubernetes                                 | HTTP, HTTPS, gRPC                | Kubernetes CRD                                      | Lua, Go Based                            | CNCF                       |\n\n## Quick Start with Envoy Gateway\n\nTo quickly get started with Envoy Gateway, you can set up a local experimental environment using the following simplified steps. First, start a local Kubernetes cluster:\n\n\u0060\u0060\u0060bash\nminikube start --driver=docker --cpus=2 --memory=2g\n\u0060\u0060\u0060\n\nNext, deploy the Gateway API CRD and Envoy Gateway itself:\n\n\u0060\u0060\u0060bash\nhelm install eg oci:\/\/docker.io\/envoyproxy\/gateway-helm --version v1.0.1 -n envoy-gateway-system --create-namespace\n\u0060\u0060\u0060\n\nThen, install the gateway configuration and deploy a sample application:\n\n\u0060\u0060\u0060bash\nkubectl apply -f https:\/\/github.com\/envoyproxy\/gateway\/releases\/download\/v1.0.1\/quickstart.yaml -n default\n\u0060\u0060\u0060\n\nTo expose the LoadBalancer service, here we use port forwarding as an example. You can also choose to use \u0060minikube tunnel\u0060 or install [MetalLB](https:\/\/metallb.universe.tf\/installation\/) as a load balancer:\n\n\u0060\u0060\u0060bash\nexport ENVOY_SERVICE=$(kubectl get svc -n envoy-gateway-system --selector=gateway.envoyproxy.io\/owning-gateway-namespace=default,gateway.envoyproxy.io\/owning-gateway-name=eg -o jsonpath=\u0027{.items[0].metadata.name}\u0027)\nkubectl -n envoy-gateway-system port-forward service\/${ENVOY_SERVICE} 8888:80 \u0026\n\u0060\u0060\u0060\n\nTest if your Envoy Gateway is working properly with the following command:\n\n\u0060\u0060\u0060bash\ncurl --verbose --header \u0022Host: www.example.com\u0022 http:\/\/localhost:8888\/get\n\u0060\u0060\u0060\n\nFor more detailed installation and configuration steps, visit the Envoy Gateway website. With these steps, you can quickly start exploring the capabilities of Envoy Gateway.\n\n## Conclusion\n\nEnvoy Gateway not only optimizes Layer 7 gateway configuration in the cloud-native era but also provides a smooth transition from edge gateways to service meshes. As the promotion of service meshes faces some challenges, such as the intrusiveness to applications and issues driving by operations teams, edge gateways are more readily accepted by development teams. Envoy Gateway, with its simplified Kubernetes Gateway API, enhances traffic management and observability capabilities. Additionally, the transition from Envoy Gateway to Istio is a confident technical advancement for teams already familiar with Envoy features, supporting seamless switching from the standard Kubernetes Gateway API to Istio Ingress Gateway or continuing to collaborate with Istio as a custom solution. These features make Envoy Gateway a gateway choice worth investing in the cloud-native era.\n\nStay tuned for the subsequent parts of this blog series, where we will delve into configuring and optimizing Envoy Gateway, providing practical guides, and showcasing a wider range of real-world use cases.\n\n---\n\nThis blog was initially published at [tetrate.io](https:\/\/tetrate.io\/blog\/envoy-microservices-overview\/).\n', '\/en\/blog\/envoy-gateway-introduction\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">This article explores the advantages of deploying Envoy Gateway on Kubernetes, its relationship with other service mesh components, and why it&#39;s the ideal choice for exposing services to the public internet.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/distributed-tracing-with-skywalking-in-istio/">How to Use SkyWalking for Distributed Tracing in Istio?</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Jan 4, 2023</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('How to Use SkyWalking for Distributed Tracing in Istio?', 'This blog will guide you to use SkyWalking for distributed tracing with Istio.', '\nIn cloud native applications, a request often needs to be processed through a series of APIs or backend services, some of which are parallel and some serial and located on different platforms or nodes. How do we determine the service paths and nodes a call goes through to help us troubleshoot the problem? This is where distributed tracing comes into play.\n\nThis article covers:\n\n- How distributed tracing works\n- How to choose distributed tracing software\n- How to use distributed tracing in Istio\n- How to view distributed tracing data using Bookinfo and SkyWalking as examples\n\n## Distributed Tracing Basics\n\nDistributed tracing is a method for tracing requests in a distributed system to help users better understand, control, and optimize distributed systems. There are two concepts used in distributed tracing: TraceID and SpanID. You can see them in Figure 1 below.\n\n- **TraceID** is a globally unique ID that identifies the trace information of a request. All traces of a request belong to the same TraceID, and the TraceID remains constant throughout the trace of the request.\n- **SpanID** is a locally unique ID that identifies a request’s trace information at a certain time. A request generates different SpanIDs at different periods, and SpanIDs are used to distinguish trace information for a request at different periods.\n\nTraceID and SpanID are the basis of distributed tracing. They provide a uniform identifier for request tracing in distributed systems and facilitate users’ ability to query, manage, and analyze the trace information of requests.\n\n![Figure 1: Trace and span](basic.svg)\n\nThe following is the process of distributed tracing:\n\n- When a system receives a request, the distributed tracing system assigns a TraceID to the request, which is used to chain together the entire chain of invocations.\n- The distributed trace system generates a SpanID and ParentID for each service call within the system for the request, which is used to record the parent-child relationship of the call; a Span without a ParentID is used as the entry point of the call chain.\n- TraceID and SpanID are to be passed during each service call.\n- When viewing a distributed trace, query the full process of a particular request by TraceID.\n\n## How Istio Implements Distributed Tracing\n\nIstio’s distributed tracing is based on information collected by the Envoy proxy in the data plane. After a service request is intercepted by Envoy, Envoy adds tracing information as headers to the request forwarded to the destination workload. The following headers are relevant for distributed tracing:\n\n- As TraceID: x-request-id\n- Used to establish parent-child relationships for Span in the LightStep trace: x-ot-span-context\u003c\/li\n- Used for Zipkin, also for Jaeger, SkyWalking, see [b3-propagation](https:\/\/github.com\/openzipkin\/b3-propagation):\n  - *x-b3-traceid*\n  - *x-b3-traceid*\n  - *x-b3-spanid*\n  - *x-b3-parentspanid*\n  - *x-b3-sampled*\n  - *x-b3-flags*\n  - *b3*\n- For Datadog:\n  - *x-datadog-trace-id*\n  - *x-datadog-parent-id*\n  - *x-datadog-sampling-priority*\n- For SkyWalking: *sw8*\n- For AWS X-Ray: *x-amzn-trace-id*\n\nFor more information on how to use these headers, please see the [Envoy documentation](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/configuration\/http\/http_conn_man\/headers).\n\nRegardless of the language of your application, Envoy will generate the appropriate tracing headers for you at the Ingress Gateway and forward these headers to the upstream cluster. However, in order to utilize the distributed tracing feature, you must modify your application code to attach the tracing headers to upstream requests. Since neither the service mesh nor the application can automatically propagate these headers, you can integrate the agent for distributed tracing into the application or manually propagate these headers in the application code itself. Once the tracing headers are propagated to all upstream requests, Envoy will send the tracing data to the tracer’s back-end processing, and then you can view the tracing data in the UI.\n\nFor example, look at the code of the Productpage service in the [Bookinfo application](https:\/\/istio.io\/latest\/docs\/examples\/bookinfo\/). You can see that it integrates the Jaeger client library and synchronizes the header generated by Envoy with the HTTP requests to the Details and Reviews services in the *getForwardHeaders (request)* function.\n\n\u0060\u0060\u0060python\ndef getForwardHeaders(request):\n    headers = {}\n\n    # Using Jaeger agent to get the x-b3-* headers\n    span = get_current_span()\n    carrier = {}\n    tracer.inject(\n        span_context=span.context,\n        format=Format.HTTP_HEADERS,\n        carrier=carrier)\n\n    headers.update(carrier)\n\n    # Dealing with the non x-b3-* header manually\n    if \u0027user\u0027 in session:\n        headers[\u0027end-user\u0027] = session[\u0027user\u0027]\n    incoming_headers = [\n        \u0027x-request-id\u0027,\n        \u0027x-ot-span-context\u0027,\n        \u0027x-datadog-trace-id\u0027,\n        \u0027x-datadog-parent-id\u0027,\n        \u0027x-datadog-sampling-priority\u0027,\n        \u0027traceparent\u0027,\n        \u0027tracestate\u0027,\n        \u0027x-cloud-trace-context\u0027,\n        \u0027grpc-trace-bin\u0027,\n        \u0027sw8\u0027,\n        \u0027user-agent\u0027,\n        \u0027cookie\u0027,\n        \u0027authorization\u0027,\n        \u0027jwt\u0027,\n    ]\n\n    for ihdr in incoming_headers:\n        val = request.headers.get(ihdr)\n        if val is not None:\n            headers[ihdr] = val\n\n    return headers\n\u0060\u0060\u0060\n\nFor more information, the [Istio documentation](https:\/\/istio.io\/latest\/about\/faq\/#distributed-tracing) provides answers to frequently asked questions about distributed tracing in Istio.\n\n## How to Choose A Distributed Tracing System\n\nDistributed tracing systems are similar in principle. There are many such systems on the market, such as [Apache SkyWalking](https:\/\/github.com\/apache\/skywalking), [Jaeger](https:\/\/github.com\/jaegertracing\/jaeger), [Zipkin](https:\/\/github.com\/openzipkin\/zipkin\/), Lightstep, [Pinpoint](https:\/\/github.com\/pinpoint-apm\/pinpoint), and so on. For our purposes here, we will choose three of them and compare them in several dimensions. Here are our inclusion criteria:\n\n- They are currently the most popular open-source distributed tracing systems.\n- All are based on the OpenTracing specification.\n- They support integration with Istio and Envoy.\n\n| Items               | Apache SkyWalking                                            | Jaeger                                       | Zipkin                                       |\n| ------------------- | ------------------------------------------------------------ | -------------------------------------------- | -------------------------------------------- |\n| Implementations     | Language-based probes, service mesh probes, eBPF agent, third-party instrumental libraries (Zipkin currently supported) | Language-based probes                        | Language-based probes                        |\n| Database            | ES, H2, MySQL, TiDB, Sharding-sphere, BanyanDB               | ES, MySQL, Cassandra, Memory                 | ES, MySQL, Cassandra, Memory                 |\n| Supported Languages | Java, Rust, PHP, NodeJS, Go, Python, C\u002b\u002b, .Net, Lua          | Java, Go, Python, NodeJS, C#, PHP, Ruby, C\u002b\u002b | Java, Go, Python, NodeJS, C#, PHP, Ruby, C\u002b\u002b |\n| Initiator           | Personal                                                     | Uber                                         | Twitter                                      |\n| Governance          | Apache Foundation                                            | CNCF                                         | CNCF                                         |\n| Version             | 9.3.0                                                        | 1.39.0                                       | 2.23.19                                      |\n| Stars               | 20.9k                                                        | 16.8k                                        | 15.8k                                        |\n\nAlthough Apache SkyWalking’s agent does not support as many languages as Jaeger and Zipkin, SkyWalking’s implementation is richer and compatible with Jaeger and Zipkin trace data, and development is more active, so it is one of the best choices for building a telemetry platform.\n\n## Demo\n\nRefer to the [Istio documentation](https:\/\/istio.io\/latest\/docs\/tasks\/observability\/distributed-tracing\/skywalking\/) to install and configure Apache SkyWalking.\n\n### Environment Description\n\nThe following is the environment for our demo:\n\n- Kubernetes 1.24.5\n- Istio 1.16\n- SkyWalking 9.1.0\n\n### Install Istio\n\nBefore installing Istio, you can check the environment for any problems:\n\n\u0060\u0060\u0060bash\n$ istioctl experimental precheck\n✔ No issues found when checking the cluster. Istio is safe to install or upgrade!\n  To get started, check out https:\/\/istio.io\/latest\/docs\/setup\/getting-started\/\n\u0060\u0060\u0060\n\nThen install Istio and configure the destination for sending tracing messages as SkyWalking:\n\n\u0060\u0060\u0060bash\n# Initial Istio Operator\nistioctl operator init\n# Configure tracing destination\nkubectl apply -f - \u003c\u003cEOF\napiVersion: install.istio.io\/v1alpha1\nkind: IstioOperator\nmetadata:\n  namespace: istio-system\n  name: istio-with-skywalking\nspec:\n  meshConfig:\n    defaultProviders:\n      tracing:\n      - \u0022skywalking\u0022\n    enableTracing: true\n    extensionProviders:\n    - name: \u0022skywalking\u0022\n      skywalking:\n        service: tracing.istio-system.svc.cluster.local\n        port: 11800\nEOF\n\u0060\u0060\u0060\n\n## Deploy Apache SkyWalking\n\nIstio 1.16 supports distributed tracing using Apache SkyWalking. Install SkyWalking by executing the following code:\n\n\u0060\u0060\u0060bash\nkubectl apply -f \nhttps:\/\/raw.githubusercontent.com\/istio\/istio\/release-1.16\/samples\/addons\/extras\/skywalking.yaml\n\u0060\u0060\u0060\n\nIt will install the following components under the *istio-system* namespace:\n\n- SkyWalking Observability Analysis Platform (OAP): Used to receive trace data, supports SkyWalking native data formats, Zipkin v1 and v2 and Jaeger format.\n- UI: Used to query distributed trace data.\n\nFor more information about SkyWalking, please refer to the SkyWalking documentation.\n\n## Deploy the Bookinfo Application\n\nExecute the following command to install the bookinfo application:\n\n\u0060\u0060\u0060bash\nkubectl label namespace default istio-injection=enabled\nkubectl apply -f samples\/bookinfo\/platform\/kube\/bookinfo.yaml\nkubectl apply -f samples\/bookinfo\/networking\/bookinfo-gateway.yaml\n\u0060\u0060\u0060\n\nLaunch the SkyWalking UI:\n\n\u0060\u0060\u0060bash\nistioctl dashboard skywalking\n\u0060\u0060\u0060\n\nFigure 2 shows all the services available in the bookinfo application:\n\n![Figure 2: SkyWalking General Service page](general-service.jpg)\n\nYou can also see information about instances, endpoints, topology, tracing, etc. For example, Figure 3 shows the service topology of the bookinfo application:\n\n![Figure 3: Topology diagram of the Bookinfo application](topology.jpg)\n\nTracing views in SkyWalking can be displayed in a variety of formats, including list, tree, table, and statistics. See Figure 4:\n\n![Figure 4: SkyWalking General Service trace supports multiple display formats](gs-styles.jpg)\n\nTo facilitate our examination, set the sampling rate of the trace to 100%:\n\n\u0060\u0060\u0060bash\nkubectl apply -f - \u003c\u003cEOF\napiVersion: telemetry.istio.io\/v1alpha1\nkind: Telemetry\nmetadata:\n  name: mesh-default\n  namespace: istio-system\nspec:\n  tracing:\n  - randomSamplingPercentage: 100.00\nEOF\n\u0060\u0060\u0060\n\n\u003e **Important:** *It’s generally not good practice to set the sampling rate to 100% in a production environment. To avoid the overhead of generating too many trace logs in production, please adjust the sampling strategy (sampling percentage).*\n\n## Uninstall\n\nAfter experimenting, uninstall Istio and SkyWalking by executing the following command.\n\n\u0060\u0060\u0060bash\nsamples\/bookinfo\/platform\/kube\/cleanup.sh\nistioctl unintall --purge\nkubectl delete namespace istio-system\n\u0060\u0060\u0060\n\n## Understanding the Bookinfo Tracing Information\n\nNavigate to the General Service tab in the Apache SkyWalking UI, and you can see the trace information for the most recent *istio-ingressgateway* service, as shown in Figure 5. Click on each span to see the details.\n\n![Figure 5: The table view shows the basic information about each span.](span-table.jpg)\n\nSwitching to the list view, you can see the execution order and duration of each span, as shown in Figure 6:\n\n![Figure 6: List display](trace-list.jpg)\n\nYou might want to know why such a straightforward application generates so much span data. Because after we inject the Envoy proxy into the pod, every request between services will be intercepted and processed by Envoy, as shown in Figure 7:\n\n![Figure 7: Envoy intercepts requests to generate a span](span.svg)\n\nThe tracing process is shown in Figure 8:\n\n![Figure 8: Trace of the Bookinfo application](bookinfo-spans-with-time.svg)\n\nWe give each span a label with a serial number, and the time taken is indicated in parentheses. For illustration purposes, we have summarized all spans in the table below.\n\n| No.  | Endpoint     | Total Duration (ms) | Component Duration (ms) | Current Service      | Description                                 |\n| ---- | ------------ | ------------------- | ----------------------- | -------------------- | ------------------------------------------- |\n| 1    | \/productpage | 190                 | 0                       | istio-ingressgateway | Envoy Outbound                              |\n| 2    | \/productpage | 190                 | 1                       | istio-ingressgateway | Ingress -\u003e Productpage network transmission |\n| 3    | \/productpage | 189                 | 1                       | productpage          | Envoy Inbound                               |\n| 4    | \/productpage | 188                 | 21                      | productpage          | Application internal processing             |\n| 5    | \/details\/0   | 8                   | 1                       | productpage          | Envoy Outbound                              |\n| 6    | \/details\/0   | 7                   | 3                       | productpage          | Productpage -\u003e Details network transmission |\n| 7    | \/details\/0   | 4                   | 0                       | details              | Envoy Inbound                               |\n| 8    | \/details\/0   | 4                   | 4                       | details              | Application internal processing             |\n| 9    | \/reviews\/0   | 159                 | 0                       | productpage          | Envoy Outbound                              |\n| 10   | \/reviews\/0   | 159                 | 14                      | productpage          | Productpage -\u003e Reviews network transmission |\n| 11   | \/reviews\/0   | 145                 | 1                       | reviews              | Envoy Inbound                               |\n| 12   | \/reviews\/0   | 144                 | 109                     | reviews              | Application internal processing             |\n| 13   | \/ratings\/0   | 35                  | 2                       | reviews              | Envoy Outbound                              |\n| 14   | \/ratings\/0   | 33                  | 16                      | reviews              | Reviews -\u003e Ratings network transmission     |\n| 15   | \/ratings\/0   | 17                  | 1                       | ratings              | Envoy Inbound                               |\n| 16   | \/ratings\/0   | 16                  | 16                      | ratings              | Application internal processing             |\n\nFrom the above information, it can be seen that:\n\n- The total time consumed for this request is 190 ms.\n- In Istio sidecar mode, each traffic flow in and out of the application container must pass through the Envoy proxy once, each time taking 0 to 2 ms.\n- Network requests between Pods take between 1 and 16ms.\n- This is because the data itself has errors and the start time of the Span is not necessarily equal to the end time of the parent Span.\n- We can see that the most time-consuming part is the Reviews application, which takes 109 ms so that we can optimize it for that application.\n\n## Summary\n\nDistributed tracing is an indispensable tool for analyzing performance and troubleshooting modern distributed applications. In this tutorial, we’ve seen how, with just a few minor changes to your application code to propagate tracing headers, Istio makes distributed tracing simple to use. We’ve also reviewed [Apache SkyWalking](https:\/\/skywalking.apache.org\/) as one of the best distributed tracing systems that Istio supports. It is a fully functional platform for cloud native application analytics, with features such as metrics and log collection, alerting, Kubernetes monitoring, [service mesh performance diagnosis using eBPF](https:\/\/skywalking.apache.org\/blog\/diagnose-service-mesh-network-performance-with-ebpf\/), and more.\n\n---\n\nIf you’re new to service mesh and Kubernetes security, we have a bunch of free online courses [available at Tetrate Academy](https:\/\/tetr8.io\/academy) that will quickly get you up to speed with Istio and Envoy.\n\nIf you’re looking for a fast way to get to production with Istio, check out [Tetrate Istio Distribution (TID)](https:\/\/tetr8.io\/tid). TID is Tetrate’s hardened, fully upstream Istio distribution, with FIPS-verified builds and support available. It’s a great way to get started with Istio knowing you have a trusted distribution to begin with, have an expert team supporting you, and also have the option to get to FIPS compliance quickly if you need to.\n\nOnce you have Istio up and running, you will probably need simpler ways to manage and secure your services beyond what’s available in Istio, that’s where Tetrate Service Bridge comes in. You can learn more about how Tetrate Service Bridge makes service mesh more secure, manageable, and resilient [here](https:\/\/tetr8.io\/tsb), or [contact us for a quick demo](https:\/\/tetr8.io\/contact).\n\n*This blog was originally published at [tetrate.io](https:\/\/tetrate.io\/blog\/how-to-use-skywalking-for-distributed-tracing-in-istio\/).*\n', '\/en\/blog\/distributed-tracing-with-skywalking-in-istio\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">This blog will guide you to use SkyWalking for distributed tracing with Istio.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/understanding-the-tls-encryption-in-istio/">How Istio’s mTLS Traffic Encryption Works as Part of a Zero Trust Security Posture</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Dec 24, 2022</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('How Istio’s mTLS Traffic Encryption Works as Part of a Zero Trust Security Posture', 'This article introduces TLS and mTLS, and describes how to enable mTLS in Istio and its application scenarios.', '\nThe Istio service mesh offers cloud native deployments a standard way to implement automatic [mutual transport layer security (mTLS)](https:\/\/en.wikipedia.org\/wiki\/Mutual_authentication#mTLS). This reduces the attack surface of network communication by using strong identities to establish encrypted channels between workloads within the mesh that are both confidential and tamper-resistant. mTLS is a key component for building zero-trust application networks. To understand mTLS traffic encryption in Istio, this article will cover the following:\n\n- An overview of TLS, mTLS, and TLS termination\n- An introduction to howTLS encryption works in Istio\n- How to use Istio to implement mTLS in Kubernetes\n- A discussion of when you do and don’t need mTLS\n\n## What Is TLS and mTLS?\n\nTLS, the successor to Secure Sockets Layer (SSL), is a widely adopted security protocol used to create authenticated and encrypted connections between networked computers. For this reason, people often use the terms TLS and SSL interchangeably. In this article, we will refer to them collectively as TLS. TLS 1.0 was released in 1999, and the latest version is 1.3 (released in August 2018); versions 1.0 and 1.1 are deprecated.\n\nThe HTTPS we see when browsing the web uses TLS, as shown in Figure 1, which is built on top of TCP as the session layer in the OSI model. To ensure compatibility, TLS usually uses port 443, but you can use any port you want.\n\n![Figure 1: HTTP vs. HTTPS](http-vs-https.svg)\n\nTLS encryption is required when a client needs to confirm the identity of the server in order to guard against man-in-the-middle attacks and ensure communication security. Figure 2 shows how TLS-encrypted communication proceeds.\n\n![Figure 2: simplified TLS handshake flow](tls-flow.svg)\n\n1. The server applies for and obtains a certificate (X.509 certificate) from a trusted [certificate authority](https:\/\/en.wikipedia.org\/wiki\/Certificate_authority) (CA).\n2. A request from the client to the server containing information such as the TLS version and password combination supported by the client.\n3. The server responds to the client request and attaches a digital certificate.\n4. The client verifies the status, validity, and digital signature of the certificate and confirms the identity of the server.\n5. Encrypted communication commences between the client and the server using a shared private key.\n\nThe above is only an outline description of the TLS communication flow. If you’re interested in the details, please see [this in-depth discussion of the complete TLS handshake process.](https:\/\/www.cloudflare.com\/learning\/ssl\/what-happens-in-a-tls-handshake\/)\n\nFrom the above process, you will find that the certificate is the critical element representing the server’s identity. The server must use a certificate issued by an authoritatively certified CA in order to provide public services over the Internet. In contrast, you can manage certificates using your own public key infrastructure (PKI) for services inside of a private environment.\n\nMutual TLS, also referred to as mTLS, is the use of a two-way encrypted channel between a server and a client that necessitates certificate exchange and identity authentication between the parties.\n\n## What Is TLS Termination?\n\nTLS termination is the process of decrypting TLS-encrypted traffic before it is forwarded to a web server. Offloading TLS traffic to an ingress gateway or specialized device improves web application performance while securing encrypted traffic. TLS termination is typically implemented at cluster ingress. All communication between the ingress and servers in the cluster will be conducted directly over HTTP in plaintext, enhancing service performance.\n\n![Figure 3: TLS termination](tls-termination.svg)\n\nBy default, Istio enables mTLS for mesh-based services and ends TLS at the ingress gateway. Furthermore, you can pass through traffic to back-end services for processing.\n\n\u0060\u0060\u0060yaml\napiVersion: networking.istio.io\/v1beta1\nkind: Gateway\nmetadata:\n  name: sample-gateway\nspec:\n  servers:\n  - port:\n      number: 443\n      name: https\n      protocol: HTTPS\n    tls:\n      mode: PASSTHROUGH\n\u0060\u0060\u0060\n\nSee [Gateway TLS Configuration](https:\/\/istio.io\/latest\/docs\/ops\/configuration\/traffic-management\/tls-configuration\/#gateways) for details.\n\n## How to Implement Automatic mTLS in Istio\n\nFigure 4 depicts the security architecture of Istio. This figure clearly shows that at the entry point, JSON Web Token (JWT) \u002b TLS authentication and encryption are used, and that mTLS is enabled between all services within the Istio mesh.\n\n![Istio 安全架构图](istio-security.svg)\n\nIstio includes a built-in CA, and [Secret Discovery Service (SDS)](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/configuration\/security\/secret)—one of the discovery services in Envoy [xDS](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-docs\/xds_protocol)—enables the issuance and rotation of SVID certificates. The mTLS flow in the Istio mesh is as follows:\n\n1. The sidecar of every service requests a certificate from Istiod on behalf of the workload at startup, and Istiod issues the [SVID](https:\/\/spiffe.io\/docs\/latest\/spiffe-about\/spiffe-concepts\/#spiffe-verifiable-identity-document-svid) certificate (the process is more complex, and I will explain it in a future blog).\n2. The sidecar of every workload intercepts all client requests within the pod.\n3. The client sidecar starts an mTLS handshake with the server sidecar. During the handshake, the [JWT](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/intro\/arch_overview\/security\/jwt_authn_filter) and [authentication filter](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/intro\/arch_overview\/security\/ext_authz_filter) in the client sidecar will authenticate the identity of the request, and store the identity in the filter metadata after the authentication. Then the request will go through the authorization filter to determine if the request is allowed.\n4. If the request is authenticated and authorized, the client and the server start to establish a connection for communication.\n\nIn Istio, authentication and authorization between services can be configured using one of three resource objects:\n\n- **[RequestAuthentication](https:\/\/istio.io\/latest\/docs\/reference\/config\/security\/request_authentication\/):** To specify the service’s only currently supported request-level authentication method, JWT.\n- **[PeerAuthentication](https:\/\/istio.io\/latest\/docs\/reference\/config\/security\/peer_authentication\/):** To enable mTLS or plaintext requests, set the transport authentication mode.\n- **[AuthorizationPolicy](https:\/\/istio.io\/latest\/docs\/reference\/config\/security\/authorization-policy\/):** To specify who can do what when traffic between services is authorized? For instance, subject A either permits (ALLOW) or forbids (DENY) traffic from subject B.\n\n## How to Enable Automatic mTLS in Istio\n\nIn PeerAuthentication, you can specify the mTLS mode that will be used for the target workload. Peer authentication is supported in the following modes:\n\n- PERMISSIVE: The workload’s default setting that allows it to accept either mTLS or plain text traffic.\n- STRICT: The workload accepts only mTLS traffic.\n- DISABLE: Disable mTLS. From a security perspective, mTLS should not be disabled unless you have your own security solution.\n- UNSET: Inherited from the parent, with the following priority: service specific \u003e namespace scope \u003e mesh scope setting.\n\nIstio’s peer authentication uses *PERMISSIVE* mode by default, automatically sending *mTLS* traffic to these workloads and clear text traffic to workloads without a sidecar. After including Kubernetes services in the Istio mesh, we can use *PERMISSIVE* mode first to prevent services from failing *mTLS*. We can use one of two ways to enable strict mTLS mode for certain services:\n\n- Use PeerAuthentication to define how traffic is transferred between sidecars.\n- Use DestinationRule to define the TLS settings in the traffic routing policy.\n\nThe reviews service’s mTLS configuration in the default namespace can be seen in the example below.\n\n### Use PeerAuthentication to Set mTLS for Workloads\n\nFor instance, the following configuration can be used to specify that a workload under a namespace has strict mTLS enabled.\n\n\u0060\u0060\u0060yaml\napiVersion: security.istio.io\/v1beta1\nkind: PeerAuthentication\nmetadata:\n  name: foo-peer-policy\n  namespace: default\nspec:\n  selector:\n    matchLabels:\n      app: reviews\n  mtls:\n    mode: STRICT\n\u0060\u0060\u0060\n\nAccording to the [Istio documentation](https:\/\/istio.io\/latest\/docs\/tasks\/security\/authentication\/mtls-migration\/), you can also enable strict mTLS for all services in the mesh by configuring strict mTLS for the namespace istio-system where Istio is installed.\n\n### Use DestinationRule to Set up mTLS for Workloads\n\nTraffic routing policies, such as load balancing, anomaly detection, TLS settings, etc., are set using DestinationRule. In the TLS settings, there are various modes. As shown below, use ISTIO_MUTUAL mode to enable Istio’s workload-based automatic TLS.\n\n\u0060\u0060\u0060yaml\napiVersion: networking.istio.io\/v1beta1\nkind: DestinationRule\nmetadata:\n  name: reviews\n  namespace: default\nspec:\n  host: reviews\n  trafficPolicy:\n    tls:\n      mode: ISTIO_MUTUAL\n\u0060\u0060\u0060\n\n## When Should You Use mTLS?\n\nThe short answer is that you should use mTLS for network communication between application components that you have some control over—like between microservices in a cluster.\n\nOne-way TLS is typically used by Internet clients to connect to Web services, which means that only the server needs to show identification and is unconcerned with the identity of the client. One-way TLS allows you to use passwords, tokens, two-factor authentication, and other methods when you need to confirm the identity of the client. However, when using a service mesh, mTLS operates outside the application and doesn’t require many changes to the application logic, whereas such an authentication method requires internal application support.\n\nAs you can see from the example above, mTLS implementation calls for certificate exchange between services. As the number of services rises, managing numerous certificates becomes a laborious task. You can implement automatic mTLS and fix the certificate management issue with the aid of a service mesh.\n\n## When Shouldn’t You Use mTLS?\n\nAlthough mTLS is the preferred protocol for securing inter-service communication in cloud-native applications, implementing mTLS necessitates a more complex, symmetric encryption and decryption process than one-way TLS. In some cases where there is high traffic volume or CPU utilization must be optimized, terminatingTLS at the traffic entry point and turning on mTLS internally for specific services only can help minimize request response times and decrease compute resource consumption for some traffic with lower security levels.\n\nAdditionally, it is necessary to [disable probe rewriting for pods](https:\/\/istio.io\/latest\/docs\/ops\/configuration\/mesh\/app-health-check\/#disable-the-http-probe-rewrite-for-a-pod) when using services that cannot obtain certificates, such as health checks performed via HTTP on Kubelet and the inability to access the service’s health check endpoint via TLS.\n\nFinally, when mesh services access some external services, mTLS is also not necessary.\n\n## Summary\n\nmTLS is a crucial component of creating a zero-trust application network, which makes it possible to encrypt traffic within the mesh. Istio makes it simple to enable automatic mTLS for Kubernetes services, doing away with the need to manage certificates. At the same time, we can selectively enable mTLS for a subset of the mesh’s services, enabling us to move services from Kubernetes to the mesh. In a subsequent blog, we’ll go into more detail about Istio’s certificate management system. Stay tuned.\n\n---\n\nIf you’re new to service mesh and Kubernetes security, we have a bunch of free online courses [available at Tetrate Academy](https:\/\/tetr8.io\/academy) that will quickly get you up to speed with Istio and Envoy.\n\nIf you’re looking for a fast way to get to production with Istio, check out [Tetrate Istio Distribution (TID)](https:\/\/tetr8.io\/tid). TID is Tetrate’s hardened, fully upstream Istio distribution, with FIPS-verified builds and support available. It’s a great way to get started with Istio knowing you have a trusted distribution to begin with, have an expert team supporting you, and also have the option to get to FIPS compliance quickly if you need to.Once you have Istio up and running, you will probably need simpler ways to manage and secure your services beyond what’s available in Istio, that’s where Tetrate Service Bridge comes in. You can learn more about how Tetrate Service Bridge makes service mesh more secure, manageable, and resilient [here](https:\/\/tetr8.io\/tsb), or [contact us for a quick demo](https:\/\/tetr8.io\/contact).\n\n*This blog was originally published at [tetrate.io](https:\/\/tetrate.io\/blog\/how-istios-mtls-traffic-encryption-works-as-part-of-a-zero-trust-security-posture\/).*\n', '\/en\/blog\/understanding-the-tls-encryption-in-istio\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">This article introduces TLS and mTLS, and describes how to enable mTLS in Istio and its application scenarios.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/why-gateway-api-is-the-future-of-ingress-and-mesh/">Why the Gateway API Is the Unified Future of Ingress for Kubernetes and Service Mesh</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Dec 13, 2022</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/kubernetes"> 
             Kubernetes
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Why the Gateway API Is the Unified Future of Ingress for Kubernetes and Service Mesh', 'This article introduces the ingress gateway and Gateway API in Kubernetes, the new trend of them with service mesh.', '\nIn this blog, you will learn about the Kubernetes Ingress Gateway, the Gateway API, and the emerging Gateway API trend, which enables the convergence of Kubernetes and service mesh.\n\n## Takeaways\n\n- Ingress, the original gateway for Kubernetes, has a resource model that is too simple to fit into today’s programmable networks.\n- The [Gateway API](https:\/\/gateway-api.sigs.k8s.io\/), the latest addition to the Kubernetes portal gateway, separates concerns through role delineation and provides cross-namespace support to make it more adaptable to multi-cloud environments. Most API gateways already support it.\n- The Gateway API provides a new reference model for the convergence of ingress gateways (north-south) and service mesh (east-west, cross-cluster routing), where there is a partial functional overlap.\n\n## History of the Kubernetes ingress gateway\n\nWhen Kubernetes was launched in June 2014, only NodePort and LoadBalancer-type Service objects were available to expose services within the cluster to the outside world. Later, [Ingress ](https:\/\/kubernetes.io\/docs\/concepts\/services-networking\/ingress\/)was introduced to offer more control over incoming traffic.. To preserve its portability and lightweight design, the Ingress API matured more slowly than other Kubernetes APIs; it was not upgraded to GA until Kubernetes 1.19.\n\nIngress’ primary objective is to expose HTTP applications using a straightforward declarative syntax. When creating an Ingress or setting a default *IngressClass* in Kubernetes, you can deploy several Ingress Controllers and define the controller the gateway uses via *IngressClass*. Kubernetes currently supports only AWS, GCE, and Nginx Ingress controllers by default; many [third-party ingress controllers](https:\/\/kubernetes.io\/docs\/concepts\/services-networking\/ingress-controllers\/) are also supported.\n\nThe following diagram illustrates the workflow of Kubernetes Ingress.\n\n![Figure 1: Kubernetes ingress workflow](ingress-flow.svg)\n\nThe detailed process is as follows:\n\n- Kubernetes cluster administrators deploy an Ingress Controller in Kubernetes.\n- The Ingress Controller continuously monitors changes to *IngressClass* and Ingress objects in the Kubernetes API Server.\n- Administrators apply *IngressClass* and Ingress to deploy the gateway.\n- Ingress Controller creates the corresponding ingress gateway and configures the routing rules according to the administrator’s configuration.\n- If in the cloud, the client accesses the load balancer for that ingress gateway.\n- The gateway will route the traffic to the corresponding back-end service based on the host and path in the HTTP request.\n\nIstio supports both the Ingress and Gateway APIs. Below is an example configuration using the Istio Ingress Gateway, which will be created later using the Gateway API:\n\n\u0060\u0060\u0060yaml\napiVersion: networking.k8s.io\/v1\nkind: IngressClass\nmetadata:\n  name: istio\nspec:\n  controller: istio.io\/ingress-controller\n---\napiVersion: networking.k8s.io\/v1\nkind: Ingress\nmetadata:\n  name: ingress\nspec:\n  ingressClassName: istio\n  rules:\n  - host: httpbin.example.com\n    http:\n      paths:\n      - path: \/\n        pathType: Prefix\n        backend:\n          service:\n            name: httpbin\n            port: 8000\n\u0060\u0060\u0060\n\nNote: You must specify the *IngressClass* in the *ingressClassName* field in the Ingress spec. Otherwise, the ingress gateway will not be created.\n\n## Limitations of Kubernetes Ingress\n\nAlthough IngressClass decouples the ingress gateway from the back-end implementation, it still has significant limitations.\n\n- Ingress is too simple for most real-world use and it only supports HTTP protocol routing.\n- It only supports host and path matching, and there is no standard configuration for advanced routing features, which can only be achieved through annotation, such as URL redirection using Nginx Ingress Controller, which requires configuration of *nginx.ingress.kubernetes.io\/rewrite-target* annotation, which is no longer adaptable to the needs of a programmable proxy.\n- The situation where services in different namespaces must be bound to the same gateway often arises in practical situations where the ingress gateway cannot be shared across multiple namespaces.\n- No delineation of responsibilities for creating and managing ingress gateways, resulting in developers having to not only configure gateway routes but also create and manage gateways themselves.\n\n## Kubernetes Gateway API\n\nThe Gateway API is a collection of API resources: *GatewayClass*, *Gateway*, *HTTPRoute*, *TCPRoute*, *ReferenceGrant*, etc. The Gateway API exposes a more generic proxy API that can be used for more protocols than HTTP and models more infrastructure components, providing better deployment and management options for cluster operations.\n\nIn addition, the Gateway API achieves configuration decoupling by separating resource objects that people can manage in different roles. The following diagram shows the roles and objects in the Gateway API.\n\n![Figure: Roles and componentes in Kubernetes Gateway API](gateway-api-roles.svg)\n\nThe following is an example of using the Gateway API in Istio.\n\n\u0060\u0060\u0060yaml\napiVersion: gateway.networking.k8s.io\/v1alpha2\nkind: Gateway\nmetadata:\n  name: gateway\n  namespace: istio-ingress\nspec:\n  gatewayClassName: istio\n  listeners:\n  - name: default\n    hostname: \u0022*.example.com\u0022\n    port: 80\n    protocol: HTTP\n    allowedRoutes:\n      namespaces:\n        from: All\n---\napiVersion: gateway.networking.k8s.io\/v1alpha2\nkind: HTTPRoute\nmetadata:\n  name: http\n  namespace: default\nspec:\n  parentRefs:\n  - name: gateway\n    namespace: istio-ingress\n  hostnames: [\u0022httpbin.example.com\u0022]\n  rules:\n  - matches:\n    - path:\n        type: PathPrefix\n        value: \/\n    backendRefs:\n    - name: httpbin\n      port: 8000\n\u0060\u0060\u0060\n\nSimilar to Ingress, Gateway uses *gatewayClassName* to declare the controller it uses, which needs to be created by the platform administrator and allows client requests for the **.example.com* domain. Application developers can create routing rules in the namespace where their service resides, in this case, default, and bind to the Gateway via parentRefs, but only if the Gateway explicitly allows them to do so (via the rules set in the *allowRoutes* field).\n\nWhen you apply the above configuration, Istio will automatically create a load-balancing gateway for you. The following diagram shows the workflow of the Gateway API.\n\n![Figure 3: Gateway API workflow](gateway-api-flow.svg)\n\nThe detailed process is as follows:\n\n- The infrastructure provider provides *GatewayClass* and Gateway Controller.\n- Platform operator deploy Gateway (multiple deployments possible, or using different *GatewayClasses*).\n- Gateway Controller continuously monitors changes to the *GatewayClass* and *Gateway* objects in the Kubernetes API Server.\n- Gateway controller will create the corresponding gateway based on cluster operations and maintenance configuration.\n- Application developers apply *xRoutes* and bind them to the service.\n- If in the cloud, the client accesses the load balancer for that ingress gateway.\n- The gateway will route to the corresponding back-end service based on the matching criteria in the traffic request.\n\nFrom the above steps, we can see that the Gateway API has a clear division of roles compared to Ingress and that routing rules can be decoupled from the gateway configuration, significantly increasing management flexibility.\n\nThe following diagram shows the route flow after it is accessed at the gateway and processed.\n\n![Figure 4: Gateway API route flow](traffic-flow.svg)\n\nFrom this figure, we can see that the route is bound to the gateway. The route is generally deployed in the same namespace as its backend services. Suppose the route is in a different namespace, and you need to explicitly give the route cross-namespace reference rights in \u0060ReferenceGrant\u0060, for example. In that case, the following HTTPRoute foo in the foo namespace can refer to the bar namespace bar service in the bar namespace.\n\n\u0060\u0060\u0060yaml\nkind: HTTPRoute\nmetadata:\n  name: foo\n  namespace: foo\nspec:\n  rules:\n  - matches:\n    - path: \/bar\n    forwardTo:\n      backend:\n      - name: bar\n        namespace: bar\n---\nkind: ReferenceGrant\nmetadata:\n  name: bar\n  namespace: bar\nspec:\n  from:\n  - group: networking.gateway.k8s.io\n    kind: HTTPRoute\n    namespace: foo\n  to:\n  - group: \u0022\u0022\n    kind: Service\n\u0060\u0060\u0060\n\nCurrently, the Gateway API only supports HTTPRoute, and the TCPRoute, UDPRoute, TLSRoute and GRCPRoute are still in the experimental stage. The Gateway API is already supported by a large number of gateway and service mesh projects, and please [check the support status in the official Gateway documentation.](https:\/\/gateway-api.sigs.k8s.io\/implementations\/)\n\n## Ingress Gateway and Service Mesh\n\nThe service mesh focuses on east-west traffic, i.e., traffic within a Kubernetes cluster, but most service meshes, including Istio, also provide ingress gateway functionality. But, since Istio’s ingress functionality and API are more advanced than we need for this example, we’ll use [Service Mesh Interface (SMI)](https:\/\/smi-spec.io\/) to illustrate the relationship between the ingress gateway and the service mesh.\n\nSMI is a CNCF incubation project, open-sourced in 2019, that defines a common standard for vendor-independent service mesh running in Kubernetes.\n\nThe following diagram illustrates the overlap between the Gateway API and the SMI.\n\n![Figure 5: Gateway API vs SMI](gateway-smi-overlay.svg)\n\nFrom the diagram, we can see a clear overlap between the Gateway API and SMI in the traffic specification section. These overlaps result in the same functionality that needs to be implemented repeatedly in both the Gateway API and the service mesh.\n\n## Traffic Management in the Istio Service Mesh\n\nOf course, not all service meshes are fully SMI-compliant. Istio, the most popular service mesh implementation, provides rich traffic management features but does not have a separate policy API for these features, instead coupling them in *VirtualService* and *DestinationRule*, as shown below.\n\n### VirtualService\n\n- Routing: canary release, matching routes based on HTTP header, URI, etc.\n- Error injection: HTTP error code injection, HTTP delay injection.\n- Traffic splitting: percentage-based traffic splitting.\n- Traffic mirroring: mirroring a certain percentage of traffic to other clusters.\n- Timeout: set the timeout period, after which the request will fail.\n- Retry: set the retry policy, such as trigger conditions, number of retries, interval time, etc.\n\n### DestinationRule\n\nLoad balancing: setting up load balancing policies, such as simple load balancing, locality-aware load balancing, and area-weighted load balancing.\nCircuit Breaking: Outlier detection and connection pool settings to remove anomalous nodes from the load balancing pool.\n\n*VirtualService* mainly handles routing-related functions, while *DestinationRule* is responsible for adding and ejecting nodes from the cluster and load balancing.\n\nGateway API Converging the Ingress Gateway from Kubernetes and Service Mesh\n\nAs mentioned above, there is a partial functional intersection between the Gateway API and the service mesh. To reduce duplication of development and enable the modeling of common concerns between the Gateway API and the service mesh, the Gateway API Working Group has proposed the [Gateway API Mesh Management and Administration](https:\/\/gateway-api.sigs.k8s.io\/contributing\/gamma\/) (GAMMA) initiative.\n\nUnder this initiative, advanced traffic management features that vary in detail across gateway implementations, such as timeouts, retries, health checks, etc., will all be implemented by individual providers through [policy attachment](https:\/\/gateway-api.sigs.k8s.io\/references\/policy-attachment\/). You can specify the resource object to which the policy attachment is attached via the *targetRef* field, as shown below.\n\n\u0060\u0060\u0060yaml\napiVersion: networking.acme.io\/v1alpha1\nkind: RetryPolicy\nmetadata:\n  name: foo\nspec:\n  override:\n    maxRetries: 10\n  default:\n    maxRetries: 5\n  targetRef:\n    group: gateway.networking.k8s.io\/v1alpha2\n    kind: HTTPRoute\n    name: foo\n\u0060\u0060\u0060\n\nIn this example, the retry policy is attached to a resource named *foo* and *HTTPRoute*. Policy attachments are connected to different resource objects with varying priorities for effectiveness. For instance, GatewayClass is a cluster-level resource and will take precedence if the policy attachment is overlaid on it.\n\nYou can assign override and default values to additional policies whose priority in the ingress and the different resources in the mesh hierarchy are shown in the figure below.\n\n![Figure 6: Kubernetes Ingress and Mesh with Overrides and Default Priorities](policy-attachment-priority.svg)\n\nCurrently, the Gateway API is being explored to handle mesh traffic, and several [design options](https:\/\/docs.google.com\/document\/d\/1T_DtMQoq2tccLAtJTpo3c0ohjm25vRS35MsestSL9QU\/edit#heading=h.6ks49gf06yii) have been proposed.\n\n## Envoy Gateway\n\nThe first open-source version of Envoy Gateway, [v0.2, was released](https:\/\/blog.envoyproxy.io\/introducing-envoy-gateway-ad385cc59532) in October 2022. It was created based on the Envoy proxy’s compliance with the Gateway API, of which [Tetrate ](https:\/\/tetrate.io\/)is a core sponsor. Its expressive, scalable, role-oriented API design through ingress and L4\/L7 traffic routing makes it the foundation for vendors to build value-added API gateway products.\n\nLong before Envoy Gateway was released, Envoy was massively adopted as one of the most popular cloud-native proxies, with several Gateway software builds based on Envoy, and the Istio service mesh used it as the default sidecar proxy and configured these distributed proxies via the xDS protocol. Envoy Gateway also uses xDS to configure the Envoy fleet. The following diagram illustrates the architecture of Envoy Gateway.\n\n![Figure: Envoy Gateway architecture](envoy-gateway-arch.svg)\n\nThe infrastructure provider will provide you with GatewayGlass. You can create an Envoy Gateway by creating a Gateway declaration. Your routing and policy attachments in the Gateway will be sent to the Envoy fleet via the xDS protocol.\n\nFor further information about Envoy Gateway, please read\n\n- [Hands on with the New Kubernetes Gateway API, Using Envoy Gateway 0.2](https:\/\/tetrate.io\/blog\/hands-on-with-the-gateway-api-using-envoy-gateway-0-2\/)\n- [Gateway to the Future: the New Kubernetes Gateway API and Envoy Gateway 0.2](https:\/\/tetrate.io\/blog\/gateway-to-the-future-the-new-gateway-api-and-envoy-gateway-0-2\/)\n\n## Summary\n\nThe Gateway API, as the next-generation Kubernetes Ingress API, provides a better degree of API specification for Kubernetes gateway providers as opposed to the Ingress API before, enriching the functionality of the ingress gateway while ensuring its portability and facilitating the management of gateways by different stakeholders through the separation of concerns. Finally, the GAMMA initiative is promoting the integration of the Ingress Gateway with the Gateway API for service mesh, and policy attachments may further extend the functionality of the Gateway API to east-west gateways.\n\n---\n\n*This blog was originally published at [tetrate.io](https:\/\/tetrate.io\/blog\/why-the-gateway-api-is-the-unified-future-of-ingress-for-kubernetes-and-service-mesh\/).*\n', '\/en\/blog\/why-gateway-api-is-the-future-of-ingress-and-mesh\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">This article introduces the ingress gateway and Gateway API in Kubernetes, the new trend of them with service mesh.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/beyond-istio-oss/">The Current State and Future of the Istio Service Mesh</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Jul 18, 2022</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('The Current State and Future of the Istio Service Mesh', 'This article explains the background of Istio\u0027s birth, its position in the cloud-native technology stack, and the development direction of Istio.', '\nThis article reviews the development of Istio open source in the past five years and looks forward to the future direction of Istio. The main points of view in this article are as follows:\n\n- Due to the popularity of Kubernetes, microservices, DevOps, and cloud-native architectures, the rise of service mesh technology.\n- The rise of Kubernetes and programmable proxies has laid the technical groundwork for Istio\u0027s implementation.\n- While eBPF can accelerate transparent traffic hijacking in Istio, it can not replace sidecars in service meshes.\n- The future of Istio is to build a zero-trust network.\n\nNext, we start this article with the background of the birth of Istio.\n\n## The eve of the birth of Istio\n\nSince 2013, with the explosion of the mobile Internet, enterprises have had higher requirements for the efficiency of application iteration. Application architecture has begun to shift from monolithic to microservices, and DevOps has also become popular. In the same year, with the open source of Docker, the problems of application encapsulation and isolation were solved, making it easier to schedule applications in the orchestration system. In 2014, Kubernetes and Spring Boot were open-sourced, and Spring framework development of microservice applications became popular. In the next few years, a large number of RPC middleware open source projects appeared, such as Google released gRPC 1.0 in 2016. The service framework is in full bloom. In order to save costs, increase development efficiency, and make applications more flexible, more and more enterprises are migrating to the cloud, but this is not just as simple as moving applications to the cloud. In order to use cloud computing more efficiently, a set of \u0022cloud native\u0022 methods and concepts are also on the horizon.\n\n## Istio Open Source Timeline\n\nLet\u0027s briefly review the major events of Istio open source:\n\n- **September 2016**: Since Envoy is an important part of Istio, Istio\u0027s open source timeline should have an Envoy part. At first, Envoy was only used as an edge proxy inside Lyft, and it was verified in large-scale production inside Lyft before Envoy was open sourced. In fact, Envoy was open sourced before it was open sourced, and it got the attention of Google engineers. At that time, Google was planning to launch an open source project of service mesh, and initially planned to use Nginx as a proxy. In 2017, Envoy donated to [CNCF](https:\/\/cncf.io\/).\n- **May 2017**: Istio was announced as open source by Google, IBM, and Lyft. The microservices architecture was used from the beginning. The composition of the data plane, control plane, and sidecar pattern were determined.\n- **March 2018**: Kubernetes successfully became the first project to graduate from CNCF, becoming more and more \u0022boring\u0022. The basic API has been finalized. In the second edition, CNCF officially wrote the service mesh into the cloud native first definition. The company I currently work for, [Tetrate](https:\/\/tetrate.io\/), was founded by the Google Istio team.\n- **July 2018**: Istio 1.0 is released, billed as \u0022production ready\u0022.\n- **March 2020**: Istio 1.5 was released, the architecture returned to a monolithic application, the release cycle was determined, a major version was released every three months, and the API became stable.\n- **From 2020 to the present**: The development of Istio mainly focuses on Day 2 operation, performance optimization, and extensibility. Several open source projects in the Istio ecosystem have begun to emerge, such as [Slime](https:\/\/github.com\/slime-io\/slime\/), [Areaki](https:\/\/github.com\/aeraki-mesh\/aeraki), and [Merbridge](https:\/\/github.com\/merbridge\/merbridge).\n\n## Why did Istio come after Kubernetes?\n\nThe emergence mentioned here refers to the birth of the concept of \u0022service mesh\u0022. After microservices and containerization, the increase in the use of heterogeneous languages, the surge in the number of services, and the shortened life cycle of containers are the fundamental reasons for the emergence of service meshes.\n\nTo make it possible for developers to manage traffic between services with minimal cost, Istio needs to solve three problems:\n\n1. Transparent traffic hijacks traffic between applications, which means that developers can quickly use the capabilities brought by Istio without modifying applications.\n1. Another point is the operation and maintenance level; how to inject the proxy into each application and manage these distributed sidecar proxies efficiently.\n1. An efficient and scalable sidecar proxy that can be configured through an API.\n\nThe above three conditions are indispensable for the Istio service mesh, and we can see from them that these requirements are basically the requirements for the sidecar proxy. The choice of this proxy will directly affect the direction and success of the project.\n\nIn order to solve the three problems above, Istio chose:\n\n1. Container Orchestration and Scheduling Platform: Kubernetes\n1. Programable proxy: Envoy\n\nFrom the figure below, we can see the transition of the service deployment architecture from Kubernetes to Istio, with many changes and constants.\n\n![Schematic diagram of the architectural change from Kubernetes to Istio](kubernetes-to-istio.svg)\n\nFrom Kubernetes to Istio, in a nutshell, the deployment architecture of the application has the following characteristics:\n\n- Kubernetes manages the life cycle of applications, specifically, application deployment and management (scaling, automatic recovery, and release).\n- Automatic sidecar injection based on Kubernetes to achieve transparent traffic interception. First, the inter-service traffic is intercepted through the sidecar proxy, and then the behavior of the microservice is managed through the control plane configuration. Nowadays, the deployment mode of service mesh has also ushered in new challenges. A sidecar is no longer necessary for Istio service mesh. The proxyless service mesh based on gRPC is also being tested.\n- The service mesh decouples traffic management from Kubernetes, and the traffic inside the service mesh does not need the support of the kube-proxy component. Through the abstraction close to the microservice application layer, the traffic between services is managed to achieve security and observability functions.\n- The control plane issues proxy configuration to the data plane through the xDS protocol. The proxies that have implemented xDS include [Envoy](https:\/\/envoyproxy.io\/) and the open source [MOSN](https:\/\/mosn.io\/).\n- When a client outside the Kubernetes cluster accesses the internal services of the cluster, it was originally through Kubernetes Ingress, but after Istio is available, it will be accessed through Gateway.\n\n### Transparent traffic hijacking\n\nIf you are using middleware such as gRPC to develop microservices, after integrating the SDK into the program, the interceptor in the SDK will automatically intercept the traffic for you, as shown in the following figure.\n\n![Interceptor diagram of gRPC](grpc.svg)\n\nHow to make the traffic in the Kubernetes pod go through the proxy? The answer is to inject a proxy into each application pod, share the network space with the application, and then modify the traffic path within the pod so that all traffic in and out of the pod goes through the sidecar. Its architecture is shown in the figure below.\n\n![Diagram of transparent traffic hijacking in Istio](istio-route-iptables.svg)\n\nFrom the figure, we can see that there is a very complex set of iptables traffic hijacking logic. The advantage of using iptables is that it is applicable to any Linux operating system. But this also has some side effects:\n\n1. All services in the Istio mesh need to add a network hop when entering and leaving the pod. Although each hop may only be two or three milliseconds, as the dependencies between services and services in the mesh increase, this latency may increase significantly, which may not be suitable for service meshes for services that pursue low latency.\n1. Because Istio injects a large number of sidecars into the data plane, especially when the number of services increases, the control plane needs to deliver more Envoy proxy configurations to the data plane, which will cause the data plane to occupy a lot of system memory and network resources.\n\nHow to optimize the service mesh in response to these two problems?\n\n1. Use proxyless mode: remove the sidecar proxy and go back to the SDK.\n1. Optimize the data plane: reduce the frequency and size of proxy configurations delivered to the data plane.\n1. eBPF: it can be used to optimize network hijacking.\n\nThis article will explain these details in the section on performance optimization later on.\n\n### Sidecar operation and maintenance management\n\nIstio is built on top of Kubernetes, which can leverage Kubernetes\u0027 container orchestration and lifecycle management to automatically inject sidecars into pods through admission controllers when Kubernetes creates pods. \n\nIn order to solve the resource consumption problem of Sidecar, some people have proposed four deployment modes for the service mesh, as shown in the following figure.\n\n![Schematic diagram of four deployment modes of service mesh](deployment-model.svg)\n\nThe following table compares these four deployment methods in detail. Each of them has advantages and disadvantages. The specific choice depends on the current situation.\n\n{{\u003ctable \u0022Comparison of four deployment modes of service mesh\u0022\u003e}}\n\n| **Mode**                                 | **Memory overhead**                                          | **Security**                                                 | **Fault domain**                                             | **Operation and maintenance**                                |\n| :--------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |\n| **Sidecar proxy**                        | The overhead is greatest because a proxy is injected per pod. | Since the sidecar must be deployed with the workload, it is possible for the workload to bypass the sidecar. | Pod-level isolation, if the proxy fails, only the workload in the Pod is affected. | A workload\u0027s sidecar can be upgraded independently without affecting other workloads. |\n| **Node sharing proxy**                   | There is only one proxy on each node, shared by all workloads on that node, with low overhead. | There are security risks in the management of encrypted content and private keys. | Node-level isolation, if a version conflict, configuration conflict, or extension incompatibility occurs when a shared proxy is upgraded, it may affect all workloads on that node. | There is no need to worry about injecting sidecars.          |\n| **Service Account \/ Node Sharing Proxy** | All workloads under the service account\/identity use a shared proxy with little overhead. | Authentication and security of connections between workloads and proxy cannot be guaranteed. | The level isolation between nodes and service accounts, the fault is the same as \u0022node sharing proxy\u0022. | Same as \u0022node sharing proxy\u0022 mode.                           |\n| **Shared remote proxy with micro-proxy** | Because injecting a micro-proxy for each pod, the overhead is relatively large. | The micro-proxy handles mTLS exclusively and is not responsible for L7 routing, which can ensure security. | When a Layer 7 policy needs to be applied, the traffic of the workload instance is redirected to the L7 proxy, and can be bypassed directly if it is not needed. The L7 proxy can run as a shared node proxy, a per-service account proxy, or a remote proxy | Same as \u0022sidecar proxy\u0022 mode.                                |\n\n{{\u003c\/table\u003e}}\n\n### Programmable proxy\n\nZhang Xiaohui of Flomesh explained the evolution of proxy software. I will quote some of his views below to illustrate the key role of programmable proxies in Istio.\n\nThe following figure shows the evolution process of the proxy software from configuration to programmable mode, and the representative proxy software in each stage.\n\n![Schematic diagram of the evolution of proxy software](proxy-evolution.svg)\n\nThe entire proxy evolution process is as the application moves from local and monolithic to large-scale and distributed. Below, I will briefly outline the evolution of the proxy software:\n\n- **The era of configuration files**: almost all software has configuration files, and proxy software is more inseparable from configuration files because of its relatively complex functions. The proxy at this stage is mainly developed using the C language, including its extension module, which highlights the ability of the proxy itself. This is also the most primitive and basic form of our use of proxies, including Nginx, Apache HTTP Server, [Squid](http:\/\/www.squid-cache.org\/), etc.\n- **Configuration language era**: Proxies in this era are more extensible and flexible, such as dynamic data acquisition and matching logic judgment. Varnish and HAProxy are two examples of representative software.\n- **The era of scripting languages**: Since the introduction of scripting languages, proxy software has become programmable. We can use scripts to add dynamic logic to proxies more easily, increasing development efficiency. The representative software is Nginx and its supported scripting languages.\n- **The era of clusters**: With the popularity of cloud computing, large-scale deployment and dynamic configuration of APIs have become necessary capabilities for proxies, and with the increase in network traffic, large-scale proxy clusters have emerged as the times require. The representative proxy software of this era includes Envoy, Kong, etc.\n- **Cloud-native era**: Multi-tenancy, elasticity, heterogeneous hybrid cloud, multi-cluster, security, and observability are all higher requirements for proxies in the cloud-native era. This will also be a historical opportunity for service meshes, with representative software such as Istio, Linkerd, and [Pypi](https:\/\/flomesh.io\/).\n\n## Are these all service meshes?\n\nSo, is it possible to build a service mesh with proxies? Now I will list the existing service mesh projects, and let\u0027s explore the development law and nature of service mesh together. The table below compares the current popular open source \u0022service mesh\u0022 projects.\n\n{{\u003ctable \u0022Service mesh open source project comparison table\u0022\u003e}}\n\n| Contrast           | Istio                                                        | Linkerd                                                     | Consul Connect                                               | Traefik Mesh                                                 | Kuma                                | Open Service Mesh (OSM)                       |\n| :----------------- | :----------------------------------------------------------- | :---------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :---------------------------------- | :-------------------------------------------- |\n| Current version   | 1.14                                                         | 2.11                                                        | 1.12                                                         | 1.4                                                          | 1.5                                 | 1.0l                                          |\n| License           | Apache License 2.0                                           | Apache License 2.0                                          | Mozilla License                                              | Apache License 2.0                                           | Apache License 2.0                  | Apache License 2.0                            |\n| Initiator          | Google, IBM, Lyft                                            | Buoyant                                                     | HashiCorp                                                    | Traefik Labs                                                 | Kong                                | Microsoft                                     |\n| Service proxy | Envoy, which supports proxyless mode for gRPC                | [Linkerd2-proxy](https:\/\/github.com\/linkerd\/linkerd2-proxy) | Default is [Envoy](https:\/\/www.envoyproxy.io\/) , replaceable | [Traefik Proxy](https:\/\/traefik.io\/traefik\/)                 | [Envoy](https:\/\/www.envoyproxy.io\/) | [Envoy](https:\/\/www.envoyproxy.io\/)           |\n| Ingress controller | Envoy, custom Ingress, supports Kubernetes Gateway API       | no built-in                                                 | Envoy, with support for the Kubernetes Gateway API           | no built-in                                                  | Kong                                | Support Contour, Nginx, compatible with other |\n| Governance         | Istio Community and Open Usage Commons, proposed to donate to CNCF | CNCF                                                        | View [Contribution Guidelines](https:\/\/github.com\/hashicorp\/consul\/blob\/master\/.github\/CONTRIBUTING.md) | View [Contribution Guidelines](https:\/\/github.com\/traefik\/mesh\/blob\/master\/CONTRIBUTING.md) | CNCF                                | CNCF                                          |\n| Comment | It is one of the most popular service mesh projects at present. | The earliest service mesh, the creator of the concept of \u0022Service Mesh\u0022, the first service mesh project to enter CNCF, using a lightweight proxy developed with Rust. | Consul service mesh, using Envoy as a sidecar proxy. | A service mesh project launched by Traefik, using Traefik Proxy as a sidecar and supporting SMI (mentioned below). | A service mesh project launched by Kong that uses Envoy as a sidecar proxy, using Kong\u0027s own gateway as ingress. | An open source service mesh created by Microsoft, using Envoy as a sidecar, compatible with SMI (also proposed by Microsoft). |\n\n{{\u003c \/table \u003e}}\n\nThe open source projects in the above table are summarized below, and several projects closely related to service mesh are added, as follows:\n\n- [Envoy](https:\/\/envoyproxy.io\/): Envoy is a cloud-native proxy, frequently used as a sidecar in other Envoy-based service meshes and for building API Gateways.\n- [Service Mesh Performance (SMP)](https:\/\/smp-spec.io\/): Metrics that capture details of infrastructure capacity, service mesh configuration, and workload metadata to standardize service mesh values and describe the performance of any deployment.\n- [Service Mesh Interface (SMI)](https:\/\/smi-spec.io\/): It is not a service mesh, but a set of service mesh implementation standards. Similar to OAM, SPIFFE, CNI, CSI, etc., it defines interface standards, and the specific implementation varies. Currently, Traefik Mesh and Open Service Mesh claim to support this specification.\n- [Network Service Mesh](https:\/\/networkservicemesh.io\/): It\u0027s worth mentioning this project because it\u0027s often mistaken for a service mesh. In fact, it is oriented towards a three-layer network, and it can be used to connect multi-cloud\/hybrid clouds without changing the CNI plug-in. It\u0027s not a \u0022service mesh\u0022 as we define it, but a powerful complement to a service mesh (albeit a somewhat confusing name with a service mesh in it).\n\nLooking at the so-called \u0022service mesh\u0022 projects mentioned above, we can see that most service mesh project initiators start out as proxies, and then do the control plane. And Istio, Consul Connect, Open Service Mesh, and Kuma all use Envoy as a sidecar proxy. Only Linkerd and Traefik Mesh have launched their own proxies. And all service mesh projects support the sidecar pattern. Apart from Istio, Linkerd, and Consul Connect, which have been used in production, other service mesh projects are currently only \u0022toys\u0022.\n\n## Performance optimization for Istio\n\nAfter Istio 1.5 had a stable architecture, the community\u0027s main focus was on optimizing Istio\u0027s performance. Below, I will give you a detailed introduction to performance optimization methods in Istio, including:\n\n- Use the Proxyless mode.\n- Use eBPF to optimize traffic hijacking.\n- Optimization of control plane performance.\n- Optimization of data plane performance.\n\n### Proxyless mode\n\nProxyless mode is an experimental feature proposed by Istio in version 1.11-a service mesh without sidecar proxy based on gRPC and Istio. Using this pattern allows you to add gRPC services directly to Istio without injecting an Envoy proxy into the Pod. The figure below shows a comparison of sidecar mode and proxyless mode.\n\n![Sidecar vs Proxyless](sidecar-to-proxyless.svg)\n\nAs we can see from the above figure, although proxyless mode does not use a proxy for data plane communication, it still needs an agent for initialization and communication with the control plane. First, the agent generates a bootstrap file at startup, in the same way that it generates bootstrap files for Envoy. This tells the gRPC library how to connect to Istiod, where to find certificates for data plane communication, and what metadata to send to the control plane. Next, the agent acts as an xDS proxy, connecting and authenticating with \u0060Istiod\u0060. Finally, the agent obtains and rotates the certificate used in the data plane communication.\n\n\u003e *The essence of a service mesh is not a sidecar model, nor a configuration center, or transparent traffic interception, but a standardized inter-service communication standard.*\n\nSome people say that the proxyless model has returned to the old way of developing microservices based on SDK, and the advantages of service meshes have been lost. Can it still be called service mesh? In fact, this is also a compromise on performance—if you mainly use gRPC to develop microservices, you only need to maintain gRPC versions in different languages; that is, you can manage microservices through the control plane.\n\n\u003e *Envoy xDS has become the de facto standard for communication between cloud-native application services.*\n\n### Optimizing traffic hijacking with eBPF\n\nIn the section on transparent traffic hijacking, we can see the iptables rules and paths that an inter-service traffic passes through when it reaches the destination pod, which needs to go through multiple iptables rules, such as \u0060PREROUTING\u0060, \u0060ISTIO_INBOUND\u0060, \u0060ISTIO_IN_REDIRECT\u0060, \u0060OUTPUT\u0060, \u0060ISTIO_OUTPUT\u0060, and so on. Suppose now that there is a service A that wants to call service B in another pod on a non-localhost through the network stack, as shown in the figure below.\n\n![Service request path between pods not on the same host (iptables mode)](iptables-process.svg)\n\nFrom the figure, we can see that there are four iptables passes in the whole calling process. Among them, the outbound (iptables2) from Envoy in Pod A and the inbound (iptables3) from eth0 in Pod B are unavoidable. So can the remaining two, iptables1 and iptables4 be optimized? Wouldn\u0027t it be possible to shorten the network path by letting the two sockets communicate directly? This requires programming through eBPF such that:\n\n- Service A\u0027s traffic is sent directly to Envoy\u0027s inbound socket.\n- After Envoy in Pod B receives the inbound traffic, it has determined that the traffic is to be sent to the local service and directly connects the outbound socket to Service B.\n\nThe transparent traffic interception network path using eBPF mode is shown in the following figure.\n\n![Service request path between pods not on the same host (eBPF mode)](ebpf-diff-node.svg)\n\nIf service A and service B to be accessed are on the same node, the network path will be shorter.\n\n![Network request path between the same host Pod (eBPF mode)](ebpf-same-node.svg)\n\nAccess between services in the same node completely bypasses the TCP\/IP stack and becomes direct access between sockets.\n\n{{\u003ccallout note \u0022What is eBPF?\u0022\u003e}}\n\nWe know that modifying the Linux kernel code is difficult, and it takes a long time for new features to be released into the kernel. eBPF is a framework that allows users to load and run custom programs within the operating system\u0027s kernel. That is, with eBPF, you can extend and change the behavior of the kernel without directly modifying the kernel. I will briefly introduce eBPF to you below.\n\n- After the eBPF program is loaded into the kernel, it needs to pass the verification of the verifier before it can run. The verifier can prevent the eBPF program from accessing beyond its authority, ensuring the kernel\u0027s security.\n- eBPF programs are attached to kernel events and are triggered when there is an entry or exit from a kernel function.\n- In kernel space, eBPF programs must be written in a language that supports a compiler that generates eBPF byte code. Currently, you can write eBPF programs in C and Rust.\n- The eBPF program has compatibility issues with different Linux versions.\n\nSince the eBPF program can directly monitor and operate the Linux kernel, it has a perspective on the lowest level of the system and can play a role in traffic management, observability, and security.\n\n{{\u003c\/callout\u003e}}\n\nThe open source project [Merbridge](https:\/\/github.com\/merbridge\/merbridge) uses eBPF to shorten the path of transparent traffic hijacking and optimize the performance of the service mesh. For some details on the Merbridge implementation, please refer to the [Istio blog](https:\/\/istio.io\/latest\/blog\/2022\/merbridge\/) .\n\n{{\u003ccallout warning Notice\u003e}}\nThe eBPF functions used by Merbridge require a Linux kernel version ≥ 5.7.\n{{\u003c\/callout\u003e}}\n\nAt first glance, eBPF seems to implement the functions of Istio at a lower level and has a greater tendency to replace sidecar. But eBPF also has many limitations that make it impossible to replace service meshes and sidecars in the foreseeable future. Removing the sidecar in favor of a proxy-per-host model would result in:\n\n1. The explosion radius of a proxy failure is expanded to the entire node.\n2. It makes the security problem more complicated because too many certificates are stored on a node. Once attacked, there will be a risk of key leakage.\n3. On the host, traffic contention between Pods.\n\nMoreover, eBPF is mainly responsible for Layer 3\/4 traffic and can run together with CNI, but it is not suitable to use eBPF for Layer 7 traffic.\n\n\u003e *In the near future, eBPF technology will not be able to replace service meshes and sidecars.*\n\n### Control plane performance optimization\n\nThe above two optimizations are carried out for the data plane. Let\u0027s look at the performance optimization of the control plane. You can think of a service mesh as a show, where the control plane is the director and the data plane is all the actors. The director is not involved in the show but directs the actors. If the plot of the show is simple and the duration is very short, then each actor will be allocated very few scenes, and rehearsal will be very easy; if it is a large-scale show, the number of actors is large and the plot is very complicated. To rehearse the show well, one director may not be enough. He can\u0027t direct so many actors, so we need multiple assistant directors (expanding the number of control plane instances); we also need to prepare lines and scripts for actors, if actors It is also possible to perform a series of lines and scenes in one shot (reduce the interruption of the data plane and push updates in batches), so is our rehearsal more efficient?\n\nFrom the above analogy, you should be able to find the direction of control plane performance optimization, that is:\n\n- Reduce the size of the configuration that needs to be pushed.\n- Push batch proxy.\n- To expand the scale of the control plane.\n\n#### Reduce the configuration that needs to be pushed out\n\nThe easiest and most straightforward way to optimize control plane performance is to reduce the size of the configuration to be pushed. Assuming that there is workload A, if the proxy configuration related to A, that is, the configuration of the service that A needs to access, is pushed to A, instead of pushing the configuration of all services in the mesh to A, it can greatly reduce the number of services to be pushed. The size and application range of the configuration. The Sidecar resource in Istio can help us do this. The following is an example of a sidecar configuration:\n\n\u0060\u0060\u0060yaml\napiVersion: networking.istio.io\/v1alpha3\nkind: Sidecar\nmetadata:\n  name: default\n  namespace: us-west-1\nspec:\n  workloadSelector:\n    labels:\n      app: app-a\n  egress:\n  - hosts:\n    - \u0022us-west-1\/*\u0022\n\u0060\u0060\u0060\n\nWe can use the \u0060workloadSelector\u0060 field  to limit the scope of workloads that the sidecar configuration applies to, and the \u0060egress\u0060 field is used to determine the scope of services for the workload, so that the control plane can only push the configuration of its dependent services to service A, greatly reducing the need to push to the data plane. The configuration size of the service mesh reduces the memory and network consumption of the service mesh.\n\n#### Batch push the proxy configurations\n\nThe process of pushing the proxy configuration from the control plane Istiod to the data plane is complex. The following figure shows the process.\n\n![Flowchart of Istiod pushing proxy configuration to the data plane](istiod-push.svg)\n\nAfter an administrator configures the Istio mesh, the process for pushing proxy configuration in Istiod is as follows:\n\n1. The event that the administrator updates the configuration will trigger the configuration synchronization of the data plane.\n1. After listening to these events, Istio\u0027s \u0060DiscoveryServer\u0060 components will not push the configuration to the data plane immediately, but will add these events to the queue and continue to merge events within a period of time. This process is called debouncing, which is to prevent frequent updates to the data plane configuration.\n1. After the debouncing period, these events will be pushed to the queue.\n1. To expedite push progress, Istiod will limit the number of simultaneous push requests.\n1. Envoy configuration push data plane workloads are translated into events.\n\nFrom the above process, we can see that the key to optimizing configuration push is the debounce period in step 2 and the current limit setting in step 4. There are several environmental variables that can help you set up control plane push:\n\n- \u0060PILOT_DEBOUNCE_AFTER\u0060: The time after which the event will be added to the push queue.\n- \u0060PILOT_DEBOUNCE_MAX\u0060: This defines the maximum amount of time an event can debounce.\n- \u0060PILOT_ENABLE_EDS_DEBOUNCE\u0060: Specifies whether endpoint updates meet debounce rules or have priority and fall into the push queue immediately.\n- \u0060PILOT_PUSH_THROTTLE\u0060: Controls how many push requests are processed at once.\n\nPlease refer to the [Istio documentation](https:\/\/istio.io\/latest\/docs\/reference\/commands\/pilot-agent\/#envvars) for the default values and specific configuration of these environment variables .\n\nHow to set these values can follow the following principles:\n\n- If control plane resources are idle, to speed up the propagation of configuration updates, you can:\n  - Shorten the debounce period and increase the number of pushes.\n  - Increase the number of push requests processed simultaneously.\n- If the control plane is saturated, to reduce performance bottlenecks, you can:\n  - Delay the debounce cycle to reduce the number of pushes.\n  - Increase the number of push requests processed simultaneously.\n\nAs for how to set the optimal solution, you need to debug it in conjunction with your observable system.\n\n#### Scale up the control plane\n\nIf setting up debounce batch processing and sidecar cannot optimize the performance of the control plane, the final choice is to expand the scale of the control plane, including expanding the resources of a single Istiod instance and increasing the number of Istiod instances. Which expansion method is used depends on the situation:\n\n- When the resource occupancy of a single Istiod is saturated, it is recommended that you increase the instance size of Istiod. This is usually because there are too many resources in the service mesh (Istio\u0027s custom resources, such as VirtualService, DestinationRule, etc.) that need to be processed.\n- Then increase the number of instances of Istiod, which can spread the workloads to be managed by each instance.\n\n### Data plane performance optimization\n\nApache SkyWalking can serve as an observability tool for Istio and can also help us analyze the performance of services in dynamic debugging and troubleshooting. Its newly launched Apache SkyWalking Rover component can use eBPF technology to accurately locate Istio\u0027s key performance issues.\n\nOn the data plane, we can increase Envoy\u0027s throughput to optimize Istio\u0027s performance by:\n\n- Disable Zipkin tracing or reduce the sample rate.\n- Simplified access log format.\n- Disable Envoy\u0027s Access Log Service (ALS).\n\nFor data on the impact of the above optimizations on Envoy throughput, see Using eBPF to pinpoint key performance issues for service meshes.\n\n## Envoy: the service mesh\u0027s leading actor\n\nWe know that the service mesh is composed of the data plane and the control plane. From the above list of service mesh open source projects, we can see that most of the service mesh open source projects are based on Envoy, and then develop their own control plane. Remember when I likened a service mesh to a gig earlier in this article? In this service mesh performance, there is no way to think that Envoy is the leading actor. The xDS protocol, invented by Envoy, has basically become a general API for service meshes. Many open source projects for service meshes use Envoy as the data plane. Shown below is the architecture diagram of Envoy.\n\n![Envoy Architecture Diagram](envoy-arch.svg)\n\nxDS is the core that differentiates Envoy from other proxies because its code and parsing process are very complex and it is difficult to expand. The following is a topology diagram of Istio components. From the figure, we can see that there is not only one \u0060envoy\u0060 process but a \u0060pilot-agent\u0060.\n\n{{\u003cfigure title=\u0022Istio component topology\u0022 alt=\u0022image\u0022 id=\u0022istio-components\u0022 src=\u0022istio-components.svg\u0022\u003e}}\n\nThe role of the \u0060pilot-agent\u0060 process is as follows:\n\n- As \u0060the\u0060 parent process of, responsible for the lifecycle management of Envoy.\n- Receive pushes from the control plane, configure the proxy and certificates.\n- Collect Envoy statistics and aggregate sidecar statistics for Prometheus to collect.\n- A built-in local DNS proxy is used to resolve the internal domain name of the cluster that cannot be resolved by Kubernetes DNS.\n- Health checks for Envoy and DNS proxy.\n\nFrom the above functions, we can see that the \u0060pilot-agent\u0060 process is mainly used to interact with Istiod and play a commanding and auxiliary role for Envoy. The core component of Istio is Envoy. So will Envoy \u0022act and guide,\u0022 no longer cooperate with Istio, and build its own control plane?\n\n\u003e *In a Sidecar container, the \u0060pilot-agent\u0060 is like Envoy\u0027s \u0022Sidecar\u0022.*\n\n{{\u003ccallout note \u0022Readers to think about\u0022\u003e}}\nCan the \u0060pilot-agent\u0060 function be built directly into Envoy, thus eliminating the \u0060pilot-agent\u0060?\n{{\u003c\/callout\u003e}}\n\n## Envoy Gateway unified service mesh gateway\n\nIn Kubernetes, the first resource object used to expose services in a cluster, in addition to the service resource object, is Ingress. Using Ingress you simply open an external access point for the cluster, routing traffic to specific services via HTTP Hosts and \u0060path\u0060. Compared with exposing services directly to service resources , it can reduce the network access point (PEP) of the cluster and reduce the risk of the cluster being attacked by the network. The following figure shows the process of using Ingress to access services in the cluster.\n\n![Kubernetes Ingress traffic access flow chart](ingress.svg)\n\nBefore Kubernetes, API Gateway software was widely used as edge routing. When referring to Istio, Istio\u0027s custom Gateway resources are added, which makes accessing resources in the Istio service mesh one more option, as shown in the following figure.\n\n![Ways to access services in the Istio mesh](access-cluster.svg)\n\nNow, to expose services in a single Istio mesh, how do I choose between \u0060NodePort\u0060, \u0060LoadBalancer\u0060, Istio Gateway, Kubernetes Ingress, and API Gateway software? If it is a multi-cluster service mesh, how do clients access services within the mesh? Our service mesh lead, Envoy, has done this well and is used in many forms:\n\n- Istio, Kuma, and Consul Connect all use Envoy as a sidecar proxy.\n- Kubernetes Ingress Controller\/API Gateway: [Contour](https:\/\/github.com\/projectcontour\/contour), [Emissary](https:\/\/github.com\/emissary-ingress\/emissary), [Hango](https:\/\/github.com\/hango-io\/hango-gateway), [Gloo](https:\/\/github.com\/solo-io\/gloo).\n\nThese projects utilize Envoy to implement service meshes and API gateways, with a lot of functional overlap, proprietary features, or a lack of community diversity due to the fact that the Envoy community does not provide a control plane implementation. In order to change the status quo, the Envoy community initiated the Envoy Gateway project, which will not change the Envoy core proxy, xDS, and go-control-plane. The project aims to combine the experience of existing Envoy-based API Gateway related projects. Some Envoy-specific extensions to the Kubernetes Gateway API lower the barrier to entry for Envoy users to use gateways. Because the Envoy Gateway still issues configuration to the Envoy proxy through xDS, you can also use it to manage gateways that support xDS, such as the Istio Gateway.\n\nThe gateways we have seen now are basically used as ingress gateways in a single cluster and can do nothing for multi-cluster and multi-mesh. To cope with multiple clusters, we need to add another layer of gateways on top of Istio and a global control plane to route traffic between multiple clusters, as shown in the figure below.\n\n![Schematic diagram of two-level gateway with multi-cluster and multi-mesh](t2-gateway.svg)\n\n{{\u003ccallout note \u0022A brief introduction to two-tire gateways\u0022\u003e}}\n- The Tire-1 gateway (hereinafter referred to as T1) is located at the application edge and is used in a multi-cluster environment. The same application is hosted on different clusters at the same time, and the T1 gateway routes the application\u0027s request traffic between these clusters.\n- The Tire-2 gateway (hereafter referred to as T2) is located at the edge of a cluster and is used to route traffic to services within that cluster managed by the service mesh.\n{{\u003c\/callout\u003e}}\n\nMulti-cluster service mesh management is achieved by adding a layer of global control plane and APIs in addition to the Istio control plane. Deploying T1 gateways as a cluster prevents a single point of failure. To learn more about two-tier gateways, refer [to Routing Service Mesh Traffic Through Two-Tier Gateway Designs](https:\/\/cloudnative.to\/blog\/designing-traffic-flow-via-tier1-and-tier2-ingress-gateways\/) .\n\nThe configuration of the T1 gateway is as follows:\n\n\u0060\u0060\u0060yaml\napiVersion: gateway.tsb.tetrate.io\/v2\nkind: Tier1Gateway\nmetadata:\n  name: service1-tier1\n  group: demo-gw-group\n  organization: demo-org\n  tenant: demo-tenant\n  workspace: demo-ws\nspec:\n  workloadSelector:\n    namespace: t1\n    labels:\n      app: gateway-t1\n      istio: ingressgateway\n  externalServers:\n  - name: service1\n    hostname: servicea.example.com\n    port: 80\n    tls: {}\n    clusters:\n    - name: cluster1\n      weight: 75\n    - name: cluster2\n      weight: 25 \n\u0060\u0060\u0060\n\nThis configuration exposes \u0060servicea.example.com\u0060  service through the T1 gateway and forwards \u006075%\u0060 of the traffic accessing the service to cluster1 and \u006025%\u0060 of the traffic to cluster2. In addition, in order to deal with the traffic, services, and security configurations in multiple clusters, Tetrate\u0027s flagship product, [Tetrate Service Bridge](https:\/\/www.tetrate.io\/tetrate-service-bridge\/), a series of group APIs have also been added to the TSB documentation for details.\n\n## Istio open source ecosystem\n\nIstio has been open source for more than five years, and many open source projects have emerged in the past two years, among which the more representative ones are:\n\n- Slime (NetEase open source)\n- Tencent\u0027s open source initiatives Aeraki\n- Istio\u0027s official support for Wasm plugins\n\nTheir presence makes Istio more intelligent and expands the scope of Istio.\n\n### Slime\n\nSlime is an Istio-based smart mesh manager open-sourced by the NetEase Shufan microservices team. Slime has been implemented based on Kubernetes Operator and can be used as the CRD manager of Istio. It can define dynamic service governance policies without any customization of Istio, so as to achieve the purpose of automatically and conveniently using the high-level functions of Istio and Envoy.\n\nIn the previous control plane performance optimization, we mentioned optimizing the performance of Istio by \u0022reducing the configuration that needs to be pushed\u0022, but Istio cannot automatically identify and cannot rely on the proxy configuration that needs to be pushed to each sidecar to optimize. Slime provides a  \u0060lazyload\u0060 controller, which can help us implement lazy loading of configuration. Users do not need to configure the \u0060SidecarScope\u0060 manually. Istio can load service configuration and service discovery information on demand.\n\nThe following figure shows the flow chart of updating the data plane configuration with Slime as the management plane of Istio.\n\n![Flowchart for updating Istio data plane configuration using Slime](slime-process.svg)\n\nThe specific steps for updating the data plane configuration are as follows:\n\n1. The Slime Operator completes the initialization of Slime components in Kubernetes according to the administrator\u0027s configuration.\n2. Developers create configurations that conform to the Slime CRD specification and apply them to the Kubernetes cluster.\n3. Slime queries the monitoring data of related services saved in Prometheus, converts Slime CRD to Istio CRD in combination with the configuration of the adaptive part in Slime CRD, and pushes it to Global Proxy at the same time.\n4. Istio monitors the creation of Istio CRDs.\n5. Istio sends the Sidecar Proxy\u0027s configuration information to the corresponding Sidecar Proxy on the data plane.\n\nBecause the first invocation of all services in the data plane passes through the Global Proxy, the Proxy can record the invocation and dependency information of all services, and update the configuration of the Sidecar resource in Istio according to the dependency information. When the routing information is redefined, the original record of the Global Proxy becomes invalid, and a new data structure is required to maintain the calling relationship of the service. Slime created a  \u0060ServiceFence\u0060 to maintain the service invocation relationship and solve the problem of missing service information.\n\n### Aeraki\n\nAeraki Mesh is a service mesh project open sourced by Tencent Cloud in March 2021. It expands support for seven-layer protocols based on Istio and focuses on solving the service governance of **non-HTTP protocols** in Istio.  It entered the CNCF sandbox in June 2022.\n\nThe following figure shows the architectural diagram of Aeraki.\n\n![Aeraki Architecture Diagram](aeraki-arch.svg)\n\nThe process of using Aeraki to serve non-HTTP into an Istio mesh is as follows:\n\n1. Aeraki\u0027s X2Istio component connects to the service registry, obtains the registration information of non-HTTP services, and generates a ServiceEntry to register with Istio.\n2. Aeraki, as the management plane on top of Istio, obtains the ServiceEntry configuration from Istio.\n3. Aeraki judges the protocol type of the service (e.g. \u0060tcp-metaprotocol-dubbo\u0060) through the port command, then generates the MetaProtocol Proxy Filter (compatible with EnvoyFilter) configuration, and at the same time modifies the RDS address to point it to Aeraki.\n4. Istio uses the xDS protocol to deliver the configuration (LDS, CDS, EDS, etc.) to the data plane.\n5. Aeraki generates routing rules based on the information in the service registry and user settings and sends them to the data plane through RDS.\n\nThe key to the whole process of accessing non-HTTP services in Istio is the **MetaProtocol Proxy**. Istio supports HTTP\/HTTP2, TCP and gRPC protocols by default, and experimentally supports Mongo, MySQL and Redis protocols. To use Istio to route traffic for other protocols not only requires a lot of work to modify the Istio control plane and extend Envoy, but also a lot of duplication because different protocols share common control logic. The Envoy MetaProtocol Proxy is a general seven-layer protocol proxy implemented based on Envoy. The MetaProtocol Proxy is an extension based on the Envoy code. It implements basic capabilities such as service discovery, load balancing, RDS dynamic routing, traffic mirroring, fault injection, local\/global traffic limiting, etc. for the seven-layer protocol, which greatly reduces the difficulty of third-party protocol development for Envoy.\n\nThe following figure shows the architecture diagram of MetaProtocol Proxy.\n\n![MetaProtocol Proxy Architecture Diagram](metaprotocol-proxy.svg)\n\nWhen we want to extend Istio to support other seven-layer protocols such as Kafka, Dubbo, and Thrift, we only need to implement the codec interfaces (Decode and Encode) in the above figure, and then we can quickly develop a third-party protocol plug-in based on MetaProtocol. Because MetaProtocol Proxy is an extension of Envoy, you can still develop filters for it in different languages and use \u0060EnvoyFilter\u0060 resources to deliver configuration to the data plane.\n\n### WasmPlugin API\n\nWasmPlugin is an API introduced in Istio 1.12. As a proxy extension mechanism, we can use it to add custom and third-party Wasm modules to the data plane. The diagram below shows how a user can use the WasmPlugin in Istio.\n\n![Flowchart of using WasmPlugin in Istio](wasmplugin.svg)\n\nSpecific steps are as follows:\n\n1. Users use the Proxy-Wasm SDK (currently available in AssemblyScript, C\u002b\u002b, Rust, Zig, and Go) to develop extensions and build them into OCI images (such as Docker images) to upload to the mirror repository.\n2. The user writes the \u0060WasmPlugin\u0060 configuration and applies it to Istio.\n3. The \u0060WasmPlugin\u0060 configuration for the workload in the configuration is selected by the Istio control plane, and the Wasm module is injected into the specified Pod.\n4. The \u0060pilot-agent\u0060 in the sidecar loads the Wasm modules from remote or local files and run them in Envoy.\n\n## Who should use Istio?\n\nWell, having said that, what does this have to do with you? Istio\u0027s relationship with you depends on your role.\n\n- If you are the platform leader, after applying the service mesh, you may enhance the observability of your platform and have a unified platform to manage microservices. You will be the direct beneficiary and the main implementer of the service mesh.\n- If you are an application developer, you will also benefit from a service mesh because you can be more dedicated to the business logic and not worry about other non-functional issues such as retry policies, TLS, etc..\n\nThe following diagram shows the adoption path for service meshes.\n\n![The path to adopt service mesh](adopt.svg)\n\nWhether to adopt a service mesh depends on your technology development stage, whether the application implements containerization and microservices, the need for multi-language, whether mTLS is required, and the acceptance of performance loss.\n\n## Service mesh positioning in the cloud native technology stack\n\nThe development of technology is changing with each passing day. In the past two years, some new technologies have appeared, which seem to challenge the status of the service mesh. Some people claim that it can directly replace the existing service mesh of the classic sidecar model. We should not be confused by the noise of the outside world, correcting the positioning of service mesh in the cloud native technology stack.\n\n\u003e *Blindly promoting a technology and ignoring its applicable scenarios is hooliganism.*\n\nThe diagram below shows the cloud-native technology stack.\n\n![Cloud native technology stack diagram](cloud-native-stack.svg)\n\nWe can see that the \u0022cloud infrastructure\u0022, \u0022middleware\u0022, and \u0022application\u0022 layers in the cloud native technology stack diagram all enumerate some iconic open source projects that build standards in their fields:\n\n- In the field of cloud infrastructure, Kubernetes unifies the standards for container orchestration and application life cycle management, and the Operator mode lays the standards for extending the Kubernetes API and third-party application access.\n- In the field of middleware, the service mesh assumes some or all of the responsibilities of the seven-layer network, observability, and security in the cloud native technology stack. It runs in the lower layer of the application and is almost imperceptible; Dapr (distributed application runtime) defines the capability model of cloud-native middleware. Developers can integrate Dapr\u0027s multi-language SDK into their applications and programs for the distributed capabilities provided by Dapr, without caring about the applications running on them. environment and docking back-end infrastructure. Because the Dapr runtime (Sidecar mode deployment, which contains various building blocks) is running in the same Pod as the application, it automatically connects us with the backend components;\n- In the application field, OAM aims to establish an application model standard, an application through components, characteristics, policies, and workflows.\n\nThe diagram below shows how Istio is positioned for seven-tier mesh management in a cloud-native deployment.\n\n![Istio is positioned in a seven-layer network in a cloud-native architecture](istio-role.svg)\n\n{{\u003ccallout note \u0022What is the relationship between Dapr and Istio?\u0022\u003e}}\n\nSimilarities between Istio and Dapr:\n\n- Both Istio and Dapr can use the sidecar mode deployment model.\n- Both belong to middleware and can also manage communication between services.\n\nDifferences between Istio and Dapr:\n\n- Different goals: Istio\u0027s goal is to build a zero-trust network and define inter-service communication standards, while Dapr\u0027s goal is to build a standard API for middleware capabilities.\n- Different architectures: Istio = Envoy \u002b transparent traffic hijacking \u002b control plane; Dapr = multilingual SDK \u002b standardized API \u002b distributed capability components.\n- However, the application of Istio is almost imperceptible to developers and mainly requires the implementation of the infrastructure operation and maintenance team, while the application of Dapr requires developers to independently choose to integrate the Dapr SDK.\n\n{{\u003c\/callout\u003e}}\n\n## The future of service mesh\n\nIn the above article, I introduced the development context and open source ecosystem of Istio. Next, I will introduce the future trends of Istio service mesh:\n- Zero trust network\n- Hybrid cloud\n\n\u003e *The future of service meshes lies in being the infrastructure for zero-trust networks and hybrid clouds.*\n\nThis is also the direction of Tetrate, the enterprise-level service mesh provider of the author\u0027s company. We are committed to building an application-aware network suitable for any environment and any load and providing a zero-trust hybrid cloud platform. Shown below is the architecture diagram of Tetrate\u0027s flagship product, Tetrate Service Bridge.\n\n![TSB Architecture Diagram](tsb.svg)\n\nTetrate was founded by the founders of the Istio project, and TSB is based on open source Istio, Envoy, and Apache SkyWalking. We also actively contributed to the upstream community and participated in the creation of the Envoy Gateway project to simplify the use of Envoy gateways (XCP in the figure above is a gateway built with Envoy).\n\n## Zero trust\n\nZero Trust is an important topic at IstioCon 2022. Istio is becoming an important part of zero trust, the most important of which is **identity-oriented control** rather than network-oriented control.\n\n{{\u003ccallout note \u0022What is Zero Trust?\u0022\u003e}}\n\nZero Trust is a security philosophy, not a best practice that all security teams follow. The concept of zero trust was proposed to bring a more secure network to the cloud-native world. Zero trust is a theoretical state where all consumers within a network not only have no authority but also have no awareness of the surrounding network. The main challenges of zero trust are the increasingly granular authorization and time limit for user authorization.\n\n{{\u003c\/callout\u003e}}\n\n### Authentication\n\nIstio 1.14 adds support for SPIRE. SPIRE (SPIFFE Runtime Environment, CNCF Incubation Project) is an implementation of SPIFFE (Secure Production Identity Framework For Everyone, CNCF Incubation Project). In Kubernetes, we use ServiceAccount to provide identity information for workloads in Pods, and its core is based on Token (using Secret resource storage) to represent workload identity. A token is a resource in a Kubernetes cluster. How to unify the identities of multiple clusters and workloads running in non-Kubernetes environments (such as virtual machines)? That\u0027s what SPIFFE is trying to solve.\n\nThe purpose of SPIFFE is to establish an open and unified workload identity standard based on the concept of zero trust, which helps to establish a fully identifiable data center network with zero trust. The core of SPIFFE is to define a short-lived encrypted identity document—SVID (SPFFE Verifiable Identity Document)—through a simple API, which is used as an identity document (based on an X.509 certificate or JWT token) for workload authentication. SPIRE can automatically rotate SVID certificates and keys according to administrator-defined policies, dynamically provide workload identities, and Istio can dynamically consume these workload identities through SPIRE.\n\nThe Kubernetes-based SPIRE architecture diagram is shown below.\n\n![Architecture diagram of SPIRE deployed in Kubernetes](spire-with-kubernetes.svg)\n\nIstio originally used the Citadel service in Istiod to be responsible for certificate management in the service mesh, and issued the certificate to the data plane through the xDS (to be precise, SDS API) protocol. With SPIRE, the work of certificate management is handed over to SPIRE Server. SPIRE also supports the Envoy SDS API. After we enable SPIRE in Istio, the traffic entering the workload pod will be authenticated once after being transparently intercepted into the sidecar. The purpose of authentication is to compare the identity of the workload with the environment information it runs on (node, Pod\u0027s ServiceAccount and Namespace, etc.) to prevent identity forgery. Please refer to How to Integrate SPIRE in Istio to learn how to use SPIRE for authentication in Istio.\n\nWe can deploy SPIRE in Kubernetes using the Kubernetes Workload Registrar, which automatically registers the workload in Kubernetes for us and generates an SVID. The registration machine is a Server-Agent architecture, which deploys a SPIRE Agent on each node, and the Agent communicates with the workload through a shared UNIX Domain Socket. The following diagram shows the process of using SPIRE for authentication in Istio.\n\n![Schematic diagram of the SPIRE-based workload authentication process in Istio\u0022](workload-attestation.svg)\n\nThe steps to using SPIRE for workload authentication in Istio are as follows:\n\n1. To obtain the SIVD, the SPIRE Agent is referred to as pilot-agent via shared UDS.\n1. The SPIRE Agent asks Kubernetes (to be precise, the kubelet on the node) for load information.\n1. The kubelet returns the information queried from the API server to the workload validator.\n1. The validator compares the result returned by the kubelet with the identity information shared by the sidecar. If it is the same, it returns the correct SVID cache to the workload. If it is different, the authentication fails.\n\nPlease refer to the SPIRE documentation for the detailed process of registering and authenticating workloads.\n\n### NGAC\n\nWhen each workload has an accurate identity, how can the permissions of these identities be restricted? RBAC is used by default in Kubernetes for access control. As the name suggests, this access control is based on roles. Although it is relatively simple to use, there is a role explosion problem for large-scale clusters—that is, there are too many roles, and the types are not static, making it difficult to track and audit role permission models. In addition, the access rights of roles in RBAC are fixed, and there is no provision for short-term use rights, nor does it take into account attributes such as location, time, or equipment. Enterprises using RBAC have difficulty meeting complex access control requirements to meet the regulatory requirements that other organizations demand.\n\nNGAC, or Next Generation Access Control, takes the approach of modeling access decision data as a graph. NGAC enables a systematic, policy-consistent approach to access control, granting or denying user management capabilities with a high level of granularity. NGAC was developed by NIST (National Institute of Standards and Technology) and is currently used for rights management in Tetrate Service Bridge. For more information on why you should choose NGAC over ABAC and RBAC, please refer to the blog post Why you should choose NGAC as your permission control model.\n\n## Hybrid cloud\n\nIn practical applications, we may deploy multiple Kubernetes clusters in various environments for reasons such as load balancing; isolation of development and production environments; decoupling of data processing and data storage; cross-cloud backup and disaster recovery; and avoiding vendor lock-in. The Kubernetes community provides a \u0022cluster federation\u0022 function that can help us create a multi-cluster architecture, such as the common Kubernetes multi-cluster architecture shown in the figure below, in which the host cluster serves as the control plane and has two member clusters, namely West and East.\n\n![Kubernetes Cluster Federation Architecture](multicluster.svg)\n\nCluster federation requires that the networks between the host cluster and member clusters can communicate with each other but does not require network connectivity between member clusters. The host cluster serves as the API entry, and all resource requests from the outside world to the host cluster will be forwarded to the member clusters. The control plane of the cluster federation is deployed in the host cluster, and the \u0022Push Reconciler\u0022 in it will propagate the identities, roles, and role bindings in the federation to all member clusters. Cluster federation simply \u0022connects\u0022 multiple clusters together, replicating workloads among multiple clusters, and the traffic between member clusters cannot be scheduled, nor can true multi-tenancy be achieved.\n\nCluster federation is not enough to realize hybrid clouds. In order to realize hybrid clouds in the true sense, it is necessary to achieve interconnection between clusters and realize multi-tenancy at the same time. TSB builds a general control plane for multi-cluster management on top of Istio and then adds a management plane to manage multi-clusters, providing functions such as multi-tenancy, management configuration, and observability. Below is a diagram of the multi-tenancy and API of the Istio management plane.\n\n![Schematic diagram of TSB\u0027s management plane built on top of Istio](tsb-management-plane.svg)\n\nIn order to manage the hybrid cloud, TSB built a management plane based on Istio, created tenant and workspace resources, and applied the gateway group, traffic group, and security group to the workloads in the corresponding cluster through selectors. For the detailed architecture of TSB, please refer to the [TSB documentation](https:\/\/docs.tetrate.io\/service-bridge).\n\nThanks for reading.\n', '\/en\/blog\/beyond-istio-oss\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">This article explains the background of Istio&#39;s birth, its position in the cloud-native technology stack, and the development direction of Istio.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/istio-service-mesh-book/">In-Depth Understanding of Istio: Announcing the Publication of a New Istio Book</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Jun 15, 2022</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('In-Depth Understanding of Istio: Announcing the Publication of a New Istio Book', 'By the Cloud Native Community(China)', '\n![](book.jpg)\n\nIt\u0027s been more than 5 years since Google, IBM, and Lyft unveiled the Istio open source project in May 2017. The Istio project has developed from a seed to a tall tree in these years. Many domestic books on the Istio service mesh were launched in the two years following the release of Istio 1.0 in 2018. My country is at the forefront of the world in the field of Istio book publishing.\n\n## Service mesh: one of the core technologies of cloud native\n\nToday, Istio is nearly synonymous with service mesh in China. The development of service mesh, as one of the core cloud-native technologies described by CNCF (Cloud Native Computing Foundation), has gone through the following stages.\n\n- 2017-2018: Exploratory Phase\n- 2019-2020: Early Adopter Phase\n- 2021 to present: Implementation on a large scale and ecological development stage\n\nCloud native technology enables enterprises to design and deploy elastically scalable applications in new dynamic settings such as public, private, and hybrid clouds, according to the CNCF. Containers, service meshes, microservices, immutable infrastructure, and declarative APIs are examples of cloud native technology.\n\nService mesh has been included to the CNCF definition of cloud native, indicating that it is one of the representative technologies of cloud native. Google is donating Istio to CNCF today, and we have reason to expect that as a CNCF project, Istio\u0027s community will be more open, and its future development will be more smooth.\n\n## Service mesh and cloud native applications\n\nCloud-native development is gaining traction. Despite the frequent emergence of new technologies and products, service mesh has maintained its place as \u0022cloud-native network infrastructure\u0022 as part of the overall cloud-native technology stack throughout the past year. The cloud-native technology stack model is depicted in the diagram below, with representative technologies for each layer to define the standard. Service mesh and other cloud-native technologies complement each other as a new era of middleware emerges. Dapr (Distributed Application Runtime) defines the cloud-native middleware capability model, OAM defines the cloud-native application model, and so on, whereas service mesh Lattice defines a cloud-native seven-layer network model.\n\n![Cloud Native Application Model](model.jpg)\n\n## Why you need a service mesh\n\nUsing a service mesh isn\u0027t tantamount to abandoning Kubernetes; it just makes sense. The goal of Kubernetes is to manage application lifecycles through declarative configuration, whereas the goal of service mesh is to provide traffic control, security management, and observability amongst apps. How do you set up load balancing and flow management for calls between services after a robust microservice platform has been developed with Kubernetes?\n\nMany open source tools, including Istio, Linkerd, MOSN, and others, support Envoy\u0027s xDS protocol. The specification of xDS is Envoy\u0027s most significant contribution to service mesh or cloud native. Many various usage cases, such as API gateways, sidecar proxies in service meshes, and edge proxies, are derived from Envoy, which is simply a network proxy, a modern version of the proxy configured through the API.\n\nIn a nutshell, the move from Kubernetes to Istio was made for the following reasons.\n\n- Application life cycle management, specifically application deployment and management, is at the heart of Kubernetes (scaling, automatic recovery, and release).\n- Kubernetes is a microservices deployment and management platform that is scalable and extremely elastic.\n- Transparent proxy is the cornerstone of service mesh, which intercepts communication between microservices via sidecar proxy and then regulates microservice behavior via control plane settings. The deployment mode of service meshes has introduced new issues today. For service meshes, sidecar is no longer required, and an agentless service mesh based on gRPC is also being tested.\n- xDS is a protocol standard for configuring service meshes, and a gRPC-based xDS is currently being developed.\n- Kubernetes traffic management is decoupled with the service mesh. The kube-proxy component is not required to support traffic within the service mesh. The traffic between services is controlled by an abstraction close to the microservice application layer to achieve security and observability features.\n- In Kubernetes, service mesh is an upper-level abstraction of service, and Serverless is the next stage, which is why Google released Knative based on Kubernetes and Istio following Istio.\n\n## Open source in the name of the community\n\nThe ServiceMesher community was founded in May 2018 with the help of Ant Financial. Following that, a tornado of service meshes erupted in China, and the community-led translation of Istio\u0027s official documentation reached a fever pitch.\n\nI became aware of a dearth of Chinese resources for systematically teaching Istio over time, so in September 2018, I began to plan and create an Istio book, launching the Istio Handbook open source e-book project on GitHub. I met many friends who are also interested in Istio and service mesh technology in the online and offline events of the community a few months later, with the promotion of service mesh technology and the expansion of the ServiceMesher community. We unanimously agreed to collaborate on an open source Istio e-book, which will compile the community\u0027s important writings and experience into a logical text and make it available to the majority of developers.\n\nHundreds of people volunteered and began co-authoring the book in March 2019 under the auspices of the Community Stewardship Council. In May 2020, we created a cloud-native community that incorporated the original ServiceMesher community in order to further promote cloud-native technology and expand the technical knowledge supplied by the community. The scope of community operations has also widened, moving away from service mesh to more extensive cloud-native tools.\n\nThe editorial board for this book, which includes me, Ma Ruofei, Wang Baiping, Wang Wei, Luo Guangming, Zhao Huabing, Zhong Hua, and Guo Xudong, was founded in October 2020. We performed further version updates, improvements, and optimizations to this book under the supervision and assistance of the publishing business. This book, \u0022In-depth Understanding of Isito: Advanced Practice of Cloud Native Service Mesh,\u0022 finally met you after many iterations.\n\n![The book cover](cover.jpg)\n\n## About this book\n\nAfter version 1.5, Istio underwent considerable architectural modifications, and various new or better features were added, including the addition of a smart DNS proxy, additional resource objects, increased support for virtual machines, and more.\n\nThis book is based on the new edition of Istio, and it aims to provide readers with the most up-to-date and comprehensive content possible by following the newest trends in the Istio community. Furthermore, several of the book\u0027s authors are front-line development or operation and maintenance engineers with extensive Istio expertise, offering detailed and useful reference cases for the book.\n\nThis book is currently available on the [JD.com](https:\/\/item.jd.com\/13200745.html). Please read \u0022In-depth Understanding of Isito: Advanced Practice of Cloud Native Service Mesh\u0022 if you want to learn more about Istio!\n', '\/en\/blog\/istio-service-mesh-book\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">By the Cloud Native Community(China)</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/what-is-new-in-istio-1-13/">What&#39;s New in Istio 1.13?</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Mar 28, 2022</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('What\u0027s New in Istio 1.13?', 'In February 2022, Istio released 1.13.0 and 1.13.1. This blog will give you an overview of what’s new in these two releases.', '\nIstio 1.13 is the first release of 2022, and, not surprisingly, the Istio team will continue to release new versions every quarter. Overall, the new features in this release include:\n\n- Support for newer versions of Kubernetes\n- New API – ProxyConfig, for configuring sidecar proxies\n- Improved Telemetry API\n- Support for hostname-based load balancers with multiple network gateways\n\n### Support for Kubernetes Versions\n\nI often see people asking in the community which Istio supports Kubernetes versions. Istio’s website has a clear list of supported Kubernetes versions. You can see [here](https:\/\/istio.io\/latest\/docs\/releases\/supported-releases\/#support-status-of-istio-releases) that Istio 1.13 supports Kubernetes versions 1.20, 1.21, 1.22, and 1.23, and has been tested but not officially supported in Kubernetes 1.16, 1.17, 1.18, 1.19.\n\nWhen configuring Istio, there are a lot of checklists. I noted them all in the [Istio cheatsheet](https:\/\/github.com\/tetratelabs\/istio-cheatsheet). There are a lot of cheat sheets about configuring Istio, using resources, dealing with everyday problems, etc., in this project, which will be online soon, so stay tuned.\n\nThe following screenshot is from the Istio cheatsheet website, it shows the basic cheat sheet for setting up Istio.\n\n![Istio cheatsheet](istio-cheatsheet.jpg)\n\n### Introducing the new ProxyConfig API\n\nBefore Istio version 1.13, if you wanted to customize the configuration of the sidecar proxy, there were two ways to do it.\n\n**MeshConfig**\n\nUse MeshConfig and use IstioOperator to modify it at the Mesh level. For example, use the following configuration to alter the default discovery port for istiod.\n\n\u0060\u0060\u0060yaml\napVersion: install.istio.io\/v1alpha1\nkind: IstioOperator\nspec:\n  meshConfig:\n\t  defaultConfig:\n      discoveryAddress: istiod:15012\n\u0060\u0060\u0060\n\n**Annotation in the Pods**\n\nYou can also use annotation at the Pod level to customize the configuration. For example, you can add the following annotations to Pod to modify the default port for \u0060istiod\u0060 of the workload:\n\n\u0060\u0060\u0060yaml\nanannotations:\n  proxy.istio.io\/config: |\n    discoveryAddress: istiod:15012\n\u0060\u0060\u0060\n\nWhen you configure sidecar in either of these ways, the fields set in annotations will completely override the default fields in MeshConfig. Please refer to the [Istio documentation](https:\/\/istio.io\/latest\/docs\/reference\/config\/istio.mesh.v1alpha1\/#ProxyConfig) for all configuration items of ProxyConfig.\n\n**The new API – ProxyConfig**\n\nBut in 1.13, a new top-level custom resource, ProxyConfig, has been added, allowing you to customize the configuration of your sidecar proxy in one place by specifying a namespace and using a selector to select the scope of the workload, just like any other CRD. Istio currently has limited support for this API, so please refer to the [Istio documentation](https:\/\/istio.io\/latest\/docs\/reference\/config\/networking\/proxy-config\/) for more information on the ProxyConfig API.\n\nHowever, no matter which way you customize the configuration of the sidecar proxy, it does not take effect dynamically and requires a workload restart to take effect. For example, for the above configuration, because you changed the default port of istiod, all the workloads in the mesh need to be restarted before connecting to the control plane.\n\n### Telemetry API\n\n[MeshConfig](https:\/\/istio.io\/latest\/docs\/reference\/config\/istio.mesh.v1alpha1\/#MeshConfig-ExtensionProvider) customized extensions and configurations in the Istio mesh. The three pillars of observability– Metrics, Telemetry, and Logging– can each be docked to different providers. The [Telemetry API](https:\/\/istio.io\/latest\/docs\/tasks\/observability\/telemetry\/) gives you a one-stop place for flexible configuration of them. Like the ProxyConfig API, the Telemetry API follows the configuration hierarchy of Workload Selector \u003e Local Namespace \u003e Root Configuration Namespace. The API was introduced in Istio 1.11 and has been further refined in that release to add support for OpenTelemetry logs, filtered access logs, and custom tracing service names. See [Telemetry Configuration](https:\/\/istio.io\/latest\/docs\/reference\/config\/telemetry\/) for details.\n\n### Automatic resolution of multi-network gateway hostnames\n\nIn September 2021, a member of the Istio community [reported an issue](https:\/\/szabo.jp\/2021\/09\/22\/multicluster-istio-on-eks\/) with the EKS load balancer failing to resolve when running multi-cluster Istio in AWS EKS. Workloads that cross cluster boundaries need to be communicated indirectly through a dedicated east-west gateway for a multi-cluster, multi-network mesh. You can follow the instructions on [Istio’s website](https:\/\/istio.io\/latest\/docs\/setup\/install\/multicluster\/multi-primary_multi-network\/) to configure a multi-network, primary-remote cluster, and Istio will automatically resolve the IP address of the load balancer based on the hostname.\n\n### Istio 1.13.1 fixing the critical security vulnerabilities\n\nIstio 1.13.1 was released to fix a known [critical vulnerability](https:\/\/cve.mitre.org\/cgi-bin\/cvekey.cgi?keyword=CVE-2022-23635) that could lead to an unauthenticated control plane denial of service attack.\n\nThe figure below shows a multi-cluster primary-remote mesh where istiod exposes port 15012 to the public Internet via a gateway so that a pod on another network can connect to it.\n\n![Multi-network Mesh](multi-network-mesh.jpg)\n\nWhen installing a multi-network, primary-remote mode Istio mesh, for a remote Kubernetes cluster to access the control plane, an east-west Gateway needs to be installed in the Primary cluster, exposing port 15012 of the control plane istiod to the Internet. An attacker could send specially crafted messages to that port, causing the control plane to crash. If you set up a firewall to allow traffic from only some IPs to access this port, you will be able to reduce the impact of the problem. It is recommended that you upgrade to Istio 1.13.1 immediately to resolve the issue completely.\n\n### IstioCon 2022\n\n![IstioCon 2022](istiocon-2022.jpg)\n\nFinally, as a committee member for the last and current IstioCon, I call on everyone to register for [IstioCon 2022](https:\/\/events.istio.io\/istiocon-2022\/), which will be held online on April 25! It will be an industry-focused event, a platform to connect contributors and users to discuss the uses of Istio in different architectural setups, its limitations, and where to take the project next. The main focus on end-user companies, as we look forward to sharing a diversity of case studies showing how to use Istio in production.\n', '\/en\/blog\/what-is-new-in-istio-1-13\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">In February 2022, Istio released 1.13.0 and 1.13.1. This blog will give you an overview of what’s new in these two releases.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/service-mesh-in-2021/">Service Mesh in 2021: The Ecosystem Is Emerging</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Jan 12, 2022</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Service Mesh in 2021: The Ecosystem Is Emerging', 'A review of the development of Service Mesh in 2021.', '\nAs the service mesh architecture concept gains traction and the scenarios for its applications emerge, there is no shortage of discussions about it in the community. I have worked on service mesh with the community for 4 years now, and will summarize the development of service mesh in 2021 from this perspective. Since Istio is the most popular service mesh, this article will focus on the technical and ecological aspects of Istio.\n\n## Service mesh: a critical tech for Cloud Native Infrastructure \n\nAs one of the vital technologies [defined by CNCF](https:\/\/github.com\/cncf\/toc\/blob\/main\/DEFINITION.md) for cloud native, Istio has been around for five years now. Their development has gone through the following periods.\n\n- Exploration phase: 2017-2018\n- Early adopter phase: 2019-2020\n- Large-scale landing and ecological development phase: 2021-present\n\nService mesh has crossed the “chasm”(refer [Crossing the Chasm](https:\/\/thinkinsights.net\/strategy\/crossing-the-chasm\/) theory) and is in between the “early majority” and “late majority” phases of adoption. Based on feedback from the audience of [Istio Weekly,](https:\/\/github.com\/tetratelabs\/istio-weekly\/) users are no longer blindly following new technologies for experimentation and are starting to consider whether they need them in their organization dialectically.\n\n![Cross the chasm](008i3skNly1gysddnj9i2j30sg0fqaaz.jpg)\n\nWhile new technologies and products continue to emerge, the service mesh, as part of the cloud native technology stack, has continued to solidify its position as the “cloud native network infrastructure” over the past year. The diagram below illustrates the cloud native technology stack model, where each layer has several representative technologies that define the standard. As new-age middleware, the service mesh mirrors other cloud native technologies, such as [Dapr](https:\/\/dapr.io\/) (Distributed Application Runtime), which represents the capability model for cloud native middleware, [OAM](https:\/\/oam.dev\/), which defines the cloud native application model, and the service mesh, which defines the L7 network model.\n\n![Cloud Native Stack](008i3skNly1gysddogtenj30sg0qlwgs.jpg)\n\nA layered view of the cloud native application platform technology stack\n\n## Optimizing the mesh for large scale production applications with different deployment models\n\nOver the past year, the community focused on the following areas.\n\n- Performance optimization: performance issues of service mesh in large-scale application scenarios.\n- Protocol and extensions: enabling service mesh to support arbitrary L7 network protocols.\n- Deployment models: Proxyless vs. Node model vs. Sidecar model.\n- eBPF: putting some of the service mesh’s capabilities to the kernel layer.\n\n### Performance optimization\n\nIstio was designed to serve service to service traffic by “proto-protocol forwarding”. The goal is making the service mesh as “transparent” as possible to applications. Thus using IPtables to hijack the traffic, according to the community-provided test results Istio 1.2 adds only 3 ms to the baseline latency for a mesh with 1000 RPS on 16 connections. However, because of issues inherent in the IPtables conntrack module, Istio’s performance issues begin to emerge as the mesh size increases. To optimize the performance of the Istio sidecar for resource usage and network latency, the community gave the following solutions.\n\n- Sidecar configuration: By configuring service dependencies manually or by adding an Operator to the control plane, the number of service configurations sent to Sidecar can be reduced, thus reducing the resource footprint of the data plane; for more automatic and intelligent configuration of Sidecar, the open source projects [Slime](https:\/\/github.com\/slime-io\/slime) and [Aeraki](https:\/\/github.com\/aeraki-framework\/aeraki) both offer their innovative configuration loading solutions.\n- The introduction of eBPF: eBPF can be a viable solution to optimize the performance of the service mesh. Some Cilium-based startups even radically propose to use eBPF to replace the Sidecar proxy completely. Still, the Envoy proxy\/xDS protocol has become the proxy for the service mesh implementation and supports the Layer 7 protocol very well. We can use eBPF to improve network performance, but complex protocol negotiation, parsing, and user scaling remain challenging to implement on the user side.\n\n### Protocol and extensions\n\nExtensibility of Istio has always been a significant problem, and there are two aspects to Istio’s extensibility.\n\n- Protocol level: allowing Istio to support all L7 protocols\n- Ecological: allowing Istio to run more extensions\n\nIstio uses Envoy as its data plane. Extending Istio is essentially an extension of Envoy’s functionality. Istio’s official solution is to use WebAssembly, and in Istio 1.12, the [Wasm plugin configuration API](https:\/\/www.tetrate.io\/blog\/istio-wasm-extensions-and-ecosystem\/) was introduced to extend the Istio ecosystem. Istio’s extension mechanism uses the [Proxy-Wasm Application Binary Interface (ABI)](https:\/\/github.com\/proxy-wasm\/spec) specification to provide a set of proxy-independent streaming APIs and utilities that can be implemented in any language with an appropriate SDK. Today, Proxy-Wasm’s SDKs are AssemblyScript (similar to TypeScript), C\u002b\u002b, Rust, Zig, and Go (using the TinyGo WebAssembly System Interface).\n\nThere are still relatively few WebAssembly extensions available, and many enterprises choose to customize their CRD and build a service mesh management plane based on Istio. In addition, making Istio support heterogeneous environments for all workloads, such as virtual machines and containers, is also in strong demand for end-users. It allows them to migrate applications from traditional loads to service mesh easily. Finally, there is the hybrid cloud traffic management with multiple clusters and mesh, which is a more advanced requirement.\n\n### Deployment models\n\nWhen the service mesh concept first emerged, there was a debate between the Per-node and Sidecar models, represented by Linkerd and Istio. eBPF later proposed a kernel to sink the service mesh, which led to more service mesh deployment models, as shown in the figure below.\n\n![Service Mesh Deployment Models](008i3skNly1gysddpco2mj30qz0sgwhk.jpg)\n\nThese four deployment methods have their own advantages and disadvantages, the specific choice of which depends on the actual situation.\n\n### Development of the Istio ecosystem and the projects that support Istio\n\n2021 was also an exciting year for the Istio community, with a series of events and tutorials.\n\n- February, the first Istio distribution, [Tetrate Istio Distro (TID)](https:\/\/istio.tetratelabs.io\/).\n- February, the first [IstioCon](https:\/\/events.istio.io\/istiocon-2021\/) was held online, with over 2,000 participants.\n- March, the first free online [Istio Fundamentals Course](https:\/\/academy.tetrate.io\/courses\/istio-fundamentals) is released.\n- May, the first [Certification Istio Administrator exam](https:\/\/academy.tetrate.io\/courses\/certified-istio-administrator) be released.\n- May, ServiceMeshCon Europe was held online.\n- July, [Istio Meetup China](https:\/\/istio.io\/latest\/zh\/blog\/2021\/istiomeetups-china\/) was held in Beijing with more than 100 attendees.\n- October, ServiceMeshCon North America was held in Los Angeles.\n\nThere are also numerous open source projects related to Istio Service Mesh, as shown in the table below.\n\n| **Project**                                                  | **Value**                                                    | **Relationship with Istio**                                  | **Category** | **Launch Date** | **Dominant company** | **Number of stars** |\n| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------ | --------------- | -------------------- | ------------------- |\n| [Envoy](https:\/\/github.com\/envoyproxy\/envoy)                 | Cloud native high-performance edge\/middle-service proxy      | The default data plane                                       | proxy        | September 2016  | Lyft                 | 18700               |\n| [Istio](https:\/\/github.com\/istio\/istio\/)                     | Connection, secure, control, and observation services.       | Control plane                                                | service mesh | May 2017        | Google               | 29100               |\n| [Emissary Gateway](https:\/\/github.com\/emissary-ingress\/emissary) | Kubernetes native API gateway for microservices, built on Envoy | Connectable to Istio                                         | gateway      | February 2018   | Ambassador           | 3600                |\n| [APISIX](https:\/\/github.com\/apache\/apisix)                   | Cloud native API gateways                                    | It can run as a data plane for Istio or as a gateway on its own | gateway      | June 2019       | API7                 | 8100                |\n| [MOSN](https:\/\/github.com\/mosn\/mosn)                         | Cloud native edge gateways \u0026 agents                          | Available as Istio data plane                                | proxy        | December 2019   | Ant                  | 3500                |\n| [Slime](https:\/\/github.com\/slime-io\/slime)                   | Intelligent service mesh manager based on Istio              | Adding a management plane to Istio                           | extensions   | January 2021    | NetEase              | 236                 |\n| [GetMesh](https:\/\/github.com\/tetratelabs\/getmesh)            | Istio integration and command-line management tools          | Utility for Istio multi-version management                   | tools        | February 2021   | Tetrate              | 95                  |\n| [Aeraki](https:\/\/github.com\/aeraki-framework\/aeraki)         | Manage any of Istio’s seven layers of load                   | Extended multi-protocol support                              | extensions   | March 2021      | Tencent              | 330                 |\n| [Layotto](https:\/\/github.com\/mosn\/layotto\/)                  | Cloud native application runtime                             | Using as a data plane for Istio                              | runtime      | June 2021       | Ant                  | 393                 |\n| [Hango Gateway](https:\/\/github.com\/hango-io\/hango-gateway)   | API gateways built on Envoy and Istio                        | Integrates with Istio                                        | gateway      | August 2021     | NetEase              | 253                 |\n\nNote: Data is as of January 6, 2022\n\n## Summary\n\nLooking back, we can see that, unlike previous years where users were experimenting, users in 2021 looked for more practical uses for service mesh before implementing them. Their position as the infrastructure of cloud native networks is further strengthened, and more importantly, the service mesh ecosystem is emerging. Looking ahead, in 2022, two technologies to watch are eBPF and WebAssembly(Wasm). We believe that more good examples of service mesh practices will emerge, taking the ecology and standardization a step further.\n', '\/en\/blog\/service-mesh-in-2021\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">A review of the development of Service Mesh in 2021.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/istio-extensions-slime-and-aeraki/">Introducing Slime and Aeraki in the Evolution of Istio Open-Source Ecosystem</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Jan 10, 2022</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Introducing Slime and Aeraki in the Evolution of Istio Open-Source Ecosystem', 'In this article, I’ll introduce you two Istio extension projects: Aeraki and Slime.', '\nIt’s been more than [four years](https:\/\/www.tetrate.io\/blog\/happy-istio-4th-anniversary-retrospect-and-outlook\/) since Istio launched in May 2017, and while the project has had a strong following on GitHub and 10\u002b releases, its growing open-source ecosystem is still in its infancy. \n\nRecently added support for [WebAssembly extensions](https:\/\/www.tetrate.io\/blog\/istio-wasm-extensions-and-ecosystem\/) has made the most popular open source service mesh more extensible than ever. This table lists the open-source projects in the Istio ecosystem as of November 11, 2021, sorted by open-source date. These projects enhance the Istio service mesh with gateways, extensions, utilities, and more. In this article, I’ll highlight the two new projects in the category of extensions.\n\n| **Project**                                                  | **Value**                                                    | **Relationship with Istio**                                  | **Category** | **Launch Date** | **Dominant company** | **Number of stars** |\n| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------ | --------------- | -------------------- | ------------------- |\n| [Envoy](https:\/\/github.com\/envoyproxy\/envoy)                 | Cloud native high-performance edge\/middle-service proxy      | The default data plane                                       | proxy        | September 2016  | Lyft                 | 18700               |\n| [Istio](https:\/\/github.com\/istio\/istio\/)                     | Connection, secure, control, and observation services.       | Control plane                                                | service mesh | May 2017        | Google               | 29100               |\n| [Emissary Gateway](https:\/\/github.com\/emissary-ingress\/emissary) | Kubernetes native API gateway for microservices, built on Envoy | Connectable to Istio                                         | gateway      | February 2018   | Ambassador           | 3600                |\n| [APISIX](https:\/\/github.com\/apache\/apisix)                   | Cloud native API gateways                                    | It can run as a data plane for Istio or as a gateway on its own | gateway      | June 2019       | API7                 | 8100                |\n| [MOSN](https:\/\/github.com\/mosn\/mosn)                         | Cloud native edge gateways \u0026 agents                          | Available as Istio data plane                                | proxy        | December 2019   | Ant                  | 3500                |\n| [Slime](https:\/\/github.com\/slime-io\/slime)                   | Intelligent service mesh manager based on Istio              | Adding a management plane to Istio                           | extensions   | January 2021    | NetEase              | 236                 |\n| [GetMesh](https:\/\/github.com\/tetratelabs\/getmesh)            | Istio integration and command-line management tools          | Utility for Istio multi-version management                   | tools        | February 2021   | Tetrate              | 95                  |\n| [Aeraki](https:\/\/github.com\/aeraki-framework\/aeraki)         | Manage any of Istio’s seven layers of load                   | Extended multi-protocol support                              | extensions   | March 2021      | Tencent              | 330                 |\n| [Layotto](https:\/\/github.com\/mosn\/layotto\/)                  | Cloud native application runtime                             | Using as a data plane for Istio                              | runtime      | June 2021       | Ant                  | 393                 |\n| [Hango Gateway](https:\/\/github.com\/hango-io\/hango-gateway)   | API gateways built on Envoy and Istio                        | Integrates with Istio                                        | gateway      | August 2021     | NetEase              | 253                 |\n\n### **Slime: an intelligent service mesh manager for Istio**\n\n[Slime](https:\/\/github.com\/slime-io\/slime) is an Istio-based, intelligent mesh manager open-sourced by NetEase’s microservices team. Based on the Kubernetes Operator implementation, Slime can be used as a CRD manager that seamlessly interfaces with Istio without needing any customization or definition of dynamic service governance policies. This achieves automatic and convenient use of Istio and Envoy’s advanced features.\n\nSlime addresses the following issues:\n\n- Implementing higher-level extensions in Istio. For example, extending the HTTP plugin; adaptive traffic limiting based on the resource usage of the service.\n- Poor performance arising from Istio sending all the configurations within the mesh to each sidecar proxy.\n\nSlime solves these problems by building an Istio management plane. Its main purpose are\n\n- to build a pluggable controller to facilitate the extension of new functions.\n- to obtain data by listening to the data plane to intelligently generate the configuration for Istio.\n- to build a higher-level CRD for the user to configure, which Slime converts into an Istio configuration.\n\nThe following diagram shows the flow chart of Istio as an Istio management plane.\n\n![Slime architecture](slime-arch.png)\n\nThe specific steps for Slime to manage Istio are as follows.\n\n1. Slime operator completes the initialization of Slime components in Kubernetes based on the administrator’s configuration.\n2. Developers create configurations that conform to the Slime CRD specification and apply them to Kubernetes clusters.\n3. Slime queries the monitoring data of the relevant service stored in Prometheus and converts the Slime CRD into an Istio CRD, in conjunction with the configuration of the adaptive part of the Slime CRD while pushing it to the Global Proxy.\n4. Istio listens for the creation of Istio CRDs.\n5. Istio pushes the configuration information of the Sidecar Proxy to the corresponding Sidecar Proxy in the data plane.\n\nThe diagram below shows the internal architecture of Slime.\n\n![Slime Internal](slime-internal.png)\n\nWe can divide Slime internally into three main components.\n\n- **slime-boot**: operator for deploying Slime modules on Kubernetes.\n- **slime-controller**: the core component of Slime that listens to the Slime CRD and converts it to an Istio CRD.\n- **slime-metric**: the component used to obtain service metrics information. slime-controller dynamically adjusts service governance rules based on the information it receives.\n\nThe following diagram shows the architecture of Slime Adaptive Traffic Limiting.\n![Slime smart limiter](slime-smart-filter.png)\n\nSlime dynamically configures traffic limits by interfacing with the Prometheus metric server to obtain real-time monitoring.\n\nSlime’s adaptive traffic limitation process has two parts: one that converts SmartLimiter to[ EnvoyFilter](https:\/\/istio.io\/latest\/docs\/reference\/config\/networking\/envoy-filter\/) and the other that monitors the data. Slime also provides an external monitoring data interface (Metric Discovery Server) that allows you to sync custom monitoring metrics to the traffic limiting component via MDS.\n\nThe CRD SmartLimiter created by Slime is used to configure adaptive traffic limiting. Its configuration is close to natural semantics, e.g., if you want to trigger an access limit for Service A with a limit of 30QPS when the CPU exceeds 80%, the corresponding SmartLimiter is defined as follows.\n\n\u0060\u0060\u0060yaml\napiVersion: microservice.netease.com\/v1alpha1\nkind: SmartLimiter\nmetadata:\n  name: a\n  namespace: default\nspec:\n  descriptors:\n  -  action:\n       fill_interval:\n         seconds: 1\n         quota: \u002230\/{pod}\u0022 # 30 is the quota for this service. If there are three pods, the limit is 10 per pod.\n       condition: \u0022{cpu}\u003e0.8\u0022 # Auto-fill the template based on the value of the monitor {cpu}\n\u0060\u0060\u0060\n\n### **Aeraki: A Non-Invasive Istio Extension Toolset**\n\n[Aeraki](https:\/\/github.com\/aeraki-framework\/aeraki) is a service mesh project open sourced by Tencent Cloud in March 2021. Aeraki provides an end-to-end cloud-native service mesh protocol extension solution that provides Istio with powerful third-party protocol extension capabilities in a non-intrusive way, supporting traffic management for Dubbo, Thrift, Redis, and private protocols in Istio. Aeraki’s architecture is shown in the following diagram.\n\n![Aeraki architecture](aeraki-architecture.png)\n\nAeraki architecture, source [Istio blog](https:\/\/istio.io\/latest\/blog\/2021\/aeraki\/).\n\nAs seen in the Aeraki architecture diagram, the Aeraki protocol extension solution consists of two components.\n\n- **Aeraki**: Aeraki runs as an Istio enhancement component on the control plane, providing user-friendly traffic rule configurations to operations via CRDs. Aeraki translates these traffic rule configurations into Envoy configurations distributed via Istio to sidecar proxies on the data plane. Aeraki also acts as an RDS server providing dynamic routing to the MetaProtocol Proxy on the data plane. The RDS provided by Aeraki differs from Envoy’s RDS in that Envoy RDS primarily offers dynamic routing for the HTTP protocol, while Aeraki RDS is designed to provide dynamic routing capabilities for all L7 protocols developed on the MetaProtocol framework.\n- **MetaProtocol Proxy**: A generic L7 protocol proxy based on Envoy implementation. MetaProtocol Proxy is an extension of Envoy. It unifies the basic capabilities of service discovery, load balancing, RDS dynamic routing, traffic mirroring, fault injection, local\/global traffic limiting, etc. for L7 protocols, which greatly reduces the difficulty of developing third-party protocols on Envoy and allows you to quickly create a third-party protocol plug-in based on MetaProtocol by only implementing the codec interface.\n\nBefore the introduction of MetaProtocol Proxy, if you wanted to use Envoy to implement an L7 protocol to implement routing, traffic limiting, telemetry, etc., you needed to write a complete TCP filter, which would have required a lot of work. For most L7 protocols, the required traffic management capabilities are similar, so there is no need to duplicate this work in each L7 filter implementation. The Aeraki project uses a MetaProtocol Proxy to implement these unified capabilities, as shown in the following figure.\n\n![MetaProtocol proxy](metaprotocol-proxy.png)\n\nMetaProtocol proxy, source [Istio blog](https:\/\/istio.io\/latest\/blog\/2021\/aeraki\/).\n\nBased on MetaProtocol Proxy, we only need to implement the codec interface part of the code to write a new L7 protocol Envoy Filter. In addition, without adding a single line of code, Aeraki can provide configuration distribution and RDS dynamic routing configuration for this L7 protocol at the control plane.\n\n### **Make Istio work for all environments and workloads**\n\nWe have seen that NetEase and Tencent are scaling Istio mainly by building Operator. However, this scaling is not enough for multi-cluster management. We know that much of our current infrastructure is transitioning to cloud native or containerized, which means containers, virtual machines, and other environments co-exist. How do we unify traffic management of these different environments? It is possible to do so using Istio.\n\nYou have to again build a management plane on top of Istio and add an abstraction layer to add CRDs that apply to cluster management, such as cluster traffic configuration, policy configuration, etc. Additionally, you have to deploy a Gateway in each cluster that connects uniformly to an edge proxy that interconnects all the groups. \n\nTo learn more about Tetrate Service Bridge (TSB), which provides this layer of infrastructure, you can go [here](https:\/\/www.tetrate.io\/tetrate-service-bridge\/). TSB is built on the open source Istio with enhancements, it follows the concept of the above two open source projects, and also builds a management plane to support heterogeneous environments.\n\nAs we can see, the Istio-based projects and the open source environment are booming and companies like Tetrate are doing useful jobs of productizing and making Istio available to all workloads.\n\n', '\/en\/blog\/istio-extensions-slime-and-aeraki\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">In this article, I’ll introduce you two Istio extension projects: Aeraki and Slime.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
          <div class="col-12">
 
 
 
 
 
 
 
 
 
 
 
 <nav aria-label="Page navigation">
   <ul class="pagination justify-content-center">
     
     
     
     
     
     
       
       
       
         
       
       
       
         <li class="page-item page-item active ">
           <a href="/en/tags/service-mesh/" class="page-link">
             1
           </a>
         </li>
       
     
       
       
       
         
       
       
       
         <li class="page-item">
           <a href="/en/tags/service-mesh/page/2/" class="page-link">
             2
           </a>
         </li>
       
     
     
     
     <li class="page-item">
       <a href="/en/tags/service-mesh/page/2/" class="page-link">
         »
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a class="page-link" href="/en/tags/service-mesh/page/2/">
         »»
       </a>
     </li>
     
   </ul>
 </nav>
 
</div>

        </div>
      </div>
      <!-- sidebar -->
      <aside class="col-lg-4 order-1 order-lg-2 d-none d-sm-block">
          <div class="sidebar">
          <!-- categories -->
<div class="blog-categories mb-4">
  <p class="sidebar-title">
      Columns
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/en/categories/istio" class="sidebar-item">
            <span>Istio</span>
            <span>(43)</span>
        </a>
      
        <a href="/en/categories/service-mesh" class="sidebar-item">
            <span>Service Mesh</span>
            <span>(10)</span>
        </a>
      
        <a href="/en/categories/envoy" class="sidebar-item">
            <span>Envoy</span>
            <span>(5)</span>
        </a>
      
        <a href="/en/categories/essays" class="sidebar-item">
            <span>Essays</span>
            <span>(5)</span>
        </a>
      
        <a href="/en/categories/cloud-native" class="sidebar-item">
            <span>Cloud Native</span>
            <span>(4)</span>
        </a>
      
        <a href="/en/categories/ai" class="sidebar-item">
            <span>AI</span>
            <span>(2)</span>
        </a>
      
        <a href="/en/categories/kubernetes" class="sidebar-item">
            <span>Kubernetes</span>
            <span>(2)</span>
        </a>
      
        <a href="/en/categories/open-source" class="sidebar-item">
            <span>Open Source</span>
            <span>(2)</span>
        </a>
  </div>
</div>

<div class="blog-categories mb-4">
  <p class="sidebar-title">
      Book
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/en/categories/translation" class="sidebar-item">
            <span>Translation</span>
            <span>(6)</span>
        </a>
      
        <a href="/en/categories/original" class="sidebar-item">
            <span>Original</span>
            <span>(2)</span>
        </a>
  </div>
</div>





          </div>
      </aside>
      <!-- /sidebar -->
    </div>
  </div>
</section>




<footer>
  
  <div class="footer bg-footer section-sm border-bottom overlay ">
    <div class="container-xl">
      <div class="row">
        <div class="col col-xl-4 d-sm-none mb-2 mb-lg-0 d-xl-block d-none">
          
          <p class="h3 text-white mb-4 text-uppercase">Contact</p>
          
          <ul class="list-unstyled">
            
            
            <li class="mb-4 text-color">Jimmy&rsquo;s LinkedIn</li>
            
            
            <li class="mb-4"><img src="/images/jimmysong-linkedin.png" width="118px" height="118px" alt="footer image"></li>
            
            
            
          
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">Blog</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/en/blog/envoy-gateway-integration-istio-mesh/">Integrating Envoy Gateway as an Ingress Gateway in Istio Service Mesh</a></li>
            
            <li class="mb-3"><a class="text-color" href="/en/blog/securing-istio-addressing-critical-security-gaps-and-best-practices/">Securing Istio: Addressing Critical Security Gaps and Best Practices</a></li>
            
            <li class="mb-3"><a class="text-color" href="/en/blog/gateway-api-istio-ingress-evolution/">How to Migrate from Kubernetes Ingress to the Gateway API</a></li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">links</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="/awesome-cloud-native/" >
                  Awesome Cloud Native
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://gateway.envoyproxy.io" target="_blank" rel="noopener noreferrer">
                  Envoy Gateway
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://istio.io" target="_blank" rel="noopener noreferrer">
                  Istio
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://tetrate.io/?jimmysong" target="_blank" rel="noopener noreferrer">
                  Tetrate - Service Mesh Company
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://docs.tetrate.io/istio-subscription/" target="_blank" rel="noopener noreferrer">
                  Tetrate Istio Subscription
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">Courses</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/envoy-fundamentals" target="_blank" rel="noopener noreferrer">
                  Envoy Fundamentals
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/istio-fundamentals" target="_blank" rel="noopener noreferrer">
                  Istio Fundamentals
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">new notice</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/en/notice/kubecon-china-2024-panel/">KubeCon China 2024 panel Preview: Istio and Modern API Gateways – Leading the Future of Service Mesh</a></li>
            
            <li class="mb-3"><a class="text-color" href="/en/notice/website-revamp-notice/">Website Revamp Notice</a></li>
            
            <li class="mb-3"><a class="text-color" href="/en/notice/kubecon-eu-2024/">See you in KubeCon Paris!</a></li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>

  
  <div class="copyright py-4 bg-footer overlay">
    <div class="container-xl">
      <div class="row">
        <div class="col-sm-6 text-sm-left text-center">
          <p class="mb-0 text-color">© 2017-2024 Jimmy Song All Right Reserved</p>
        </div>
        <div class="col-sm-6 text-sm-right text-center">
          <ul class="list-inline">
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://twitter.com/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-x-twitter text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/en/contact/" >
                    <i class="fa-brands fa-weixin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://github.com/rootsongjc" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-github text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://linkedin.com/in/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-linkedin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="mailto:rootsongjc@gmail.com" >
                    <i class="fa-solid fa-envelope text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/en/blog/index.xml" >
                    <i class="fa-solid fa-rss text-white"></i>
              </a>
            </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>


<!-- JS Plugins -->

<script src="/plugins/popper/popper.min.js"></script>

<script src="/plugins/bootstrap/bootstrap.min.js"></script>

<script src="/plugins/slick/slick.min.js"></script>

<script src="/plugins/filterizr/jquery.filterizr.min.js"></script>

<script src="/plugins/search/fuse.min.js"></script>

<script src="/plugins/search/mark.js"></script>

<script src="/plugins/hex_md5/hex_md5.js"></script>

<script src="/plugins/anchor/anchor.min.js"></script>

<script src="/plugins/tocbot/tocbot.min.js"></script>

<script src="/plugins/bigger-picture/bigger-picture.min.js"></script>


<!-- Main Script -->

<script src="/js/script.min.f94c22b1d478bfc9e2e0a7d954429e47b7e6d36edd423758482e04154ae1842e.js"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-ESY906ZWZ0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ESY906ZWZ0');
</script>


<!-- Baidu analysis -->
<meta name="baidu-site-verification" content="g8IYR9SNLF" />


<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?11f7d254cfa4e0ca44b175c66d379ecc";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>









<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>






  





<script src="/js/wowchemy-search.min.ce03c611044441cf6e84f9e4bef20818.js" type="module"></script>
<script id="search-hit-fuse-template" type="text/x-template">
  <div class="search-hit" id="summary-{{key}}">
    <div class="search-hit-content border-bottom">
      <div class="search-hit-name">
        <div class='search-hit-link'><a href="{{relpermalink}}">{{title}}</a></div>
        <div class="search-hit-metadata d-flex">
            <span class="mr-1"><i class="fa-regular fa-calendar mr-1"></i>{{date}}</span>
            <span class="mr-1"><i class="fa-regular fa-folder-open mr-1"></i>{{section}}</span>
            <span class="d-sm-block d-none"><i class="fa-solid fa-link mr-1"></i>{{relpermalink}}</span>
        </div>
        <div class="search-hit-description">{{snippet}}</div>
      </div>
    </div>
  </div>
</script>



    </body>
</html>
