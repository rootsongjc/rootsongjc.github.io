<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jimmy Song&#39;s blog – Service Mesh</title>
    <link>https://jimmysong.io/en/tags/service-mesh/</link>
    <description>Recent content in Service Mesh on Jimmy Song&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 04 Jan 2023 10:09:40 +0800</lastBuildDate>
    
	  <atom:link href="https://jimmysong.io/en/tags/service-mesh/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>How to Use SkyWalking for Distributed Tracing in Istio?</title>
      <link>https://jimmysong.io/en/blog/distributed-tracing-with-skywalking-in-istio/</link>
      <pubDate>Wed, 04 Jan 2023 10:09:40 +0800</pubDate>
      
      <guid>https://jimmysong.io/en/blog/distributed-tracing-with-skywalking-in-istio/</guid>
      <description>
        
        
        &lt;p&gt;In cloud native applications, a request often needs to be processed through a series of APIs or backend services, some of which are parallel and some serial and located on different platforms or nodes. How do we determine the service paths and nodes a call goes through to help us troubleshoot the problem? This is where distributed tracing comes into play.&lt;/p&gt;
&lt;p&gt;This article covers:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;How distributed tracing works&lt;/li&gt;
&lt;li&gt;How to choose distributed tracing software&lt;/li&gt;
&lt;li&gt;How to use distributed tracing in Istio&lt;/li&gt;
&lt;li&gt;How to view distributed tracing data using Bookinfo and SkyWalking as examples&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;distributed-tracing-basics&#34;&gt;Distributed Tracing Basics&lt;/h2&gt;
&lt;p&gt;Distributed tracing is a method for tracing requests in a distributed system to help users better understand, control, and optimize distributed systems. There are two concepts used in distributed tracing: TraceID and SpanID. You can see them in Figure 1 below.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;TraceID&lt;/strong&gt; is a globally unique ID that identifies the trace information of a request. All traces of a request belong to the same TraceID, and the TraceID remains constant throughout the trace of the request.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SpanID&lt;/strong&gt; is a locally unique ID that identifies a request’s trace information at a certain time. A request generates different SpanIDs at different periods, and SpanIDs are used to distinguish trace information for a request at different periods.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;TraceID and SpanID are the basis of distributed tracing. They provide a uniform identifier for request tracing in distributed systems and facilitate users’ ability to query, manage, and analyze the trace information of requests.&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/en/blog/distributed-tracing-with-skywalking-in-istio/basic.svg&#34; data-img=&#34;/en/blog/distributed-tracing-with-skywalking-in-istio/basic.svg&#34; alt=&#34;image&#34; data-caption=&#34;Figure 1: Trace and span&#34;&gt;
    
  
  &lt;figcaption&gt;Figure 1: Trace and span&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;The following is the process of distributed tracing:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;When a system receives a request, the distributed tracing system assigns a TraceID to the request, which is used to chain together the entire chain of invocations.&lt;/li&gt;
&lt;li&gt;The distributed trace system generates a SpanID and ParentID for each service call within the system for the request, which is used to record the parent-child relationship of the call; a Span without a ParentID is used as the entry point of the call chain.&lt;/li&gt;
&lt;li&gt;TraceID and SpanID are to be passed during each service call.&lt;/li&gt;
&lt;li&gt;When viewing a distributed trace, query the full process of a particular request by TraceID.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;how-istio-implements-distributed-tracing&#34;&gt;How Istio Implements Distributed Tracing&lt;/h2&gt;
&lt;p&gt;Istio’s distributed tracing is based on information collected by the Envoy proxy in the data plane. After a service request is intercepted by Envoy, Envoy adds tracing information as headers to the request forwarded to the destination workload. The following headers are relevant for distributed tracing:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;As TraceID: x-request-id&lt;/li&gt;
&lt;li&gt;Used to establish parent-child relationships for Span in the LightStep trace: x-ot-span-context&amp;lt;/li&lt;/li&gt;
&lt;li&gt;Used for Zipkin, also for Jaeger, SkyWalking, see &lt;a href=&#34;https://github.com/openzipkin/b3-propagation&#34; title=&#34;b3-propagation&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;b3-propagation&lt;/a&gt;
:
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;x-b3-traceid&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;x-b3-traceid&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;x-b3-spanid&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;x-b3-parentspanid&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;x-b3-sampled&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;x-b3-flags&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;b3&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;For Datadog:
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;x-datadog-trace-id&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;x-datadog-parent-id&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;x-datadog-sampling-priority&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;For SkyWalking: &lt;em&gt;sw8&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;For AWS X-Ray: &lt;em&gt;x-amzn-trace-id&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For more information on how to use these headers, please see the &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_conn_man/headers&#34; title=&#34;Envoy documentation&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy documentation&lt;/a&gt;
.&lt;/p&gt;
&lt;p&gt;Regardless of the language of your application, Envoy will generate the appropriate tracing headers for you at the Ingress Gateway and forward these headers to the upstream cluster. However, in order to utilize the distributed tracing feature, you must modify your application code to attach the tracing headers to upstream requests. Since neither the service mesh nor the application can automatically propagate these headers, you can integrate the agent for distributed tracing into the application or manually propagate these headers in the application code itself. Once the tracing headers are propagated to all upstream requests, Envoy will send the tracing data to the tracer’s back-end processing, and then you can view the tracing data in the UI.&lt;/p&gt;
&lt;p&gt;For example, look at the code of the Productpage service in the &lt;a href=&#34;https://istio.io/latest/docs/examples/bookinfo/&#34; title=&#34;Bookinfo application&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Bookinfo application&lt;/a&gt;
. You can see that it integrates the Jaeger client library and synchronizes the header generated by Envoy with the HTTP requests to the Details and Reviews services in the &lt;em&gt;getForwardHeaders (request)&lt;/em&gt; function.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getForwardHeaders&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;request&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;headers&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;# Using Jaeger agent to get the x-b3-* headers&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;span&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;get_current_span&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;carrier&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;tracer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;inject&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;span_context&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;span&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nb&#34;&gt;format&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Format&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;HTTP_HEADERS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;carrier&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;carrier&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;headers&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;update&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;carrier&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;# Dealing with the non x-b3-* header manually&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;user&amp;#39;&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;session&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;headers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;end-user&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;session&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;user&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;incoming_headers&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;s1&#34;&gt;&amp;#39;x-request-id&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;s1&#34;&gt;&amp;#39;x-ot-span-context&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;s1&#34;&gt;&amp;#39;x-datadog-trace-id&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;s1&#34;&gt;&amp;#39;x-datadog-parent-id&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;s1&#34;&gt;&amp;#39;x-datadog-sampling-priority&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;s1&#34;&gt;&amp;#39;traceparent&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;s1&#34;&gt;&amp;#39;tracestate&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;s1&#34;&gt;&amp;#39;x-cloud-trace-context&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;s1&#34;&gt;&amp;#39;grpc-trace-bin&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;s1&#34;&gt;&amp;#39;sw8&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;s1&#34;&gt;&amp;#39;user-agent&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;s1&#34;&gt;&amp;#39;cookie&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;s1&#34;&gt;&amp;#39;authorization&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;s1&#34;&gt;&amp;#39;jwt&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ihdr&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;incoming_headers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;val&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;request&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;headers&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ihdr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;val&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;is&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;not&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;None&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;headers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ihdr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;val&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;headers&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;For more information, the &lt;a href=&#34;https://istio.io/latest/about/faq/#distributed-tracing&#34; title=&#34;Istio documentation&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio documentation&lt;/a&gt;
 provides answers to frequently asked questions about distributed tracing in Istio.&lt;/p&gt;
&lt;h2 id=&#34;how-to-choose-a-distributed-tracing-system&#34;&gt;How to Choose A Distributed Tracing System&lt;/h2&gt;
&lt;p&gt;Distributed tracing systems are similar in principle. There are many such systems on the market, such as &lt;a href=&#34;https://github.com/apache/skywalking&#34; title=&#34;Apache SkyWalking&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Apache SkyWalking&lt;/a&gt;
, &lt;a href=&#34;https://github.com/jaegertracing/jaeger&#34; title=&#34;Jaeger&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Jaeger&lt;/a&gt;
, &lt;a href=&#34;https://github.com/openzipkin/zipkin/&#34; title=&#34;Zipkin&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Zipkin&lt;/a&gt;
, &lt;a href=&#34;https://lightstep.com/&#34; title=&#34;Lightstep&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Lightstep&lt;/a&gt;
, &lt;a href=&#34;https://github.com/pinpoint-apm/pinpoint&#34; title=&#34;Pinpoint&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Pinpoint&lt;/a&gt;
, and so on. For our purposes here, we will choose three of them and compare them in several dimensions. Here are our inclusion criteria:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;They are currently the most popular open-source distributed tracing systems.&lt;/li&gt;
&lt;li&gt;All are based on the OpenTracing specification.&lt;/li&gt;
&lt;li&gt;They support integration with Istio and Envoy.&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Items&lt;/th&gt;
&lt;th&gt;Apache SkyWalking&lt;/th&gt;
&lt;th&gt;Jaeger&lt;/th&gt;
&lt;th&gt;Zipkin&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Implementations&lt;/td&gt;
&lt;td&gt;Language-based probes, service mesh probes, eBPF agent, third-party instrumental libraries (Zipkin currently supported)&lt;/td&gt;
&lt;td&gt;Language-based probes&lt;/td&gt;
&lt;td&gt;Language-based probes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Database&lt;/td&gt;
&lt;td&gt;ES, H2, MySQL, TiDB, Sharding-sphere, BanyanDB&lt;/td&gt;
&lt;td&gt;ES, MySQL, Cassandra, Memory&lt;/td&gt;
&lt;td&gt;ES, MySQL, Cassandra, Memory&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Supported Languages&lt;/td&gt;
&lt;td&gt;Java, Rust, PHP, NodeJS, Go, Python, C++, .Net, Lua&lt;/td&gt;
&lt;td&gt;Java, Go, Python, NodeJS, C#, PHP, Ruby, C++&lt;/td&gt;
&lt;td&gt;Java, Go, Python, NodeJS, C#, PHP, Ruby, C++&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Initiator&lt;/td&gt;
&lt;td&gt;Personal&lt;/td&gt;
&lt;td&gt;Uber&lt;/td&gt;
&lt;td&gt;Twitter&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Governance&lt;/td&gt;
&lt;td&gt;Apache Foundation&lt;/td&gt;
&lt;td&gt;CNCF&lt;/td&gt;
&lt;td&gt;CNCF&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Version&lt;/td&gt;
&lt;td&gt;9.3.0&lt;/td&gt;
&lt;td&gt;1.39.0&lt;/td&gt;
&lt;td&gt;2.23.19&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Stars&lt;/td&gt;
&lt;td&gt;20.9k&lt;/td&gt;
&lt;td&gt;16.8k&lt;/td&gt;
&lt;td&gt;15.8k&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Although Apache SkyWalking’s agent does not support as many languages as Jaeger and Zipkin, SkyWalking’s implementation is richer and compatible with Jaeger and Zipkin trace data, and development is more active, so it is one of the best choices for building a telemetry platform.&lt;/p&gt;
&lt;h2 id=&#34;demo&#34;&gt;Demo&lt;/h2&gt;
&lt;p&gt;Refer to the &lt;a href=&#34;https://istio.io/latest/docs/tasks/observability/distributed-tracing/skywalking/&#34; title=&#34;Istio documentation&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio documentation&lt;/a&gt;
 to install and configure Apache SkyWalking.&lt;/p&gt;
&lt;h3 id=&#34;environment-description&#34;&gt;Environment Description&lt;/h3&gt;
&lt;p&gt;The following is the environment for our demo:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Kubernetes 1.24.5&lt;/li&gt;
&lt;li&gt;Istio 1.16&lt;/li&gt;
&lt;li&gt;SkyWalking 9.1.0&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;install-istio&#34;&gt;Install Istio&lt;/h3&gt;
&lt;p&gt;Before installing Istio, you can check the environment for any problems:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ istioctl experimental precheck
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;✔ No issues found when checking the cluster. Istio is safe to install or upgrade!
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  To get started, check out https://istio.io/latest/docs/setup/getting-started/
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Then install Istio and configure the destination for sending tracing messages as SkyWalking:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Initial Istio Operator&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;istioctl operator init
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Configure tracing destination&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl apply -f - &lt;span class=&#34;s&#34;&gt;&amp;lt;&amp;lt;EOF
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;apiVersion: install.istio.io/v1alpha1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;kind: IstioOperator
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;metadata:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;  namespace: istio-system
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;  name: istio-with-skywalking
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;spec:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;  meshConfig:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;    defaultProviders:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;      tracing:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;      - &amp;#34;skywalking&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;    enableTracing: true
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;    extensionProviders:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;    - name: &amp;#34;skywalking&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;      skywalking:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;        service: tracing.istio-system.svc.cluster.local
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;        port: 11800
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;EOF&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;deploy-apache-skywalking&#34;&gt;Deploy Apache SkyWalking&lt;/h2&gt;
&lt;p&gt;Istio 1.16 supports distributed tracing using Apache SkyWalking. Install SkyWalking by executing the following code:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl apply -f 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;https://raw.githubusercontent.com/istio/istio/release-1.16/samples/addons/extras/skywalking.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;It will install the following components under the &lt;em&gt;istio-system&lt;/em&gt; namespace:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://skywalking.apache.org/docs/main/v9.3.0/en/concepts-and-designs/backend-overview/&#34; title=&#34;SkyWalking Observability Analysis Platform (OAP)&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SkyWalking Observability Analysis Platform (OAP)&lt;/a&gt;
: Used to receive trace data, supports SkyWalking native data formats, Zipkin v1 and v2 and Jaeger format.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://skywalking.apache.org/docs/main/v9.3.0/en/ui/readme/&#34; title=&#34;UI&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;UI&lt;/a&gt;
: Used to query distributed trace data.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For more information about SkyWalking, please refer to the &lt;a href=&#34;https://skywalking.apache.org/docs/main/v9.3.0/readme/&#34; title=&#34;SkyWalking documentation&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SkyWalking documentation&lt;/a&gt;
.&lt;/p&gt;
&lt;h2 id=&#34;deploy-the-bookinfo-application&#34;&gt;Deploy the Bookinfo Application&lt;/h2&gt;
&lt;p&gt;Execute the following command to install the bookinfo application:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl label namespace default istio-injection&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;enabled
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl apply -f samples/bookinfo/platform/kube/bookinfo.yaml
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl apply -f samples/bookinfo/networking/bookinfo-gateway.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Launch the SkyWalking UI:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;istioctl dashboard skywalking
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Figure 2 shows all the services available in the bookinfo application:&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/en/blog/distributed-tracing-with-skywalking-in-istio/general-service.jpg&#34; data-img=&#34;/en/blog/distributed-tracing-with-skywalking-in-istio/general-service.jpg&#34; data-width=&#34;1622&#34; data-height=&#34;1080&#34; alt=&#34;image&#34; data-caption=&#34;Figure 2: SkyWalking General Service page&#34;&gt;
    
  
  &lt;figcaption&gt;Figure 2: SkyWalking General Service page&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;You can also see information about instances, endpoints, topology, tracing, etc. For example, Figure 3 shows the service topology of the bookinfo application:&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/en/blog/distributed-tracing-with-skywalking-in-istio/topology.jpg&#34; data-img=&#34;/en/blog/distributed-tracing-with-skywalking-in-istio/topology.jpg&#34; data-width=&#34;1622&#34; data-height=&#34;1080&#34; alt=&#34;image&#34; data-caption=&#34;Figure 3: Topology diagram of the Bookinfo application&#34;&gt;
    
  
  &lt;figcaption&gt;Figure 3: Topology diagram of the Bookinfo application&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Tracing views in SkyWalking can be displayed in a variety of formats, including list, tree, table, and statistics. See Figure 4:&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/en/blog/distributed-tracing-with-skywalking-in-istio/gs-styles.jpg&#34; data-img=&#34;/en/blog/distributed-tracing-with-skywalking-in-istio/gs-styles.jpg&#34; data-width=&#34;2062&#34; data-height=&#34;1080&#34; alt=&#34;image&#34; data-caption=&#34;Figure 4: SkyWalking General Service trace supports multiple display formats&#34;&gt;
    
  
  &lt;figcaption&gt;Figure 4: SkyWalking General Service trace supports multiple display formats&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;To facilitate our examination, set the sampling rate of the trace to 100%:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl apply -f - &lt;span class=&#34;s&#34;&gt;&amp;lt;&amp;lt;EOF
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;apiVersion: telemetry.istio.io/v1alpha1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;kind: Telemetry
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;metadata:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;  name: mesh-default
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;  namespace: istio-system
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;spec:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;  tracing:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;  - randomSamplingPercentage: 100.00
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;EOF&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Important:&lt;/strong&gt; &lt;em&gt;It’s generally not good practice to set the sampling rate to 100% in a production environment. To avoid the overhead of generating too many trace logs in production, please adjust the sampling strategy (sampling percentage).&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;uninstall&#34;&gt;Uninstall&lt;/h2&gt;
&lt;p&gt;After experimenting, uninstall Istio and SkyWalking by executing the following command.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;samples/bookinfo/platform/kube/cleanup.sh
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;istioctl unintall --purge
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl delete namespace istio-system
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;understanding-the-bookinfo-tracing-information&#34;&gt;Understanding the Bookinfo Tracing Information&lt;/h2&gt;
&lt;p&gt;Navigate to the General Service tab in the Apache SkyWalking UI, and you can see the trace information for the most recent &lt;em&gt;istio-ingressgateway&lt;/em&gt; service, as shown in Figure 5. Click on each span to see the details.&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/en/blog/distributed-tracing-with-skywalking-in-istio/span-table.jpg&#34; data-img=&#34;/en/blog/distributed-tracing-with-skywalking-in-istio/span-table.jpg&#34; data-width=&#34;1495&#34; data-height=&#34;1080&#34; alt=&#34;image&#34; data-caption=&#34;Figure 5: The table view shows the basic information about each span.&#34;&gt;
    
  
  &lt;figcaption&gt;Figure 5: The table view shows the basic information about each span.&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Switching to the list view, you can see the execution order and duration of each span, as shown in Figure 6:&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/en/blog/distributed-tracing-with-skywalking-in-istio/trace-list.jpg&#34; data-img=&#34;/en/blog/distributed-tracing-with-skywalking-in-istio/trace-list.jpg&#34; data-width=&#34;1190&#34; data-height=&#34;816&#34; alt=&#34;image&#34; data-caption=&#34;Figure 6: List display&#34;&gt;
    
  
  &lt;figcaption&gt;Figure 6: List display&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;You might want to know why such a straightforward application generates so much span data. Because after we inject the Envoy proxy into the pod, every request between services will be intercepted and processed by Envoy, as shown in Figure 7:&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/en/blog/distributed-tracing-with-skywalking-in-istio/span.svg&#34; data-img=&#34;/en/blog/distributed-tracing-with-skywalking-in-istio/span.svg&#34; alt=&#34;image&#34; data-caption=&#34;Figure 7: Envoy intercepts requests to generate a span&#34;&gt;
    
  
  &lt;figcaption&gt;Figure 7: Envoy intercepts requests to generate a span&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;The tracing process is shown in Figure 8:&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/en/blog/distributed-tracing-with-skywalking-in-istio/bookinfo-spans-with-time.svg&#34; data-img=&#34;/en/blog/distributed-tracing-with-skywalking-in-istio/bookinfo-spans-with-time.svg&#34; alt=&#34;image&#34; data-caption=&#34;Figure 8: Trace of the Bookinfo application&#34;&gt;
    
  
  &lt;figcaption&gt;Figure 8: Trace of the Bookinfo application&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;We give each span a label with a serial number, and the time taken is indicated in parentheses. For illustration purposes, we have summarized all spans in the table below.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;No.&lt;/th&gt;
&lt;th&gt;Endpoint&lt;/th&gt;
&lt;th&gt;Total Duration (ms)&lt;/th&gt;
&lt;th&gt;Component Duration (ms)&lt;/th&gt;
&lt;th&gt;Current Service&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;/productpage&lt;/td&gt;
&lt;td&gt;190&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;istio-ingressgateway&lt;/td&gt;
&lt;td&gt;Envoy Outbound&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;/productpage&lt;/td&gt;
&lt;td&gt;190&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;istio-ingressgateway&lt;/td&gt;
&lt;td&gt;Ingress -&amp;gt; Productpage network transmission&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;/productpage&lt;/td&gt;
&lt;td&gt;189&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;productpage&lt;/td&gt;
&lt;td&gt;Envoy Inbound&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;/productpage&lt;/td&gt;
&lt;td&gt;188&lt;/td&gt;
&lt;td&gt;21&lt;/td&gt;
&lt;td&gt;productpage&lt;/td&gt;
&lt;td&gt;Application internal processing&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;/details/0&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;productpage&lt;/td&gt;
&lt;td&gt;Envoy Outbound&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;/details/0&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;productpage&lt;/td&gt;
&lt;td&gt;Productpage -&amp;gt; Details network transmission&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;/details/0&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;details&lt;/td&gt;
&lt;td&gt;Envoy Inbound&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;/details/0&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;details&lt;/td&gt;
&lt;td&gt;Application internal processing&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;/reviews/0&lt;/td&gt;
&lt;td&gt;159&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;productpage&lt;/td&gt;
&lt;td&gt;Envoy Outbound&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;/reviews/0&lt;/td&gt;
&lt;td&gt;159&lt;/td&gt;
&lt;td&gt;14&lt;/td&gt;
&lt;td&gt;productpage&lt;/td&gt;
&lt;td&gt;Productpage -&amp;gt; Reviews network transmission&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;/reviews/0&lt;/td&gt;
&lt;td&gt;145&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;reviews&lt;/td&gt;
&lt;td&gt;Envoy Inbound&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;/reviews/0&lt;/td&gt;
&lt;td&gt;144&lt;/td&gt;
&lt;td&gt;109&lt;/td&gt;
&lt;td&gt;reviews&lt;/td&gt;
&lt;td&gt;Application internal processing&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;13&lt;/td&gt;
&lt;td&gt;/ratings/0&lt;/td&gt;
&lt;td&gt;35&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;reviews&lt;/td&gt;
&lt;td&gt;Envoy Outbound&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;14&lt;/td&gt;
&lt;td&gt;/ratings/0&lt;/td&gt;
&lt;td&gt;33&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;reviews&lt;/td&gt;
&lt;td&gt;Reviews -&amp;gt; Ratings network transmission&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;15&lt;/td&gt;
&lt;td&gt;/ratings/0&lt;/td&gt;
&lt;td&gt;17&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;ratings&lt;/td&gt;
&lt;td&gt;Envoy Inbound&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;/ratings/0&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;ratings&lt;/td&gt;
&lt;td&gt;Application internal processing&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;From the above information, it can be seen that:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The total time consumed for this request is 190 ms.&lt;/li&gt;
&lt;li&gt;In Istio sidecar mode, each traffic flow in and out of the application container must pass through the Envoy proxy once, each time taking 0 to 2 ms.&lt;/li&gt;
&lt;li&gt;Network requests between Pods take between 1 and 16ms.&lt;/li&gt;
&lt;li&gt;This is because the data itself has errors and the start time of the Span is not necessarily equal to the end time of the parent Span.&lt;/li&gt;
&lt;li&gt;We can see that the most time-consuming part is the Reviews application, which takes 109 ms so that we can optimize it for that application.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;
&lt;p&gt;Distributed tracing is an indispensable tool for analyzing performance and troubleshooting modern distributed applications. In this tutorial, we’ve seen how, with just a few minor changes to your application code to propagate tracing headers, Istio makes distributed tracing simple to use. We’ve also reviewed &lt;a href=&#34;https://skywalking.apache.org/&#34; title=&#34;Apache SkyWalking&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Apache SkyWalking&lt;/a&gt;
 as one of the best distributed tracing systems that Istio supports. It is a fully functional platform for cloud native application analytics, with features such as metrics and log collection, alerting, Kubernetes monitoring, &lt;a href=&#34;https://skywalking.apache.org/blog/diagnose-service-mesh-network-performance-with-ebpf/&#34; title=&#34;service mesh performance diagnosis using eBPF&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;service mesh performance diagnosis using eBPF&lt;/a&gt;
, and more.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;If you’re new to service mesh and Kubernetes security, we have a bunch of free online courses &lt;a href=&#34;https://tetr8.io/academy&#34; title=&#34;available at Tetrate Academy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;available at Tetrate Academy&lt;/a&gt;
 that will quickly get you up to speed with Istio and Envoy.&lt;/p&gt;
&lt;p&gt;If you’re looking for a fast way to get to production with Istio, check out &lt;a href=&#34;https://tetr8.io/tid&#34; title=&#34;Tetrate Istio Distribution (TID)&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tetrate Istio Distribution (TID)&lt;/a&gt;
. TID is Tetrate’s hardened, fully upstream Istio distribution, with FIPS-verified builds and support available. It’s a great way to get started with Istio knowing you have a trusted distribution to begin with, have an expert team supporting you, and also have the option to get to FIPS compliance quickly if you need to.&lt;/p&gt;
&lt;p&gt;Once you have Istio up and running, you will probably need simpler ways to manage and secure your services beyond what’s available in Istio, that’s where Tetrate Service Bridge comes in. You can learn more about how Tetrate Service Bridge makes service mesh more secure, manageable, and resilient &lt;a href=&#34;https://tetr8.io/tsb&#34; title=&#34;here&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;here&lt;/a&gt;
, or &lt;a href=&#34;https://tetr8.io/contact&#34; title=&#34;contact us for a quick demo&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;contact us for a quick demo&lt;/a&gt;
.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;This blog was originally published at &lt;a href=&#34;https://tetrate.io/blog/how-to-use-skywalking-for-distributed-tracing-in-istio/&#34; title=&#34;tetrate.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;tetrate.io&lt;/a&gt;
.&lt;/em&gt;&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>How Istio’s mTLS Traffic Encryption Works as Part of a Zero Trust Security Posture</title>
      <link>https://jimmysong.io/en/blog/understanding-the-tls-encryption-in-istio/</link>
      <pubDate>Sat, 24 Dec 2022 14:09:40 +0800</pubDate>
      
      <guid>https://jimmysong.io/en/blog/understanding-the-tls-encryption-in-istio/</guid>
      <description>
        
        
        &lt;p&gt;The Istio service mesh offers cloud native deployments a standard way to implement automatic &lt;a href=&#34;https://en.wikipedia.org/wiki/Mutual_authentication#mTLS&#34; title=&#34;mutual transport layer security (mTLS)&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;mutual transport layer security (mTLS)&lt;/a&gt;
. This reduces the attack surface of network communication by using strong identities to establish encrypted channels between workloads within the mesh that are both confidential and tamper-resistant. mTLS is a key component for building zero-trust application networks. To understand mTLS traffic encryption in Istio, this article will cover the following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;An overview of TLS, mTLS, and TLS termination&lt;/li&gt;
&lt;li&gt;An introduction to howTLS encryption works in Istio&lt;/li&gt;
&lt;li&gt;How to use Istio to implement mTLS in Kubernetes&lt;/li&gt;
&lt;li&gt;A discussion of when you do and don’t need mTLS&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;what-is-tls-and-mtls&#34;&gt;What Is TLS and mTLS?&lt;/h2&gt;
&lt;p&gt;TLS, the successor to Secure Sockets Layer (SSL), is a widely adopted security protocol used to create authenticated and encrypted connections between networked computers. For this reason, people often use the terms TLS and SSL interchangeably. In this article, we will refer to them collectively as TLS. TLS 1.0 was released in 1999, and the latest version is 1.3 (released in August 2018); versions 1.0 and 1.1 are deprecated.&lt;/p&gt;
&lt;p&gt;The HTTPS we see when browsing the web uses TLS, as shown in Figure 1, which is built on top of TCP as the session layer in the OSI model. To ensure compatibility, TLS usually uses port 443, but you can use any port you want.&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/en/blog/understanding-the-tls-encryption-in-istio/http-vs-https.svg&#34; data-img=&#34;/en/blog/understanding-the-tls-encryption-in-istio/http-vs-https.svg&#34; alt=&#34;image&#34; data-caption=&#34;Figure 1: HTTP vs. HTTPS&#34;&gt;
    
  
  &lt;figcaption&gt;Figure 1: HTTP vs. HTTPS&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;TLS encryption is required when a client needs to confirm the identity of the server in order to guard against man-in-the-middle attacks and ensure communication security. Figure 2 shows how TLS-encrypted communication proceeds.&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/en/blog/understanding-the-tls-encryption-in-istio/tls-flow.svg&#34; data-img=&#34;/en/blog/understanding-the-tls-encryption-in-istio/tls-flow.svg&#34; alt=&#34;image&#34; data-caption=&#34;Figure 2: simplified TLS handshake flow&#34;&gt;
    
  
  &lt;figcaption&gt;Figure 2: simplified TLS handshake flow&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The server applies for and obtains a certificate (X.509 certificate) from a trusted &lt;a href=&#34;https://en.wikipedia.org/wiki/Certificate_authority&#34; title=&#34;certificate authority&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;certificate authority&lt;/a&gt;
 (CA).&lt;/li&gt;
&lt;li&gt;A request from the client to the server containing information such as the TLS version and password combination supported by the client.&lt;/li&gt;
&lt;li&gt;The server responds to the client request and attaches a digital certificate.&lt;/li&gt;
&lt;li&gt;The client verifies the status, validity, and digital signature of the certificate and confirms the identity of the server.&lt;/li&gt;
&lt;li&gt;Encrypted communication commences between the client and the server using a shared private key.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The above is only an outline description of the TLS communication flow. If you’re interested in the details, please see &lt;a href=&#34;https://www.cloudflare.com/learning/ssl/what-happens-in-a-tls-handshake/&#34; title=&#34;this in-depth discussion of the complete TLS handshake process.&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;this in-depth discussion of the complete TLS handshake process.&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;From the above process, you will find that the certificate is the critical element representing the server’s identity. The server must use a certificate issued by an authoritatively certified CA in order to provide public services over the Internet. In contrast, you can manage certificates using your own public key infrastructure (PKI) for services inside of a private environment.&lt;/p&gt;
&lt;p&gt;Mutual TLS, also referred to as mTLS, is the use of a two-way encrypted channel between a server and a client that necessitates certificate exchange and identity authentication between the parties.&lt;/p&gt;
&lt;h2 id=&#34;what-is-tls-termination&#34;&gt;What Is TLS Termination?&lt;/h2&gt;
&lt;p&gt;TLS termination is the process of decrypting TLS-encrypted traffic before it is forwarded to a web server. Offloading TLS traffic to an ingress gateway or specialized device improves web application performance while securing encrypted traffic. TLS termination is typically implemented at cluster ingress. All communication between the ingress and servers in the cluster will be conducted directly over HTTP in plaintext, enhancing service performance.&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/en/blog/understanding-the-tls-encryption-in-istio/tls-termination.svg&#34; data-img=&#34;/en/blog/understanding-the-tls-encryption-in-istio/tls-termination.svg&#34; alt=&#34;image&#34; data-caption=&#34;Figure 3: TLS termination&#34;&gt;
    
  
  &lt;figcaption&gt;Figure 3: TLS termination&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;By default, Istio enables mTLS for mesh-based services and ends TLS at the ingress gateway. Furthermore, you can pass through traffic to back-end services for processing.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;networking.istio.io/v1beta1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Gateway&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;sample-gateway&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;servers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;number&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;443&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;https&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;protocol&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;HTTPS&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;tls&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;mode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;PASSTHROUGH&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;See &lt;a href=&#34;https://istio.io/latest/docs/ops/configuration/traffic-management/tls-configuration/#gateways&#34; title=&#34;Gateway TLS Configuration&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Gateway TLS Configuration&lt;/a&gt;
 for details.&lt;/p&gt;
&lt;h2 id=&#34;how-to-implement-automatic-mtls-in-istio&#34;&gt;How to Implement Automatic mTLS in Istio&lt;/h2&gt;
&lt;p&gt;Figure 4 depicts the security architecture of Istio. This figure clearly shows that at the entry point, JSON Web Token (JWT) + TLS authentication and encryption are used, and that mTLS is enabled between all services within the Istio mesh.&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/en/blog/understanding-the-tls-encryption-in-istio/istio-security.svg&#34; data-img=&#34;/en/blog/understanding-the-tls-encryption-in-istio/istio-security.svg&#34; alt=&#34;image&#34; data-caption=&#34;Istio 安全架构图&#34;&gt;
    
  
  &lt;figcaption&gt;Istio 安全架构图&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Istio includes a built-in CA, and &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret&#34; title=&#34;Secret Discovery Service (SDS)&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Secret Discovery Service (SDS)&lt;/a&gt;
—one of the discovery services in Envoy &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/api-docs/xds_protocol&#34; title=&#34;xDS&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;xDS&lt;/a&gt;
—enables the issuance and rotation of SVID certificates. The mTLS flow in the Istio mesh is as follows:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The sidecar of every service requests a certificate from Istiod on behalf of the workload at startup, and Istiod issues the &lt;a href=&#34;https://spiffe.io/docs/latest/spiffe-about/spiffe-concepts/#spiffe-verifiable-identity-document-svid&#34; title=&#34;SVID&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SVID&lt;/a&gt;
 certificate (the process is more complex, and I will explain it in a future blog).&lt;/li&gt;
&lt;li&gt;The sidecar of every workload intercepts all client requests within the pod.&lt;/li&gt;
&lt;li&gt;The client sidecar starts an mTLS handshake with the server sidecar. During the handshake, the &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/security/jwt_authn_filter&#34; title=&#34;JWT&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;JWT&lt;/a&gt;
 and &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/security/ext_authz_filter&#34; title=&#34;authentication filter&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;authentication filter&lt;/a&gt;
 in the client sidecar will authenticate the identity of the request, and store the identity in the filter metadata after the authentication. Then the request will go through the authorization filter to determine if the request is allowed.&lt;/li&gt;
&lt;li&gt;If the request is authenticated and authorized, the client and the server start to establish a connection for communication.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In Istio, authentication and authorization between services can be configured using one of three resource objects:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://istio.io/latest/docs/reference/config/security/request_authentication/&#34; title=&#34;RequestAuthentication&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RequestAuthentication&lt;/a&gt;
:&lt;/strong&gt; To specify the service’s only currently supported request-level authentication method, JWT.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://istio.io/latest/docs/reference/config/security/peer_authentication/&#34; title=&#34;PeerAuthentication&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;PeerAuthentication&lt;/a&gt;
:&lt;/strong&gt; To enable mTLS or plaintext requests, set the transport authentication mode.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://istio.io/latest/docs/reference/config/security/authorization-policy/&#34; title=&#34;AuthorizationPolicy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;AuthorizationPolicy&lt;/a&gt;
:&lt;/strong&gt; To specify who can do what when traffic between services is authorized? For instance, subject A either permits (ALLOW) or forbids (DENY) traffic from subject B.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;how-to-enable-automatic-mtls-in-istio&#34;&gt;How to Enable Automatic mTLS in Istio&lt;/h2&gt;
&lt;p&gt;In PeerAuthentication, you can specify the mTLS mode that will be used for the target workload. Peer authentication is supported in the following modes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PERMISSIVE: The workload’s default setting that allows it to accept either mTLS or plain text traffic.&lt;/li&gt;
&lt;li&gt;STRICT: The workload accepts only mTLS traffic.&lt;/li&gt;
&lt;li&gt;DISABLE: Disable mTLS. From a security perspective, mTLS should not be disabled unless you have your own security solution.&lt;/li&gt;
&lt;li&gt;UNSET: Inherited from the parent, with the following priority: service specific &amp;gt; namespace scope &amp;gt; mesh scope setting.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Istio’s peer authentication uses &lt;em&gt;PERMISSIVE&lt;/em&gt; mode by default, automatically sending &lt;em&gt;mTLS&lt;/em&gt; traffic to these workloads and clear text traffic to workloads without a sidecar. After including Kubernetes services in the Istio mesh, we can use &lt;em&gt;PERMISSIVE&lt;/em&gt; mode first to prevent services from failing &lt;em&gt;mTLS&lt;/em&gt;. We can use one of two ways to enable strict mTLS mode for certain services:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Use PeerAuthentication to define how traffic is transferred between sidecars.&lt;/li&gt;
&lt;li&gt;Use DestinationRule to define the TLS settings in the traffic routing policy.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The reviews service’s mTLS configuration in the default namespace can be seen in the example below.&lt;/p&gt;
&lt;h3 id=&#34;use-peerauthentication-to-set-mtls-for-workloads&#34;&gt;Use PeerAuthentication to Set mTLS for Workloads&lt;/h3&gt;
&lt;p&gt;For instance, the following configuration can be used to specify that a workload under a namespace has strict mTLS enabled.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;security.istio.io/v1beta1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;PeerAuthentication&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;foo-peer-policy&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;selector&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;matchLabels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;reviews&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;mtls&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;mode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;STRICT&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;According to the &lt;a href=&#34;https://istio.io/latest/docs/tasks/security/authentication/mtls-migration/&#34; title=&#34;Istio documentation&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio documentation&lt;/a&gt;
, you can also enable strict mTLS for all services in the mesh by configuring strict mTLS for the namespace istio-system where Istio is installed.&lt;/p&gt;
&lt;h3 id=&#34;use-destinationrule-to-set-up-mtls-for-workloads&#34;&gt;Use DestinationRule to Set up mTLS for Workloads&lt;/h3&gt;
&lt;p&gt;Traffic routing policies, such as load balancing, anomaly detection, TLS settings, etc., are set using DestinationRule. In the TLS settings, there are various modes. As shown below, use ISTIO_MUTUAL mode to enable Istio’s workload-based automatic TLS.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;networking.istio.io/v1beta1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;DestinationRule&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;reviews&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;host&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;reviews&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;trafficPolicy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;tls&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;mode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ISTIO_MUTUAL&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;when-should-you-use-mtls&#34;&gt;When Should You Use mTLS?&lt;/h2&gt;
&lt;p&gt;The short answer is that you should use mTLS for network communication between application components that you have some control over—like between microservices in a cluster.&lt;/p&gt;
&lt;p&gt;One-way TLS is typically used by Internet clients to connect to Web services, which means that only the server needs to show identification and is unconcerned with the identity of the client. One-way TLS allows you to use passwords, tokens, two-factor authentication, and other methods when you need to confirm the identity of the client. However, when using a service mesh, mTLS operates outside the application and doesn’t require many changes to the application logic, whereas such an authentication method requires internal application support.&lt;/p&gt;
&lt;p&gt;As you can see from the example above, mTLS implementation calls for certificate exchange between services. As the number of services rises, managing numerous certificates becomes a laborious task. You can implement automatic mTLS and fix the certificate management issue with the aid of a service mesh.&lt;/p&gt;
&lt;h2 id=&#34;when-shouldnt-you-use-mtls&#34;&gt;When Shouldn’t You Use mTLS?&lt;/h2&gt;
&lt;p&gt;Although mTLS is the preferred protocol for securing inter-service communication in cloud-native applications, implementing mTLS necessitates a more complex, symmetric encryption and decryption process than one-way TLS. In some cases where there is high traffic volume or CPU utilization must be optimized, terminatingTLS at the traffic entry point and turning on mTLS internally for specific services only can help minimize request response times and decrease compute resource consumption for some traffic with lower security levels.&lt;/p&gt;
&lt;p&gt;Additionally, it is necessary to &lt;a href=&#34;https://istio.io/latest/docs/ops/configuration/mesh/app-health-check/#disable-the-http-probe-rewrite-for-a-pod&#34; title=&#34;disable probe rewriting for pods&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;disable probe rewriting for pods&lt;/a&gt;
 when using services that cannot obtain certificates, such as health checks performed via HTTP on Kubelet and the inability to access the service’s health check endpoint via TLS.&lt;/p&gt;
&lt;p&gt;Finally, when mesh services access some external services, mTLS is also not necessary.&lt;/p&gt;
&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;
&lt;p&gt;mTLS is a crucial component of creating a zero-trust application network, which makes it possible to encrypt traffic within the mesh. Istio makes it simple to enable automatic mTLS for Kubernetes services, doing away with the need to manage certificates. At the same time, we can selectively enable mTLS for a subset of the mesh’s services, enabling us to move services from Kubernetes to the mesh. In a subsequent blog, we’ll go into more detail about Istio’s certificate management system. Stay tuned.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;If you’re new to service mesh and Kubernetes security, we have a bunch of free online courses &lt;a href=&#34;https://tetr8.io/academy&#34; title=&#34;available at Tetrate Academy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;available at Tetrate Academy&lt;/a&gt;
 that will quickly get you up to speed with Istio and Envoy.&lt;/p&gt;
&lt;p&gt;If you’re looking for a fast way to get to production with Istio, check out &lt;a href=&#34;https://tetr8.io/tid&#34; title=&#34;Tetrate Istio Distribution (TID)&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tetrate Istio Distribution (TID)&lt;/a&gt;
. TID is Tetrate’s hardened, fully upstream Istio distribution, with FIPS-verified builds and support available. It’s a great way to get started with Istio knowing you have a trusted distribution to begin with, have an expert team supporting you, and also have the option to get to FIPS compliance quickly if you need to.Once you have Istio up and running, you will probably need simpler ways to manage and secure your services beyond what’s available in Istio, that’s where Tetrate Service Bridge comes in. You can learn more about how Tetrate Service Bridge makes service mesh more secure, manageable, and resilient &lt;a href=&#34;https://tetr8.io/tsb&#34; title=&#34;here&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;here&lt;/a&gt;
, or &lt;a href=&#34;https://tetr8.io/contact&#34; title=&#34;contact us for a quick demo&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;contact us for a quick demo&lt;/a&gt;
.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;This blog was originally published at &lt;a href=&#34;https://tetrate.io/blog/how-istios-mtls-traffic-encryption-works-as-part-of-a-zero-trust-security-posture/&#34; title=&#34;tetrate.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;tetrate.io&lt;/a&gt;
.&lt;/em&gt;&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Why the Gateway API Is the Unified Future of Ingress for Kubernetes and Service Mesh</title>
      <link>https://jimmysong.io/en/blog/why-gateway-api-is-the-future-of-ingress-and-mesh/</link>
      <pubDate>Tue, 13 Dec 2022 11:18:40 +0800</pubDate>
      
      <guid>https://jimmysong.io/en/blog/why-gateway-api-is-the-future-of-ingress-and-mesh/</guid>
      <description>
        
        
        &lt;p&gt;In this blog, you will learn about the Kubernetes Ingress Gateway, the Gateway API, and the emerging Gateway API trend, which enables the convergence of Kubernetes and service mesh.&lt;/p&gt;
&lt;h2 id=&#34;takeaways&#34;&gt;Takeaways&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Ingress, the original gateway for Kubernetes, has a resource model that is too simple to fit into today’s programmable networks.&lt;/li&gt;
&lt;li&gt;The &lt;a href=&#34;https://gateway-api.sigs.k8s.io/&#34; title=&#34;Gateway API&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Gateway API&lt;/a&gt;
, the latest addition to the Kubernetes portal gateway, separates concerns through role delineation and provides cross-namespace support to make it more adaptable to multi-cloud environments. Most API gateways already support it.&lt;/li&gt;
&lt;li&gt;The Gateway API provides a new reference model for the convergence of ingress gateways (north-south) and service mesh (east-west, cross-cluster routing), where there is a partial functional overlap.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;history-of-the-kubernetes-ingress-gateway&#34;&gt;History of the Kubernetes ingress gateway&lt;/h2&gt;
&lt;p&gt;When Kubernetes was launched in June 2014, only NodePort and LoadBalancer-type Service objects were available to expose services within the cluster to the outside world. Later, &lt;a href=&#34;https://kubernetes.io/docs/concepts/services-networking/ingress/&#34; title=&#34;Ingress &#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Ingress &lt;/a&gt;
was introduced to offer more control over incoming traffic.. To preserve its portability and lightweight design, the Ingress API matured more slowly than other Kubernetes APIs; it was not upgraded to GA until Kubernetes 1.19.&lt;/p&gt;
&lt;p&gt;Ingress’ primary objective is to expose HTTP applications using a straightforward declarative syntax. When creating an Ingress or setting a default &lt;em&gt;IngressClass&lt;/em&gt; in Kubernetes, you can deploy several Ingress Controllers and define the controller the gateway uses via &lt;em&gt;IngressClass&lt;/em&gt;. Kubernetes currently supports only AWS, GCE, and Nginx Ingress controllers by default; many &lt;a href=&#34;https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/&#34; title=&#34;third-party ingress controllers&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;third-party ingress controllers&lt;/a&gt;
 are also supported.&lt;/p&gt;
&lt;p&gt;The following diagram illustrates the workflow of Kubernetes Ingress.&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/en/blog/why-gateway-api-is-the-future-of-ingress-and-mesh/ingress-flow.svg&#34; data-img=&#34;/en/blog/why-gateway-api-is-the-future-of-ingress-and-mesh/ingress-flow.svg&#34; alt=&#34;image&#34; data-caption=&#34;Figure 1: Kubernetes ingress workflow&#34;&gt;
    
  
  &lt;figcaption&gt;Figure 1: Kubernetes ingress workflow&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;The detailed process is as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Kubernetes cluster administrators deploy an Ingress Controller in Kubernetes.&lt;/li&gt;
&lt;li&gt;The Ingress Controller continuously monitors changes to &lt;em&gt;IngressClass&lt;/em&gt; and Ingress objects in the Kubernetes API Server.&lt;/li&gt;
&lt;li&gt;Administrators apply &lt;em&gt;IngressClass&lt;/em&gt; and Ingress to deploy the gateway.&lt;/li&gt;
&lt;li&gt;Ingress Controller creates the corresponding ingress gateway and configures the routing rules according to the administrator’s configuration.&lt;/li&gt;
&lt;li&gt;If in the cloud, the client accesses the load balancer for that ingress gateway.&lt;/li&gt;
&lt;li&gt;The gateway will route the traffic to the corresponding back-end service based on the host and path in the HTTP request.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Istio supports both the Ingress and Gateway APIs. Below is an example configuration using the Istio Ingress Gateway, which will be created later using the Gateway API:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;networking.k8s.io/v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;IngressClass&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;istio&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;controller&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;istio.io/ingress-controller&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nn&#34;&gt;---&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;networking.k8s.io/v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Ingress&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ingress&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ingressClassName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;istio&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;rules&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;host&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;httpbin.example.com&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;paths&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;pathType&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Prefix&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;backend&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;service&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;httpbin&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;8000&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Note: You must specify the &lt;em&gt;IngressClass&lt;/em&gt; in the &lt;em&gt;ingressClassName&lt;/em&gt; field in the Ingress spec. Otherwise, the ingress gateway will not be created.&lt;/p&gt;
&lt;h2 id=&#34;limitations-of-kubernetes-ingress&#34;&gt;Limitations of Kubernetes Ingress&lt;/h2&gt;
&lt;p&gt;Although IngressClass decouples the ingress gateway from the back-end implementation, it still has significant limitations.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ingress is too simple for most real-world use and it only supports HTTP protocol routing.&lt;/li&gt;
&lt;li&gt;It only supports host and path matching, and there is no standard configuration for advanced routing features, which can only be achieved through annotation, such as URL redirection using Nginx Ingress Controller, which requires configuration of &lt;em&gt;nginx.ingress.kubernetes.io/rewrite-target&lt;/em&gt; annotation, which is no longer adaptable to the needs of a programmable proxy.&lt;/li&gt;
&lt;li&gt;The situation where services in different namespaces must be bound to the same gateway often arises in practical situations where the ingress gateway cannot be shared across multiple namespaces.&lt;/li&gt;
&lt;li&gt;No delineation of responsibilities for creating and managing ingress gateways, resulting in developers having to not only configure gateway routes but also create and manage gateways themselves.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;kubernetes-gateway-api&#34;&gt;Kubernetes Gateway API&lt;/h2&gt;
&lt;p&gt;The Gateway API is a collection of API resources: &lt;em&gt;GatewayClass&lt;/em&gt;, &lt;em&gt;Gateway&lt;/em&gt;, &lt;em&gt;HTTPRoute&lt;/em&gt;, &lt;em&gt;TCPRoute&lt;/em&gt;, &lt;em&gt;ReferenceGrant&lt;/em&gt;, etc. The Gateway API exposes a more generic proxy API that can be used for more protocols than HTTP and models more infrastructure components, providing better deployment and management options for cluster operations.&lt;/p&gt;
&lt;p&gt;In addition, the Gateway API achieves configuration decoupling by separating resource objects that people can manage in different roles. The following diagram shows the roles and objects in the Gateway API.&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/en/blog/why-gateway-api-is-the-future-of-ingress-and-mesh/gateway-api-roles.svg&#34; data-img=&#34;/en/blog/why-gateway-api-is-the-future-of-ingress-and-mesh/gateway-api-roles.svg&#34; alt=&#34;image&#34; data-caption=&#34;Figure: Roles and componentes in Kubernetes Gateway API&#34;&gt;
    
  
  &lt;figcaption&gt;Figure: Roles and componentes in Kubernetes Gateway API&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;The following is an example of using the Gateway API in Istio.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;gateway.networking.k8s.io/v1alpha2&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Gateway&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;gateway&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;istio-ingress&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;gatewayClassName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;istio&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;listeners&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;hostname&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;*.example.com&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;80&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;protocol&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;HTTP&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;allowedRoutes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespaces&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;from&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;All&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nn&#34;&gt;---&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;gateway.networking.k8s.io/v1alpha2&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;HTTPRoute&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;parentRefs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;gateway&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;istio-ingress&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;hostnames&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;httpbin.example.com&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;rules&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;matches&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;PathPrefix&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;backendRefs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;httpbin&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;8000&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Similar to Ingress, Gateway uses &lt;em&gt;gatewayClassName&lt;/em&gt; to declare the controller it uses, which needs to be created by the platform administrator and allows client requests for the *&lt;em&gt;.example.com&lt;/em&gt; domain. Application developers can create routing rules in the namespace where their service resides, in this case, default, and bind to the Gateway via parentRefs, but only if the Gateway explicitly allows them to do so (via the rules set in the &lt;em&gt;allowRoutes&lt;/em&gt; field).&lt;/p&gt;
&lt;p&gt;When you apply the above configuration, Istio will automatically create a load-balancing gateway for you. The following diagram shows the workflow of the Gateway API.&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/en/blog/why-gateway-api-is-the-future-of-ingress-and-mesh/gateway-api-flow.svg&#34; data-img=&#34;/en/blog/why-gateway-api-is-the-future-of-ingress-and-mesh/gateway-api-flow.svg&#34; alt=&#34;image&#34; data-caption=&#34;Figure 3: Gateway API workflow&#34;&gt;
    
  
  &lt;figcaption&gt;Figure 3: Gateway API workflow&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;The detailed process is as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The infrastructure provider provides &lt;em&gt;GatewayClass&lt;/em&gt; and Gateway Controller.&lt;/li&gt;
&lt;li&gt;Platform operator deploy Gateway (multiple deployments possible, or using different &lt;em&gt;GatewayClasses&lt;/em&gt;).&lt;/li&gt;
&lt;li&gt;Gateway Controller continuously monitors changes to the &lt;em&gt;GatewayClass&lt;/em&gt; and &lt;em&gt;Gateway&lt;/em&gt; objects in the Kubernetes API Server.&lt;/li&gt;
&lt;li&gt;Gateway controller will create the corresponding gateway based on cluster operations and maintenance configuration.&lt;/li&gt;
&lt;li&gt;Application developers apply &lt;em&gt;xRoutes&lt;/em&gt; and bind them to the service.&lt;/li&gt;
&lt;li&gt;If in the cloud, the client accesses the load balancer for that ingress gateway.&lt;/li&gt;
&lt;li&gt;The gateway will route to the corresponding back-end service based on the matching criteria in the traffic request.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;From the above steps, we can see that the Gateway API has a clear division of roles compared to Ingress and that routing rules can be decoupled from the gateway configuration, significantly increasing management flexibility.&lt;/p&gt;
&lt;p&gt;The following diagram shows the route flow after it is accessed at the gateway and processed.&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/en/blog/why-gateway-api-is-the-future-of-ingress-and-mesh/traffic-flow.svg&#34; data-img=&#34;/en/blog/why-gateway-api-is-the-future-of-ingress-and-mesh/traffic-flow.svg&#34; alt=&#34;image&#34; data-caption=&#34;Figure 4: Gateway API route flow&#34;&gt;
    
  
  &lt;figcaption&gt;Figure 4: Gateway API route flow&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;From this figure, we can see that the route is bound to the gateway. The route is generally deployed in the same namespace as its backend services. Suppose the route is in a different namespace, and you need to explicitly give the route cross-namespace reference rights in &lt;code&gt;ReferenceGrant&lt;/code&gt;, for example. In that case, the following HTTPRoute foo in the foo namespace can refer to the bar namespace bar service in the bar namespace.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;HTTPRoute&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;rules&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;matches&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/bar&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;forwardTo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;backend&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;bar&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;bar&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nn&#34;&gt;---&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ReferenceGrant&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;bar&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;bar&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;from&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;group&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;networking.gateway.k8s.io&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;HTTPRoute&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;to&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;group&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Service&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Currently, the Gateway API only supports HTTPRoute, and the TCPRoute, UDPRoute, TLSRoute and GRCPRoute are still in the experimental stage. The Gateway API is already supported by a large number of gateway and service mesh projects, and please &lt;a href=&#34;https://gateway-api.sigs.k8s.io/implementations/&#34; title=&#34;check the support status in the official Gateway documentation.&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;check the support status in the official Gateway documentation.&lt;/a&gt;
&lt;/p&gt;
&lt;h2 id=&#34;ingress-gateway-and-service-mesh&#34;&gt;Ingress Gateway and Service Mesh&lt;/h2&gt;
&lt;p&gt;The service mesh focuses on east-west traffic, i.e., traffic within a Kubernetes cluster, but most service meshes, including Istio, also provide ingress gateway functionality. But, since Istio’s ingress functionality and API are more advanced than we need for this example, we’ll use &lt;a href=&#34;https://smi-spec.io/&#34; title=&#34;Service Mesh Interface (SMI)&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Service Mesh Interface (SMI)&lt;/a&gt;
 to illustrate the relationship between the ingress gateway and the service mesh.&lt;/p&gt;
&lt;p&gt;SMI is a CNCF incubation project, open-sourced in 2019, that defines a common standard for vendor-independent service mesh running in Kubernetes.&lt;/p&gt;
&lt;p&gt;The following diagram illustrates the overlap between the Gateway API and the SMI.&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/en/blog/why-gateway-api-is-the-future-of-ingress-and-mesh/gateway-smi-overlay.svg&#34; data-img=&#34;/en/blog/why-gateway-api-is-the-future-of-ingress-and-mesh/gateway-smi-overlay.svg&#34; alt=&#34;image&#34; data-caption=&#34;Figure 5: Gateway API vs SMI&#34;&gt;
    
  
  &lt;figcaption&gt;Figure 5: Gateway API vs SMI&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;From the diagram, we can see a clear overlap between the Gateway API and SMI in the traffic specification section. These overlaps result in the same functionality that needs to be implemented repeatedly in both the Gateway API and the service mesh.&lt;/p&gt;
&lt;h2 id=&#34;traffic-management-in-the-istio-service-mesh&#34;&gt;Traffic Management in the Istio Service Mesh&lt;/h2&gt;
&lt;p&gt;Of course, not all service meshes are fully SMI-compliant. Istio, the most popular service mesh implementation, provides rich traffic management features but does not have a separate policy API for these features, instead coupling them in &lt;em&gt;VirtualService&lt;/em&gt; and &lt;em&gt;DestinationRule&lt;/em&gt;, as shown below.&lt;/p&gt;
&lt;h3 id=&#34;virtualservice&#34;&gt;VirtualService&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Routing: canary release, matching routes based on HTTP header, URI, etc.&lt;/li&gt;
&lt;li&gt;Error injection: HTTP error code injection, HTTP delay injection.&lt;/li&gt;
&lt;li&gt;Traffic splitting: percentage-based traffic splitting.&lt;/li&gt;
&lt;li&gt;Traffic mirroring: mirroring a certain percentage of traffic to other clusters.&lt;/li&gt;
&lt;li&gt;Timeout: set the timeout period, after which the request will fail.&lt;/li&gt;
&lt;li&gt;Retry: set the retry policy, such as trigger conditions, number of retries, interval time, etc.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;destinationrule&#34;&gt;DestinationRule&lt;/h3&gt;
&lt;p&gt;Load balancing: setting up load balancing policies, such as simple load balancing, locality-aware load balancing, and area-weighted load balancing.
Circuit Breaking: Outlier detection and connection pool settings to remove anomalous nodes from the load balancing pool.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;VirtualService&lt;/em&gt; mainly handles routing-related functions, while &lt;em&gt;DestinationRule&lt;/em&gt; is responsible for adding and ejecting nodes from the cluster and load balancing.&lt;/p&gt;
&lt;p&gt;Gateway API Converging the Ingress Gateway from Kubernetes and Service Mesh&lt;/p&gt;
&lt;p&gt;As mentioned above, there is a partial functional intersection between the Gateway API and the service mesh. To reduce duplication of development and enable the modeling of common concerns between the Gateway API and the service mesh, the Gateway API Working Group has proposed the &lt;a href=&#34;https://gateway-api.sigs.k8s.io/contributing/gamma/&#34; title=&#34;Gateway API Mesh Management and Administration&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Gateway API Mesh Management and Administration&lt;/a&gt;
 (GAMMA) initiative.&lt;/p&gt;
&lt;p&gt;Under this initiative, advanced traffic management features that vary in detail across gateway implementations, such as timeouts, retries, health checks, etc., will all be implemented by individual providers through &lt;a href=&#34;https://gateway-api.sigs.k8s.io/references/policy-attachment/&#34; title=&#34;policy attachment&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;policy attachment&lt;/a&gt;
. You can specify the resource object to which the policy attachment is attached via the &lt;em&gt;targetRef&lt;/em&gt; field, as shown below.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;networking.acme.io/v1alpha1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;RetryPolicy&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;override&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;maxRetries&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;maxRetries&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;targetRef&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;group&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;gateway.networking.k8s.io/v1alpha2&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;HTTPRoute&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In this example, the retry policy is attached to a resource named &lt;em&gt;foo&lt;/em&gt; and &lt;em&gt;HTTPRoute&lt;/em&gt;. Policy attachments are connected to different resource objects with varying priorities for effectiveness. For instance, GatewayClass is a cluster-level resource and will take precedence if the policy attachment is overlaid on it.&lt;/p&gt;
&lt;p&gt;You can assign override and default values to additional policies whose priority in the ingress and the different resources in the mesh hierarchy are shown in the figure below.&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/en/blog/why-gateway-api-is-the-future-of-ingress-and-mesh/policy-attachment-priority.svg&#34; data-img=&#34;/en/blog/why-gateway-api-is-the-future-of-ingress-and-mesh/policy-attachment-priority.svg&#34; alt=&#34;image&#34; data-caption=&#34;Figure 6: Kubernetes Ingress and Mesh with Overrides and Default Priorities&#34;&gt;
    
  
  &lt;figcaption&gt;Figure 6: Kubernetes Ingress and Mesh with Overrides and Default Priorities&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Currently, the Gateway API is being explored to handle mesh traffic, and several &lt;a href=&#34;https://docs.google.com/document/d/1T_DtMQoq2tccLAtJTpo3c0ohjm25vRS35MsestSL9QU/edit#heading=h.6ks49gf06yii&#34; title=&#34;design options&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;design options&lt;/a&gt;
 have been proposed.&lt;/p&gt;
&lt;h2 id=&#34;envoy-gateway&#34;&gt;Envoy Gateway&lt;/h2&gt;
&lt;p&gt;The first open-source version of Envoy Gateway, &lt;a href=&#34;https://blog.envoyproxy.io/introducing-envoy-gateway-ad385cc59532&#34; title=&#34;v0.2, was released&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;v0.2, was released&lt;/a&gt;
 in October 2022. It was created based on the Envoy proxy’s compliance with the Gateway API, of which &lt;a href=&#34;https://tetrate.io/&#34; title=&#34;Tetrate &#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tetrate &lt;/a&gt;
is a core sponsor. Its expressive, scalable, role-oriented API design through ingress and L4/L7 traffic routing makes it the foundation for vendors to build value-added API gateway products.&lt;/p&gt;
&lt;p&gt;Long before Envoy Gateway was released, Envoy was massively adopted as one of the most popular cloud-native proxies, with several Gateway software builds based on Envoy, and the Istio service mesh used it as the default sidecar proxy and configured these distributed proxies via the xDS protocol. Envoy Gateway also uses xDS to configure the Envoy fleet. The following diagram illustrates the architecture of Envoy Gateway.&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/en/blog/why-gateway-api-is-the-future-of-ingress-and-mesh/envoy-gateway-arch.svg&#34; data-img=&#34;/en/blog/why-gateway-api-is-the-future-of-ingress-and-mesh/envoy-gateway-arch.svg&#34; alt=&#34;image&#34; data-caption=&#34;Figure: Envoy Gateway architecture&#34;&gt;
    
  
  &lt;figcaption&gt;Figure: Envoy Gateway architecture&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;The infrastructure provider will provide you with GatewayGlass. You can create an Envoy Gateway by creating a Gateway declaration. Your routing and policy attachments in the Gateway will be sent to the Envoy fleet via the xDS protocol.&lt;/p&gt;
&lt;p&gt;For further information about Envoy Gateway, please read&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://tetrate.io/blog/hands-on-with-the-gateway-api-using-envoy-gateway-0-2/&#34; title=&#34;Hands on with the New Kubernetes Gateway API, Using Envoy Gateway 0.2&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Hands on with the New Kubernetes Gateway API, Using Envoy Gateway 0.2&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://tetrate.io/blog/gateway-to-the-future-the-new-gateway-api-and-envoy-gateway-0-2/&#34; title=&#34;Gateway to the Future: the New Kubernetes Gateway API and Envoy Gateway 0.2&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Gateway to the Future: the New Kubernetes Gateway API and Envoy Gateway 0.2&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;
&lt;p&gt;The Gateway API, as the next-generation Kubernetes Ingress API, provides a better degree of API specification for Kubernetes gateway providers as opposed to the Ingress API before, enriching the functionality of the ingress gateway while ensuring its portability and facilitating the management of gateways by different stakeholders through the separation of concerns. Finally, the GAMMA initiative is promoting the integration of the Ingress Gateway with the Gateway API for service mesh, and policy attachments may further extend the functionality of the Gateway API to east-west gateways.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;This blog was originally published at &lt;a href=&#34;https://tetrate.io/blog/why-the-gateway-api-is-the-unified-future-of-ingress-for-kubernetes-and-service-mesh/&#34; title=&#34;tetrate.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;tetrate.io&lt;/a&gt;
.&lt;/em&gt;&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>In-Depth Understanding of Istio: Announcing the Publication of a New Istio Book</title>
      <link>https://jimmysong.io/en/blog/istio-service-mesh-book/</link>
      <pubDate>Wed, 15 Jun 2022 20:27:49 +0800</pubDate>
      
      <guid>https://jimmysong.io/en/blog/istio-service-mesh-book/</guid>
      <description>
        
        
        &lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/en/blog/istio-service-mesh-book/book.jpg&#34; data-img=&#34;/en/blog/istio-service-mesh-book/book.jpg&#34; data-width=&#34;1200&#34; data-height=&#34;800&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
    
  
  &lt;figcaption&gt;&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;It&amp;rsquo;s been more than 5 years since Google, IBM, and Lyft unveiled the Istio open source project in May 2017. The Istio project has developed from a seed to a tall tree in these years. Many domestic books on the Istio service mesh were launched in the two years following the release of Istio 1.0 in 2018. My country is at the forefront of the world in the field of Istio book publishing.&lt;/p&gt;
&lt;h2 id=&#34;service-mesh-one-of-the-core-technologies-of-cloud-native&#34;&gt;Service mesh: one of the core technologies of cloud native&lt;/h2&gt;
&lt;p&gt;Today, Istio is nearly synonymous with service mesh in China. The development of service mesh, as one of the core cloud-native technologies described by CNCF (Cloud Native Computing Foundation), has gone through the following stages.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2017-2018: Exploratory Phase&lt;/li&gt;
&lt;li&gt;2019-2020: Early Adopter Phase&lt;/li&gt;
&lt;li&gt;2021 to present: Implementation on a large scale and ecological development stage&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Cloud native technology enables enterprises to design and deploy elastically scalable applications in new dynamic settings such as public, private, and hybrid clouds, according to the CNCF. Containers, service meshes, microservices, immutable infrastructure, and declarative APIs are examples of cloud native technology.&lt;/p&gt;
&lt;p&gt;Service mesh has been included to the CNCF definition of cloud native, indicating that it is one of the representative technologies of cloud native. Google is donating Istio to CNCF today, and we have reason to expect that as a CNCF project, Istio&amp;rsquo;s community will be more open, and its future development will be more smooth.&lt;/p&gt;
&lt;h2 id=&#34;service-mesh-and-cloud-native-applications&#34;&gt;Service mesh and cloud native applications&lt;/h2&gt;
&lt;p&gt;Cloud-native development is gaining traction. Despite the frequent emergence of new technologies and products, service mesh has maintained its place as &amp;ldquo;cloud-native network infrastructure&amp;rdquo; as part of the overall cloud-native technology stack throughout the past year. The cloud-native technology stack model is depicted in the diagram below, with representative technologies for each layer to define the standard. Service mesh and other cloud-native technologies complement each other as a new era of middleware emerges. Dapr (Distributed Application Runtime) defines the cloud-native middleware capability model, OAM defines the cloud-native application model, and so on, whereas service mesh Lattice defines a cloud-native seven-layer network model.&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
    &lt;img src=&#34;model.jpg&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34;
         alt=&#34;Cloud Native Application Model&#34; width=&#34;80%&#34;data-img=&#34;model.jpg&#34;
         data-caption=&#34;Cloud Native Application Model&#34;
         
         
         data-width=&#34;1200&#34;
         data-height=&#34;1104&#34;
         
         
    /&gt;&lt;figcaption&gt;
            Cloud Native Application Model
        &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h2 id=&#34;why-you-need-a-service-mesh&#34;&gt;Why you need a service mesh&lt;/h2&gt;
&lt;p&gt;Using a service mesh isn&amp;rsquo;t tantamount to abandoning Kubernetes; it just makes sense. The goal of Kubernetes is to manage application lifecycles through declarative configuration, whereas the goal of service mesh is to provide traffic control, security management, and observability amongst apps. How do you set up load balancing and flow management for calls between services after a robust microservice platform has been developed with Kubernetes?&lt;/p&gt;
&lt;p&gt;Many open source tools, including Istio, Linkerd, MOSN, and others, support Envoy&amp;rsquo;s xDS protocol. The specification of xDS is Envoy&amp;rsquo;s most significant contribution to service mesh or cloud native. Many various usage cases, such as API gateways, sidecar proxies in service meshes, and edge proxies, are derived from Envoy, which is simply a network proxy, a modern version of the proxy configured through the API.&lt;/p&gt;
&lt;p&gt;In a nutshell, the move from Kubernetes to Istio was made for the following reasons.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Application life cycle management, specifically application deployment and management, is at the heart of Kubernetes (scaling, automatic recovery, and release).&lt;/li&gt;
&lt;li&gt;Kubernetes is a microservices deployment and management platform that is scalable and extremely elastic.&lt;/li&gt;
&lt;li&gt;Transparent proxy is the cornerstone of service mesh, which intercepts communication between microservices via sidecar proxy and then regulates microservice behavior via control plane settings. The deployment mode of service meshes has introduced new issues today. For service meshes, sidecar is no longer required, and an agentless service mesh based on gRPC is also being tested.&lt;/li&gt;
&lt;li&gt;xDS is a protocol standard for configuring service meshes, and a gRPC-based xDS is currently being developed.&lt;/li&gt;
&lt;li&gt;Kubernetes traffic management is decoupled with the service mesh. The kube-proxy component is not required to support traffic within the service mesh. The traffic between services is controlled by an abstraction close to the microservice application layer to achieve security and observability features.&lt;/li&gt;
&lt;li&gt;In Kubernetes, service mesh is an upper-level abstraction of service, and Serverless is the next stage, which is why Google released Knative based on Kubernetes and Istio following Istio.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;open-source-in-the-name-of-the-community&#34;&gt;Open source in the name of the community&lt;/h2&gt;
&lt;p&gt;The ServiceMesher community was founded in May 2018 with the help of Ant Financial. Following that, a tornado of service meshes erupted in China, and the community-led translation of Istio&amp;rsquo;s official documentation reached a fever pitch.&lt;/p&gt;
&lt;p&gt;I became aware of a dearth of Chinese resources for systematically teaching Istio over time, so in September 2018, I began to plan and create an Istio book, launching the Istio Handbook open source e-book project on GitHub. I met many friends who are also interested in Istio and service mesh technology in the online and offline events of the community a few months later, with the promotion of service mesh technology and the expansion of the ServiceMesher community. We unanimously agreed to collaborate on an open source Istio e-book, which will compile the community&amp;rsquo;s important writings and experience into a logical text and make it available to the majority of developers.&lt;/p&gt;
&lt;p&gt;Hundreds of people volunteered and began co-authoring the book in March 2019 under the auspices of the Community Stewardship Council. In May 2020, we created a cloud-native community that incorporated the original ServiceMesher community in order to further promote cloud-native technology and expand the technical knowledge supplied by the community. The scope of community operations has also widened, moving away from service mesh to more extensive cloud-native tools.&lt;/p&gt;
&lt;p&gt;The editorial board for this book, which includes me, Ma Ruofei, Wang Baiping, Wang Wei, Luo Guangming, Zhao Huabing, Zhong Hua, and Guo Xudong, was founded in October 2020. We performed further version updates, improvements, and optimizations to this book under the supervision and assistance of the publishing business. This book, &amp;ldquo;In-depth Understanding of Isito: Advanced Practice of Cloud Native Service Mesh,&amp;rdquo; finally met you after many iterations.&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
    &lt;img src=&#34;cover.jpg&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34;
         alt=&#34;The book cover&#34; width=&#34;70%&#34;data-img=&#34;cover.jpg&#34;
         data-caption=&#34;The book cover&#34;
         
         
         data-width=&#34;1200&#34;
         data-height=&#34;1569&#34;
         
         
    /&gt;&lt;figcaption&gt;
            The book cover
        &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h2 id=&#34;about-this-book&#34;&gt;About this book&lt;/h2&gt;
&lt;p&gt;After version 1.5, Istio underwent considerable architectural modifications, and various new or better features were added, including the addition of a smart DNS proxy, additional resource objects, increased support for virtual machines, and more.&lt;/p&gt;
&lt;p&gt;This book is based on the new edition of Istio, and it aims to provide readers with the most up-to-date and comprehensive content possible by following the newest trends in the Istio community. Furthermore, several of the book&amp;rsquo;s authors are front-line development or operation and maintenance engineers with extensive Istio expertise, offering detailed and useful reference cases for the book.&lt;/p&gt;
&lt;p&gt;This book is currently available on the &lt;a href=&#34;https://item.jd.com/13200745.html&#34; title=&#34;JD.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;JD.com&lt;/a&gt;
. Please read &amp;ldquo;In-depth Understanding of Isito: Advanced Practice of Cloud Native Service Mesh&amp;rdquo; if you want to learn more about Istio!&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
    &lt;a href=&#34;https://item.jd.com/13200745.html&#34;&gt;&lt;img src=&#34;qrcode.jpg&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;30%&#34;data-img=&#34;qrcode.jpg&#34;
         data-caption=&#34;&#34;
         
         
         data-width=&#34;400&#34;
         data-height=&#34;401&#34;
         
         
    /&gt;&lt;/a&gt;&lt;figcaption&gt;
            &lt;p&gt;&lt;a href=&#34;https://item.jd.com/13200745.html&#34; title=&#34;Buy now&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Buy now&lt;/a&gt;&lt;/p&gt;
        &lt;/figcaption&gt;
&lt;/figure&gt;


      </description>
    </item>
    
    <item>
      <title>What&#39;s New in Istio 1.13?</title>
      <link>https://jimmysong.io/en/blog/what-is-new-in-istio-1-13/</link>
      <pubDate>Mon, 28 Mar 2022 16:43:27 +0800</pubDate>
      
      <guid>https://jimmysong.io/en/blog/what-is-new-in-istio-1-13/</guid>
      <description>
        
        
        &lt;p&gt;Istio 1.13 is the first release of 2022, and, not surprisingly, the Istio team will continue to release new versions every quarter. Overall, the new features in this release include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Support for newer versions of Kubernetes&lt;/li&gt;
&lt;li&gt;New API – ProxyConfig, for configuring sidecar proxies&lt;/li&gt;
&lt;li&gt;Improved Telemetry API&lt;/li&gt;
&lt;li&gt;Support for hostname-based load balancers with multiple network gateways&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;support-for-kubernetes-versions&#34;&gt;Support for Kubernetes Versions&lt;/h3&gt;
&lt;p&gt;I often see people asking in the community which Istio supports Kubernetes versions. Istio’s website has a clear list of supported Kubernetes versions. You can see &lt;a href=&#34;https://istio.io/latest/docs/releases/supported-releases/#support-status-of-istio-releases&#34; title=&#34;here&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;here&lt;/a&gt;
 that Istio 1.13 supports Kubernetes versions 1.20, 1.21, 1.22, and 1.23, and has been tested but not officially supported in Kubernetes 1.16, 1.17, 1.18, 1.19.&lt;/p&gt;
&lt;p&gt;When configuring Istio, there are a lot of checklists. I noted them all in the &lt;a href=&#34;https://github.com/tetratelabs/istio-cheatsheet&#34; title=&#34;Istio cheatsheet&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio cheatsheet&lt;/a&gt;
. There are a lot of cheat sheets about configuring Istio, using resources, dealing with everyday problems, etc., in this project, which will be online soon, so stay tuned.&lt;/p&gt;
&lt;p&gt;The following screenshot is from the Istio cheatsheet website, it shows the basic cheat sheet for setting up Istio.&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/en/blog/what-is-new-in-istio-1-13/istio-cheatsheet.jpg&#34; data-img=&#34;/en/blog/what-is-new-in-istio-1-13/istio-cheatsheet.jpg&#34; data-width=&#34;1728&#34; data-height=&#34;1080&#34; alt=&#34;image&#34; data-caption=&#34;Istio cheatsheet&#34;&gt;
    
  
  &lt;figcaption&gt;Istio cheatsheet&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;introducing-the-new-proxyconfig-api&#34;&gt;Introducing the new ProxyConfig API&lt;/h3&gt;
&lt;p&gt;Before Istio version 1.13, if you wanted to customize the configuration of the sidecar proxy, there were two ways to do it.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MeshConfig&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Use MeshConfig and use IstioOperator to modify it at the Mesh level. For example, use the following configuration to alter the default discovery port for istiod.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;install.istio.io/v1alpha1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;IstioOperator&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;meshConfig&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;	  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;defaultConfig&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;discoveryAddress&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;istiod:15012&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;Annotation in the Pods&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;You can also use annotation at the Pod level to customize the configuration. For example, you can add the following annotations to Pod to modify the default port for &lt;code&gt;istiod&lt;/code&gt; of the workload:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;anannotations&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;proxy.istio.io/config&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;    discoveryAddress: istiod:15012&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;When you configure sidecar in either of these ways, the fields set in annotations will completely override the default fields in MeshConfig. Please refer to the &lt;a href=&#34;https://istio.io/latest/docs/reference/config/istio.mesh.v1alpha1/#ProxyConfig&#34; title=&#34;Istio documentation&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio documentation&lt;/a&gt;
 for all configuration items of ProxyConfig.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The new API – ProxyConfig&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;But in 1.13, a new top-level custom resource, ProxyConfig, has been added, allowing you to customize the configuration of your sidecar proxy in one place by specifying a namespace and using a selector to select the scope of the workload, just like any other CRD. Istio currently has limited support for this API, so please refer to the &lt;a href=&#34;https://istio.io/latest/docs/reference/config/networking/proxy-config/&#34; title=&#34;Istio documentation&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio documentation&lt;/a&gt;
 for more information on the ProxyConfig API.&lt;/p&gt;
&lt;p&gt;However, no matter which way you customize the configuration of the sidecar proxy, it does not take effect dynamically and requires a workload restart to take effect. For example, for the above configuration, because you changed the default port of istiod, all the workloads in the mesh need to be restarted before connecting to the control plane.&lt;/p&gt;
&lt;h3 id=&#34;telemetry-api&#34;&gt;Telemetry API&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://istio.io/latest/docs/reference/config/istio.mesh.v1alpha1/#MeshConfig-ExtensionProvider&#34; title=&#34;MeshConfig&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;MeshConfig&lt;/a&gt;
 customized extensions and configurations in the Istio mesh. The three pillars of observability– Metrics, Telemetry, and Logging– can each be docked to different providers. The &lt;a href=&#34;https://istio.io/latest/docs/tasks/observability/telemetry/&#34; title=&#34;Telemetry API&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Telemetry API&lt;/a&gt;
 gives you a one-stop place for flexible configuration of them. Like the ProxyConfig API, the Telemetry API follows the configuration hierarchy of Workload Selector &amp;gt; Local Namespace &amp;gt; Root Configuration Namespace. The API was introduced in Istio 1.11 and has been further refined in that release to add support for OpenTelemetry logs, filtered access logs, and custom tracing service names. See &lt;a href=&#34;https://istio.io/latest/docs/reference/config/telemetry/&#34; title=&#34;Telemetry Configuration&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Telemetry Configuration&lt;/a&gt;
 for details.&lt;/p&gt;
&lt;h3 id=&#34;automatic-resolution-of-multi-network-gateway-hostnames&#34;&gt;Automatic resolution of multi-network gateway hostnames&lt;/h3&gt;
&lt;p&gt;In September 2021, a member of the Istio community &lt;a href=&#34;https://szabo.jp/2021/09/22/multicluster-istio-on-eks/&#34; title=&#34;reported an issue&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;reported an issue&lt;/a&gt;
 with the EKS load balancer failing to resolve when running multi-cluster Istio in AWS EKS. Workloads that cross cluster boundaries need to be communicated indirectly through a dedicated east-west gateway for a multi-cluster, multi-network mesh. You can follow the instructions on &lt;a href=&#34;https://istio.io/latest/docs/setup/install/multicluster/multi-primary_multi-network/&#34; title=&#34;Istio’s website&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio’s website&lt;/a&gt;
 to configure a multi-network, primary-remote cluster, and Istio will automatically resolve the IP address of the load balancer based on the hostname.&lt;/p&gt;
&lt;h3 id=&#34;istio-1131-fixing-the-critical-security-vulnerabilities&#34;&gt;Istio 1.13.1 fixing the critical security vulnerabilities&lt;/h3&gt;
&lt;p&gt;Istio 1.13.1 was released to fix a known &lt;a href=&#34;https://cve.mitre.org/cgi-bin/cvekey.cgi?keyword=CVE-2022-23635&#34; title=&#34;critical vulnerability&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;critical vulnerability&lt;/a&gt;
 that could lead to an unauthenticated control plane denial of service attack.&lt;/p&gt;
&lt;p&gt;The figure below shows a multi-cluster primary-remote mesh where istiod exposes port 15012 to the public Internet via a gateway so that a pod on another network can connect to it.&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/en/blog/what-is-new-in-istio-1-13/multi-network-mesh.jpg&#34; data-img=&#34;/en/blog/what-is-new-in-istio-1-13/multi-network-mesh.jpg&#34; data-width=&#34;1299&#34; data-height=&#34;1080&#34; alt=&#34;image&#34; data-caption=&#34;Multi-network Mesh&#34;&gt;
    
  
  &lt;figcaption&gt;Multi-network Mesh&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;When installing a multi-network, primary-remote mode Istio mesh, for a remote Kubernetes cluster to access the control plane, an east-west Gateway needs to be installed in the Primary cluster, exposing port 15012 of the control plane istiod to the Internet. An attacker could send specially crafted messages to that port, causing the control plane to crash. If you set up a firewall to allow traffic from only some IPs to access this port, you will be able to reduce the impact of the problem. It is recommended that you upgrade to Istio 1.13.1 immediately to resolve the issue completely.&lt;/p&gt;
&lt;h3 id=&#34;istiocon-2022&#34;&gt;IstioCon 2022&lt;/h3&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/en/blog/what-is-new-in-istio-1-13/istiocon-2022.jpg&#34; data-img=&#34;/en/blog/what-is-new-in-istio-1-13/istiocon-2022.jpg&#34; data-width=&#34;1318&#34; data-height=&#34;736&#34; alt=&#34;image&#34; data-caption=&#34;IstioCon 2022&#34;&gt;
    
  
  &lt;figcaption&gt;IstioCon 2022&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Finally, as a committee member for the last and current IstioCon, I call on everyone to register for &lt;a href=&#34;https://events.istio.io/istiocon-2022/&#34; title=&#34;IstioCon 2022&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;IstioCon 2022&lt;/a&gt;
, which will be held online on April 25! It will be an industry-focused event, a platform to connect contributors and users to discuss the uses of Istio in different architectural setups, its limitations, and where to take the project next. The main focus on end-user companies, as we look forward to sharing a diversity of case studies showing how to use Istio in production.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Service Mesh in 2021: The Ecosystem Is Emerging</title>
      <link>https://jimmysong.io/en/blog/service-mesh-in-2021/</link>
      <pubDate>Wed, 12 Jan 2022 16:43:27 +0800</pubDate>
      
      <guid>https://jimmysong.io/en/blog/service-mesh-in-2021/</guid>
      <description>
        
        
        &lt;p&gt;As the service mesh architecture concept gains traction and the scenarios for its applications emerge, there is no shortage of discussions about it in the community. I have worked on service mesh with the community for 4 years now, and will summarize the development of service mesh in 2021 from this perspective. Since Istio is the most popular service mesh, this article will focus on the technical and ecological aspects of Istio.&lt;/p&gt;
&lt;h2 id=&#34;service-mesh-a-critical-tech-for-cloud-native-infrastructure&#34;&gt;Service mesh: a critical tech for Cloud Native Infrastructure&lt;/h2&gt;
&lt;p&gt;As one of the vital technologies &lt;a href=&#34;https://github.com/cncf/toc/blob/main/DEFINITION.md&#34; title=&#34;defined by CNCF&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;defined by CNCF&lt;/a&gt;
 for cloud native, Istio has been around for five years now. Their development has gone through the following periods.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Exploration phase: 2017-2018&lt;/li&gt;
&lt;li&gt;Early adopter phase: 2019-2020&lt;/li&gt;
&lt;li&gt;Large-scale landing and ecological development phase: 2021-present&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Service mesh has crossed the “chasm”(refer &lt;a href=&#34;https://thinkinsights.net/strategy/crossing-the-chasm/&#34; title=&#34;Crossing the Chasm&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Crossing the Chasm&lt;/a&gt;
 theory) and is in between the “early majority” and “late majority” phases of adoption. Based on feedback from the audience of &lt;a href=&#34;https://github.com/tetratelabs/istio-weekly/&#34; title=&#34;Istio Weekly,&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio Weekly,&lt;/a&gt;
 users are no longer blindly following new technologies for experimentation and are starting to consider whether they need them in their organization dialectically.&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/en/blog/service-mesh-in-2021/008i3skNly1gysddnj9i2j30sg0fqaaz.jpg&#34; data-img=&#34;/en/blog/service-mesh-in-2021/008i3skNly1gysddnj9i2j30sg0fqaaz.jpg&#34; data-width=&#34;1024&#34; data-height=&#34;566&#34; alt=&#34;image&#34; data-caption=&#34;Cross the chasm&#34;&gt;
    
  
  &lt;figcaption&gt;Cross the chasm&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;While new technologies and products continue to emerge, the service mesh, as part of the cloud native technology stack, has continued to solidify its position as the “cloud native network infrastructure” over the past year. The diagram below illustrates the cloud native technology stack model, where each layer has several representative technologies that define the standard. As new-age middleware, the service mesh mirrors other cloud native technologies, such as &lt;a href=&#34;https://dapr.io/&#34; title=&#34;Dapr&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Dapr&lt;/a&gt;
 (Distributed Application Runtime), which represents the capability model for cloud native middleware, &lt;a href=&#34;https://oam.dev/&#34; title=&#34;OAM&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OAM&lt;/a&gt;
, which defines the cloud native application model, and the service mesh, which defines the L7 network model.&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/en/blog/service-mesh-in-2021/008i3skNly1gysddogtenj30sg0qlwgs.jpg&#34; data-img=&#34;/en/blog/service-mesh-in-2021/008i3skNly1gysddogtenj30sg0qlwgs.jpg&#34; data-width=&#34;1024&#34; data-height=&#34;957&#34; alt=&#34;image&#34; data-caption=&#34;Cloud Native Stack&#34;&gt;
    
  
  &lt;figcaption&gt;Cloud Native Stack&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;A layered view of the cloud native application platform technology stack&lt;/p&gt;
&lt;h2 id=&#34;optimizing-the-mesh-for-large-scale-production-applications-with-different-deployment-models&#34;&gt;Optimizing the mesh for large scale production applications with different deployment models&lt;/h2&gt;
&lt;p&gt;Over the past year, the community focused on the following areas.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Performance optimization: performance issues of service mesh in large-scale application scenarios.&lt;/li&gt;
&lt;li&gt;Protocol and extensions: enabling service mesh to support arbitrary L7 network protocols.&lt;/li&gt;
&lt;li&gt;Deployment models: Proxyless vs. Node model vs. Sidecar model.&lt;/li&gt;
&lt;li&gt;eBPF: putting some of the service mesh’s capabilities to the kernel layer.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;performance-optimization&#34;&gt;Performance optimization&lt;/h3&gt;
&lt;p&gt;Istio was designed to serve service to service traffic by “proto-protocol forwarding”. The goal is making the service mesh as “transparent” as possible to applications. Thus using IPtables to hijack the traffic, according to the community-provided test results Istio 1.2 adds only 3 ms to the baseline latency for a mesh with 1000 RPS on 16 connections. However, because of issues inherent in the IPtables conntrack module, Istio’s performance issues begin to emerge as the mesh size increases. To optimize the performance of the Istio sidecar for resource usage and network latency, the community gave the following solutions.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Sidecar configuration: By configuring service dependencies manually or by adding an Operator to the control plane, the number of service configurations sent to Sidecar can be reduced, thus reducing the resource footprint of the data plane; for more automatic and intelligent configuration of Sidecar, the open source projects &lt;a href=&#34;https://github.com/slime-io/slime&#34; title=&#34;Slime&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Slime&lt;/a&gt;
 and &lt;a href=&#34;https://github.com/aeraki-framework/aeraki&#34; title=&#34;Aeraki&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Aeraki&lt;/a&gt;
 both offer their innovative configuration loading solutions.&lt;/li&gt;
&lt;li&gt;The introduction of eBPF: eBPF can be a viable solution to optimize the performance of the service mesh. Some Cilium-based startups even radically propose to use eBPF to replace the Sidecar proxy completely. Still, the Envoy proxy/xDS protocol has become the proxy for the service mesh implementation and supports the Layer 7 protocol very well. We can use eBPF to improve network performance, but complex protocol negotiation, parsing, and user scaling remain challenging to implement on the user side.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;protocol-and-extensions&#34;&gt;Protocol and extensions&lt;/h3&gt;
&lt;p&gt;Extensibility of Istio has always been a significant problem, and there are two aspects to Istio’s extensibility.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Protocol level: allowing Istio to support all L7 protocols&lt;/li&gt;
&lt;li&gt;Ecological: allowing Istio to run more extensions&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Istio uses Envoy as its data plane. Extending Istio is essentially an extension of Envoy’s functionality. Istio’s official solution is to use WebAssembly, and in Istio 1.12, the &lt;a href=&#34;https://www.tetrate.io/blog/istio-wasm-extensions-and-ecosystem/&#34; title=&#34;Wasm plugin configuration API&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Wasm plugin configuration API&lt;/a&gt;
 was introduced to extend the Istio ecosystem. Istio’s extension mechanism uses the &lt;a href=&#34;https://github.com/proxy-wasm/spec&#34; title=&#34;Proxy-Wasm Application Binary Interface (ABI)&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Proxy-Wasm Application Binary Interface (ABI)&lt;/a&gt;
 specification to provide a set of proxy-independent streaming APIs and utilities that can be implemented in any language with an appropriate SDK. Today, Proxy-Wasm’s SDKs are AssemblyScript (similar to TypeScript), C++, Rust, Zig, and Go (using the TinyGo WebAssembly System Interface).&lt;/p&gt;
&lt;p&gt;There are still relatively few WebAssembly extensions available, and many enterprises choose to customize their CRD and build a service mesh management plane based on Istio. In addition, making Istio support heterogeneous environments for all workloads, such as virtual machines and containers, is also in strong demand for end-users. It allows them to migrate applications from traditional loads to service mesh easily. Finally, there is the hybrid cloud traffic management with multiple clusters and mesh, which is a more advanced requirement.&lt;/p&gt;
&lt;h3 id=&#34;deployment-models&#34;&gt;Deployment models&lt;/h3&gt;
&lt;p&gt;When the service mesh concept first emerged, there was a debate between the Per-node and Sidecar models, represented by Linkerd and Istio. eBPF later proposed a kernel to sink the service mesh, which led to more service mesh deployment models, as shown in the figure below.&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/en/blog/service-mesh-in-2021/008i3skNly1gysddpco2mj30qz0sgwhk.jpg&#34; data-img=&#34;/en/blog/service-mesh-in-2021/008i3skNly1gysddpco2mj30qz0sgwhk.jpg&#34; data-width=&#34;971&#34; data-height=&#34;1024&#34; alt=&#34;image&#34; data-caption=&#34;Service Mesh Deployment Models&#34;&gt;
    
  
  &lt;figcaption&gt;Service Mesh Deployment Models&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;These four deployment methods have their own advantages and disadvantages, the specific choice of which depends on the actual situation.&lt;/p&gt;
&lt;h3 id=&#34;development-of-the-istio-ecosystem-and-the-projects-that-support-istio&#34;&gt;Development of the Istio ecosystem and the projects that support Istio&lt;/h3&gt;
&lt;p&gt;2021 was also an exciting year for the Istio community, with a series of events and tutorials.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;February, the first Istio distribution, &lt;a href=&#34;https://istio.tetratelabs.io/&#34; title=&#34;Tetrate Istio Distro (TID)&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tetrate Istio Distro (TID)&lt;/a&gt;
.&lt;/li&gt;
&lt;li&gt;February, the first &lt;a href=&#34;https://events.istio.io/istiocon-2021/&#34; title=&#34;IstioCon&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;IstioCon&lt;/a&gt;
 was held online, with over 2,000 participants.&lt;/li&gt;
&lt;li&gt;March, the first free online &lt;a href=&#34;https://academy.tetrate.io/courses/istio-fundamentals&#34; title=&#34;Istio Fundamentals Course&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio Fundamentals Course&lt;/a&gt;
 is released.&lt;/li&gt;
&lt;li&gt;May, the first &lt;a href=&#34;https://academy.tetrate.io/courses/certified-istio-administrator&#34; title=&#34;Certification Istio Administrator exam&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Certification Istio Administrator exam&lt;/a&gt;
 be released.&lt;/li&gt;
&lt;li&gt;May, ServiceMeshCon Europe was held online.&lt;/li&gt;
&lt;li&gt;July, &lt;a href=&#34;https://istio.io/latest/zh/blog/2021/istiomeetups-china/&#34; title=&#34;Istio Meetup China&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio Meetup China&lt;/a&gt;
 was held in Beijing with more than 100 attendees.&lt;/li&gt;
&lt;li&gt;October, ServiceMeshCon North America was held in Los Angeles.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There are also numerous open source projects related to Istio Service Mesh, as shown in the table below.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;Project&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Value&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Relationship with Istio&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Category&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Launch Date&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Dominant company&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Number of stars&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/envoyproxy/envoy&#34; title=&#34;Envoy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy&lt;/a&gt;
&lt;/td&gt;
&lt;td&gt;Cloud native high-performance edge/middle-service proxy&lt;/td&gt;
&lt;td&gt;The default data plane&lt;/td&gt;
&lt;td&gt;proxy&lt;/td&gt;
&lt;td&gt;September 2016&lt;/td&gt;
&lt;td&gt;Lyft&lt;/td&gt;
&lt;td&gt;18700&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/istio/istio/&#34; title=&#34;Istio&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio&lt;/a&gt;
&lt;/td&gt;
&lt;td&gt;Connection, secure, control, and observation services.&lt;/td&gt;
&lt;td&gt;Control plane&lt;/td&gt;
&lt;td&gt;service mesh&lt;/td&gt;
&lt;td&gt;May 2017&lt;/td&gt;
&lt;td&gt;Google&lt;/td&gt;
&lt;td&gt;29100&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/emissary-ingress/emissary&#34; title=&#34;Emissary Gateway&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Emissary Gateway&lt;/a&gt;
&lt;/td&gt;
&lt;td&gt;Kubernetes native API gateway for microservices, built on Envoy&lt;/td&gt;
&lt;td&gt;Connectable to Istio&lt;/td&gt;
&lt;td&gt;gateway&lt;/td&gt;
&lt;td&gt;February 2018&lt;/td&gt;
&lt;td&gt;Ambassador&lt;/td&gt;
&lt;td&gt;3600&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/apache/apisix&#34; title=&#34;APISIX&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;APISIX&lt;/a&gt;
&lt;/td&gt;
&lt;td&gt;Cloud native API gateways&lt;/td&gt;
&lt;td&gt;It can run as a data plane for Istio or as a gateway on its own&lt;/td&gt;
&lt;td&gt;gateway&lt;/td&gt;
&lt;td&gt;June 2019&lt;/td&gt;
&lt;td&gt;API7&lt;/td&gt;
&lt;td&gt;8100&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/mosn/mosn&#34; title=&#34;MOSN&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;MOSN&lt;/a&gt;
&lt;/td&gt;
&lt;td&gt;Cloud native edge gateways &amp;amp; agents&lt;/td&gt;
&lt;td&gt;Available as Istio data plane&lt;/td&gt;
&lt;td&gt;proxy&lt;/td&gt;
&lt;td&gt;December 2019&lt;/td&gt;
&lt;td&gt;Ant&lt;/td&gt;
&lt;td&gt;3500&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/slime-io/slime&#34; title=&#34;Slime&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Slime&lt;/a&gt;
&lt;/td&gt;
&lt;td&gt;Intelligent service mesh manager based on Istio&lt;/td&gt;
&lt;td&gt;Adding a management plane to Istio&lt;/td&gt;
&lt;td&gt;extensions&lt;/td&gt;
&lt;td&gt;January 2021&lt;/td&gt;
&lt;td&gt;NetEase&lt;/td&gt;
&lt;td&gt;236&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/tetratelabs/getmesh&#34; title=&#34;GetMesh&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GetMesh&lt;/a&gt;
&lt;/td&gt;
&lt;td&gt;Istio integration and command-line management tools&lt;/td&gt;
&lt;td&gt;Utility for Istio multi-version management&lt;/td&gt;
&lt;td&gt;tools&lt;/td&gt;
&lt;td&gt;February 2021&lt;/td&gt;
&lt;td&gt;Tetrate&lt;/td&gt;
&lt;td&gt;95&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/aeraki-framework/aeraki&#34; title=&#34;Aeraki&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Aeraki&lt;/a&gt;
&lt;/td&gt;
&lt;td&gt;Manage any of Istio’s seven layers of load&lt;/td&gt;
&lt;td&gt;Extended multi-protocol support&lt;/td&gt;
&lt;td&gt;extensions&lt;/td&gt;
&lt;td&gt;March 2021&lt;/td&gt;
&lt;td&gt;Tencent&lt;/td&gt;
&lt;td&gt;330&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/mosn/layotto/&#34; title=&#34;Layotto&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Layotto&lt;/a&gt;
&lt;/td&gt;
&lt;td&gt;Cloud native application runtime&lt;/td&gt;
&lt;td&gt;Using as a data plane for Istio&lt;/td&gt;
&lt;td&gt;runtime&lt;/td&gt;
&lt;td&gt;June 2021&lt;/td&gt;
&lt;td&gt;Ant&lt;/td&gt;
&lt;td&gt;393&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/hango-io/hango-gateway&#34; title=&#34;Hango Gateway&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Hango Gateway&lt;/a&gt;
&lt;/td&gt;
&lt;td&gt;API gateways built on Envoy and Istio&lt;/td&gt;
&lt;td&gt;Integrates with Istio&lt;/td&gt;
&lt;td&gt;gateway&lt;/td&gt;
&lt;td&gt;August 2021&lt;/td&gt;
&lt;td&gt;NetEase&lt;/td&gt;
&lt;td&gt;253&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Note: Data is as of January 6, 2022&lt;/p&gt;
&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;
&lt;p&gt;Looking back, we can see that, unlike previous years where users were experimenting, users in 2021 looked for more practical uses for service mesh before implementing them. Their position as the infrastructure of cloud native networks is further strengthened, and more importantly, the service mesh ecosystem is emerging. Looking ahead, in 2022, two technologies to watch are eBPF and WebAssembly(Wasm). We believe that more good examples of service mesh practices will emerge, taking the ecology and standardization a step further.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Introducing Slime and Aeraki in the Evolution of Istio Open-Source Ecosystem</title>
      <link>https://jimmysong.io/en/blog/istio-extensions-slime-and-aeraki/</link>
      <pubDate>Mon, 10 Jan 2022 16:43:27 +0800</pubDate>
      
      <guid>https://jimmysong.io/en/blog/istio-extensions-slime-and-aeraki/</guid>
      <description>
        
        
        &lt;p&gt;It’s been more than &lt;a href=&#34;https://www.tetrate.io/blog/happy-istio-4th-anniversary-retrospect-and-outlook/&#34; title=&#34;four years&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;four years&lt;/a&gt;
 since Istio launched in May 2017, and while the project has had a strong following on GitHub and 10+ releases, its growing open-source ecosystem is still in its infancy.&lt;/p&gt;
&lt;p&gt;Recently added support for &lt;a href=&#34;https://www.tetrate.io/blog/istio-wasm-extensions-and-ecosystem/&#34; title=&#34;WebAssembly extensions&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;WebAssembly extensions&lt;/a&gt;
 has made the most popular open source service mesh more extensible than ever. This table lists the open-source projects in the Istio ecosystem as of November 11, 2021, sorted by open-source date. These projects enhance the Istio service mesh with gateways, extensions, utilities, and more. In this article, I’ll highlight the two new projects in the category of extensions.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;Project&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Value&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Relationship with Istio&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Category&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Launch Date&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Dominant company&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Number of stars&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/envoyproxy/envoy&#34; title=&#34;Envoy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy&lt;/a&gt;
&lt;/td&gt;
&lt;td&gt;Cloud native high-performance edge/middle-service proxy&lt;/td&gt;
&lt;td&gt;The default data plane&lt;/td&gt;
&lt;td&gt;proxy&lt;/td&gt;
&lt;td&gt;September 2016&lt;/td&gt;
&lt;td&gt;Lyft&lt;/td&gt;
&lt;td&gt;18700&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/istio/istio/&#34; title=&#34;Istio&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio&lt;/a&gt;
&lt;/td&gt;
&lt;td&gt;Connection, secure, control, and observation services.&lt;/td&gt;
&lt;td&gt;Control plane&lt;/td&gt;
&lt;td&gt;service mesh&lt;/td&gt;
&lt;td&gt;May 2017&lt;/td&gt;
&lt;td&gt;Google&lt;/td&gt;
&lt;td&gt;29100&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/emissary-ingress/emissary&#34; title=&#34;Emissary Gateway&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Emissary Gateway&lt;/a&gt;
&lt;/td&gt;
&lt;td&gt;Kubernetes native API gateway for microservices, built on Envoy&lt;/td&gt;
&lt;td&gt;Connectable to Istio&lt;/td&gt;
&lt;td&gt;gateway&lt;/td&gt;
&lt;td&gt;February 2018&lt;/td&gt;
&lt;td&gt;Ambassador&lt;/td&gt;
&lt;td&gt;3600&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/apache/apisix&#34; title=&#34;APISIX&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;APISIX&lt;/a&gt;
&lt;/td&gt;
&lt;td&gt;Cloud native API gateways&lt;/td&gt;
&lt;td&gt;It can run as a data plane for Istio or as a gateway on its own&lt;/td&gt;
&lt;td&gt;gateway&lt;/td&gt;
&lt;td&gt;June 2019&lt;/td&gt;
&lt;td&gt;API7&lt;/td&gt;
&lt;td&gt;8100&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/mosn/mosn&#34; title=&#34;MOSN&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;MOSN&lt;/a&gt;
&lt;/td&gt;
&lt;td&gt;Cloud native edge gateways &amp;amp; agents&lt;/td&gt;
&lt;td&gt;Available as Istio data plane&lt;/td&gt;
&lt;td&gt;proxy&lt;/td&gt;
&lt;td&gt;December 2019&lt;/td&gt;
&lt;td&gt;Ant&lt;/td&gt;
&lt;td&gt;3500&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/slime-io/slime&#34; title=&#34;Slime&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Slime&lt;/a&gt;
&lt;/td&gt;
&lt;td&gt;Intelligent service mesh manager based on Istio&lt;/td&gt;
&lt;td&gt;Adding a management plane to Istio&lt;/td&gt;
&lt;td&gt;extensions&lt;/td&gt;
&lt;td&gt;January 2021&lt;/td&gt;
&lt;td&gt;NetEase&lt;/td&gt;
&lt;td&gt;236&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/tetratelabs/getmesh&#34; title=&#34;GetMesh&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GetMesh&lt;/a&gt;
&lt;/td&gt;
&lt;td&gt;Istio integration and command-line management tools&lt;/td&gt;
&lt;td&gt;Utility for Istio multi-version management&lt;/td&gt;
&lt;td&gt;tools&lt;/td&gt;
&lt;td&gt;February 2021&lt;/td&gt;
&lt;td&gt;Tetrate&lt;/td&gt;
&lt;td&gt;95&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/aeraki-framework/aeraki&#34; title=&#34;Aeraki&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Aeraki&lt;/a&gt;
&lt;/td&gt;
&lt;td&gt;Manage any of Istio’s seven layers of load&lt;/td&gt;
&lt;td&gt;Extended multi-protocol support&lt;/td&gt;
&lt;td&gt;extensions&lt;/td&gt;
&lt;td&gt;March 2021&lt;/td&gt;
&lt;td&gt;Tencent&lt;/td&gt;
&lt;td&gt;330&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/mosn/layotto/&#34; title=&#34;Layotto&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Layotto&lt;/a&gt;
&lt;/td&gt;
&lt;td&gt;Cloud native application runtime&lt;/td&gt;
&lt;td&gt;Using as a data plane for Istio&lt;/td&gt;
&lt;td&gt;runtime&lt;/td&gt;
&lt;td&gt;June 2021&lt;/td&gt;
&lt;td&gt;Ant&lt;/td&gt;
&lt;td&gt;393&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/hango-io/hango-gateway&#34; title=&#34;Hango Gateway&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Hango Gateway&lt;/a&gt;
&lt;/td&gt;
&lt;td&gt;API gateways built on Envoy and Istio&lt;/td&gt;
&lt;td&gt;Integrates with Istio&lt;/td&gt;
&lt;td&gt;gateway&lt;/td&gt;
&lt;td&gt;August 2021&lt;/td&gt;
&lt;td&gt;NetEase&lt;/td&gt;
&lt;td&gt;253&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;slime-an-intelligent-service-mesh-manager-for-istio&#34;&gt;&lt;strong&gt;Slime: an intelligent service mesh manager for Istio&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/slime-io/slime&#34; title=&#34;Slime&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Slime&lt;/a&gt;
 is an Istio-based, intelligent mesh manager open-sourced by NetEase’s microservices team. Based on the Kubernetes Operator implementation, Slime can be used as a CRD manager that seamlessly interfaces with Istio without needing any customization or definition of dynamic service governance policies. This achieves automatic and convenient use of Istio and Envoy’s advanced features.&lt;/p&gt;
&lt;p&gt;Slime addresses the following issues:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Implementing higher-level extensions in Istio. For example, extending the HTTP plugin; adaptive traffic limiting based on the resource usage of the service.&lt;/li&gt;
&lt;li&gt;Poor performance arising from Istio sending all the configurations within the mesh to each sidecar proxy.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Slime solves these problems by building an Istio management plane. Its main purpose are&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;to build a pluggable controller to facilitate the extension of new functions.&lt;/li&gt;
&lt;li&gt;to obtain data by listening to the data plane to intelligently generate the configuration for Istio.&lt;/li&gt;
&lt;li&gt;to build a higher-level CRD for the user to configure, which Slime converts into an Istio configuration.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The following diagram shows the flow chart of Istio as an Istio management plane.&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/en/blog/istio-extensions-slime-and-aeraki/slime-arch.png&#34; data-img=&#34;/en/blog/istio-extensions-slime-and-aeraki/slime-arch.png&#34; data-width=&#34;1921&#34; data-height=&#34;1081&#34; alt=&#34;image&#34; data-caption=&#34;Slime architecture&#34;&gt;
    
  
  &lt;figcaption&gt;Slime architecture&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;The specific steps for Slime to manage Istio are as follows.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Slime operator completes the initialization of Slime components in Kubernetes based on the administrator’s configuration.&lt;/li&gt;
&lt;li&gt;Developers create configurations that conform to the Slime CRD specification and apply them to Kubernetes clusters.&lt;/li&gt;
&lt;li&gt;Slime queries the monitoring data of the relevant service stored in Prometheus and converts the Slime CRD into an Istio CRD, in conjunction with the configuration of the adaptive part of the Slime CRD while pushing it to the Global Proxy.&lt;/li&gt;
&lt;li&gt;Istio listens for the creation of Istio CRDs.&lt;/li&gt;
&lt;li&gt;Istio pushes the configuration information of the Sidecar Proxy to the corresponding Sidecar Proxy in the data plane.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The diagram below shows the internal architecture of Slime.&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/en/blog/istio-extensions-slime-and-aeraki/slime-internal.png&#34; data-img=&#34;/en/blog/istio-extensions-slime-and-aeraki/slime-internal.png&#34; data-width=&#34;1921&#34; data-height=&#34;1081&#34; alt=&#34;image&#34; data-caption=&#34;Slime Internal&#34;&gt;
    
  
  &lt;figcaption&gt;Slime Internal&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;We can divide Slime internally into three main components.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;slime-boot&lt;/strong&gt;: operator for deploying Slime modules on Kubernetes.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;slime-controller&lt;/strong&gt;: the core component of Slime that listens to the Slime CRD and converts it to an Istio CRD.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;slime-metric&lt;/strong&gt;: the component used to obtain service metrics information. slime-controller dynamically adjusts service governance rules based on the information it receives.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The following diagram shows the architecture of Slime Adaptive Traffic Limiting.
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/en/blog/istio-extensions-slime-and-aeraki/slime-smart-filter.png&#34; data-img=&#34;/en/blog/istio-extensions-slime-and-aeraki/slime-smart-filter.png&#34; data-width=&#34;1920&#34; data-height=&#34;1081&#34; alt=&#34;image&#34; data-caption=&#34;Slime smart limiter&#34;&gt;
    
  
  &lt;figcaption&gt;Slime smart limiter&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Slime dynamically configures traffic limits by interfacing with the Prometheus metric server to obtain real-time monitoring.&lt;/p&gt;
&lt;p&gt;Slime’s adaptive traffic limitation process has two parts: one that converts SmartLimiter to&lt;a href=&#34;https://istio.io/latest/docs/reference/config/networking/envoy-filter/&#34; title=&#34; EnvoyFilter&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt; EnvoyFilter&lt;/a&gt;
 and the other that monitors the data. Slime also provides an external monitoring data interface (Metric Discovery Server) that allows you to sync custom monitoring metrics to the traffic limiting component via MDS.&lt;/p&gt;
&lt;p&gt;The CRD SmartLimiter created by Slime is used to configure adaptive traffic limiting. Its configuration is close to natural semantics, e.g., if you want to trigger an access limit for Service A with a limit of 30QPS when the CPU exceeds 80%, the corresponding SmartLimiter is defined as follows.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;microservice.netease.com/v1alpha1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;SmartLimiter&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;descriptors&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;action&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;       &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;fill_interval&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;         &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;seconds&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;         &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;quota&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;30/{pod}&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 30 is the quota for this service. If there are three pods, the limit is 10 per pod.&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;       &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;condition&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;{cpu}&amp;gt;0.8&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# Auto-fill the template based on the value of the monitor {cpu}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;aeraki-a-non-invasive-istio-extension-toolset&#34;&gt;&lt;strong&gt;Aeraki: A Non-Invasive Istio Extension Toolset&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/aeraki-framework/aeraki&#34; title=&#34;Aeraki&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Aeraki&lt;/a&gt;
 is a service mesh project open sourced by Tencent Cloud in March 2021. Aeraki provides an end-to-end cloud-native service mesh protocol extension solution that provides Istio with powerful third-party protocol extension capabilities in a non-intrusive way, supporting traffic management for Dubbo, Thrift, Redis, and private protocols in Istio. Aeraki’s architecture is shown in the following diagram.&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/en/blog/istio-extensions-slime-and-aeraki/aeraki-architecture.png&#34; data-img=&#34;/en/blog/istio-extensions-slime-and-aeraki/aeraki-architecture.png&#34; data-width=&#34;1920&#34; data-height=&#34;1081&#34; alt=&#34;image&#34; data-caption=&#34;Aeraki architecture&#34;&gt;
    
  
  &lt;figcaption&gt;Aeraki architecture&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Aeraki architecture, source &lt;a href=&#34;https://istio.io/latest/blog/2021/aeraki/&#34; title=&#34;Istio blog&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio blog&lt;/a&gt;
.&lt;/p&gt;
&lt;p&gt;As seen in the Aeraki architecture diagram, the Aeraki protocol extension solution consists of two components.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Aeraki&lt;/strong&gt;: Aeraki runs as an Istio enhancement component on the control plane, providing user-friendly traffic rule configurations to operations via CRDs. Aeraki translates these traffic rule configurations into Envoy configurations distributed via Istio to sidecar proxies on the data plane. Aeraki also acts as an RDS server providing dynamic routing to the MetaProtocol Proxy on the data plane. The RDS provided by Aeraki differs from Envoy’s RDS in that Envoy RDS primarily offers dynamic routing for the HTTP protocol, while Aeraki RDS is designed to provide dynamic routing capabilities for all L7 protocols developed on the MetaProtocol framework.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MetaProtocol Proxy&lt;/strong&gt;: A generic L7 protocol proxy based on Envoy implementation. MetaProtocol Proxy is an extension of Envoy. It unifies the basic capabilities of service discovery, load balancing, RDS dynamic routing, traffic mirroring, fault injection, local/global traffic limiting, etc. for L7 protocols, which greatly reduces the difficulty of developing third-party protocols on Envoy and allows you to quickly create a third-party protocol plug-in based on MetaProtocol by only implementing the codec interface.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Before the introduction of MetaProtocol Proxy, if you wanted to use Envoy to implement an L7 protocol to implement routing, traffic limiting, telemetry, etc., you needed to write a complete TCP filter, which would have required a lot of work. For most L7 protocols, the required traffic management capabilities are similar, so there is no need to duplicate this work in each L7 filter implementation. The Aeraki project uses a MetaProtocol Proxy to implement these unified capabilities, as shown in the following figure.&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/en/blog/istio-extensions-slime-and-aeraki/metaprotocol-proxy.png&#34; data-img=&#34;/en/blog/istio-extensions-slime-and-aeraki/metaprotocol-proxy.png&#34; data-width=&#34;3000&#34; data-height=&#34;1081&#34; alt=&#34;image&#34; data-caption=&#34;MetaProtocol proxy&#34;&gt;
    
  
  &lt;figcaption&gt;MetaProtocol proxy&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;MetaProtocol proxy, source &lt;a href=&#34;https://istio.io/latest/blog/2021/aeraki/&#34; title=&#34;Istio blog&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio blog&lt;/a&gt;
.&lt;/p&gt;
&lt;p&gt;Based on MetaProtocol Proxy, we only need to implement the codec interface part of the code to write a new L7 protocol Envoy Filter. In addition, without adding a single line of code, Aeraki can provide configuration distribution and RDS dynamic routing configuration for this L7 protocol at the control plane.&lt;/p&gt;
&lt;h3 id=&#34;make-istio-work-for-all-environments-and-workloads&#34;&gt;&lt;strong&gt;Make Istio work for all environments and workloads&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;We have seen that NetEase and Tencent are scaling Istio mainly by building Operator. However, this scaling is not enough for multi-cluster management. We know that much of our current infrastructure is transitioning to cloud native or containerized, which means containers, virtual machines, and other environments co-exist. How do we unify traffic management of these different environments? It is possible to do so using Istio.&lt;/p&gt;
&lt;p&gt;You have to again build a management plane on top of Istio and add an abstraction layer to add CRDs that apply to cluster management, such as cluster traffic configuration, policy configuration, etc. Additionally, you have to deploy a Gateway in each cluster that connects uniformly to an edge proxy that interconnects all the groups.&lt;/p&gt;
&lt;p&gt;To learn more about Tetrate Service Bridge (TSB), which provides this layer of infrastructure, you can go &lt;a href=&#34;https://www.tetrate.io/tetrate-service-bridge/&#34; title=&#34;here&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;here&lt;/a&gt;
. TSB is built on the open source Istio with enhancements, it follows the concept of the above two open source projects, and also builds a management plane to support heterogeneous environments.&lt;/p&gt;
&lt;p&gt;As we can see, the Istio-based projects and the open source environment are booming and companies like Tetrate are doing useful jobs of productizing and making Istio available to all workloads.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>The Debate in the Community About Istio and Service Mesh</title>
      <link>https://jimmysong.io/en/blog/the-debate-in-the-community-about-istio-and-service-mesh/</link>
      <pubDate>Fri, 17 Dec 2021 16:43:27 +0800</pubDate>
      
      <guid>https://jimmysong.io/en/blog/the-debate-in-the-community-about-istio-and-service-mesh/</guid>
      <description>
        
        
        &lt;p&gt;You can use Istio to do &lt;a href=&#34;https://www.tetrate.io/blog/multicluster-management-with-kubernetes-and-istio/&#34; title=&#34;multi-cluster management&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;multi-cluster management&lt;/a&gt;
, &lt;a href=&#34;https://www.tetrate.io/blog/istio-servicemesh-api-gateway/&#34; title=&#34;API Gateway&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;API Gateway&lt;/a&gt;
, and manage applications on Kubernetes or &lt;a href=&#34;https://www.tetrate.io/blog/istio-18-a-virtual-machine-integration-odyssey/&#34; title=&#34;virtual machines&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;virtual machines&lt;/a&gt;
. In my &lt;a href=&#34;https://www.tetrate.io/blog/why-is-service-mesh-a-necessary-part-of-cloud-native/&#34; title=&#34;last blog&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;last blog&lt;/a&gt;
, I talked about how service mesh is an integral part of cloud native applications. However, building infrastructure can be a big deal. There is no shortage of debate in the community about the practicability of service mesh and Istio– here’s a list of common questions and concerns, and how to address them.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Is anyone using Istio in production?&lt;/li&gt;
&lt;li&gt;What is the impact on application performance due to the many resources consumed by injecting sidecar into the pod?&lt;/li&gt;
&lt;li&gt;Istio supports a limited number of protocols; is it scalable?&lt;/li&gt;
&lt;li&gt;Will Istio be manageable? – Or is it too complex, old services too costly to migrate, and the learning curve too steep?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I will answer each of these questions below.&lt;/p&gt;
&lt;h3 id=&#34;istio-is-architecturally-stable-production-ready-and-ecologically-emerging&#34;&gt;Istio is architecturally stable, production-ready, and ecologically emerging&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.tetrate.io/blog/istio-wasm-extensions-and-ecosystem/&#34; title=&#34;Istio 1.12&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio 1.12&lt;/a&gt;
 was just released in November – and has evolved significantly since the explosion of service mesh in 2018 (the year Istio co-founders established Tetrate). Istio has a large community of providers and &lt;a href=&#34;https://istio.io/latest/about/case-studies/&#34; title=&#34;users&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;users&lt;/a&gt;
. The Istio SIG of Cloud Native Community has held eight &lt;a href=&#34;https://cloudnative.to/sig-istio/big-talk/overview.html&#34; title=&#34;Istio Big Talk (Istio 大咖说)&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio Big Talk (Istio 大咖说)&lt;/a&gt;
, with Baidu, Tencent, NetEase, Xiaohongshu(小红书), and Xiaodian Technology(小电科技) sharing their Istio practices. According to &lt;a href=&#34;https://www.cncf.io/wp-content/uploads/2020/11/CNCF_Survey_Report_2020.pdf&#34; title=&#34;CNCF Survey Report 2020&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNCF Survey Report 2020&lt;/a&gt;
, about 50% of the companies surveyed are using a service mesh in production or planning to in the next year, and about half (47%) of organizations using a service mesh in production are using Istio.&lt;/p&gt;
&lt;p&gt;Many companies have developed extensions or plugins for Istio, such as Ant, NetEase, eBay, and Airbnb. Istio’s architecture has been stable since the 1.5 release, and the release cycle is fixed quarterly, with the current project’s main task being Day-2 Operations.&lt;/p&gt;
&lt;p&gt;The Istio community has also hosted various events, with the first IstioCon in March 2021, the Istio Meetup China in Beijing in July, and the Service Mesh Summit 2022 in Shanghai in January 2022.&lt;/p&gt;
&lt;p&gt;So we can say that the Istio architecture is stable and production-ready, and the ecosystem is budding.&lt;/p&gt;
&lt;h3 id=&#34;the-impact-of-service-mesh-on-application-performance&#34;&gt;The impact of service mesh on application performance&lt;/h3&gt;
&lt;p&gt;A service mesh uses iptables to do traffic hijacking by default to be transparent to applications. When the number of services is large, there are a lot of iptables rules that affect network performance. You can use techniques like &lt;a href=&#34;https://cloudnative.to/blog/how-ebpf-streamlines-the-service-mesh/&#34; title=&#34;eBPF&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;eBPF&lt;/a&gt;
 to provide application performance, but the method requires a high version of the operating system kernel, which few enterprises can achieve.&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/en/blog/the-debate-in-the-community-about-istio-and-service-mesh/008i3skNly1gxgyfcfm5oj30sg0djmxt.jpg&#34; data-img=&#34;/en/blog/the-debate-in-the-community-about-istio-and-service-mesh/008i3skNly1gxgyfcfm5oj30sg0djmxt.jpg&#34; data-width=&#34;1024&#34; data-height=&#34;487&#34; alt=&#34;image&#34; data-caption=&#34;Istio DNS&#34;&gt;
    
  
  &lt;figcaption&gt;Istio DNS&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;In the early days, Istio distributed the routing information of all services in the mesh to all proxy sidecars, which caused &lt;a href=&#34;https://istio.io/latest/docs/reference/config/networking/sidecar/&#34; title=&#34;sidecar&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;sidecar&lt;/a&gt;
s to take up a lot of resources. &lt;a href=&#34;https://github.com/aeraki-framework/aeraki&#34; title=&#34;Aeraki&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Aeraki&lt;/a&gt;
 and &lt;a href=&#34;https://github.com/slime-io/slime&#34; title=&#34;Slime&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Slime&lt;/a&gt;
 can achieve configuration lazy loading. We will introduce these two open-source projects in the Istio open-source ecosystem.&lt;/p&gt;
&lt;p&gt;Finally, there is a problem related to Sidecar proxy operation and maintenance: upgrading all Envoy proxies while ensuring constant traffic. A solution is using the &lt;a href=&#34;https://xie.infoq.cn/article/23ae6d3f0d0260b4797a708a0&#34; title=&#34;SidecarSet&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SidecarSet&lt;/a&gt;
 resource in the open-source project &lt;a href=&#34;https://github.com/openkruise/kruise&#34; title=&#34;OpenKruise&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenKruise&lt;/a&gt;
.&lt;/p&gt;
&lt;p&gt;The resource consumption and network latency associated with the introduction of Sidecar are also within reasonable limits, as you can see from the &lt;a href=&#34;https://istio.io/latest/blog/2019/performance-best-practices/&#34; title=&#34;service mesh benchmark performance tests&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;service mesh benchmark performance tests&lt;/a&gt;
.&lt;/p&gt;
&lt;h3 id=&#34;extending-the-istio-service-mesh&#34;&gt;Extending the Istio service mesh&lt;/h3&gt;
&lt;p&gt;The next question is about extending the Istio service mesh. The current solution given by the Istio community is to use &lt;a href=&#34;https://www.tetrate.io/blog/istio-wasm-extensions-and-ecosystem/&#34; title=&#34;WebAssembly&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;WebAssembly&lt;/a&gt;
, an extension that is still relatively little used in production by now and has performance concerns. Most of the answers I’ve observed are CRDs that build a service mesh management plane based on Istio.&lt;/p&gt;
&lt;p&gt;Also, making Istio support heterogeneous environments for all workloads, such as virtual machines and containers, is in strong demand for end-users. It allows them to migrate applications from traditional loads to cloud native easily. Finally, hybrid cloud traffic management for multiple clusters and meshes is a more advanced requirement.&lt;/p&gt;
&lt;h3 id=&#34;steep-learning-curve&#34;&gt;Steep learning curve&lt;/h3&gt;
&lt;p&gt;Many people complain that Istio has too little learning material. Istio has been open source for four years, and there are a lot of learning resources now:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://istio.io/&#34; title=&#34;Istio Documentation&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio Documentation&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://events.istio.io/istiocon-2021/&#34; title=&#34;IstioCon 2021&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;IstioCon 2021&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/tetratelabs/istio-weekly&#34; title=&#34;Istio Big Talk/Istio Weekly&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio Big Talk/Istio Weekly&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://academy.tetrate.io/courses/istio-fundamentals&#34; title=&#34;Istio Fundamentals Course&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio Fundamentals Course&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://academy.tetrate.io/courses/certified-istio-administrator&#34; title=&#34;Certified Istio Administrator&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Certified Istio Administrator&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Yes, Istio is complex, but it’s been getting more and more manageable with every release. In my next blog, I will introduce you to two open source projects that extend Istio and give you some insight into what’s going on in the Istio community.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Service Mesh - An Integral Part of Cloud-Native Applications</title>
      <link>https://jimmysong.io/en/blog/service-mesh-an-integral-part-of-cloud-native-apps/</link>
      <pubDate>Sun, 12 Dec 2021 16:43:27 +0800</pubDate>
      
      <guid>https://jimmysong.io/en/blog/service-mesh-an-integral-part-of-cloud-native-apps/</guid>
      <description>
        
        
        &lt;p&gt;If you don’t know what Istio is, you can read my previous articles below:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.tetrate.io/blog/what-is-istio-and-why-does-kubernetes-need-it/&#34; title=&#34;What Is Istio and Why Does Kubernetes Need it?&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;What Is Istio and Why Does Kubernetes Need it?&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.tetrate.io/blog/why-do-you-need-istio-when-you-already-have-kubernetes/&#34; title=&#34;Why do you need Istio when you already have Kubernetes?&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Why do you need Istio when you already have Kubernetes?&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This article will explore the relationship between service mesh and cloud native.&lt;/p&gt;
&lt;h3 id=&#34;service-mesh--the-product-of-the-container-orchestration-war&#34;&gt;Service mesh – the product of the container orchestration war&lt;/h3&gt;
&lt;p&gt;If you’ve been following the cloud-native space since its early days, you’ll remember the container orchestration wars of 2015 to 2017. Kubernetes won the container wars in 2017, the idea of microservices had taken hold, and the trend toward containerization was unstoppable. Kubernetes architecture matured and slowly became boring, and service mesh technologies, represented by Linkerd and Istio, entered the CNCF-defined cloud-native critical technologies on the horizon.&lt;/p&gt;
&lt;p&gt;Kubernetes was designed with the concept of cloud-native in mind. A critical idea in cloud-native is the architectural design of microservices. When a single application is split into microservices, how can microservices be managed to ensure the SLA of the service as the number of services increases? The service mesh was born to solve this problem at the architectural level, free programmers’ creativity, and avoid tedious service discovery, monitoring, distributed tracing, and other matters.&lt;/p&gt;
&lt;p&gt;The service mesh takes the standard functionality of microservices down to the infrastructure layer, allowing developers to focus more on business logic and thus speed up service delivery, which is consistent with the whole idea of cloud-native. You no longer need to integrate bulky SDKs in your application, develop and maintain SDKs for different languages, and just use the service mesh for Day 2 operations after the application is deployed.&lt;/p&gt;
&lt;p&gt;The service mesh is regarded as the next generation of microservices. In the diagram, we can see that many of the concerns of microservices overlap with the functionality of Kubernetes. Kubernetes focuses on the application lifecycle, managing resources and deployments with little control over services. The service mesh fills this gap. The service mesh can connect, control, observe and protect microservices.&lt;/p&gt;
&lt;h3 id=&#34;kubernetes-vs-xds-vs-istio&#34;&gt;&lt;strong&gt;Kubernetes vs. xDS vs. Istio&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;This diagram shows the layered architecture of Kubernetes and Istio.&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/en/blog/service-mesh-an-integral-part-of-cloud-native-apps/008i3skNly1gxgxss9mamj30n90d73zs.jpg&#34; data-img=&#34;/en/blog/service-mesh-an-integral-part-of-cloud-native-apps/008i3skNly1gxgxss9mamj30n90d73zs.jpg&#34; data-width=&#34;837&#34; data-height=&#34;475&#34; alt=&#34;image&#34; data-caption=&#34;Kubernetes vs xDS vs Istio&#34;&gt;
    
  
  &lt;figcaption&gt;Kubernetes vs xDS vs Istio&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;The diagram indicates that the kube-proxy settings are global and cannot be controlled at a granular level for each service. All Kubernetes can do is topology-aware routing, routing traffic closer to the Pod, and setting network policies in and out of the Pod.&lt;/p&gt;
&lt;p&gt;In contrast, the service mesh takes traffic control out of the service layer in Kubernetes through sidecar proxies, injects proxies into each Pod, and manipulates these distributed proxies through a control plane. It allows for more excellent resiliency.&lt;/p&gt;
&lt;p&gt;Kube-proxy implements traffic load balancing between multiple pod instances of a Kubernetes service. But how do you finely control the traffic between these services — such as dividing the traffic by percentage to different application versions (which are all part of the same service, but on other deployments), or doing canary releases and blue-green releases?&lt;/p&gt;
&lt;p&gt;The Kubernetes community gives a way to do canary releases using Deployment, assigning different pods to deployed services by modifying the pod’s label.&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/en/blog/service-mesh-an-integral-part-of-cloud-native-apps/008i3skNly1gxgxsswmoij30sg0kl76r.jpg&#34; data-img=&#34;/en/blog/service-mesh-an-integral-part-of-cloud-native-apps/008i3skNly1gxgxsswmoij30sg0kl76r.jpg&#34; data-width=&#34;1024&#34; data-height=&#34;741&#34; alt=&#34;image&#34; data-caption=&#34;Envoy Architecture&#34;&gt;
    
  
  &lt;figcaption&gt;Envoy Architecture&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Currently, the most popular open-source implementation of service mesh in the world is Istio. From the &lt;a href=&#34;https://www.cncf.io/wp-content/uploads/2020/11/CNCF_Survey_Report_2020.pdf&#34; title=&#34;CNCF Survey Report 2020&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNCF Survey Report 2020&lt;/a&gt;
, we know that Istio is the most used service mesh in production today. Many companies have built their service mesh based on Istio, such as Ant, Airbnb, eBay, NetEase, Tencent, etc.&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/en/blog/service-mesh-an-integral-part-of-cloud-native-apps/008i3skNly1gxgxstgg4qj30sg0gg0ts.jpg&#34; data-img=&#34;/en/blog/service-mesh-an-integral-part-of-cloud-native-apps/008i3skNly1gxgxstgg4qj30sg0gg0ts.jpg&#34; data-width=&#34;1024&#34; data-height=&#34;592&#34; alt=&#34;image&#34; data-caption=&#34;CNCF Survey Report 2020&#34;&gt;
    
  
  &lt;figcaption&gt;CNCF Survey Report 2020&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Figure from &lt;a href=&#34;https://www.cncf.io/wp-content/uploads/2020/11/CNCF_Survey_Report_2020.pdf&#34; title=&#34;CNCF Survey Report 2020&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNCF Survey Report 2020&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;Istio is developed based on Envoy, which has been used by default as its distributed proxy since the first day it was open-sourced. Envoy pioneered the creation of the xDS protocol for distributed gateway configuration, greatly simplifying the configuration of large-scale distributed networks. Ant Group open source MOSN also supported xDS In 2019. Envoy was also one of the first projects to graduate from CNCF, tested by large-scale production applications.&lt;/p&gt;
&lt;h3 id=&#34;service-mesh--the-cloud-native-networking-infrastructure&#34;&gt;Service mesh – the cloud-native networking infrastructure&lt;/h3&gt;
&lt;p&gt;With the above comparison between Kubernetes and service mesh in mind, we can see the place of service mesh in the cloud-native application architecture. That is, building a cloud-native network infrastructure specifically provides:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Traffic management: controlling the flow of traffic and API calls between services, making calls more reliable, and enhancing network robustness in different environments.&lt;/li&gt;
&lt;li&gt;Observability: understanding the dependencies between services and the nature and flow of traffic between them provides the ability to identify problems quickly.&lt;/li&gt;
&lt;li&gt;Policy enforcement: controlling access policies between services by configuring the mesh rather than by changing the code.&lt;/li&gt;
&lt;li&gt;Service Identification and Security: providing service identifiability and security protection in the mesh.&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Using Istio Service Mesh as API Gateway</title>
      <link>https://jimmysong.io/en/blog/istio-servicemesh-api-gateway/</link>
      <pubDate>Fri, 06 Aug 2021 10:22:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/en/blog/istio-servicemesh-api-gateway/</guid>
      <description>
        
        
        &lt;p&gt;API gateways have been around for a long time as the entry point for clients to access the back-end, mainly to manage “north-south” traffic, In recent years, service mesh architectures have become popular, mainly for managing internal systems,(i.e. “east-west” traffic), while a service mesh like Istio also has built-in gateways that bring traffic inside and outside the system under unified control. This often creates confusion for first-time users of Istio. What is the relationship between the service mesh and the API gateway? How does Istio’s gateway work? What are the ways to expose the services in the Istio mesh? This article gives you the answer.&lt;/p&gt;
&lt;h2 id=&#34;key-insights&#34;&gt;Key Insights&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;The service mesh was originally created to solve the problem of managing internal traffic for distributed systems, but API gateways existed long before it.&lt;/li&gt;
&lt;li&gt;While the Gateway is built into Istio, you can still use a custom Ingress Controller to proxy external traffic.&lt;/li&gt;
&lt;li&gt;API gateways and service mesh are converging.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;how-do-i-expose-services-in-the-istio-mesh&#34;&gt;How do I expose services in the Istio mesh?&lt;/h2&gt;
&lt;p&gt;The following diagram shows four approaches to expose services in the Istio mesh using Istio Gateway, Kubernetes Ingress, API Gateway, and NodePort/LB.&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/en/blog/istio-servicemesh-api-gateway/access-cluster.svg&#34; data-img=&#34;/en/blog/istio-servicemesh-api-gateway/access-cluster.svg&#34; alt=&#34;image&#34; data-caption=&#34;Exposing services through Istio Ingress Gateway&#34;&gt;
    
  
  &lt;figcaption&gt;Exposing services through Istio Ingress Gateway&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;The Istio mesh is shaded, and the traffic in the mesh is internal (east-west) traffic, while the traffic from clients accessing services within the Kubernetes cluster is external (north-south) traffic.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;Approach&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Controller&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Features&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;NodePort/LoadBalancer&lt;/td&gt;
&lt;td&gt;Kubernetes&lt;/td&gt;
&lt;td&gt;Load balancing&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Kubernetes Ingress&lt;/td&gt;
&lt;td&gt;Ingress controller&lt;/td&gt;
&lt;td&gt;Load balancing, TLS, virtual host, traffic routing&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Istio Gateway&lt;/td&gt;
&lt;td&gt;Istio&lt;/td&gt;
&lt;td&gt;Load balancing, TLS, virtual host, advanced traffic routing, other advanced Istio features&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;API Gateway&lt;/td&gt;
&lt;td&gt;API Gateway&lt;/td&gt;
&lt;td&gt;Load balancing, TLS, virtual host, advanced traffic routing, API lifecycle management, billing, rate limiting, policy enforcement, data aggregation&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Since NodePort/LoadBalancer is a basic way to expose services built into Kubernetes, this article will not discuss that option. Each of the other three approaches will be described below.&lt;/p&gt;
&lt;h2 id=&#34;using-kubernetes-ingress-to-expose-traffic&#34;&gt;Using Kubernetes Ingress to expose traffic&lt;/h2&gt;
&lt;p&gt;We all know that clients of a Kubernetes cluster cannot directly access the IP address of a pod because the pod is in a network plane built into Kubernetes. We can expose services inside Kubernetes outside the cluster using NodePort or Load Balancer Kubernetes service type. To support virtual hosting, hiding and saving IP addresses, you can use Ingress resources to expose services in Kubernetes.&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/en/blog/istio-servicemesh-api-gateway/ingress.svg&#34; data-img=&#34;/en/blog/istio-servicemesh-api-gateway/ingress.svg&#34; alt=&#34;image&#34; data-caption=&#34;Kubernetes Ingress to expose services&#34;&gt;
    
  
  &lt;figcaption&gt;Kubernetes Ingress to expose services&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Ingress is a Kubernetes resource that controls the behavior of an ingress controller that does the traffic touring, which is the equivalent of a load-balanced directional proxy server such as Nginx, Apache, etc., which also includes rule definitions, i.e., routing information for URLs, which is provided by the &lt;a href=&#34;https://kubernetes.io/docs/concepts/services-networking/ingress/#ingress-controllers&#34; title=&#34;Ingress controller&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Ingress controller&lt;/a&gt;
.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;networking.k8s.io/v1beta1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Ingress&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;annotations&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kubernetes.io/ingress.class&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;istio&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ingress&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;rules&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;host&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;httpbin.example.com&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;paths&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/status/*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;backend&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;serviceName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;httpbin&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;servicePort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;8000&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The &lt;em&gt;kubernetes.io/ingress.class: istio&lt;/em&gt; annotation in the example above indicates that the Ingress uses the Istio Ingress Controller which in fact uses Envoy proxy.&lt;/p&gt;
&lt;h2 id=&#34;using-istio-gateway-to-expose-services&#34;&gt;Using Istio Gateway to expose services&lt;/h2&gt;
&lt;p&gt;Istio is a popular service mesh implementation that has evolved from Kubernetes that implements some features that Kubernetes doesn’t. (See &lt;a href=&#34;https://www.tetrate.io/blog/what-is-istio-and-why-does-kubernetes-need-it/&#34; title=&#34;What is Istio and why does Kubernetes need Istio?&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;What is Istio and why does Kubernetes need Istio?&lt;/a&gt;
) It makes traffic management transparent to the application, moving this functionality from the application to the platform layer and becoming a cloud-native infrastructure.&lt;/p&gt;
&lt;p&gt;Istio used Kubernetes Ingress as the traffic portal in versions prior to Istio 0.8, where Envoy was used as the Ingress Controller. From Istio 0.8 and later, Istio created the Gateway object. Gateway and VirtualService are used to represent the configuration model of Istio Ingress, and the default implementation of Istio Ingress uses the same Envoy proxy. In this way, the Istio control plane controls both the ingress gateway and the internal sidecar proxy with a consistent configuration model. These configurations include routing rules, policy enforcement, telemetry, and other service control functions.&lt;/p&gt;
&lt;p&gt;The Istio Gateway resources function similarly to the Kubernetes Ingress in that it is responsible for north-south traffic to and from the cluster. The Istio Gateway acts as a load balancer to carry connections to and from the edge of the service mesh. The specification describes a set of open ports and the protocols used by those ports, as well as the SNI configuration for load balancing, etc.&lt;/p&gt;
&lt;p&gt;The Istio Gateway resource itself can only be configured for L4 through L6, such as exposed ports, TLS settings, etc.; however, the Gateway can be bound to a VirtualService, where routing rules can be configured on L7, such as versioned traffic routing, fault injection, HTTP redirects, HTTP rewrites, and all other routing rules supported within the mesh.&lt;/p&gt;
&lt;p&gt;Below is an example of a Gateway binding to a VirtualService. The pod with the “istio: ingressgateway” label will act as the Ingress controller and route HTTP traffic to port 80 of the httpbin.example.com virtual host. The biggest difference between this and using Kubernetes Ingress is that it requires us to manually bind the VirtualService to the Gateway and specify the pod where the Gateway is located. This configuration is equivalent to opening up an entry point to Kubernetes for external access.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;networking.istio.io/v1alpha3&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Gateway&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;httpbin-gateway&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;selector&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;istio&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ingressgateway&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;servers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;number&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;80&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;protocol&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;HTTP&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;hosts&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;s2&#34;&gt;&amp;#34;httpbin.example.com&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The VirtualService below is bound to the gateway above via &lt;em&gt;gateways&lt;/em&gt; to accept traffic from that gateway.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;networking.istio.io/v1alpha3&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;VirtualService&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;httpbin&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;hosts&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;s2&#34;&gt;&amp;#34;httpbin.example.com&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;gateways&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;httpbin-gateway&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;match&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;uri&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;prefix&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/status&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;route&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;destination&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;number&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;8000&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;host&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;httpbin&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;using-an-api-gateway&#34;&gt;Using an API Gateway&lt;/h2&gt;
&lt;p&gt;API gateways are API management tools that sit between the client and the back-end service and are widely used in microservices as a way to separate the client interface from the back-end implementation. When a client makes a request, the API gateway breaks it down into multiple requests, then routes them to the correct location, generates a response, and keeps track of everything.&lt;/p&gt;
&lt;p&gt;The API Gateway is a special type of service in the microservices architecture that serves as the entry point for all microservices and is responsible for performing routing requests, protocol conversions, aggregating data, authentication, rate limiting, circuit breaking, and more. Most enterprise APIs are deployed through API Gateways, which typically handle common tasks across API service systems, such as TLS termination, authentication and authorization, rate limiting, and statistical information.&lt;/p&gt;
&lt;p&gt;There can be one or more API Gateways in the mesh. The responsibilities of the API Gateway are&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Request routing and version control&lt;/li&gt;
&lt;li&gt;Facilitating the transition of monolithic applications to microservices&lt;/li&gt;
&lt;li&gt;Permission authentication&lt;/li&gt;
&lt;li&gt;Data aggregation: monitoring and billing&lt;/li&gt;
&lt;li&gt;Protocol conversion&lt;/li&gt;
&lt;li&gt;Messaging and caching&lt;/li&gt;
&lt;li&gt;Security and alerting&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Many of the above basic functions such as routing and permission authentication can also be achieved through Istio Gateway, but some mature API gateways may be more advantageous in terms of feature richness and scalability.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The introduction of API Gateway requires consideration of the deployment, operation and maintenance, load balancing, and other scenarios of API Gateway itself, which increases the complexity of back-end services.&lt;/li&gt;
&lt;li&gt;An API Gateway carries a large number of interface adaptations, which makes it difficult to maintain.&lt;/li&gt;
&lt;li&gt;For some scenarios, the addition of a hop may lead to a reduction in performance.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Currently, some API Gateway imitations are building their own service mesh by deploying them in the sidecar.&lt;/p&gt;
&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;
&lt;p&gt;In the Istio mesh, you can use a variety of Kubernetes Ingress Controllers to act as entry gateways, but of course, you can also use Istio’s built-in Istio Gateway directly, for policy control, traffic management, and usage monitoring. The advantage of this is that the gateway can be managed directly through Istio’s control plane, without the need for additional tools. But for functions such as API statement cycle management, complex billing, protocol conversion, and authentication, a traditional API gateway may be a better fit for you. So, you can choose according to your needs, or you can use a combination.&lt;/p&gt;
&lt;p&gt;Some traditional reverse proxies are also moving towards Service Mesh, such as Nginx with Nginx Service Mesh and Traefik with Traefik Mesh, and some API gateway products are also moving towards Service Mesh, such as Kong with Kuma, and in the future, we will see more convergence of API gateways, reverse proxies, and service meshes.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Multicluster Management With Kubernetes and Istio</title>
      <link>https://jimmysong.io/en/blog/multicluster-management-with-kubernetes-and-istio/</link>
      <pubDate>Mon, 12 Jul 2021 22:22:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/en/blog/multicluster-management-with-kubernetes-and-istio/</guid>
      <description>
        
        
        &lt;p&gt;Do you have multiple Kubernetes clusters and a service mesh? Do your virtual machines and services in a Kubernetes cluster need to interact? This article will take you through the process and considerations of building a hybrid cloud using Kubernetes and an Istio Service Mesh. Together, Kubernetes and Istio can be used to bring hybrid workloads into a mesh and achieve interoperability for multicluster. But another layer of infrastructure — a management plane — is helpful for managing multicluster or multimesh deployments.&lt;/p&gt;
&lt;h2 id=&#34;kubernetes&#34;&gt;Kubernetes&lt;/h2&gt;
&lt;p&gt;Using Kubernetes enables rapid deployment of a distributed environment that enables cloud interoperability and unifies the control plane on the cloud. It also provides resource objects, such as Service, Ingress and &lt;a href=&#34;https://kubernetes.io/blog/2021/04/22/evolving-kubernetes-networking-with-the-gateway-api/&#34; title=&#34;Gateway&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Gateway&lt;/a&gt;
, to handle application traffic. The Kubernetes API Server communicates with the kube-proxy component on each node in the cluster, creates iptables rules for the node, and forwards requests to other pods.&lt;/p&gt;
&lt;p&gt;Assuming that a client now wants to access a service in Kubernetes, the request is first sent to the Ingress/Gateway, then forwarded to the backend service (Service A in the diagram below) based on the routing configuration in the Ingress/Gateway. Then Service A polls an instance of Service B for the traffic requested by Service B. Lastly, the traffic requested by Service A for Service B is polled forward to Service B’s instance.&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/en/blog/multicluster-management-with-kubernetes-and-istio/008i3skNly1gsgg6a11l1j31lu0u042s.jpg&#34; data-img=&#34;/en/blog/multicluster-management-with-kubernetes-and-istio/008i3skNly1gsgg6a11l1j31lu0u042s.jpg&#34; data-width=&#34;2082&#34; data-height=&#34;1080&#34; alt=&#34;image&#34; data-caption=&#34;Kubernetes&#34;&gt;
    
  
  &lt;figcaption&gt;Kubernetes&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;kubernetes-multicluster&#34;&gt;Kubernetes Multicluster&lt;/h2&gt;
&lt;p&gt;The most common usage scenarios for multicluster management include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;service traffic load balancing&lt;/li&gt;
&lt;li&gt;isolating development and production environments&lt;/li&gt;
&lt;li&gt;decoupling data processing and data storage&lt;/li&gt;
&lt;li&gt;cross-cloud backup and disaster recovery&lt;/li&gt;
&lt;li&gt;flexible allocation of compute resources&lt;/li&gt;
&lt;li&gt;low-latency access to services across regions&lt;/li&gt;
&lt;li&gt;avoiding vendor lock-in&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There are often multiple Kubernetes clusters within an enterprise; and the &lt;a href=&#34;https://github.com/kubernetes-sigs/kubefed&#34; title=&#34;KubeFed&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;KubeFed&lt;/a&gt;
 implementation of Kubernetes cluster federation developed by &lt;a href=&#34;https://github.com/kubernetes/community/blob/master/sig-multicluster/README.md&#34; title=&#34;Multicluster SIG&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Multicluster SIG&lt;/a&gt;
 enables multicluster management capabilities, which allows all Kubernetes clusters to be managed through the same interface.&lt;/p&gt;
&lt;p&gt;There are several general issues that need to be addressed when using cluster federation:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Configuring which clusters need to be federated&lt;/li&gt;
&lt;li&gt;API resources need to be propagated across the clusters&lt;/li&gt;
&lt;li&gt;Configuring how API resources are distributed to different clusters&lt;/li&gt;
&lt;li&gt;Registering DNS records in clusters to enable service discovery across clusters&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The following is a multicluster architecture for &lt;a href=&#34;https://kubesphere.io/&#34; title=&#34;KubeSphere&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;KubeSphere&lt;/a&gt;
 — one of the most commonly used Kubernetes multicluster management architectures — where the Host Cluster serves as the control plane with two member clusters, West and East.&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/en/blog/multicluster-management-with-kubernetes-and-istio/008i3skNly1gsgg7a2ojvj31aa0u0491.jpg&#34; data-img=&#34;/en/blog/multicluster-management-with-kubernetes-and-istio/008i3skNly1gsgg7a2ojvj31aa0u0491.jpg&#34; data-width=&#34;1666&#34; data-height=&#34;1080&#34; alt=&#34;image&#34; data-caption=&#34;Multicluster&#34;&gt;
    
  
  &lt;figcaption&gt;Multicluster&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;The Host Cluster needs to be able to access the API Server of the Member Cluster, but the network connectivity between Member Clusters is not required. The Host Cluster is independent of the Member Cluster it manages and the Member Cluster is not aware of the existence of the Host Cluster. The advantage of this is that when the control plane fails, the Member Cluster will not be affected and the deployed load can still operate normally without being affected.&lt;/p&gt;
&lt;p&gt;The Host Cluster also assumes the role of API portal, and the Host Cluster forwards the resource requests to the Member Cluster — which is convenient for aggregation and also facilitates unified authority authentication. We see that there is a Federation Control Plane in the Host Cluster, where the Push Reconciler propagates the identity, role, and role binding from the Federation Cluster to all Member Clusters.&lt;/p&gt;
&lt;h2 id=&#34;istio-service-mesh&#34;&gt;Istio Service Mesh&lt;/h2&gt;
&lt;p&gt;Consider using the Istio service mesh when we have multilingual, multiversion microservices running in Kubernetes and need finer-grained canary publishing and unified security policy management for inter-service observability. Istio enables intelligent application-aware load balancing from the application layer to other Service Mesh-enabled services in the cluster, by transparently intercepting all traffic to and from the application using IPTables, and bypassing the primary kube-proxy load balancing. The Istio control plane communicates with the Kubernetes API Server to obtain information about all registered services in the cluster.&lt;/p&gt;
&lt;p&gt;The following diagram illustrates the basics of Istio, where all nodes belong to the same Kubernetes cluster.&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/en/blog/multicluster-management-with-kubernetes-and-istio/008i3skNly1gsgg6sdrk2j32v60u0qbb.jpg&#34; data-img=&#34;/en/blog/multicluster-management-with-kubernetes-and-istio/008i3skNly1gsgg6sdrk2j32v60u0qbb.jpg&#34; data-width=&#34;3714&#34; data-height=&#34;1080&#34; alt=&#34;image&#34; data-caption=&#34;Istio Service Mesh&#34;&gt;
    
  
  &lt;figcaption&gt;Istio Service Mesh&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;You may end up with at least a few Kubernetes clusters, each hosting microservices. Multiple &lt;a href=&#34;https://istio.io/latest/docs/setup/install/multicluster/&#34; title=&#34;deployment models&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;deployment models&lt;/a&gt;
 exist for Istio’s multicluster deployments — depending on network isolation, primary and backup — which can be specified by declaration when deploying using Istio Operator. Communication between these microservices in a cluster can be enhanced by a service mesh. Within the cluster, Istio provides common communication patterns to improve resiliency, security and observability.&lt;/p&gt;
&lt;p&gt;All of the above is about application load management on Kubernetes, but for legacy applications on virtual machines: how can they be managed in the same plane? Istio supports applications on virtual machines, so why do we need a management plane?&lt;/p&gt;
&lt;h2 id=&#34;management-plane&#34;&gt;Management Plane&lt;/h2&gt;
&lt;p&gt;To manage gateways, traffic and security groupings, and apply them to different clusters and namespaces, you’ll need to add another layer of abstraction on top of Istio: a management plane. The diagram below shows the multitenant model of Tetrate Service Bridge (TSB). TSB uses Next Generation Access Control (NGAC) — a fine-grained authorization framework — to manage user access and also facilitate the construction of a zero-trust network.&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/en/blog/multicluster-management-with-kubernetes-and-istio/008i3skNly1gsgg8ndcajj31il0u00z9.jpg&#34; data-img=&#34;/en/blog/multicluster-management-with-kubernetes-and-istio/008i3skNly1gsgg8ndcajj31il0u00z9.jpg&#34; data-width=&#34;1965&#34; data-height=&#34;1080&#34; alt=&#34;image&#34; data-caption=&#34;Management Plane&#34;&gt;
    
  
  &lt;figcaption&gt;Management Plane&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Istio provides workload identification, protected by strong mTLS encryption. This zero-trust model is better than trusting workloads based on topology information, such as source IP. A common control plane for multicluster management is built on top of Istio. Then a management plane is added to manage multiple clusters — providing multitenancy, management configuration, observability, and more.&lt;/p&gt;
&lt;p&gt;The diagram below shows the architecture of Tetrate Service Bridge.&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/en/blog/multicluster-management-with-kubernetes-and-istio/008i3skNly1gsgg951mknj314g0u0dnf.jpg&#34; data-img=&#34;/en/blog/multicluster-management-with-kubernetes-and-istio/008i3skNly1gsgg951mknj314g0u0dnf.jpg&#34; data-width=&#34;1456&#34; data-height=&#34;1080&#34; alt=&#34;image&#34; data-caption=&#34;Tetrate Service Bridge&#34;&gt;
    
  
  &lt;figcaption&gt;Tetrate Service Bridge&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;
&lt;p&gt;Interoperability of heterogeneous clusters is achieved with Kubernetes. Istio brings containerized and virtual machine loads into a single control plane, to unify traffic, security and observability within the clusters. However, as the number of clusters, network environments and user permissions become more complex, there is a need to build another management plane above Istio’s control plane (for example, &lt;a href=&#34;https://www.tetrate.io/tetrate-service-bridge/&#34; title=&#34;Tetrate Service Bridge&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tetrate Service Bridge&lt;/a&gt;
) for hybrid cloud management.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>How to Debug Microservices in Kubernetes With Proxy, Sidecar or Service Mesh?</title>
      <link>https://jimmysong.io/en/blog/how-to-debug-microservices-in-kubernetes-with-proxy-sidecar-or-service-mesh/</link>
      <pubDate>Mon, 05 Jul 2021 22:22:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/en/blog/how-to-debug-microservices-in-kubernetes-with-proxy-sidecar-or-service-mesh/</guid>
      <description>
        
        
        &lt;p&gt;Kubernetes is arguably the best environment for running microservices so far, but the experience of debugging microservices in a Kubernetes environment may not be as user-friendly. This article will show you how to debug microservices in Kubernetes, introduce common tools, and explain how the introduction of Istio impacts debugging microservices.&lt;/p&gt;
&lt;h2 id=&#34;debugging-microservices-is-vastly-different-from-traditional-monolithic-applications&#34;&gt;Debugging microservices is vastly different from traditional monolithic applications&lt;/h2&gt;
&lt;p&gt;The debugging of microservices has been a long-standing problem for software developers. This challenge does not exist in traditional monolithic applications because developers can leverage the debugger in IDEs to add breakpoints, modify environment variables, single-step execution, etc. for their applications, all of which provide great help in software debugging. With the popularity of Kubernetes, the debugging of microservices becomes a thorny issue, where the following issues are more complicated than the debugging of traditional monolithic applications.&lt;/p&gt;
&lt;h3 id=&#34;multiple-dependencies&#34;&gt;Multiple dependencies&lt;/h3&gt;
&lt;p&gt;A microservice often depends on multiple other microservices, some shared volumes across multiple microservices, and authorizations based on service accounts. When debugging a microservice, how do you deploy other dependent services to quickly build a latest set of staging environments?&lt;/p&gt;
&lt;h3 id=&#34;access-from-a-local-machine&#34;&gt;Access from a local machine&lt;/h3&gt;
&lt;p&gt;When microservices are running on a developer’s local computer, there is usually no direct access to the services in a Kubernetes cluster. How can you debug microservices deployed in a Kubernetes cluster as if they were local services?&lt;/p&gt;
&lt;h3 id=&#34;slow-development-loop&#34;&gt;Slow development loop&lt;/h3&gt;
&lt;p&gt;Usually, it takes a long process to update the code and build it into an image before pushing it to the cluster. How do you speed up the development cycle? Let’s look at the tools that address those challenges.&lt;/p&gt;
&lt;h2 id=&#34;tools&#34;&gt;Tools&lt;/h2&gt;
&lt;p&gt;The main solutions for debugging microservices in Kubernetes are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Proxy: by building a VPN, deploying a proxy in the Kubernetes cluster, and adding local debug endpoints to make the services in Kubernetes directly accessible to local applications, your architecture will look like [ local service ] &amp;lt;-&amp;gt; [ proxy ] &amp;lt;-&amp;gt; [ app in Kubernetes ].&lt;/li&gt;
&lt;li&gt;Sidecar: Inject a sidecar into the pod of the microservice to be debugged to intercept all traffic to and from the service, so that the service can be tracked and monitored, and the service can also be debugged in this sidecar.&lt;/li&gt;
&lt;li&gt;Service Mesh: To get an overall picture of the application, inject sidecars into all microservices so that you can get a dashboard that monitors global status.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Here are three typical open source projects that implement the above solutions, each of which can help you debug microservices from a different perspective. You can apply them at different stages of software development and they can be said to be complementary to each other.&lt;/p&gt;
&lt;h3 id=&#34;proxy--debugging-microservices-with-telepresence&#34;&gt;Proxy – debugging microservices with Telepresence&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.telepresence.io/&#34; title=&#34;Telepresence&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Telepresence&lt;/a&gt;
 is essentially a local proxy that proxies data volumes, environment variables, and networks in a Kubernetes cluster locally. The following diagram shows the main usage scenarios for Telepresence.&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/en/blog/how-to-debug-microservices-in-kubernetes-with-proxy-sidecar-or-service-mesh/telepresence.jpg&#34; data-img=&#34;/en/blog/how-to-debug-microservices-in-kubernetes-with-proxy-sidecar-or-service-mesh/telepresence.jpg&#34; data-width=&#34;1080&#34; data-height=&#34;1197&#34; alt=&#34;image&#34; data-caption=&#34;Proxy mode: Telepresence&#34;&gt;
    
  
  &lt;figcaption&gt;Proxy mode: Telepresence&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Users need to manually execute the telepresence command locally, which will automatically deploy the agent to Kubernetes. Once the agent has been deployed,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Local services will have complete access to other services in the Kubernetes cluster, environment variables, Secret, ConfigMap, etc.&lt;/li&gt;
&lt;li&gt;Services in the cluster also have direct access to the locally exposed endpoints.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;However, this approach requires users to run multiple commands while debugging locally, and in some network environments it may not be possible to establish a VPN connection to the Kubernetes cluster.&lt;/p&gt;
&lt;h3 id=&#34;sidecar--debugging-microservices-with-nocalhost&#34;&gt;Sidecar – debugging microservices with Nocalhost&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://nocalhost.dev/&#34; title=&#34;Nocalhost&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Nocalhost&lt;/a&gt;
 is a Kubernetes-based cloud development environment. To use it, you just need to install a plugin in your IDE – VS Code to extend Kubernetes and shorten the development feedback cycle. The development environment can be isolated by creating different namespaces for different users and using ServiceAccount when binding to different user corners. Nocalhost also provides a web console and API for administrators to manage different development environments.&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/en/blog/how-to-debug-microservices-in-kubernetes-with-proxy-sidecar-or-service-mesh/sidecar-nocalhost.jpg&#34; data-img=&#34;/en/blog/how-to-debug-microservices-in-kubernetes-with-proxy-sidecar-or-service-mesh/sidecar-nocalhost.jpg&#34; data-width=&#34;1928&#34; data-height=&#34;1080&#34; alt=&#34;image&#34; data-caption=&#34;Sidecar mode: Nocalhost&#34;&gt;
    
  
  &lt;figcaption&gt;Sidecar mode: Nocalhost&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;As long as you have a Kubernetes cluster and have admin rights to the cluster, you can refer to the &lt;a href=&#34;https://nocalhost.dev/getting-started/&#34; title=&#34;Nocalhost documentation&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Nocalhost documentation&lt;/a&gt;
 to quickly start trying it out. To use the Nocalhost plugin in VS Code, you need to configure the Kubernetes cluster in the plugin first.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Select the Kubeconfig file you just exported or copy and paste the contents of the file directly into the configuration.&lt;/li&gt;
&lt;li&gt;Then select the service you need to test and select the corresponding Dev Container. VS Code will automatically open a new code window.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Here is an example of the &lt;a href=&#34;https://istio.io/latest/docs/examples/bookinfo/&#34; title=&#34;bookinfo sample&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;bookinfo sample&lt;/a&gt;
 provided by Istio. You can open the cloned code in your local IDE and click the hammer next to the code file to enter development mode. Selecting the corresponding DevContainer and Nocalhost will automatically inject a development container sidecar into the pod and automatically enter the container in the terminal, as shown in the following figure.&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/en/blog/how-to-debug-microservices-in-kubernetes-with-proxy-sidecar-or-service-mesh/nocalhost-vs-code.jpg&#34; data-img=&#34;/en/blog/how-to-debug-microservices-in-kubernetes-with-proxy-sidecar-or-service-mesh/nocalhost-vs-code.jpg&#34; data-width=&#34;1722&#34; data-height=&#34;1080&#34; alt=&#34;image&#34; data-caption=&#34;Nocalhost VS code&#34;&gt;
    
  
  &lt;figcaption&gt;Nocalhost VS code&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;In development mode, the code is modified locally without rebuilding the image, and the remote development environment takes effect in real time, which can greatly accelerate the development speed. At the same time, Nocalhost also provides a server for managing the development environment and user rights, as shown in the following figure.&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/en/blog/how-to-debug-microservices-in-kubernetes-with-proxy-sidecar-or-service-mesh/nocalhost-web-admin.jpg&#34; data-img=&#34;/en/blog/how-to-debug-microservices-in-kubernetes-with-proxy-sidecar-or-service-mesh/nocalhost-web-admin.jpg&#34; data-width=&#34;2354&#34; data-height=&#34;1080&#34; alt=&#34;image&#34; data-caption=&#34;Nocalhost Web&#34;&gt;
    
  
  &lt;figcaption&gt;Nocalhost Web&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;service-mesh--debugging-microservices-with-istio&#34;&gt;Service Mesh – debugging microservices with Istio&lt;/h3&gt;
&lt;p&gt;The above method of using proxy and sidecar can only debug one service at a time. You’ll need a mesh to get the global status of the application, such as the metrics of the service obtained, and debug the performance of the service by understanding the dependency and invocation process of the service through distributed tracing. These observability features need to be implemented by injecting sidecar uniformly for all services. And, when your services are in the process of migrating from VMs to Kubernetes, using Istio can bring VMs and Kubernetes into a single network plane (as shown below), making it easy for developers to debug and do incremental migrations.&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/en/blog/how-to-debug-microservices-in-kubernetes-with-proxy-sidecar-or-service-mesh/istio-service-mesh.jpg&#34; data-img=&#34;/en/blog/how-to-debug-microservices-in-kubernetes-with-proxy-sidecar-or-service-mesh/istio-service-mesh.jpg&#34; data-width=&#34;1956&#34; data-height=&#34;1080&#34; alt=&#34;image&#34; data-caption=&#34;Serivce Mesh mode: Istio&#34;&gt;
    
  
  &lt;figcaption&gt;Serivce Mesh mode: Istio&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Of course, these benefits do not come without a “cost.” With the introduction of Istio, your Kubernetes services will need to adhere to the Istio naming convention and you’ll need to know how to debug microservices using the Istioctl command line and logging.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Use the &lt;em&gt;istioctl analyze&lt;/em&gt; command to debug the deployment of microservices in your cluster, and you can use YAML files to examine the deployment of resources in a namespace or across your cluster.&lt;/li&gt;
&lt;li&gt;Use &lt;em&gt;istioctl proxy-config secret&lt;/em&gt; to ensure that the secret of a pod in a service mesh is loaded correctly and is valid.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;
&lt;p&gt;In the process of microservicing applications and migrating from virtual machines to Kubernetes, developers need to make a lot of changes in their mindset and habits. By building a VPN between local and Kubernetes via proxy, developers can easily debug services in Kubernetes as if they were local services. By injecting a sidecar into the pod, you can achieve real-time debugging and speed up the development process. Finally, the Istio service mesh truly enables global observability, and you can also use tools like &lt;a href=&#34;https://www.tetrate.io/tetrate-service-bridge/&#34; title=&#34;Tetrate Service Bridge&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tetrate Service Bridge&lt;/a&gt;
 to manage heterogeneous platforms, helping you gradually move from monolithic applications to microservices.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Happy Istio 4th Anniversary -- Retrospect and Outlook</title>
      <link>https://jimmysong.io/en/blog/istio-4-year-birthday/</link>
      <pubDate>Mon, 24 May 2021 08:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/en/blog/istio-4-year-birthday/</guid>
      <description>
        
        
        &lt;p&gt;Istio was named by &lt;a href=&#34;https://tetrate.io/&#34; title=&#34;Tetrate&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tetrate&lt;/a&gt;
 founder Varun Talwar and Google lead engineer Louis Ryan in 2017 and was open sourced on May 24, 2017. Today is the fourth anniversary of Istio’s open source arrival. Let’s take a look back at Istio’s four years of development — and look forward to Istio’s future.&lt;/p&gt;
&lt;h3 id=&#34;istios-open-source-history&#34;&gt;Istio’s open source history&lt;/h3&gt;
&lt;p&gt;In 2017, the year Kubernetes ended the container orchestration battle, Google took the opportunity to consolidate its dominance in the cloud native space and compensate for Kubernetes’ disadvantage in service-to-service traffic management by open-sourcing Istio. Istio released its 1.10 last week — but here are some of the most important releases in Istio’s history to date.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;Date&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Version&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Note&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;May 24, 2017&lt;/td&gt;
&lt;td&gt;0.1&lt;/td&gt;
&lt;td&gt;Officially open source; established the architectural foundation of Control Plane, Data Plane and sidecar proxy.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;October 10, 2017&lt;/td&gt;
&lt;td&gt;0.2&lt;/td&gt;
&lt;td&gt;Started to support multiple runtime environments, such as virtual machines.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;June 1, 2018&lt;/td&gt;
&lt;td&gt;0.8&lt;/td&gt;
&lt;td&gt;API refactoring&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;July 31, 2018&lt;/td&gt;
&lt;td&gt;1.0&lt;/td&gt;
&lt;td&gt;Production-ready, after which the Istio team underwent a massive reorganization.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;March 19, 2019&lt;/td&gt;
&lt;td&gt;1.1&lt;/td&gt;
&lt;td&gt;Enterprise-ready. Support for multiple Kubernetes clusters, with performance optimizations.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;March 3, 2020&lt;/td&gt;
&lt;td&gt;1.5&lt;/td&gt;
&lt;td&gt;Back to monolith, with microservice components merged into istiod, making Istio’s architecture cleaner and easier to maintain. Support for WebAssembly extension, making Istio’s ecology much stronger.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;November 18, 2020&lt;/td&gt;
&lt;td&gt;1.8&lt;/td&gt;
&lt;td&gt;Officially deprecated Mixer and focused on adding support for virtual machines.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;A year after its inception– and two months before the 1.0 release, version 0.8 was released with a massive refactoring of the API. In late July 2018, when 1.0 was released, Istio reached a production-ready tipping point. Since then, Google has massively reorganized the Istio team and several Istio-based service mesh startups were born, making 2018 the booming year of the service mesh industry.&lt;/p&gt;
&lt;p&gt;Istio 1.1 was released in March 2019, almost 9 months after 1.0 was released, which is far beyond the average release cycle of an open-source project. We know that the speed of iteration and evolution is a core competency of basic software. Since then, Istio has started a regular &lt;a href=&#34;https://istio.io/v1.7/about/release-cadence/&#34; title=&#34;release cadence&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;release cadence&lt;/a&gt;
 of one version per quarter and has become the &lt;a href=&#34;https://octoverse.github.com/#fastest-growing-oss-projects-by-contributors&#34; title=&#34;#4 fastest growing project in GitHub’s top 10 in 2019&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;#4 fastest growing project in GitHub’s top 10 in 2019&lt;/a&gt;
!&lt;/p&gt;
&lt;h3 id=&#34;the-istio-community&#34;&gt;The Istio community&lt;/h3&gt;
&lt;p&gt;In 2020, Istio’s project management began to mature and its governance reached a stage of evolution. We saw the first &lt;a href=&#34;https://istio.io/latest/blog/2020/steering-election-results/&#34; title=&#34;election&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;election&lt;/a&gt;
 of a steering committee for the Istio community and the transfer of the trademark to &lt;a href=&#34;https://istio.io/latest/blog/2020/open-usage/&#34; title=&#34;Open Usage Commons&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Open Usage Commons&lt;/a&gt;
. The first &lt;a href=&#34;https://events.istio.io/istiocon-2021/&#34; title=&#34;IstioCon&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;IstioCon&lt;/a&gt;
 was successfully held in February 2021, with thousands of people attending the online conference. There is also a &lt;a href=&#34;https://www.youtube.com/watch?v=6m-rhyfy8sg&amp;amp;list=PL7wB27eZmdffS-g_xh7X-b0echc_XZMKV&amp;amp;index=8&#34; title=&#34;large Istio community in China&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;large Istio community in China&lt;/a&gt;
, and face-to-face Istio community meetups will be held there in 2021. Stay tuned for more.&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/en/blog/istio-4-year-birthday/008i3skNly1gquicfqg14j31lw0smwl2.jpg&#34; data-img=&#34;/en/blog/istio-4-year-birthday/008i3skNly1gquicfqg14j31lw0smwl2.jpg&#34; data-width=&#34;2084&#34; data-height=&#34;1030&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
    
  
  &lt;figcaption&gt;&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;According to the CNCF 2020 Survey, 46% of organizations were either using a service mesh in production or planning to use it in the next 12 months. Istio was the top used mesh among those using a mesh in production.&lt;/p&gt;
&lt;h3 id=&#34;the-future&#34;&gt;The future&lt;/h3&gt;
&lt;p&gt;After 4 years of development, there is not only a large user base around Istio, but also several Istio vendors, as you can see on the &lt;a href=&#34;https://istio.io/&#34; title=&#34;homepage&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;homepage&lt;/a&gt;
 of the recently revamped Istio website. In the last few releases, Istio has shifted its development focus to improving the Day 2 Operation experience. We also expect to see more Istio adoption path recommendations, case studies, learning materials, training, and certifications (such as the industry’s first &lt;a href=&#34;https://academy.tetrate.io/courses/certified-istio-administrator&#34; title=&#34;Certified Istio Administrator&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Certified Istio Administrator&lt;/a&gt;
 from Tetrate) that will facilitate the adoption of Istio.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Why Do You Need Istio When You Already Have Kubernetes?</title>
      <link>https://jimmysong.io/en/blog/why-do-you-need-istio-when-you-already-have-kubernetes/</link>
      <pubDate>Wed, 07 Apr 2021 08:27:17 +0800</pubDate>
      
      <guid>https://jimmysong.io/en/blog/why-do-you-need-istio-when-you-already-have-kubernetes/</guid>
      <description>
        
        
        &lt;p&gt;If you’ve heard of service mesh and tried &lt;a href=&#34;https://istio.io/&#34; title=&#34;Istio&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio&lt;/a&gt;
, you may have the following questions:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Why is Istio running on Kubernetes?&lt;/li&gt;
&lt;li&gt;What is the role of Kubernetes and a service mesh in the cloud native application architecture, respectively?&lt;/li&gt;
&lt;li&gt;What aspects of Kubernetes does Istio extend? What problems does it solve?&lt;/li&gt;
&lt;li&gt;What is the relationship between Kubernetes, Envoy, and Istio?&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This article will take you through the inner workings of Kubernetes and Istio. In addition, I will introduce the load balancing approach in Kubernetes, and explain why you need Istio when you have Kubernetes.&lt;/p&gt;
&lt;p&gt;Kubernetes is essentially about application lifecycle management through declarative configuration, while a service mesh is essentially about providing inter-application traffic, security management and observability. If you have already built a stable application platform using Kubernetes, how do you set up load balancing and traffic control for calls between services? This is where a service mesh comes into the picture.&lt;/p&gt;
&lt;p&gt;Envoy introduces the xDS protocol, which is supported by various open source software, such as &lt;a href=&#34;https://istio.io/&#34; title=&#34;Istio&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio&lt;/a&gt;
, &lt;a href=&#34;https://github.com/mosn/mosn&#34; title=&#34;MOSN&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;MOSN&lt;/a&gt;
, etc. Envoy contributes xDS to a service mesh or cloud native infrastructure. Envoy is essentially a modern version of a proxy that can be configured through APIs, based on which many different usage scenarios are derived — such as API Gateway, sidecar proxy in service mesh, and edge proxy.&lt;/p&gt;
&lt;p&gt;This article contains the following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A description of the role of kube-proxy.&lt;/li&gt;
&lt;li&gt;The limitations of Kubernetes for microservice management.&lt;/li&gt;
&lt;li&gt;An introduction to the capabilities of Istio service mesh.&lt;/li&gt;
&lt;li&gt;A comparison of some of the concepts in Kubernetes, Envoy, and the Istio service mesh.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;kubernetes-vs-service-mesh&#34;&gt;Kubernetes vs Service Mesh&lt;/h2&gt;
&lt;p&gt;The following diagram shows the service access relationship in Kubernetes and service mesh (one sidecar per pod model).&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/en/blog/why-do-you-need-istio-when-you-already-have-kubernetes/008eGmZEly1gpb7knfo4dj31hk0redrz.jpg&#34; data-img=&#34;/en/blog/why-do-you-need-istio-when-you-already-have-kubernetes/008eGmZEly1gpb7knfo4dj31hk0redrz.jpg&#34; data-width=&#34;1928&#34; data-height=&#34;986&#34; alt=&#34;image&#34; data-caption=&#34;Kubernetes vs Service Mesh&#34;&gt;
    
  
  &lt;figcaption&gt;Kubernetes vs Service Mesh&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;traffic-forwarding&#34;&gt;Traffic Forwarding&lt;/h3&gt;
&lt;p&gt;Each node in a Kubernetes cluster deploys a kube-proxy component that communicates with the Kubernetes API Server, gets information about the services in the cluster, and then sets iptables rules to send requests for service directly to the corresponding Endpoint (a pod belonging to the same group of services).&lt;/p&gt;
&lt;h3 id=&#34;service-discovery&#34;&gt;Service Discovery&lt;/h3&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/en/blog/why-do-you-need-istio-when-you-already-have-kubernetes/008eGmZEly1gpb7knwb79j30kq0fcjs9.jpg&#34; data-img=&#34;/en/blog/why-do-you-need-istio-when-you-already-have-kubernetes/008eGmZEly1gpb7knwb79j30kq0fcjs9.jpg&#34; data-width=&#34;746&#34; data-height=&#34;552&#34; alt=&#34;image&#34; data-caption=&#34;Service Discovery&#34;&gt;
    
  
  &lt;figcaption&gt;Service Discovery&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Istio can follow the service registration in Kubernetes and can also interface with other service discovery systems via platform adapters in the control plane; and then generate data plane configurations (using CRD, which are stored in etcd) with transparent proxies for the data plane. The transparent proxy of the data plane is deployed as a sidecar container in the pod of each application service, and all these proxies need to request the control plane to synchronize the proxy configuration. The proxy is “transparent” because the application container is completely unaware of the presence of the proxy. The kube-proxy component in the process needs to intercept traffic as well, except that the kube-proxy intercepts traffic to and from the Kubernetes node — while the sidecar proxy intercepts traffic to and from the pod.&lt;/p&gt;
&lt;h3 id=&#34;disadvantages-of-a-service-mesh&#34;&gt;Disadvantages of a Service Mesh&lt;/h3&gt;
&lt;p&gt;Since Kubernetes has many pods running on each node, putting the original kube-proxy route forwarding function in each pod will increase the response latency — due to more hops when the sidecar intercepts the traffic — and consume more resources. In order to manage traffic in a fine-grained manner, a series of new abstractions will be added. This will further increase the learning cost for users, but as the technology becomes more popular this situation will be slowly alleviated.&lt;/p&gt;
&lt;h3 id=&#34;advantages-of-a-service-mesh&#34;&gt;Advantages of a Service Mesh&lt;/h3&gt;
&lt;p&gt;The kube-proxy settings are global and cannot be controlled at a granular level for each service, while service mesh takes the traffic control out of the service layer in Kubernetes by means of sidecar proxy — allowing for more elasticity.&lt;/p&gt;
&lt;h3 id=&#34;shortcomings-of-kube-proxy&#34;&gt;Shortcomings of Kube-Proxy&lt;/h3&gt;
&lt;p&gt;First, it does not automatically try another pod if the forwarded pod is not serving properly. Each pod has a health check mechanism and when a pod has health problems, kubelet will restart the pod and kube-proxy will remove the corresponding forwarding rules. Also, nodePort-type services cannot add TLS or more complex message routing mechanisms.&lt;/p&gt;
&lt;p&gt;Kube-proxy implements load balancing of traffic across multiple pod instances of a Kubernetes service, but how do you do fine-grained control of traffic between these services — such as dividing traffic by percentage to different application versions (which are all part of the same service but on different deployments), or doing canary releases (grayscale releases) and blue-green releases?&lt;/p&gt;
&lt;p&gt;The Kubernetes community gives a way to &lt;a href=&#34;https://kubernetes.io/docs/concepts/cluster-administration/manage-deployment/#canary-deployments&#34; title=&#34;do canary releases using Deployment&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;do canary releases using Deployment&lt;/a&gt;
, which is essentially a way to assign different pods to a deployment’s service by modifying the pod’s label.&lt;/p&gt;
&lt;h2 id=&#34;kubernetes-ingress-vs-istio-gateway&#34;&gt;Kubernetes Ingress vs. Istio Gateway&lt;/h2&gt;
&lt;p&gt;As mentioned above, kube-proxy can only route traffic within a Kubernetes cluster. The pods of a Kubernetes cluster are located in a network created by CNI. An ingress — a resource object created in Kubernetes — is created for communication outside the cluster. It’s driven by an ingress controller located on Kubernetes edge nodes responsible for managing north-south traffic. Ingress must be docked to various Ingress Controllers, such as the &lt;a href=&#34;https://github.com/kubernetes/ingress-nginx&#34; title=&#34;nginx ingress controller&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;nginx ingress controller&lt;/a&gt;
 and &lt;a href=&#34;https://traefik.io/&#34; title=&#34;traefik&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;traefik&lt;/a&gt;
. Ingress is only applicable to HTTP traffic and is simple to use. It can only route traffic by matching a limited number of fields — such as service, port, HTTP path, etc. This makes it impossible to route TCP traffic such as MySQL, Redis, and various RPCs. This is why you see people writing nginx config language in ingress resource annotations.The only way to directly route north-south traffic is to use the service’s LoadBalancer or NodePort, the former requiring cloud vendor support and the latter requiring additional port management.&lt;/p&gt;
&lt;p&gt;Istio Gateway functions similarly to Kubernetes Ingress, in that it is responsible for north-south traffic to and from the cluster. Istio Gateway describes a load balancer for carrying connections to and from the edge of the mesh. The specification describes a set of open ports and the protocols used by those ports, the SNI configuration for load balancing, etc. Gateway is a CRD extension that also reuses the capabilities of the sidecar proxy; see the &lt;a href=&#34;https://istio.io/latest/docs/reference/config/networking/gateway/&#34; title=&#34;Istio website&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio website&lt;/a&gt;
 for detailed configuration.&lt;/p&gt;
&lt;h2 id=&#34;envoy&#34;&gt;Envoy&lt;/h2&gt;
&lt;p&gt;Envoy is the default sidecar proxy in Istio. Istio extends its control plane based on Enovy’s xDS protocol. We need to familiarize ourselves with Envoy’s basic terminology before talking about Envoy’s xDS protocol. The following is a list of basic terms and their data structures in Envoy; please refer to the &lt;a href=&#34;https://envoyproxy.io/&#34; title=&#34;Envoy documentation&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy documentation&lt;/a&gt;
 for more details.&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/en/blog/why-do-you-need-istio-when-you-already-have-kubernetes/008eGmZEly1gpb7koah95j31450tetta.jpg&#34; data-img=&#34;/en/blog/why-do-you-need-istio-when-you-already-have-kubernetes/008eGmZEly1gpb7koah95j31450tetta.jpg&#34; data-width=&#34;1445&#34; data-height=&#34;1058&#34; alt=&#34;image&#34; data-caption=&#34;Envoy&#34;&gt;
    
  
  &lt;figcaption&gt;Envoy&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;basic-terminology&#34;&gt;Basic Terminology&lt;/h3&gt;
&lt;p&gt;The following are the basic terms in Enovy that you should know.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Downstream&lt;/strong&gt;: The downstream host connects to Envoy, sends the request, and receives the response; i.e., the host that sent the request.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Upstream&lt;/strong&gt;: The upstream host receives connections and requests from Envoy and returns responses; i.e., the host that receives the requests.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Listener&lt;/strong&gt;: Listener is a named network address (for example, port, UNIX domain socket, etc.); downstream clients can connect to these listeners. Envoy exposes one or more listeners to the downstream hosts to connect.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Cluster&lt;/strong&gt;: A cluster is a group of logically identical upstream hosts to which Envoy connects. Envoy discovers the members of a cluster through service discovery. Optionally, the health status of cluster members can be determined through proactive health checks. Envoy decides which member of the cluster to route requests through a load balancing policy.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Multiple listeners can be set in Envoy, each listener can set a filter chain (filter chain table), and the filter is scalable so that we can more easily manipulate the behavior of traffic — such as setting encryption, private RPC, etc.&lt;/p&gt;
&lt;p&gt;The xDS protocol was proposed by Envoy and is the default sidecar proxy in Istio, but as long as the xDS protocol is implemented, it can theoretically be used as a sidecar proxy in Istio — such as the &lt;a href=&#34;https://github.com/mosn/mosn&#34; title=&#34;MOSN&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;MOSN&lt;/a&gt;
 open source by Ant Group.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://cdn.thenewstack.io/media/2021/03/b800bf17-image3.png&#34; title=&#34;&amp;lt;figure class=&amp;#34;mx-auto text-center&amp;#34;&amp;gt;
  
  
  
  
    
    &amp;lt;img src=&amp;#34;/en/blog/why-do-you-need-istio-when-you-already-have-kubernetes/008eGmZEly1gpb7kk7wk4j31060lqgqx.jpg&amp;#34; data-img=&amp;#34;/en/blog/why-do-you-need-istio-when-you-already-have-kubernetes/008eGmZEly1gpb7kk7wk4j31060lqgqx.jpg&amp;#34; data-width=&amp;#34;1302&amp;#34; data-height=&amp;#34;782&amp;#34; alt=&amp;#34;image&amp;#34; data-caption=&amp;#34;img&amp;#34;&amp;gt;
    
  
  &amp;lt;figcaption&amp;gt;img&amp;lt;/figcaption&amp;gt;
&amp;lt;/figure&amp;gt;
&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/en/blog/why-do-you-need-istio-when-you-already-have-kubernetes/008eGmZEly1gpb7kk7wk4j31060lqgqx.jpg&#34; data-img=&#34;/en/blog/why-do-you-need-istio-when-you-already-have-kubernetes/008eGmZEly1gpb7kk7wk4j31060lqgqx.jpg&#34; data-width=&#34;1302&#34; data-height=&#34;782&#34; alt=&#34;image&#34; data-caption=&#34;img&#34;&gt;
    
  
  &lt;figcaption&gt;img&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;Istio is a very feature-rich service mesh that includes the following capabilities.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Traffic Management: This is the most basic feature of Istio.&lt;/li&gt;
&lt;li&gt;Policy Control: Enables access control systems, telemetry capture, quota management, billing, etc.&lt;/li&gt;
&lt;li&gt;Observability: Implemented in the sidecar proxy.&lt;/li&gt;
&lt;li&gt;Security Authentication: The Citadel component does key and certificate management.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;traffic-management-in-istio&#34;&gt;Traffic Management in Istio&lt;/h2&gt;
&lt;p&gt;The following CRDs are defined in Istio to help users with traffic management.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Gateway: Gateway describes a load balancer that runs at the edge of the network and is used to receive incoming or outgoing HTTP/TCP connections.&lt;/li&gt;
&lt;li&gt;VirtualService: VirtualService actually connects the Kubernetes service to the Istio Gateway. It can also perform additional operations, such as defining a set of traffic routing rules to be applied when a host is addressed.&lt;/li&gt;
&lt;li&gt;DestinationRule: The policy defined by the DestinationRule determines the access policy for the traffic after it has been routed. Simply put, it defines how traffic is routed. Among others, these policies can be defined as load balancing configurations, connection pool sizes, and external detection (for identifying and expelling unhealthy hosts in the load balancing pool) configurations.&lt;/li&gt;
&lt;li&gt;EnvoyFilter: The EnvoyFilter object describes filters for proxy services that can customize the proxy configuration generated by Istio Pilot. This configuration is generally rarely used by primary users.&lt;/li&gt;
&lt;li&gt;ServiceEntry: By default, services in the Istio service mesh are unable to discover services outside of the Mesh. ServiceEntry enables additional entries to be added to the service registry inside Istio, thus allowing automatically discovered services in the mesh to access and route to these manually added services.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;kubernetes-vs-xds-vs-istio&#34;&gt;Kubernetes vs. xDS vs. Istio&lt;/h2&gt;
&lt;p&gt;Having reviewed the abstraction of traffic management in Kubernetes’ kube-proxy component, xDS, and Istio, let’s look now at a comparison of the three components/protocols in terms of traffic management only (note that the three are not exactly equivalent).&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;Kubernetes&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;xDS&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Istio service mesh&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Endpoint&lt;/td&gt;
&lt;td&gt;Endpoint&lt;/td&gt;
&lt;td&gt;WorkloadEntry&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Service&lt;/td&gt;
&lt;td&gt;Route&lt;/td&gt;
&lt;td&gt;VirtualService&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;kube-proxy&lt;/td&gt;
&lt;td&gt;Route&lt;/td&gt;
&lt;td&gt;DestinationRule&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;kube-proxy&lt;/td&gt;
&lt;td&gt;Listener&lt;/td&gt;
&lt;td&gt;EnvoyFilter&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ingress&lt;/td&gt;
&lt;td&gt;Listener&lt;/td&gt;
&lt;td&gt;Gateway&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Service&lt;/td&gt;
&lt;td&gt;Cluster&lt;/td&gt;
&lt;td&gt;ServiceEntry&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;takeaways&#34;&gt;Takeaways&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;The essence of Kubernetes is application lifecycle management, specifically deployment and management (scaling up and down, auto-recovery, release).&lt;/li&gt;
&lt;li&gt;Kubernetes provides a scalable and highly resilient deployment and management platform for microservices.&lt;/li&gt;
&lt;li&gt;A service mesh is based on transparent proxies that intercept traffic between services through sidecar proxies, and then manage the behavior of them through control plane configuration.&lt;/li&gt;
&lt;li&gt;A service mesh decouples traffic management from Kubernetes, eliminating the need for a kube-proxy component to support traffic within service mesh; and managing inter-service traffic, security and observability by providing an abstraction closer to the microservice application layer.&lt;/li&gt;
&lt;li&gt;xDS is one of the protocol standards for service mesh configuration.&lt;/li&gt;
&lt;li&gt;A service mesh is a higher-level abstraction of service in Kubernetes.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;
&lt;p&gt;If the object managed by Kubernetes is a pod, then the object managed in service mesh is a service, so it’s just a matter of using Kubernetes to manage microservices and then applying service mesh. If you don’t even want to manage a service, then use a serverless platform like &lt;a href=&#34;https://knative.dev/&#34; title=&#34;Knative&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Knative&lt;/a&gt;
 — but that’s an afterthought.&lt;/p&gt;

      </description>
    </item>
    
  </channel>
</rss>
