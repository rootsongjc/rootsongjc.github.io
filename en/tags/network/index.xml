
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jimmy Song â€“ Network</title>
    <link>https://jimmysong.io/en/tags/network/</link>
    <description>Recent content in Network on Jimmy Song</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>Jimmy Song</managingEditor>
    <webMaster>Jimmy Song</webMaster>
    <lastBuildDate>Sat, 18 May 2024 13:54:49 +0800</lastBuildDate>
    
	  <atom:link href="https://jimmysong.io/en/tags/network/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
                                                         
    
                                                   
                           
    <item>
      <title>CNI Essentials: Powering Kubernetes&#39; Network</title>
      <link>https://jimmysong.io/en/blog/cni-deep-dive/</link>
      <pubDate>Sat, 18 May 2024 13:54:49 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/en/blog/cni-deep-dive/</guid>
      <description>
        
        
        &lt;p&gt;Effective management of networking is crucial in containerized environments. The Container Network Interface (CNI) is a standard that defines how containers should be networked. This article delves into the fundamentals of CNI and explores its relationship with CRI.&lt;/p&gt;
&lt;h2 id=&#34;what-is-cni&#34;&gt;What is CNI?&lt;/h2&gt;
&lt;p&gt;The CNI (Container Network Interface) specification provides a common interface between container runtimes and network plugins, aiming to standardize container network configuration.&lt;/p&gt;
&lt;p&gt;The CNI specification comprises several core components:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Network configuration format&lt;/strong&gt;: Defines how administrators define network configurations.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Request protocol&lt;/strong&gt;: Describes how container runtimes send network configuration or cleanup requests to network plugins.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Plugin execution process&lt;/strong&gt;: Details how plugins execute network setup or cleanup based on the provided configuration.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Plugin delegation&lt;/strong&gt;: Allows plugins to delegate specific functionalities to other plugins.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Result return&lt;/strong&gt;: Defines the data format for returning results to the runtime after plugin execution.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;By defining these core components, the CNI specification ensures that different container runtimes and network plugins can interact in a consistent manner, enabling automation and standardization of network configuration.&lt;/p&gt;



&lt;div class=&#34;alert alert-note-container&#34;&gt;
  
  &lt;div class=&#34;alert-note-title px-2 py-2&#34;&gt;
    Key points of the CNI specification
  &lt;/div&gt;
  
  &lt;div class=&#34;alert-note px-2&#34;&gt;
    &lt;ul&gt;
&lt;li&gt;CNI is a plugin-based containerized networking solution.&lt;/li&gt;
&lt;li&gt;CNI plugins are executable files.&lt;/li&gt;
&lt;li&gt;The responsibility of a single CNI plugin is singular.&lt;/li&gt;
&lt;li&gt;CNI plugins are invoked in a chained manner.&lt;/li&gt;
&lt;li&gt;The CNI specification defines a Linux network namespace for a container.&lt;/li&gt;
&lt;li&gt;Network definitions in CNI are stored in JSON format.&lt;/li&gt;
&lt;li&gt;Network definitions are transmitted to plugins via STDIN input streams, meaning network configuration files are not stored on the host, and other configuration parameters are passed to plugins via environment variables.&lt;/li&gt;
&lt;/ul&gt;

  &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;CNI plugins receive network configuration parameters according to the operation type, perform network setup or cleanup tasks accordingly, and return the execution results. This process ensures dynamic configuration of container networks synchronized with container lifecycles.&lt;/p&gt;
&lt;p&gt;The following diagram illustrates the multitude of network plugins encompassed by CNI.&lt;/p&gt;

&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/en/blog/cni-deep-dive/cdc38d55a4fc4468ab20df85ab63c2c7.svg&#34; data-img=&#34;/en/blog/cni-deep-dive/cdc38d55a4fc4468ab20df85ab63c2c7.svg&#34; alt=&#34;image&#34; data-caption=&#34;Mermaid Diagram&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;Mermaid Diagram&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;According to the &lt;a href=&#34;https://github.com/containernetworking/cni/blob/main/SPEC.md#section-2-execution-protocol&#34; title=&#34;CNI specification&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNI specification&lt;/a&gt;, a CNI plugin is responsible for configuring a container&amp;rsquo;s network interface in some way. Plugins can be classified into two major categories:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&amp;ldquo;Interface&amp;rdquo; plugins, responsible for creating network interfaces inside containers and ensuring their connectivity.&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Chained&amp;rdquo; plugins, adjusting the configuration of already created interfaces (but may need to create more interfaces to accomplish this).&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;relationship-between-cni-and-cri&#34;&gt;Relationship Between CNI and CRI&lt;/h2&gt;
&lt;p&gt;CNI and CRI (Container Runtime Interface) are two critical interfaces in Kubernetes, responsible for container network configuration and runtime management, respectively. In Kubernetes clusters, CRI invokes CNI plugins to configure or clean up container networks, ensuring tight coordination between the network configuration process and container creation and destruction processes.&lt;/p&gt;
&lt;p&gt;The following diagram intuitively illustrates how CNI collaborates with CRI:&lt;/p&gt;

&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/en/blog/cni-deep-dive/9efc34ed8d34997a651adff337bb1630.svg&#34; data-img=&#34;/en/blog/cni-deep-dive/9efc34ed8d34997a651adff337bb1630.svg&#34; alt=&#34;image&#34; data-caption=&#34;Mermaid Diagram&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;Mermaid Diagram&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Kubelet to CRI&lt;/strong&gt;: The Kubelet instructs the CRI to create the containers for a scheduled pod.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CRI to Pod&lt;/strong&gt;: The container runtime starts the container within the pod.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Pod to CRI&lt;/strong&gt;: Once the container is running, it signals back to the container runtime.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CRI to Kubelet&lt;/strong&gt;: The container runtime notifies the Kubelet that the containers are ready.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Kubelet to CNI&lt;/strong&gt;: With the containers up, the Kubelet calls the CNI to set up the network for the pod.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CNI to Pod&lt;/strong&gt;: The CNI configures the network for the pod, attaching it to the necessary network interface.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Pod to CNI&lt;/strong&gt;: After the network is configured, the pod confirms network setup to the CNI.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CNI to Kubelet&lt;/strong&gt;: The CNI informs the Kubelet that the pod&amp;rsquo;s network is ready.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Kubelet to Pod&lt;/strong&gt;: The pod is now fully operational, with both containers running and network configured.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The following diagram shows the detailed steps involved in setting up networking for a pod in Kubernetes:&lt;/p&gt;

&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/en/blog/cni-deep-dive/640af94970463b3c8707011903bfe19a.svg&#34; data-img=&#34;/en/blog/cni-deep-dive/640af94970463b3c8707011903bfe19a.svg&#34; alt=&#34;image&#34; data-caption=&#34;Mermaid Diagram&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;Mermaid Diagram&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Pod scheduling&lt;/strong&gt;: The Kubelet schedules a pod to run on a node.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Request network setup&lt;/strong&gt;: The scheduled pod requests network setup from the Kubelet.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Invoke CNI&lt;/strong&gt;: The Kubelet invokes the CNI to handle the network setup for the pod.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Create network namespace&lt;/strong&gt;: The CNI creates a network namespace for the pod, isolating its network environment.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Allocate IP address&lt;/strong&gt;: The CNI, through its IP Address Management (IPAM) plugin, allocates an IP address for the pod.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Setup network interfaces&lt;/strong&gt;: The CNI sets up the necessary network interfaces within the pod&amp;rsquo;s network namespace, attaching it to the network.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Network setup complete&lt;/strong&gt;: The pod notifies the Kubelet that its network setup is complete.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Pod running with network&lt;/strong&gt;: The pod is now running with its network configured and can communicate with other pods and services within the Kubernetes cluster.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;cni-workflow&#34;&gt;CNI Workflow&lt;/h2&gt;
&lt;p&gt;The Container Network Interface (CNI) specification defines how containers should configure networks, including five operations: &lt;code&gt;ADD&lt;/code&gt;, &lt;code&gt;CHECK&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, &lt;code&gt;GC&lt;/code&gt;, and &lt;code&gt;VERSION&lt;/code&gt;. Container runtimes execute these operations by calling various CNI plugins, enabling dynamic management and updates of container networks.&lt;/p&gt;

&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/en/blog/cni-deep-dive/7b22cf25a480085d500bf3031dbaf6ec.svg&#34; data-img=&#34;/en/blog/cni-deep-dive/7b22cf25a480085d500bf3031dbaf6ec.svg&#34; alt=&#34;image&#34; data-caption=&#34;Mermaid Diagram&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;Mermaid Diagram&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;To elaborate on each step described in the sequence diagram, involving interactions between Kubelet, Pod, CNI plugins (both interface and chained), network setup, and IP address management (IPAM), let&amp;rsquo;s delve deeper into the process:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Schedule Pod&lt;/strong&gt;: Kubelet schedules a Pod to run on a node. This step initiates the lifecycle of Pods within the Kubernetes cluster.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Request Network Setup&lt;/strong&gt;: The Pod requests Kubelet for network setup. This request triggers the process of configuring the network for the Pod, ensuring its ability to communicate within the Kubernetes cluster.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Call CNI Plugins&lt;/strong&gt;: Kubelet invokes configured Container Network Interface (CNI) plugins. CNI defines a standardized way for container management systems to set up network interfaces within Linux containers. Kubelet passes necessary information to CNI plugins to initiate network setup.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Call Interface Plugin&lt;/strong&gt;: The CNI framework calls an interface CNI plugin responsible for setting up primary network interfaces for the Pod. This plugin may create a new network namespace, connect a pair of veth, or perform other actions to ensure the Pod has the required network interfaces.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Set Network Interfaces&lt;/strong&gt;: The interface CNI plugin configures network interfaces for the Pod. This setup includes assigning IP addresses, setting up routes, and ensuring interfaces are ready for communication.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Call Chained Plugin&lt;/strong&gt;: After setting up network interfaces, the interface CNI plugin or the CNI framework calls chained CNI plugins. These plugins perform additional network configuration tasks, such as setting up IP masquerading, configuring ingress/egress rules, or applying network policies.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Allocate IP Address&lt;/strong&gt;: As part of the chained process, one of the chained CNI plugins may involve IP Address Management (IPAM). The IPAM plugin is responsible for assigning an IP address to the Pod, ensuring each Pod has a unique IP within the cluster or namespace.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;IP Address Allocated&lt;/strong&gt;: The IPAM plugin allocates an IP address and returns the allocation information to the calling plugin. This information typically includes the IP address itself, subnet mask, and possible gateway.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Apply Network Policies&lt;/strong&gt;: Chained CNI plugins apply any specified network policies to the Pod&amp;rsquo;s network interfaces. These policies may dictate allowed ingress and egress traffic, ensuring network security and isolation per cluster configuration requirements.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Chained Configuration Complete&lt;/strong&gt;: Once all chained plugins have completed their tasks, the overall network configuration for the Pod is considered complete. The CNI framework or the last plugin in the chain signals to Kubelet that network setup is complete.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Network Setup Complete&lt;/strong&gt;: Kubelet receives confirmation of network setup completion from the Pod. At this point, the Pod has fully configured network interfaces with IP addresses, route rules, and applied network policies.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Pod Running with Network&lt;/strong&gt;: The Pod is now running and has its network configured. It can communicate with other Pods within the Kubernetes cluster, access external resources per network policies, and perform its designated functions.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The following are example sequence diagrams and detailed explanations for the &lt;code&gt;ADD&lt;/code&gt;, &lt;code&gt;CHECK&lt;/code&gt;, and &lt;code&gt;DELETE&lt;/code&gt; operations based on the &lt;a href=&#34;https://github.com/containernetworking/cni/blob/main/SPEC.md#appendix-examples&#34; title=&#34;official CNI examples&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;official CNI examples&lt;/a&gt;. Through these operations, interactions between the container runtime and CNI plugins facilitate dynamic management and updates of container network configurations.&lt;/p&gt;
&lt;h3 id=&#34;add-operation-example&#34;&gt;ADD Operation Example&lt;/h3&gt;
&lt;p&gt;Below is the example sequence diagram and detailed explanation for the ADD operation:&lt;/p&gt;

&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/en/blog/cni-deep-dive/4f28f5eda4192e0eb4cd9c65f2c6f61f.svg&#34; data-img=&#34;/en/blog/cni-deep-dive/4f28f5eda4192e0eb4cd9c65f2c6f61f.svg&#34; alt=&#34;image&#34; data-caption=&#34;Mermaid Diagram&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;Mermaid Diagram&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Container Runtime Calls Portmap Plugin&lt;/strong&gt;: The container runtime executes the ADD operation by calling the Portmap plugin to configure port mapping for the container.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Portmap Configuration Complete&lt;/strong&gt;: The Portmap plugin completes the port mapping configuration and returns the result to the container runtime.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Container Runtime Calls Tuning Plugin&lt;/strong&gt;: The container runtime invokes the Tuning plugin to execute the ADD operation and configure network tuning parameters for the container.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Tuning Configuration Complete&lt;/strong&gt;: The Tuning plugin finishes configuring network tuning parameters and returns the result to the container runtime.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Container Runtime Calls Bridge Plugin&lt;/strong&gt;: The container runtime calls the Bridge plugin to execute the ADD operation and configure network interfaces and IP addresses for the container.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Bridge Plugin Calls Host-local Plugin&lt;/strong&gt;: Before completing its own configuration, the Bridge plugin calls the Host-local plugin to execute the ADD operation and configure IP addresses for the container.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;IPAM Configuration Complete&lt;/strong&gt;: The Host-local plugin, acting as the authority for IP Address Management (IPAM), completes IP address allocation and returns the result to the Bridge plugin.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Bridge Configuration Complete&lt;/strong&gt;: The Bridge plugin finishes configuring network interfaces and IP addresses and returns the result to the container runtime.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;These operations ensure that the required network configuration is set up as expected when the container starts, including port mapping, network tuning, and IP address allocation.&lt;/p&gt;
&lt;h3 id=&#34;check-operation-example&#34;&gt;CHECK Operation Example&lt;/h3&gt;
&lt;p&gt;Below is the example sequence diagram and detailed explanation for the CHECK operation:&lt;/p&gt;

&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/en/blog/cni-deep-dive/c20cc6391b4f6cf89ffac159410ca851.svg&#34; data-img=&#34;/en/blog/cni-deep-dive/c20cc6391b4f6cf89ffac159410ca851.svg&#34; alt=&#34;image&#34; data-caption=&#34;Mermaid Diagram&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;Mermaid Diagram&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Container Runtime Calls Bridge Plugin for Check&lt;/strong&gt;: The container runtime performs the CHECK operation by calling the Bridge plugin to inspect the container&amp;rsquo;s network configuration.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Bridge Plugin Calls Host-local Plugin for Check&lt;/strong&gt;: The Bridge plugin calls the Host-local plugin to inspect IP address allocation.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;No Errors Detected&lt;/strong&gt;: The Host-local plugin detects no errors in IP address allocation and reports no errors to the Bridge plugin.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Return with 0 Exit Code&lt;/strong&gt;: The Bridge plugin confirms no network configuration errors and returns with a 0 exit code to the container runtime.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Container Runtime Calls Tuning Plugin for Check&lt;/strong&gt;: The container runtime invokes the Tuning plugin to inspect network tuning parameters.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Operation Successful&lt;/strong&gt;: The Tuning plugin confirms no errors in network tuning parameters, indicating a successful operation to the container runtime.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;These operations ensure that during container runtime, network configuration and tuning parameters are checked and verified as expected to ensure consistency and correctness in network configuration.&lt;/p&gt;
&lt;h3 id=&#34;delete-operation-example&#34;&gt;DELETE Operation Example&lt;/h3&gt;
&lt;p&gt;Below is the example sequence diagram and detailed explanation for the DELETE operation:&lt;/p&gt;

&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/en/blog/cni-deep-dive/40d9a191cc29a56b101c764a520d521e.svg&#34; data-img=&#34;/en/blog/cni-deep-dive/40d9a191cc29a56b101c764a520d521e.svg&#34; alt=&#34;image&#34; data-caption=&#34;Mermaid Diagram&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;Mermaid Diagram&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Container Runtime Calls Portmap Plugin for Delete&lt;/strong&gt;: The container runtime initiates the DELETE operation by calling the Portmap plugin to remove port mapping configuration for the container.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Portmap Deletion Complete&lt;/strong&gt;: The Portmap plugin finishes deleting port mapping and reports completion to the container runtime.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Container Runtime Calls Tuning Plugin for Delete&lt;/strong&gt;: The container runtime calls the Tuning plugin to execute the DELETE operation and remove network tuning parameters for the container.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Tuning Deletion Complete&lt;/strong&gt;: The Tuning plugin completes deletion of network tuning parameters and notifies the container runtime.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Container Runtime Calls Bridge Plugin for Delete&lt;/strong&gt;: The container runtime invokes the Bridge plugin to execute the DELETE operation and remove network interfaces and IP address configuration for the container.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Bridge Plugin Calls Host-local Plugin for Delete&lt;/strong&gt;: Before completing its own deletion, the Bridge plugin calls the Host-local plugin to execute the DELETE operation and remove IP address allocation for the container.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;IPAM Deletion Complete&lt;/strong&gt;: The Host-local plugin completes IP address deletion and informs the Bridge plugin.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Bridge Deletion Complete&lt;/strong&gt;: The Bridge plugin finishes removing network interfaces and IP addresses and notifies the container runtime.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;These operations ensure that when the container stops running, its required network configuration is properly cleaned up and removed to ensure effective release and management of network resources.&lt;/p&gt;
&lt;p&gt;Through the example sequence diagrams and detailed explanations for ADD, CHECK, and DELETE operations, it&amp;rsquo;s clear how interactions between the container runtime and CNI plugins facilitate dynamic management and updates of container network configurations.&lt;/p&gt;
&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;The Container Network Interface (CNI) specification standardizes container network configuration in Kubernetes clusters, allowing container runtimes to interface with various network plugins seamlessly. Understanding CNI&amp;rsquo;s core components and its collaboration with the Container Runtime Interface (CRI) is essential for effective network management in containerized environments.&lt;/p&gt;
&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/containernetworking/cni/blob/main/SPEC.md&#34; title=&#34;CNI Spec&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNI Spec&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;This blog was initially published at &lt;a href=&#34;https://tetrate.io/blog/envoy-microservices-overview/&#34; title=&#34;tetrate.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;tetrate.io&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;

      </description>
    </item>
                           
    <item>
      <title>How Istioâ€™s mTLS Traffic Encryption Works as Part of a Zero Trust Security Posture</title>
      <link>https://jimmysong.io/en/blog/understanding-the-tls-encryption-in-istio/</link>
      <pubDate>Sat, 24 Dec 2022 14:09:40 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/en/blog/understanding-the-tls-encryption-in-istio/</guid>
      <description>
        
        
        &lt;p&gt;The Istio service mesh offers cloud native deployments a standard way to implement automatic &lt;a href=&#34;https://en.wikipedia.org/wiki/Mutual_authentication#mTLS&#34; title=&#34;mutual transport layer security (mTLS)&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;mutual transport layer security (mTLS)&lt;/a&gt;. This reduces the attack surface of network communication by using strong identities to establish encrypted channels between workloads within the mesh that are both confidential and tamper-resistant. mTLS is a key component for building zero-trust application networks. To understand mTLS traffic encryption in Istio, this article will cover the following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;An overview of TLS, mTLS, and TLS termination&lt;/li&gt;
&lt;li&gt;An introduction to howTLS encryption works in Istio&lt;/li&gt;
&lt;li&gt;How to use Istio to implement mTLS in Kubernetes&lt;/li&gt;
&lt;li&gt;A discussion of when you do and donâ€™t need mTLS&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;what-is-tls-and-mtls&#34;&gt;What Is TLS and mTLS?&lt;/h2&gt;
&lt;p&gt;TLS, the successor to Secure Sockets Layer (SSL), is a widely adopted security protocol used to create authenticated and encrypted connections between networked computers. For this reason, people often use the terms TLS and SSL interchangeably. In this article, we will refer to them collectively as TLS. TLS 1.0 was released in 1999, and the latest version is 1.3 (released in August 2018); versions 1.0 and 1.1 are deprecated.&lt;/p&gt;
&lt;p&gt;The HTTPS we see when browsing the web uses TLS, as shown in Figure 1, which is built on top of TCP as the session layer in the OSI model. To ensure compatibility, TLS usually uses port 443, but you can use any port you want.&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/en/blog/understanding-the-tls-encryption-in-istio/http-vs-https.svg&#34; data-img=&#34;/en/blog/understanding-the-tls-encryption-in-istio/http-vs-https.svg&#34; alt=&#34;image&#34; data-caption=&#34;Figure 1: HTTP vs. HTTPS&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;Figure 1: HTTP vs. HTTPS&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;TLS encryption is required when a client needs to confirm the identity of the server in order to guard against man-in-the-middle attacks and ensure communication security. Figure 2 shows how TLS-encrypted communication proceeds.&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/en/blog/understanding-the-tls-encryption-in-istio/tls-flow.svg&#34; data-img=&#34;/en/blog/understanding-the-tls-encryption-in-istio/tls-flow.svg&#34; alt=&#34;image&#34; data-caption=&#34;Figure 2: simplified TLS handshake flow&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;Figure 2: simplified TLS handshake flow&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;The server applies for and obtains a certificate (X.509 certificate) from a trusted &lt;a href=&#34;https://en.wikipedia.org/wiki/Certificate_authority&#34; title=&#34;certificate authority&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;certificate authority&lt;/a&gt; (CA).&lt;/li&gt;
&lt;li&gt;A request from the client to the server containing information such as the TLS version and password combination supported by the client.&lt;/li&gt;
&lt;li&gt;The server responds to the client request and attaches a digital certificate.&lt;/li&gt;
&lt;li&gt;The client verifies the status, validity, and digital signature of the certificate and confirms the identity of the server.&lt;/li&gt;
&lt;li&gt;Encrypted communication commences between the client and the server using a shared private key.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The above is only an outline description of the TLS communication flow. If youâ€™re interested in the details, please see &lt;a href=&#34;https://www.cloudflare.com/learning/ssl/what-happens-in-a-tls-handshake/&#34; title=&#34;this in-depth discussion of the complete TLS handshake process.&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;this in-depth discussion of the complete TLS handshake process.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;From the above process, you will find that the certificate is the critical element representing the serverâ€™s identity. The server must use a certificate issued by an authoritatively certified CA in order to provide public services over the Internet. In contrast, you can manage certificates using your own public key infrastructure (PKI) for services inside of a private environment.&lt;/p&gt;
&lt;p&gt;Mutual TLS, also referred to as mTLS, is the use of a two-way encrypted channel between a server and a client that necessitates certificate exchange and identity authentication between the parties.&lt;/p&gt;
&lt;h2 id=&#34;what-is-tls-termination&#34;&gt;What Is TLS Termination?&lt;/h2&gt;
&lt;p&gt;TLS termination is the process of decrypting TLS-encrypted traffic before it is forwarded to a web server. Offloading TLS traffic to an ingress gateway or specialized device improves web application performance while securing encrypted traffic. TLS termination is typically implemented at cluster ingress. All communication between the ingress and servers in the cluster will be conducted directly over HTTP in plaintext, enhancing service performance.&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/en/blog/understanding-the-tls-encryption-in-istio/tls-termination.svg&#34; data-img=&#34;/en/blog/understanding-the-tls-encryption-in-istio/tls-termination.svg&#34; alt=&#34;image&#34; data-caption=&#34;Figure 3: TLS termination&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;Figure 3: TLS termination&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;By default, Istio enables mTLS for mesh-based services and ends TLS at the ingress gateway. Furthermore, you can pass through traffic to back-end services for processing.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;networking.istio.io/v1beta1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Gateway&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;sample-gateway&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;servers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;number&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;443&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;https&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;protocol&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;HTTPS&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;tls&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;mode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;PASSTHROUGH&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;See &lt;a href=&#34;https://istio.io/latest/docs/ops/configuration/traffic-management/tls-configuration/#gateways&#34; title=&#34;Gateway TLS Configuration&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Gateway TLS Configuration&lt;/a&gt; for details.&lt;/p&gt;
&lt;h2 id=&#34;how-to-implement-automatic-mtls-in-istio&#34;&gt;How to Implement Automatic mTLS in Istio&lt;/h2&gt;
&lt;p&gt;Figure 4 depicts the security architecture of Istio. This figure clearly shows that at the entry point, JSON Web Token (JWT) + TLS authentication and encryption are used, and that mTLS is enabled between all services within the Istio mesh.&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/en/blog/understanding-the-tls-encryption-in-istio/istio-security.svg&#34; data-img=&#34;/en/blog/understanding-the-tls-encryption-in-istio/istio-security.svg&#34; alt=&#34;image&#34; data-caption=&#34;Istio å®‰å…¨æž¶æž„å›¾&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;Istio å®‰å…¨æž¶æž„å›¾&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;Istio includes a built-in CA, and &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret&#34; title=&#34;Secret Discovery Service (SDS)&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Secret Discovery Service (SDS)&lt;/a&gt;â€”one of the discovery services in Envoy &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/api-docs/xds_protocol&#34; title=&#34;xDS&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;xDS&lt;/a&gt;â€”enables the issuance and rotation of SVID certificates. The mTLS flow in the Istio mesh is as follows:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The sidecar of every service requests a certificate from Istiod on behalf of the workload at startup, and Istiod issues the &lt;a href=&#34;https://spiffe.io/docs/latest/spiffe-about/spiffe-concepts/#spiffe-verifiable-identity-document-svid&#34; title=&#34;SVID&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SVID&lt;/a&gt; certificate (the process is more complex, and I will explain it in a future blog).&lt;/li&gt;
&lt;li&gt;The sidecar of every workload intercepts all client requests within the pod.&lt;/li&gt;
&lt;li&gt;The client sidecar starts an mTLS handshake with the server sidecar. During the handshake, the &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/security/jwt_authn_filter&#34; title=&#34;JWT&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;JWT&lt;/a&gt; and &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/security/ext_authz_filter&#34; title=&#34;authentication filter&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;authentication filter&lt;/a&gt; in the client sidecar will authenticate the identity of the request, and store the identity in the filter metadata after the authentication. Then the request will go through the authorization filter to determine if the request is allowed.&lt;/li&gt;
&lt;li&gt;If the request is authenticated and authorized, the client and the server start to establish a connection for communication.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In Istio, authentication and authorization between services can be configured using one of three resource objects:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://istio.io/latest/docs/reference/config/security/request_authentication/&#34; title=&#34;RequestAuthentication&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RequestAuthentication&lt;/a&gt;:&lt;/strong&gt; To specify the serviceâ€™s only currently supported request-level authentication method, JWT.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://istio.io/latest/docs/reference/config/security/peer_authentication/&#34; title=&#34;PeerAuthentication&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;PeerAuthentication&lt;/a&gt;:&lt;/strong&gt; To enable mTLS or plaintext requests, set the transport authentication mode.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://istio.io/latest/docs/reference/config/security/authorization-policy/&#34; title=&#34;AuthorizationPolicy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;AuthorizationPolicy&lt;/a&gt;:&lt;/strong&gt; To specify who can do what when traffic between services is authorized? For instance, subject A either permits (ALLOW) or forbids (DENY) traffic from subject B.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;how-to-enable-automatic-mtls-in-istio&#34;&gt;How to Enable Automatic mTLS in Istio&lt;/h2&gt;
&lt;p&gt;In PeerAuthentication, you can specify the mTLS mode that will be used for the target workload. Peer authentication is supported in the following modes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PERMISSIVE: The workloadâ€™s default setting that allows it to accept either mTLS or plain text traffic.&lt;/li&gt;
&lt;li&gt;STRICT: The workload accepts only mTLS traffic.&lt;/li&gt;
&lt;li&gt;DISABLE: Disable mTLS. From a security perspective, mTLS should not be disabled unless you have your own security solution.&lt;/li&gt;
&lt;li&gt;UNSET: Inherited from the parent, with the following priority: service specific &amp;gt; namespace scope &amp;gt; mesh scope setting.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Istioâ€™s peer authentication uses &lt;em&gt;PERMISSIVE&lt;/em&gt; mode by default, automatically sending &lt;em&gt;mTLS&lt;/em&gt; traffic to these workloads and clear text traffic to workloads without a sidecar. After including Kubernetes services in the Istio mesh, we can use &lt;em&gt;PERMISSIVE&lt;/em&gt; mode first to prevent services from failing &lt;em&gt;mTLS&lt;/em&gt;. We can use one of two ways to enable strict mTLS mode for certain services:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Use PeerAuthentication to define how traffic is transferred between sidecars.&lt;/li&gt;
&lt;li&gt;Use DestinationRule to define the TLS settings in the traffic routing policy.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The reviews serviceâ€™s mTLS configuration in the default namespace can be seen in the example below.&lt;/p&gt;
&lt;h3 id=&#34;use-peerauthentication-to-set-mtls-for-workloads&#34;&gt;Use PeerAuthentication to Set mTLS for Workloads&lt;/h3&gt;
&lt;p&gt;For instance, the following configuration can be used to specify that a workload under a namespace has strict mTLS enabled.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;security.istio.io/v1beta1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;PeerAuthentication&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;foo-peer-policy&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;selector&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;matchLabels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;reviews&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;mtls&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;mode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;STRICT&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;According to the &lt;a href=&#34;https://istio.io/latest/docs/tasks/security/authentication/mtls-migration/&#34; title=&#34;Istio documentation&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio documentation&lt;/a&gt;, you can also enable strict mTLS for all services in the mesh by configuring strict mTLS for the namespace istio-system where Istio is installed.&lt;/p&gt;
&lt;h3 id=&#34;use-destinationrule-to-set-up-mtls-for-workloads&#34;&gt;Use DestinationRule to Set up mTLS for Workloads&lt;/h3&gt;
&lt;p&gt;Traffic routing policies, such as load balancing, anomaly detection, TLS settings, etc., are set using DestinationRule. In the TLS settings, there are various modes. As shown below, use ISTIO_MUTUAL mode to enable Istioâ€™s workload-based automatic TLS.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;networking.istio.io/v1beta1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;DestinationRule&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;reviews&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;host&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;reviews&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;trafficPolicy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;tls&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;mode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ISTIO_MUTUAL&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;when-should-you-use-mtls&#34;&gt;When Should You Use mTLS?&lt;/h2&gt;
&lt;p&gt;The short answer is that you should use mTLS for network communication between application components that you have some control overâ€”like between microservices in a cluster.&lt;/p&gt;
&lt;p&gt;One-way TLS is typically used by Internet clients to connect to Web services, which means that only the server needs to show identification and is unconcerned with the identity of the client. One-way TLS allows you to use passwords, tokens, two-factor authentication, and other methods when you need to confirm the identity of the client. However, when using a service mesh, mTLS operates outside the application and doesnâ€™t require many changes to the application logic, whereas such an authentication method requires internal application support.&lt;/p&gt;
&lt;p&gt;As you can see from the example above, mTLS implementation calls for certificate exchange between services. As the number of services rises, managing numerous certificates becomes a laborious task. You can implement automatic mTLS and fix the certificate management issue with the aid of a service mesh.&lt;/p&gt;
&lt;h2 id=&#34;when-shouldnt-you-use-mtls&#34;&gt;When Shouldnâ€™t You Use mTLS?&lt;/h2&gt;
&lt;p&gt;Although mTLS is the preferred protocol for securing inter-service communication in cloud-native applications, implementing mTLS necessitates a more complex, symmetric encryption and decryption process than one-way TLS. In some cases where there is high traffic volume or CPU utilization must be optimized, terminatingTLS at the traffic entry point and turning on mTLS internally for specific services only can help minimize request response times and decrease compute resource consumption for some traffic with lower security levels.&lt;/p&gt;
&lt;p&gt;Additionally, it is necessary to &lt;a href=&#34;https://istio.io/latest/docs/ops/configuration/mesh/app-health-check/#disable-the-http-probe-rewrite-for-a-pod&#34; title=&#34;disable probe rewriting for pods&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;disable probe rewriting for pods&lt;/a&gt; when using services that cannot obtain certificates, such as health checks performed via HTTP on Kubelet and the inability to access the serviceâ€™s health check endpoint via TLS.&lt;/p&gt;
&lt;p&gt;Finally, when mesh services access some external services, mTLS is also not necessary.&lt;/p&gt;
&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;
&lt;p&gt;mTLS is a crucial component of creating a zero-trust application network, which makes it possible to encrypt traffic within the mesh. Istio makes it simple to enable automatic mTLS for Kubernetes services, doing away with the need to manage certificates. At the same time, we can selectively enable mTLS for a subset of the meshâ€™s services, enabling us to move services from Kubernetes to the mesh. In a subsequent blog, weâ€™ll go into more detail about Istioâ€™s certificate management system. Stay tuned.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;If youâ€™re new to service mesh and Kubernetes security, we have a bunch of free online courses &lt;a href=&#34;https://tetr8.io/academy&#34; title=&#34;available at Tetrate Academy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;available at Tetrate Academy&lt;/a&gt; that will quickly get you up to speed with Istio and Envoy.&lt;/p&gt;
&lt;p&gt;If youâ€™re looking for a fast way to get to production with Istio, check out &lt;a href=&#34;https://tetr8.io/tid&#34; title=&#34;Tetrate Istio Distribution (TID)&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tetrate Istio Distribution (TID)&lt;/a&gt;. TID is Tetrateâ€™s hardened, fully upstream Istio distribution, with FIPS-verified builds and support available. Itâ€™s a great way to get started with Istio knowing you have a trusted distribution to begin with, have an expert team supporting you, and also have the option to get to FIPS compliance quickly if you need to.Once you have Istio up and running, you will probably need simpler ways to manage and secure your services beyond whatâ€™s available in Istio, thatâ€™s where Tetrate Service Bridge comes in. You can learn more about how Tetrate Service Bridge makes service mesh more secure, manageable, and resilient &lt;a href=&#34;https://tetr8.io/tsb&#34; title=&#34;here&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;here&lt;/a&gt;, or &lt;a href=&#34;https://tetr8.io/contact&#34; title=&#34;contact us for a quick demo&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;contact us for a quick demo&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;This blog was originally published at &lt;a href=&#34;https://tetrate.io/blog/how-istios-mtls-traffic-encryption-works-as-part-of-a-zero-trust-security-posture/&#34; title=&#34;tetrate.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;tetrate.io&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;

      </description>
    </item>
    
  </channel>
</rss>
