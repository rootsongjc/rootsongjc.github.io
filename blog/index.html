<!DOCTYPE html>
<html lang="zh"><head>
  <meta charset="utf-8">
  
  <title>博客 - Jimmy Song</title>
  

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta name="description" content="专注开源技术、云原生与生活随笔的分享与思考。">
  <meta name="author" content="Jimmy Song">
  <meta name="generator" content="Hugo 0.136.0">

  <!-- CSS plugins -->
  
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
  
  <link rel="preload" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" as="style">
  <link rel="stylesheet" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" media="screen">
  

  <!-- Main Stylesheet -->
  
  <link rel="preload" href="/scss/style.min.784204edcd29c092198e88494fa2ae755eba9ae231d6fa7faf8e7da3207b4623.css" as="style">
  <link rel="stylesheet" href="/scss/style.min.784204edcd29c092198e88494fa2ae755eba9ae231d6fa7faf8e7da3207b4623.css" media="screen">

  <!-- Bigger picture css -->
  
  <link rel="stylesheet" href="/plugins/bigger-picture/bigger-picture.min.css" media="print" onload="this.media='all'">
  <!--Favicon generate by https://realfavicongenerator.net-->
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="200x200" href="/images/favicon.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">

  <link href='/opensearchdescription.xml' rel='search' title='Content search' type='application/opensearchdescription+xml'/>

  <!--Twitter card-->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="jimmysong.io" />
  <meta name="twitter:creator" content="@jimmysongio" />
  <meta property="og:url" content="https://jimmysong.io/blog/" />
  <meta property="og:title" content="博客 | Jimmy Song" />
  <meta property="twitter:title" content="博客 | Jimmy Song" />

  
  <meta property="og:description" content="专注开源技术、云原生与生活随笔的分享与思考。" />
  <meta property="twitter:description" content="专注开源技术、云原生与生活随笔的分享与思考。" />

  
  <meta property="og:image" content="https://jimmysong.io/images/banner/default.jpg" />
  <meta property="twitter:image" content="https://jimmysong.io/images/banner/default.jpg" />

  
  
</head>
<body>
<header class="fixed-top header">
  
  
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa fa-arrow-circle-up" aria-hidden="true"></i></button>
  
  <div class="navigation w-100 ">
    <div class="container-xl">
      <nav class="navbar navbar-expand-lg navbar-light p-0">
        <a class="navbar-brand" href="/">
            
            <b>JIMMY SONG</b>
            
        </a>
        <button class="navbar-toggler rounded-0" type="button" data-toggle="collapse" data-target="#navigation"
          aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse text-center" id="navigation">
          <ul class="navbar-nav ml-auto">
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/blog">博客</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/book">资料</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/tags">标签</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/notice">公告</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/contact">联系</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/about">关于</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/community/">社区</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener">视频 <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i></a>
              
            </li>
            
            

          
          
          <li class="nav-item">
            
            
            
              
              
                
                
                
                  
                    
                    <a class="nav-link" href="/en/blog/">English</a>
                    
                  
                
              
              
              
                
                  
                    
                    
                  
                
                
                
              
          </li>
          
          
          <!-- search -->
           <button type="button" class="search-btn js-search" id="searchOpen" aria-label="Search">
              <div class="search-container d-flex justify-content-center">
              <span class="search-content">
                  <i class="fa fa-search"></i>
                  <span>搜索</span>
              </span>
              <span class="search-shortcuts d-none d-sm-block">
                  <kbd class="cmd-key">⌘</kbd>
                  <kbd class="k-key">K</kbd>
              </span>
              </div>
          </button>
          
          </ul>
        </div>
      </nav>
    </div>
  </div>
</header>


            <aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between">
        <div class="col-6 search-title">
          <p>站内搜索</p> 
        </div>
        <div class="col-6 col-search-close">
          <div class="js-search" aria-label="关闭"><i class="fa-solid fa-circle-xmark text-muted" aria-hidden="true"></i></div>
        </div>
      </div>

      <div id="search-box">
        <i class="fa-solid fa-magnifying-glass" id="search-icon" aria-hidden="true"></i>
        <input name="q" id="search-query" placeholder="请输入搜索词" autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control" aria-label="请输入搜索词">
        
        <div class="mt-4">
          <span>搜索类型: </span>
          <span>
            <input type="radio" id="all" name="search_type" value="all" checked>
            <label for="all">所有</label>
            
              <input type="radio" id="blog" name="search_type" value="blog">
              <label for="blog">原创</label>
              <input type="radio" id="trans" name="search_type" value="trans">
              <label for="trans">译文</label>
            
            <input type="radio" id="book" name="search_type" value="book">
            <label for="book">资料</label>
            <input type="radio" id="notice" name="search_type" value="notice">
            <label for="notice">公告</label>
          </span>
        </div>
      </div>
      
    </section>
    <section class="section-search-results">
      <div id="search-results-count" class="search-results-count"></div>
      <div id="search-hits">
        
      </div>
    </section>
  </div>
</aside>

        
        
            

<section class="bg-cover page-title-section overlay" style="background-image: url('/images/backgrounds/circle.svg'),url('/images/backgrounds/page-title.webp');background-size: cover;">
    <div class="container-xl">
        <div class="row">
            <div class="col-12">
                <p class="h1">
                    博客
                </p>
                <p class="page-description">
                    专注开源技术、云原生与生活随笔的分享与思考。
                </p>
                
            </div>
        </div>
    </div>
</section>

        


<section class="section-sm book-list-section bg-gray">
  <div class="container-xl">
    <div class="row">
      <div class="col-lg-8 order-2 order-lg-1">
        <div class="row">
          
          
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-ambient-terminology/">Istio Ambient 模式：图解及概念解读</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2025/02/13</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio Ambient 模式：图解及概念解读', '本文通过一份详细的 Istio Ambient 模式的术语表，帮助你更好地理解其中的关键概念及其背后的技术实现。', '\nIstio 的 Ambient 模式是一种创新的、无 Sidecar 的服务网格部署方式，通过 ztunnel 和 waypoint proxy 分离数据平面功能，简化了操作并降低了资源消耗。本篇博客将通过一份详细的术语表，帮助你更好地理解 Istio Ambient 模式中的关键概念及其背后的技术实现。\n\n## Ambient 模式\n\n![Ambient 模式架构图](ambient-mode-architecture.svg)\n\n  - **定义**：Istio 的一种无 Sidecar 的数据平面模式，通过 ztunnel 和 waypoint proxy 实现服务之间的安全通信和管理。相较于 Sidecar 模式，Ambient 模式更加轻量，降低了资源消耗并简化了配置。\n  - **架构**：数据平面功能分为 L4 层的安全覆盖层（由 ztunnel 提供）和 L7 层的策略处理层（由 waypoint proxy 提供）。\n\n## 控制平面与数据平面\n\n![控制平面与数据平面](control-plane-and-data-plane.svg)\n\n  - **定义**：在 Ambient 模式中，控制平面（\u0060istiod\u0060）负责管理集群内 ztunnel 和 waypoint proxy 的配置和策略，而数据平面由 ztunnel 和 waypoint proxy 组成，负责处理实际的网络流量。\n  - **组件交互**：ztunnel 使用 xDS APIs 从 \u0060istiod\u0060 获取配置并执行策略，管理 Pod 之间的 L4 和 L7 流量。\n\n## Istio Control Plane (\u0060istiod\u0060)\n\n  - **定义**：Istio 的控制平面组件，负责与 ztunnel 和 waypoint proxy 通信，提供 xDS 接口用于动态配置。\n  - **功能**：\u0060istiod\u0060 使用 xDS APIs 进行配置推送，动态管理 Ambient 模式中的流量策略、证书分发以及与 Kubernetes 集群的交互。\n\n## 透明性与非侵入性\n\n  - **定义**：Ambient 模式的架构旨在减少对应用的侵入性，应用无需感知数据平面的存在，Pod 无需重启或注入 Sidecar 即可加入网格。\n  - **优势**：提高了服务网格的灵活性，降低了操作复杂度，使应用和基础设施的生命周期更加解耦。\n\n## Sidecar Proxy\n\n![Sidecar 模式](sidecar-mode.svg)\n\n  - **定义**：传统 Istio 中的 Envoy 代理，与应用容器共同部署在一个 Pod 中。\n  - **问题**：对应用具有侵入性，Sidecar 必须在 Pod 中注入并伴随应用运行，增加了资源开销，并且使应用与代理的生命周期耦合。\n\n## Ztunnel (Zero-Trust Tunnel)\n\n![ztunnel](ztunnel.svg)\n\n  - **定义**：Ambient 模式中的关键组件，部署为 DaemonSet，为每个节点提供 L4 层的零信任隧道。\n  - **功能**:\n    - **安全**：提供 mTLS 加密和基于 SPIFFE ID 的身份验证，确保节点和工作负载之间的安全通信。\n    - **可观测性**：收集 L4 层的 TCP 指标和日志。\n    - **连接多路复用和均衡**：在节点之间建立安全的流量隧道，以优化连接和网络性能。\n    - **多租户架构**：单个 ztunnel 可以代表同一节点上的多个工作负载进行 L4 数据平面功能处理，这与每个应用 Pod 拥有自己代理的 Sidecar 模式形成对比。\n    - **证书管理**：ztunnel 代表节点内的所有 Pod 从 Istio 控制平面 (\u0060istiod\u0060) 获取 mTLS 证书，并负责证书的管理和轮换。\n  - **接口**:\n    - **\u0060pistioin\u0060 和 \u0060pistioout\u0060**：用于与节点上的 \u0060istioin\u0060 和 \u0060istioout\u0060 接口通过 GENEVE 隧道连接。\n\n## Waypoint Proxy\n\n![Waypoint Proxy](waypoint-proxy.svg)\n\n  - **定义**：Ambient 模式中的 L7 层代理，部署在每个命名空间级别，用于处理 L7 层请求。\n  - **功能**：提供 L7 授权策略，如基于 HTTP headers 的访问控制、L7 级别的遥测等。Waypoint Proxy 只处理需要的 L7 代理流量，其他 L4 流量由 ztunnel 处理。\n\n## GENEVE 隧道 (Generic Network Virtualization Encapsulation)\n\n![GENEVE 协议组成](geneve.svg)\n\n  - **定义**：用于在 Kubernetes 节点之间建立虚拟隧道连接，将流量从节点上的 Pod 转发到 ztunnel。\n  - **在 Ambient 模式中的应用**：GENEVE 隧道用于连接节点上的虚拟网络接口（\u0060istioin\u0060 和 \u0060istioout\u0060）与 ztunnel 内的接口（\u0060pistioin\u0060 和 \u0060pistioout\u0060）。\n\n## HBONE (HTTP-Based Overlay Network Environment)\n\n![HBONE 数据包格式](hbone.svg)\n\n\u003c!--\n\u0060\u0060\u0060\n\u002b-----------------\u002b\n|    IP Header    | \u003c-- 源 IP，目标 IP，协议类型\n\u002b-----------------\u002b\n|    TCP Header   | \u003c-- 源端口，目标端口，序列号，确认号，标志位等\n\u002b-----------------\u002b\n|    TLS Header   | \u003c-- 握手消息，证书，加密应用数据\n\u002b-----------------\u002b\n| HTTP\/2 \u0026 CONNECT| \u003c-- HTTP 方法，目标地址，请求头，路径等\n\u002b-----------------\u002b\n|  Application    | \u003c-- 应用层数据，字节流，例如 HTTP 请求\n\u002b-----------------\u002b\n\u0060\u0060\u0060\n--\u003e\n\n  - **定义**：Istio 特有的安全隧道协议，用于在 Ambient 模式组件之间传输数据。HBONE 是一种基于 HTTP\/2 和 HTTP CONNECT 建立的安全 mTLS 加密通道。\n  - **实现方式**：通过 HTTP\/2 进行多路复用，通过 HTTP CONNECT 建立隧道，并使用 mTLS 确保安全性。详见 [Istio 文档](https:\/\/istio.io\/latest\/docs\/ambient\/architecture\/hbone\/)。\n\n## Istioin 和 Istioout 虚拟接口\n\n![Ambient 模式中两个位于两个不同节点上的 Pod 访问路径](ambient-ztunnel-routing.svg)\n\n  - **定义**：由 Istio CNI 插件在每个节点上配置的两个虚拟接口，用于处理进入和离开节点的流量。\n  - **功能**：\u0060istioin\u0060 处理进入节点的流量，\u0060istioout\u0060 处理离开节点的流量。两者通过 GENEVE 隧道连接到 ztunnel 中相应的接口。\n\n## iptables 和流量重定向\n\n  - **定义**：用于配置 Linux 内核中的流量规则，将来自 Ambient 工作负载的流量进行重定向和标记。\n  - **在 Ambient 模式中的应用**：Istio CNI 插件通过 iptables 规则，将流量标记并重定向到 \u0060istioin\u0060 或 \u0060istioout\u0060，然后通过 GENEVE 隧道传递给 ztunnel。\n\n## 流量拦截与重定向 (Traffic Redirection)\n\n  - **定义**：Ambient 模式中，ztunnel 负责透明拦截所有进出 \u0022in-mesh\u0022 Pod 的流量并将其加密后重定向到其他节点上的目标 Pod，确保网络流量符合服务网格的安全策略。\n  - **机制**：通过 Istio CNI 插件安装的 iptables 规则或 eBPF 程序，ztunnel 能够透明地捕获工作负载的流量，并在不改变客户端应用的情况下进行安全代理。\n\n## 流量路径分类\n\n  - **Out of Mesh**：Pod 没有加入服务网格，流量不会被 Ambient 数据平面处理。\n  - **In Mesh**：Pod 被纳入 Ambient 数据平面，L4 层的流量被 ztunnel 拦截和处理，提供 L4 授权和安全加密。\n  - **In Mesh, Waypoint Enabled**：Pod 被纳入 Ambient 数据平面且启用了 waypoint proxy，L7 层的流量通过 waypoint 进行高级策略处理。\n\n## TPROXY\n\n![TPROXY 作为透明代理，客户端和服务端都对其无感知](tproxy.svg)\n\n  - **定义**：Linux 内核功能，用于透明拦截和重定向网络流量。\n  - **在 Ambient 模式中的应用**：ztunnel 使用 TPROXY 来拦截和处理流量，保留原始源 IP 和端口信息，从而实现透明代理功能。\n\n## Mutual TLS (mTLS)\n\n![Istio 中的安全身份架构（以 Sidecar 模式为例）](istio-mtls-process.svg)\n\n  - **定义**：一种双向 TLS 认证机制，确保通信双方的身份验证和数据加密。\n  - **在 Ambient 模式中的应用**：通过 ztunnel 和 waypoint proxy 确保工作负载之间的 mTLS 加密，实现零信任安全。\n\n详见 [如何理解 Istio 中的 MTLS 流量加密？](\/blog\/understanding-the-tls-encryption-in-istio\/)\n\n## SPIFFE ID\n\n![SPIFFE ID 格式](spiffe.svg)\n\nIstio 服务网格中所有工作负载将根据其服务账户注册 SPIFFE 标准的服务身份格式：\u0060spiffe:\/\/\u003ctrust-domain\u003e\/ns\/\u003cnamespace\u003e\/sa\/\u003cservice-account\u003e\u0060。\n\n  - **定义**：用于标识工作负载的身份标识符，在服务网格中用于身份管理。\n  - **在 Ambient 模式中的应用**：SPIFFE ID 被用于对节点和工作负载进行身份验证，以确保网络通信的安全性。\n\n详见 [为什么 Istio 要使用 SPIRE 做身份认证？](\/blog\/why-istio-need-spire\/)\n\n## eBPF (Extended Berkeley Packet Filter)\n\n  - **定义**：eBPF 是 Linux 内核中的一种技术，用于在内核空间中运行沙盒程序，实现网络数据包处理等功能。\n  - **在 Ambient 模式中的应用**：eBPF 可以替代传统的 iptables 和 GENEVE 隧道，用于流量重定向和管理。eBPF 更高效、复杂度更低且易于管理。\n  - **eBPF 程序**:\n    - 应用入站\n    - 应用出站\n    - Ztunnel 主机入站\n    - Ztunnel 入站\n  - **作用**：Istio CNI 使用 eBPF 程序将它们挂载在特定的 TC 点，用于处理应用和 ztunnel 的网络流量。\n\n## Waypoint Proxy 的弹性扩展\n\n![Waypoing Proxy 作为 Deployment 部署在 Kubernetes 中](ambient-waypoint-proxy-scale.svg)\n\n  - **定义**：在 Ambient 模式中，waypoint proxy 可以根据流量需求动态扩展，而无需为每个工作负载实例部署独立代理。\n  - **优势**：通过动态扩展 waypoint proxy，可以降低基础设施成本并提高资源利用率。\n\n## Ztunnel 的弹性和故障恢复\n\n  - **定义**：ztunnel 部署为 DaemonSet，如果 ztunnel 容器失效，Kubernetes 会自动重新调度，以确保节点流量的继续处理。\n  - **特点**：使得故障的影响范围最小化，仅影响该节点上的工作负载。\n\n## IP Set 和 ztunnel-pods-ips\n\n  - **定义**：IP Set 是用于存储 IP 地址的工具，\u0060ztunnel-pods-ips\u0060 是每个节点上用于存储 Ambient 网格 Pod IP 的集合。\n  - **在 Ambient 模式中的应用**：Istio CNI 插件会将每个加入 Ambient 网格的 Pod IP 添加到 \u0060ztunnel-pods-ips\u0060 中，以确保这些 Pod 的流量可以被 iptables 规则识别和处理。\n\n## 连接多路复用 (Connection Multiplexing)\n\n  - **定义**：在单个物理连接中传输多条逻辑连接的技术。\n  - **在 Ambient 模式中的应用**：ztunnel 实现了连接多路复用，使多个工作负载可以共享相同的连接，提升网络效率。\n\n## 节点网络的虚拟接口对 (veth)\n\n  - 定义：每个 Pod 在运行时会在节点上创建一个虚拟接口对，用于将 Pod 的网络连接到节点的网络。\n  - 在 Ambient 模式中的应用：veth 接口用于将 Pod 的流量连接到节点的虚拟接口（如 \u0060istioin\u0060 和 \u0060istioout\u0060），从而将流量引导至 ztunnel 进行处理。\n\n## Waypoint Proxy 的流量路径\n\n![Waypoint Proxy 的流量路径](waypoint-proxy-routing.svg)\n\n  - **定义**：Waypoint Proxy 只参与服务器端的流量路径，作为 L7 代理执行服务端的请求。\n  - **应用场景**：当部署了 Waypoint Proxy 时，来自同一服务账户的工作负载将通过 ztunnel 重定向至 Waypoint Proxy 进行处理，然后到达目标 Pod，确保 L7 级别的策略和认证得以执行。\n\n## Istio CNI (Container Network Interface)\n\n- **定义**：Istio 的容器网络接口插件，用于在 Kubernetes 集群中自动配置流量拦截规则。\n- **功能**：Istio CNI 负责为每个新创建或加入网格的 Pod 设置必要的网络重定向规则。它通过修改 iptables 规则或应用 eBPF 程序来确保所有流量能够被 ztunnel 或 waypoint proxy 拦截和处理，从而实现服务网格的透明流量管理。\n- **Istio CNI Node Agent**：Istio CNI Node Agent 负责在每个节点上安装 Istio CNI 插件，并更新节点的 CNI 配置，确保当 Pod 加入服务网格时能够正确地配置流量重定向规则。在 Sidecar 模式中，CNI 插件通过 iptables 配置 Pod 的网络。在 Ambient 模式中，CNI 插件负责将新的 Pod 事件推送到 Ambient 监控服务器，以便配置 Pod 的网络重定向规则。\n\n## 总结\n\nIstio Ambient 模式通过将数据平面功能分为 L4 和 L7 层的独立组件，为用户提供了更轻量且灵活的服务网格解决方案。这种方式不仅简化了服务的部署，还大幅降低了资源开销。通过术语表的方式，我们探讨了 Ambient 模式中的各种核心概念，从 ztunnel 到 waypoint proxy，再到 iptables 和 eBPF 的使用，帮助你全面了解 Istio Ambient 模式的架构和运行机制。如果你对服务网格感兴趣或正在考虑如何优化微服务通信，希望这篇文章对你有所帮助。\n', '\/blog\/istio-ambient-terminology\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文通过一份详细的 Istio Ambient 模式的术语表，帮助你更好地理解其中的关键概念及其背后的技术实现。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/free-ai-drawing-tool-raphael/">免费的 AI 绘图工具推荐：Raphael.app</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2025/01/21</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e5%b7%a5%e5%85%b7"> 
             工具
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('免费的 AI 绘图工具推荐：Raphael.app', 'Raphael 是一款完全免费的 AI 绘图工具，只需输入英文提示词即可生成效果不错的图片，适合创作者和新手尝试。', '\n在如今各种 AI 工具层出不穷的时代，找到一个好用又免费的绘图工具真的不容易。而 [Raphael.app](https:\/\/raphael.app\/) 就是一款非常值得一试的 AI 绘图工具。它简单易用，而且用英文提示词就能生成效果不错的图片。\n\n![Raphael.app 页面](https:\/\/jimmysong.io\/img\/blog\/free-ai-drawing-tool-raphael\/raphael.webp)\n\n## Raphael 简介\n\n这款以文艺复兴三杰之一拉斐尔（Raphael，全名：Raffaello Sanzio da Urbino，1483 年 4 月 6 日－1520 年 4 月 6 日）命名的工具，有以下特点：\n\n1. **完全免费**：市面上很多 AI 绘图工具要么功能受限，要么需要订阅才能解锁更多功能，而 Raphael 完全免费（至少到撰写本文为止，网站中承诺免费），无需付费也能用它创造出不错的作品。\n2. **支持英文提示**：只需要用英文简单描述你想要的图片，比如“A cat-like colorful cat”，Raphael 就可以根据提示生成对应的画面。\n3. **效果还不错**：虽然和一些高端付费工具相比还有提升空间，但 Raphael 生成的图片已经足够让人满意了，尤其对于新手或尝试 AI 绘图的人来说，它完全够用。\n\n## 谁适合用 Raphael？\n\n- **艺术爱好者**：可以用它来寻找创作灵感。\n- **内容创作者**：为博客、视频或社交媒体增加独特的视觉元素。\n- **学生和老师**：为作业或课件增添一些创意。\n- **AI 绘图初学者**：零成本尝试 AI 艺术创作。\n\n## 如何使用？\n\n操作非常简单：\n\n1. 打开 [raphael.app](https:\/\/raphael.app\/)，无需注册或登录。\n2. 输入你想要的图片描述，用英文提示词效果会更好。\n3. 点击“生成”，等待 10 秒钟左右 AI 生成图片，这一步可能需要经过 CloudFlare 的自动人机验证。\n4. 你还可以选择对生成的图片进行精修。\n5. 下载或者直接分享生成的作品。\n\n![使用 Raphael 生成的图片（一只长的像猫的五彩缤纷的鸟）](https:\/\/jimmysong.io\/img\/blog\/free-ai-drawing-tool-raphael\/cat-bird.webp)\n\n## 总结\n\nRaphael 是一个用起来特别方便的 AI 绘图工具，既免费又能生成效果不错的图片。不管你是想找灵感还是单纯玩玩 AI，都非常值得一试。\n', '\/blog\/free-ai-drawing-tool-raphael\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">Raphael 是一款完全免费的 AI 绘图工具，只需输入英文提示词即可生成效果不错的图片，适合创作者和新手尝试。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/cloud-native-observability-devops/">探索云原生可观测性：技术与团队协作的深度结合</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2025/01/20</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e5%8f%af%e8%a7%82%e6%b5%8b%e6%80%a7"> 
             可观测性
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('探索云原生可观测性：技术与团队协作的深度结合', 'TheNewStack 出品的电子书《Cloud Native Observability for DevOps Teams》读后感。', '\n最近读了 TheNewStack 发布的电子书《[Cloud Native Observability for DevOps Teams](https:\/\/thenewstack.io\/ebooks\/observability\/cloud-native-observability-for-devops-teams\/)》，虽然这本书是 2022 年出品的，但给我了很大的启发。它不仅讨论了技术工具，还深入探讨了团队协作、文化建设和未来趋势的结合点。在这本书里，“观察”不仅仅是看到数据，而是看清背后的意义。可以说，它从根本上改变了我对可观测性的理解。\n\n## 核心内容\n\n本书从基础定义到实际操作，系统地阐述了云原生可观测性的重要性及其实现方式。通过具体的工具和策略，它帮助读者理解如何整合指标、日志、追踪和混沌工程等维度，全面掌控分布式系统的健康状况，为 DevOps 团队提供高效的决策支持。\n\n### 可观测性的定义与价值\n\n书中开篇就点明：可观测性是通过系统的外部信号推断内部状态的能力。不仅是传统的指标（Metrics）、日志（Logs）、追踪（Tracing）三根支柱的组合，而是一种综合性、全局化的分析方法。正如作者所说：\n\n\u003e \u0022Observability isn’t just the ability to see each piece at a time; it’s also the ability to understand the broader picture and how these pieces combine.\u0022\n\n### 云原生环境的挑战\n\n书中特别强调了 Kubernetes 环境中日志和监控的复杂性。Kubernetes 没有内置的完整可观测性解决方案，只提供了基础功能，比如 \u0060kubectl\u0060 查看对象状态，而更高级的功能需要依赖第三方工具如 Fluentd 和 Prometheus。\n\n### 实践指南\n\n书中在实践部分提到了多种实现可观测性的具体策略和工具：\n\n- **应用日志**：通过 Fluentd 或类似工具采集容器内的标准输出日志，帮助开发者定位应用问题。\n- **集群日志**：收集 Kubernetes 核心组件如 kube-apiserver 和 etcd 的日志，适合排查系统级别的故障。\n- **事件日志**：利用 \u0060kubectl get events\u0060 快速了解集群中资源的状态变化。\n- **审计日志**：记录 API 请求，便于安全审查和权限问题的定位。\n- **混沌工程**：利用工具如 Chaos Mesh 和 Litmus Chaos，验证系统在高压或异常情况下的表现。\n\n这些实践指南强调了工具与策略的结合，从而实现全面的可观测性。\n\n## 我的思考与观点\n\n### 超越数据本身的“观察力”\n\n书中强调，单纯收集数据并不能解决问题，关键在于跨维度数据的整合与分析。例如，在性能问题排查时，指标和追踪往往无法直接关联，而这正是现有工具的短板。未来，统一数据存储和分析视角的工具，比如 OpenTelemetry 提倡的标准化方法，可能是突破口。\n\n### AI 与可观测性的结合\n\n随着 AI 技术的发展，可观测性工具也可以更智能化。例如，通过机器学习预测异常，或是自动推荐优化策略。这不仅能减少人为干预，还能提升故障响应速度。正如作者在混沌工程部分提到的：\n\n\u003e \u0022Instead of waiting for something to happen and finding out how your application fares, you put it through duress under controlled conditions to identify weaknesses and fix them.\u0022\n\n### 从团队协作到文化转型\n\n书中提到“DevOps 的终极目标是跨团队的协作与同理心”，这点深有共鸣。尤其是在复杂分布式系统中，开发和运维团队往往各自为战，导致沟通断层。跨团队协作的关键在于工具提供的透明性与共享视角，而不仅仅是技术能力。\n\n## 总结\n\n这本书的独到之处在于它从技术和人文两个角度同时切入，它让我意识到，可观测性不仅是一组工具的集合，而是一种文化、一种能力，帮助我们更深刻地理解系统，推动团队协作，并在复杂的云原生环境中建立起真正的“透明化”。\n\n最后，我想引用书中一段非常打动我的话来结尾：\n\n\u003e \u0022Observability lets you see the beautiful and complete picture that is your production software systems.\u0022\n', '\/blog\/cloud-native-observability-devops\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">TheNewStack 出品的电子书《Cloud Native Observability for DevOps Teams》读后感。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/http2-envoy-tunnel-demo/">使用 Envoy 实现 HTTP/2 CONNECT 隧道：原理与实践</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2025/01/14</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('使用 Envoy 实现 HTTP\/2 CONNECT 隧道：原理与实践', '深入讲解如何利用 HTTP\/2 CONNECT 方法创建隧道，涵盖技术原理、实践流程与示例代码。', '\n在最近对 Istio Ambient 模式的研究中，我发现 HTTP2 Connect 方法被用作创建隧道的核心技术，以实现透明流量的拦截和转发。HTTP\/2 CONNECT 隧道是一种强大的工具，可以在已有的 HTTP\/2 连接中创建高效的隧道，用于传输原始的 TCP 数据。这篇文章通过一个简单的 Demo，展示了如何使用 Envoy 来实现 HTTP\/2 CONNECT 隧道的基本功能。\n\n## 什么是 HTTP2 Connect 方法以及 HBONE 隧道？\n\nHTTP2 Connect 方法是一种标准化的方式来创建隧道，用于透明地传输数据。特别是在 Istio 的 Ambient 模式中，它为代理数据平面之间的通信提供了一种高效的手段。HBONE（HTTP-Based Overlay Network Environment）隧道则是基于这种 HTTP2 Connect 技术的实现，用于 Istio 中的透明流量拦截和转发。通过使用 HBONE，数据可以有效地通过 HTTP2 隧道安全传输，替代了传统的 Sidecar 模式。这一创新设计极大地简化了服务网格的管理和部署。\n\nHBONE 是 Istio 特有的术语，它是一种安全隧道协议，用于在 Istio 组件之间进行通信。在当前的 Istio 实现中，HBONE 协议包含了三个开放标准：\n\n- **HTTP\/2**\n- **HTTP CONNECT**\n- **Mutual TLS (mTLS)**\n\nHTTP CONNECT 用于建立隧道连接，mTLS 用于安全地加密连接，而 HTTP\/2 用于在单一安全隧道中多路复用应用连接流并传输附加的流级元数据。更多关于 HBONE 隧道的细节可以参考官方文档：[HBONE 详细介绍](https:\/\/istio.io\/latest\/docs\/ambient\/architecture\/hbone\/)。\n\n## 使用 HTTP2 Connect 建立隧道的基本原理\n\nHTTP2 Connect 方法允许我们创建一个类似于 VPN 的隧道，通过这个隧道可以安全地传递数据。建立隧道的基本步骤如下：\n\n1. 首先，客户端向代理发送一个普通的 TCP 或 HTTP 链接请求。\n2. 代理接收到请求后，代表客户端向目标服务器发送一个带有 CONNECT 方法的 HTTP2 请求。\n3. 如果服务器允许建立隧道，那么它会返回一个 HTTP2 200 OK 的响应给代理。\n5. 随后，客户端、代理和服务器之间的双向流数据就可以通过这个隧道进行传输。\n\n这种方法能够使得数据的传输过程更加透明且安全，特别适用于需要高效通信和端到端加密的场景。\n\n下图展示了 HTTP2 Connect 方法建立隧道的基本过程。\n\n\u0060\u0060\u0060mermaid \u0022HTTP2 Connect 方法建立隧道的基本过程\u0022\nsequenceDiagram\n    participant Client\n    participant Proxy\n    participant Server\n    Client-\u003e\u003eProxy: 普通 TCP 请求\n    Proxy-\u003e\u003eServer: 发送 CONNECT 请求 (HTTP2 CONNECT)\n    Server--\u003e\u003eProxy: 返回 200 OK 响应\n    Proxy--\u003e\u003eClient: 转发 200 OK 响应\n    Client-\u003e\u003eProxy: 开始传输数据\n    Proxy-\u003e\u003eServer: 转发数据\n    Server-\u003e\u003eProxy: 返回处理后的数据\n    Proxy-\u003e\u003eClient: 转发处理后的数据\n\u0060\u0060\u0060\n\n![HTTP2 Connect 方法建立隧道的基本过程](1f4003a92425618f8bf5b9c1403169a7.svg)\n\n## Demo：使用 Envoy 与上游 Server 建立 HTTP\/2 Connect 隧道\n\n本示例展示了一个基础场景：\n\n1. **客户端**：向 Envoy 代理发送文本消息。\n2. **Envoy**：接收客户端的 TCP 数据，将其封装为 HTTP\/2 CONNECT 请求，并与上游服务器建立加密隧道。\n3. **服务器**：接收来自 Envoy 的 HTTP\/2 CONNECT 流量，解封装并返回响应给客户端。\n\n架构图如下：\n\n\u0060\u0060\u0060mermaid \u0022架构图\u0022\ngraph LR\n    Client[Client] --\u003e|TCP| Envoy[Envoy Proxy]\n    Envoy --\u003e|HTTP\/2 CONNECT \u002b TLS| Server[Server]\n\u0060\u0060\u0060\n\n![架构图](b25a0e3bb0f015f7a0c8b280d1025f88.svg)\n\n我们将使用 Node.js 来编写客户端和服务端，并将服务端和 Envoy 代理运行在容器中，在本地通过客户端访问 Envoy 代理从而达到访问客户端的目的。\n\n完整的目录结构如下：\n\n\u0060\u0060\u0060\nenvoy-http2-tunnel\/\n├── certs\/\n│   ├── openssl.cnf\n│   ├── server.crt\n│   ├── server.key\n├── client\/\n│   └── client.js\n├── docker-compose.yml\n├── envoy.yaml\n└── server\/\n    ├── Dockerfile\n    └── server.js\n\u0060\u0060\u0060\n\n### 核心功能展示\n\n#### **1. HTTP\/2 CONNECT 隧道的基本实现**\n\n- 客户端通过普通的 TCP 连接与 Envoy 通信。\n- Envoy 将 TCP 数据封装为 HTTP\/2 CONNECT 请求，发送到上游服务器。\n- 服务器接收并解封装隧道中的数据，进行处理后返回响应。\n- 隧道通信对客户端完全透明。\n\n#### **2. Envoy 的透明代理能力**\n\n- Envoy 作为中间代理，将客户端与服务器之间的通信逻辑完全封装。\n- 客户端无需支持复杂的协议（如 HTTP\/2 或 TLS），Envoy 代理完成所有协议转换。\n\n#### **3. 加密通信的实现**\n\n- Envoy 与服务器之间的通信通过 TLS 加密，确保隧道内的数据安全。\n- 服务器终止 TLS，处理解密后的数据。\n\n#### **4. 隧道的简化使用场景**\n\n- 通过该 Demo，可以快速理解 HTTP\/2 CONNECT 隧道的建立和基本数据传输流程。\n\n### 环境准备\n\n#### 1. 安装 Node.js\n\n确保你的系统已安装 **Node.js**（版本 \u003e= **10.10.0**），因为 \u0060http2\u0060 模块在该版本后稳定。\n\n- **下载链接：** [Node.js 官方网站](https:\/\/nodejs.org\/)\n\n#### 2. 安装 Docker 和 Docker Compose\n\n- **Docker 下载链接：** [Docker 官方网站](https:\/\/www.docker.com\/get-started)\n- **Docker Compose 下载链接：** [Docker Compose 官方文档](https:\/\/docs.docker.com\/compose\/install\/)\n\n#### 3. 创建项目目录\n\n在你的工作空间中创建一个新目录并进入：\n\n\u0060\u0060\u0060bash\nmkdir envoy-http2-tunnel\ncd envoy-http2-tunnel\n\u0060\u0060\u0060\n\n### 生成自签名证书\n\n由于 Envoy 和服务器之间需要加密通信，我们需要生成包含正确配置的自签名证书。\n\n#### 1. 创建证书目录和 OpenSSL 配置文件\n\n创建 \u0060certs\u0060 目录：\n\n\u0060\u0060\u0060bash\nmkdir certs\ncd certs\n\u0060\u0060\u0060\n\n创建 \u0060openssl.cnf\u0060，内容如下：\n\n\u0060\u0060\u0060ini\n[ req ]\ndefault_bits       = 2048\ndefault_md         = sha256\nprompt             = no\ndistinguished_name = dn\nreq_extensions     = req_ext\n\n[ dn ]\nC            = US\nST           = California\nL            = San Francisco\nO            = My Company\nOU           = My Division\nCN           = server\n\n[ req_ext ]\nsubjectAltName = @alt_names\n\n[ alt_names ]\nDNS.1   = server\nDNS.2   = localhost\n\u0060\u0060\u0060\n\n#### 2. 生成密钥和证书\n\n运行以下命令生成密钥和证书：\n\n\u0060\u0060\u0060bash\nopenssl req -x509 -nodes -days 365 -newkey rsa:2048 \\\n  -keyout server.key -out server.crt -config openssl.cnf\n\u0060\u0060\u0060\n\n这将在 \u0060certs\u0060 目录中生成 \u0060server.key\u0060 和 \u0060server.crt\u0060 文件。\n\n### 配置 Envoy 代理\n\n我们需要配置 Envoy，使其能够接受客户端的普通 TCP 连接，将数据通过 HTTP\/2 CONNECT 隧道传递给服务器。\n\n#### 1. 创建 Envoy 配置文件\n\n在项目根目录创建 \u0060envoy.yaml\u0060，内容如下：\n\n\u0060\u0060\u0060yaml\nstatic_resources:\n  listeners:\n  - name: listener_0\n    address:\n      socket_address:\n        protocol: TCP\n        address: 0.0.0.0\n        port_value: 10000\n    filter_chains:\n    - filters:\n      - name: envoy.filters.network.tcp_proxy\n        typed_config:\n          \u0022@type\u0022: type.googleapis.com\/envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy\n          stat_prefix: tcp_stats\n          cluster: tunnel_cluster\n          tunneling_config:\n            hostname: server:8080\n          access_log:\n          - name: envoy.access_loggers.stdout\n            typed_config:\n              \u0022@type\u0022: type.googleapis.com\/envoy.extensions.access_loggers.stream.v3.StdoutAccessLog\n              log_format:\n                json_format:\n                  start_time: \u0022%START_TIME%\u0022\n                  method: \u0022%REQ(:METHOD)%\u0022\n                  path: \u0022%REQ(X-ENVOY-ORIGINAL-PATH?:PATH)%\u0022\n                  protocol: \u0022%PROTOCOL%\u0022\n                  response_code: \u0022%RESPONSE_CODE%\u0022\n                  response_flags: \u0022%RESPONSE_FLAGS%\u0022\n                  bytes_received: \u0022%BYTES_RECEIVED%\u0022\n                  bytes_sent: \u0022%BYTES_SENT%\u0022\n                  duration: \u0022%DURATION%\u0022\n                  upstream_service_time: \u0022%RESP(X-ENVOY-UPSTREAM-SERVICE-TIME)%\u0022\n                  x_forwarded_for: \u0022%REQ(X-FORWARDED-FOR)%\u0022\n                  user_agent: \u0022%REQ(USER-AGENT)%\u0022\n                  request_id: \u0022%REQ(X-REQUEST-ID)%\u0022\n                  upstream_host: \u0022%UPSTREAM_HOST%\u0022\n                  upstream_cluster: \u0022%UPSTREAM_CLUSTER%\u0022\n                  downstream_local_address: \u0022%DOWNSTREAM_LOCAL_ADDRESS%\u0022\n                  downstream_remote_address: \u0022%DOWNSTREAM_REMOTE_ADDRESS%\u0022\n  clusters:\n  - name: tunnel_cluster\n    connect_timeout: 5s\n    type: LOGICAL_DNS\n    lb_policy: ROUND_ROBIN\n    transport_socket:\n      name: envoy.transport_sockets.tls\n      typed_config:\n        \u0022@type\u0022: type.googleapis.com\/envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext\n        sni: server\n        common_tls_context:\n          validation_context:\n            trusted_ca:\n              filename: \u0022\/certs\/server.crt\u0022\n          alpn_protocols: [ \u0022h2\u0022 ]\n    http2_protocol_options: {}\n    load_assignment:\n      cluster_name: tunnel_cluster\n      endpoints:\n      - lb_endpoints:\n        - endpoint:\n            address:\n              socket_address:\n                address: server\n                port_value: 8080\n\u0060\u0060\u0060\n\n#### 2. 关键点\n\n- **Envoy 监听 TCP 连接**，将流量通过 **HTTP\/2 CONNECT 隧道**转发到服务器。\n- **客户端**只需与 **Envoy** 建立 TCP 连接，发送文本消息。\n- **Envoy**负责隧道的建立和加密，**客户端**无需感知。\n\n### 实现服务器\n\n#### 1. 创建服务器目录和文件\n\n在项目根目录创建 \u0060server\u0060 目录：\n\n\u0060\u0060\u0060bash\nmkdir server\n\u0060\u0060\u0060\n\n在 \u0060server\u0060 目录中创建 \u0060server.js\u0060 和 \u0060Dockerfile\u0060。\n\n#### 2. 编写 \u0060server.js\u0060\n\n在 \u0060server\/server.js\u0060 中添加以下代码：\n\n\u0060\u0060\u0060javascript\nconst http2 = require(\u0027http2\u0027);\nconst fs = require(\u0027fs\u0027);\n\nconst server = http2.createSecureServer({\n  key: fs.readFileSync(\u0027\/certs\/server.key\u0027),\n  cert: fs.readFileSync(\u0027\/certs\/server.crt\u0027),\n});\n\nserver.on(\u0027stream\u0027, (stream, headers) =\u003e {\n  const method = headers[\u0027:method\u0027];\n  const path = headers[\u0027:path\u0027];\n\n  if (method === \u0027CONNECT\u0027) {\n    console.log(\u0060Received CONNECT request for ${path}\u0060);\n\n    \/\/ 响应 200，建立隧道\n    stream.respond({\n      \u0027:status\u0027: 200,\n    });\n\n    \/\/ 在隧道内处理数据\n    stream.on(\u0027data\u0027, (chunk) =\u003e {\n      const message = chunk.toString();\n      console.log(\u0060Received from client: ${message}\u0060);\n\n      \/\/ 回应客户端\n      const response = \u0060Echo from server: ${message}\u0060;\n      stream.write(response);\n    });\n\n    stream.on(\u0027end\u0027, () =\u003e {\n      console.log(\u0027Stream ended by client.\u0027);\n      stream.end();\n    });\n  } else {\n    \/\/ 对于非 CONNECT 请求，返回 404\n    stream.respond({\n      \u0027:status\u0027: 404,\n    });\n    stream.end();\n  }\n});\n\nserver.listen(8080, () =\u003e {\n  console.log(\u0027Secure HTTP\/2 server is listening on port 8080\u0027);\n});\n\u0060\u0060\u0060\n\n**注意：**\n\n- 监听 \u0060secureConnection\u0060 事件，直接处理 TLS 连接后的 socket。\n- 在 socket 上接收数据，处理来自客户端的文本消息，并回复。\n\n#### 3. 创建 \u0060Dockerfile\u0060\n\n在 \u0060server\/Dockerfile\u0060 中添加以下内容：\n\n\u0060\u0060\u0060dockerfile\nFROM node:14\n\nWORKDIR \/app\n\nCOPY server.js .\n\nEXPOSE 8080\n\nCMD [\u0022node\u0022, \u0022server.js\u0022]\n\u0060\u0060\u0060\n\n### 实现客户端\n\n#### 1. 创建客户端目录和文件\n\n在项目根目录创建 \u0060client\u0060 目录：\n\n\u0060\u0060\u0060bash\nmkdir client\n\u0060\u0060\u0060\n\n在 \u0060client\u0060 目录中创建 \u0060client.js\u0060。\n\n#### 2. 编写 \u0060client.js\u0060\n\n在 \u0060client\/client.js\u0060 中添加以下代码：\n\n\u0060\u0060\u0060javascript\nconst net = require(\u0027net\u0027);\n\n\/\/ 创建与 Envoy 的 TCP 连接\nconst client = net.createConnection({ port: 10000 }, () =\u003e {\n  console.log(\u0027Connected to Envoy.\u0027);\n\n  \/\/ 发送消息给服务器\n  let counter = 1;\n  const interval = setInterval(() =\u003e {\n    const message = \u0060Message ${counter} from client!\u0060;\n    client.write(message);\n    counter \u002b= 1;\n  }, 1000);\n\n  \/\/ 关闭连接\n  setTimeout(() =\u003e {\n    clearInterval(interval);\n    client.end();\n  }, 5000);\n});\n\nclient.on(\u0027data\u0027, (data) =\u003e {\n  console.log(\u0060Received from server: ${data.toString()}\u0060);\n});\n\nclient.on(\u0027end\u0027, () =\u003e {\n  console.log(\u0027Disconnected from server.\u0027);\n});\n\nclient.on(\u0027error\u0027, (err) =\u003e {\n  console.error(\u0027Client error:\u0027, err);\n});\n\u0060\u0060\u0060\n\n**说明：**\n\n- **客户端**与 **Envoy** 建立普通的 TCP 连接，发送文本消息。\n- 该客户端的存在只是为了触发 Envoy 与服务器建立隧道。\n\n### 创建 Docker Compose 文件\n\n在项目根目录创建 \u0060docker-compose.yml\u0060：\n\n\u0060\u0060\u0060yaml\nversion: \u00273.8\u0027\n\nservices:\n  envoy:\n    image: envoyproxy\/envoy:v1.32.1\n    volumes:\n      - .\/envoy.yaml:\/etc\/envoy\/envoy.yaml\n      - .\/certs:\/certs  # 挂载证书目录\n    ports:\n      - \u002210000:10000\u0022\n    networks:\n      - envoy_network\n    depends_on:\n      - server\n    command: \/usr\/local\/bin\/envoy -c \/etc\/envoy\/envoy.yaml --service-cluster envoy --log-level debug\n\n  server:\n    build:\n      context: .\/server\n    networks:\n      - envoy_network\n    expose:\n      - \u00228080\u0022\n    volumes:\n      - .\/certs:\/certs  # 挂载证书目录\n\nnetworks:\n  envoy_network:\n\u0060\u0060\u0060\n\n### 运行示例\n\n#### 1. 启动 Docker Compose\n\n在项目根目录下，运行：\n\n\u0060\u0060\u0060bash\ndocker-compose up --build\n\u0060\u0060\u0060\n\n**预期输出：**\n\n- **Envoy 容器：** 显示启动信息和调试日志。\n- **服务器容器：** 显示 \u0060Secure HTTP\/2 server is listening on port 8080\u0060。\n\n#### 2. 运行客户端\n\n打开新的终端窗口，进入 \u0060client\u0060 目录：\n\n\u0060\u0060\u0060bash\ncd client\n\u0060\u0060\u0060\n\n运行客户端：\n\n\u0060\u0060\u0060bash\nnode client.js\n\u0060\u0060\u0060\n\n**预期输出：**\n\n\u0060\u0060\u0060\nConnected to Envoy.\nReceived from server: Echo from server: Message 1 from client!\nReceived from server: Echo from server: Message 2 from client!\nReceived from server: Echo from server: Message 3 from client!\nReceived from server: Echo from server: Message 4 from client!\nReceived from server: Echo from server: Message 5 from client!\nDisconnected from server.\n\u0060\u0060\u0060\n\n#### 3. 检查服务器日志\n\n在 Docker Compose 的输出中，你应该能看到服务器的日志：\n\n\u0060\u0060\u0060\nenvoy_1   | {\u0022downstream_remote_address\u0022:\u0022192.168.65.1:46306\u0022,\u0022path\u0022:null,\u0022request_id\u0022:null,\u0022bytes_sent\u0022:160,\u0022protocol\u0022:null,\u0022upstream_service_time\u0022:null,\u0022bytes_received\u0022:88,\u0022response_code\u0022:0,\u0022user_agent\u0022:null,\u0022downstream_local_address\u0022:\u0022172.21.0.3:10000\u0022,\u0022upstream_host\u0022:\u0022172.21.0.2:8080\u0022,\u0022start_time\u0022:\u00222024-12-03T11:37:59.542Z\u0022,\u0022upstream_cluster\u0022:\u0022tunnel_cluster\u0022,\u0022duration\u0022:5012,\u0022response_flags\u0022:\u0022-\u0022,\u0022method\u0022:null,\u0022x_forwarded_for\u0022:null}\nserver_1  | Secure HTTP\/2 server is listening on port 8080\nserver_1  | New secure connection established.\nserver_1  | Received from client: Message 1 from client!\nserver_1  | Received from client: Message 2 from client!\nserver_1  | Received from client: Message 3 from client!\nserver_1  | Received from client: Message 4 from client!\nserver_1  | Received from client: Message 5 from client!\nserver_1  | Connection ended by client.\n\u0060\u0060\u0060\n\n#### 4. 检查 Envoy 日志\n\n在 Envoy 的日志中，你可以看到它使用 **HTTP\/2 CONNECT 隧道**与服务器建立连接的记录。\n\n### 测试通信\n\n- **客户端**通过 TCP 连接向 **Envoy 代理**发送文本消息。\n- **Envoy**将客户端的 TCP 流量通过 **HTTP\/2 CONNECT 隧道**转发给 **服务器**。\n- **服务器**接收到来自客户端的消息，处理并回复。\n- **Envoy**将服务器的回复通过隧道传回给 **客户端**。\n- **客户端**收到服务器的回复。\n\n### 注意事项\n\n- **证书管理：** 确保证书正确配置，并在 Envoy 和服务器中正确使用。\n- **Docker 网络：** 使用 Docker Compose 定义的网络，容器可以通过服务名称互相通信。\n- **端口冲突：** 确保端口 \u006010000\u0060（Envoy）和 \u00608080\u0060（服务器）未被占用。\n- **TLS 配置：** 在示例中，Envoy 与服务器之间的通信使用 TLS 和 HTTP\/2，确保了安全性。\n\n## 隧道建立过程\n\n下图展示了客户端、Envoy 代理和服务器之间的交互，反映了数据的传递和隧道连接的建立的流程。\n\n\u0060\u0060\u0060mermaid \u0022隧道建立流程\u0022\nsequenceDiagram\n\nparticipant Client\nparticipant Envoy\nparticipant Server\n\n%% 客户端与 Envoy 建立 TCP 连接\nClient-\u003e\u003eEnvoy: TCP Connect\nEnvoy--\u003e\u003eClient: Connection Established\n\n%% Envoy 创建新的 TCP 代理会话\nNote over Envoy: 创建新的 TCP 代理会话 (ConnectionId: 0)\n\n%% Envoy 创建到上游服务器的连接\nEnvoy-\u003e\u003eServer: Connect to tunnel_cluster\nNote over Envoy,Server: 尝试创建新的连接 (ConnectionId: 1)\n\n%% Envoy 与服务器建立 HTTP\/2 连接\nEnvoy-\u003e\u003eServer: Establish HTTP\/2 Connection\nServer--\u003e\u003eEnvoy: Connection Established\n\n%% Envoy 通过 HTTP\/2 CONNECT 建立隧道\nEnvoy-\u003e\u003eServer: HTTP\/2 CONNECT (hostname: server:8080)\nServer--\u003e\u003eEnvoy: 200 OK (Tunnel Established)\nNote over Envoy,Server: 隧道建立成功\n\n%% 客户端发送数据\nloop Send Messages\nClient-\u003e\u003eEnvoy: Data (Message N)\nEnvoy-\u003e\u003eServer: Forward Data (Message N)\nServer--\u003e\u003eEnvoy: Response (Echo Message N)\nEnvoy--\u003e\u003eClient: Forward Response (Echo Message N)\nServer--\u003e\u003eServer: Log \u0022Received from client: Message N from client!\u0022\nend\n\n%% 客户端关闭连接\nClient-\u003e\u003eEnvoy: FIN (Close Connection)\nEnvoy-\u003e\u003eServer: FIN (Close Tunnel)\nServer--\u003e\u003eEnvoy: ACK\nEnvoy--\u003e\u003eClient: ACK\nNote over Envoy,Server: 隧道关闭\nNote over Envoy,Client: 连接关闭\n\n%% 连接关闭日志\nEnvoy--\u003e\u003eEnvoy: Log Connection Closed (ConnectionId: 0 \u0026 1)\nServer--\u003e\u003eServer: Log \u0022Stream ended by client.\u0022\n\u0060\u0060\u0060\n\n![隧道建立流程](f426fb19b797e505aed4758bdc372f45.svg)\n\n说明：\n\n1. **客户端与 Envoy 建立 TCP 连接**：\n    - 客户端向 Envoy 发起 TCP 连接请求。\n    - Envoy 接受连接，建立新的 TCP 代理会话（ConnectionId: 0）。\n2. **Envoy 创建到服务器的连接**：\n\n    - Envoy 尝试连接上游集群 \u0060tunnel_cluster\u0060，创建新的连接（ConnectionId: 1）。\n3. **建立 HTTP\/2 CONNECT 隧道**：\n\n    - Envoy 与服务器建立 HTTP\/2 连接。\n    - Envoy 发送 HTTP\/2 CONNECT 请求，目标主机名为 \u0060server:8080\u0060。\n    - 服务器响应 \u0060200 OK\u0060，隧道建立成功。\n4. **数据传输**：\n\n    - **消息传递循环**：\n        - 客户端发送数据（\u0060Message N\u0060）到 Envoy。\n        - Envoy 将数据通过隧道转发给服务器。\n        - 服务器处理数据并返回响应（\u0060Echo Message N\u0060）给 Envoy。\n        - Envoy 将响应转发给客户端。\n    - **日志记录**：\n        - 服务器记录收到的消息，例如 \u0060Received from client: Message N from client!\u0060。\n5. **连接关闭**：\n\n    - 客户端发送 FIN 请求，通知关闭连接。\n    - Envoy 将 FIN 转发给服务器，关闭隧道。\n    - 服务器响应 ACK 确认关闭。\n    - Envoy 向客户端发送 ACK，完成连接关闭。\n6. **日志记录**：\n\n    - Envoy 记录连接关闭日志，包括 ConnectionId 和统计信息。\n    - 服务器记录日志，显示流已由客户端结束，例如 \u0060Stream ended by client.\u0060。\n\n## 结语\n\n虽然这是一个入门示例，但它为理解和进一步探索 HTTP\/2 CONNECT 隧道功能提供了坚实的基础。在下一篇博客中讲解通过两个 Envoy 代理实现的隧道，带你进一步了解 Istio ambient 模式中的 HBONE 透明隧道。\n\n## 参考\n\n - [HTTP upgrades — envoy 1.33.0-dev-6d8d0b documentation](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/intro\/arch_overview\/http\/upgrades)\n - [envoy\/configs\/proxy\\_connect.yaml at 6d8d0b0ee2cc267b2cd9f57eb952863ddc8e49c3 · envoyproxy\/envoy · GitHub](https:\/\/github.com\/envoyproxy\/envoy\/blob\/6d8d0b0ee2cc267b2cd9f57eb952863ddc8e49c3\/configs\/proxy_connect.yaml)\n - [Istio Ambient 模式流量管理实现机制详解（一）- 赵化冰的博客 | Zhaohuabing Blog](https:\/\/www.zhaohuabing.com\/post\/2022-09-11-ambient-deep-dive-1\/)\n', '\/blog\/http2-envoy-tunnel-demo\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">深入讲解如何利用 HTTP/2 CONNECT 方法创建隧道，涵盖技术原理、实践流程与示例代码。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/napkin-ai-visualization-tool/">AI 工具推荐 Napkin.ai：让复杂想法一键变成直观图表</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2025/01/09</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e5%b7%a5%e5%85%b7"> 
             工具
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('AI 工具推荐 Napkin.ai：让复杂想法一键变成直观图表', 'Napkin.ai 是一款智能工具，能自动将文字生成信息图、流程图等多种图形。支持多样化样式选择和自定义调整，还能导出为多种格式。', '\n在工作中，我们经常需要清晰地传达复杂的想法，但单靠文字有时候实在不够直观。这时候，一张清晰的图表往往能让人一眼看懂你的思路。\n\n![抽象概念可视化的好处（本图使用 napkin.ai 生成）](f1.svg)\n\n今天想给大家推荐一个特别好用的工具——[Napkin.ai](https:\/\/napkin.ai)。它可以自动把你的文字内容变成图表，比如信息图、流程图等等，让你的想法更容易被理解和传播。\n\n![Napkin 界面](napkin.webp)\n\n## Napkin.ai 的核心功能\n\n1. 文本自动变图表：把文字粘贴到 Napkin.ai，系统会自动生成相关的图表，完全不用自己动手画。\n2. 图表样式多样：根据你的内容，Napkin.ai 会提供多种图表样式，你可以选择最适合的那个。\n3. 支持自定义：图表生成后还能调整，比如更改图标、颜色、字体等，让它看起来更符合你的风格。\n4. 多种格式导出：生成的图表可以导出为 PNG、SVG 或 PDF，用起来很方便。\n\n## 适合谁用\n\n![Napkin 如何提升沟通效率（本图使用 napkin.ai 生成）](f2.svg)\n\n不管你是市场营销人员、内容创作者，还是需要做商业演示的专业人士，Napkin.ai 都能帮你提升沟通效果，让你的内容更吸引人。\n\n## 如何开始？\n\n1. 打开 [napkin.ai](https:\/\/www.napkin.ai\/)。\n2. 注册一个账号（免费），目前高级版本还在 beta 阶段，暂未收费，未来的收费还未公开。\n3. 粘贴文字，生成图表，然后根据需要调整。\n4. 导出图表，用在你的工作或分享中。\n\n这款工具真的非常方便，试一次就会爱上！支持中文，而且免费使用，无次数限制。如果你也需要一个帮手来把复杂想法变得更直观，赶紧去试试吧！\n', '\/blog\/napkin-ai-visualization-tool\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">Napkin.ai 是一款智能工具，能自动将文字生成信息图、流程图等多种图形。支持多样化样式选择和自定义调整，还能导出为多种格式。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/cilium-annual-report-2024/">Cilium 2024 年度报告解读</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2025/01/07</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e5%85%b6%e4%bb%96"> 
             其他
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Cilium 2024 年度报告解读', 'Cilium 2024 年度报告回顾成就与技术创新，展望其在云原生网络与安全领域的发展。', '\n近日 Cilium 项目发布了 2024 年度报告，见 [Github](https:\/\/github.com\/cilium\/cilium.io\/blob\/main\/Annual-Reports\/Cilium_Annual_Report_2024.pdf)。这份报告详细回顾了 Cilium 在过去一年中所取得的重大成就，并展望了其在云原生网络和安全领域的未来发展方向。Cilium 项目自首次提交以来，历经近十年发展，其势头持续强劲，正引领云原生网络和安全领域的新变革。\n\n![Cilium 2024 年度报告概述](f1.svg)\n\n## Cilium 的卓越发展\n\n2024 年是 Cilium 发展历程中至关重要的一年，它不仅巩固了其作为 Kubernetes 事实标准 CNI 的地位，更发展成为 Kubernetes 环境下的综合网络堆栈。Cilium 的演进展示了其应对现代云原生环境挑战的卓越能力，从最初的 pod 到 pod 连接方案，扩展到一个统一网络、可观察性和安全性的项目，这一切都由 eBPF 技术驱动。\n\n![Cilium 在 2024 年的演变](f2.svg)\n\n## 关键里程碑与重大成就\n\n![关键里程碑与重大成就](f3.svg)\n\n- **社区蓬勃发展**：Cilium 社区持续壮大，贡献者和贡献公司数量不断增加，用户遍布金融、物流、媒体、电信等众多行业。自加入 CNCF 以来，贡献公司数量增长了 90%，达到 1,011 家，个人贡献者增长了 252%，达到 4,464 人。Cilium 还是 CNCF 生态系统中第三大发展最快的项目。\n- **技术创新**：Cilium 在 2024 年发布了 1.15 和 1.16 两个主要版本，带来了诸多创新功能。\n  - **Cilium 1.15**: 引入了对 Gateway API 1.0 的全面支持，使 Cluster Mesh 的可扩展性翻倍，增强了可观测性，将流量与网络策略关联，并扩展了 BGP 的功能，以更好地集成外部世界。\n  - **Cilium 1.16**: 以“更快、更强、更智能”为主题，通过 netkit 消除了虚拟网络开销，实现了主机和容器之间的性能对等；引入了 BGPv2 API，支持用户定义复杂的网络策略；支持多播数据路径；并显著优化了 CPU 和内存使用，同时将尾部延迟降低了高达 5 倍。\n- **广泛应用**：用户调查显示，Cilium 正在逐步接管 Kubernetes 网络堆栈，Cluster Mesh、BGP 和 Gateway API 等功能已广泛应用于生产环境。95% 的受访者运行多个 Kubernetes 集群，而 Cilium 被 CNCF 技术雷达评为顶级多集群管理工具。\n- **行业认可**：Cilium 荣获 OpenUK 2024 年度开源软件奖。同时，在 CNCF 的多集群管理技术雷达中，Cilium 被评为最值得采用的技术，并在实用性和成熟度方面均获得最高分。\n- **eBPF 安全**：eBPF 基金会发布了两份重要研究报告，提升了基于 eBPF 部署的安全性与操作指导：\n  - **eBPF 安全威胁模型**：详细阐述了 eBPF 的潜在风险，并提供了相应的缓解策略。\n  - **eBPF 验证器代码审计**：强调了验证器在保障 eBPF 部署安全方面的作用，并提出了改进建议。\n\n## 用户反馈与应用案例\n\n来自用户的反馈和案例进一步印证了 Cilium 在性能、成本效益以及功能方面的优势。用户普遍认为，Cilium 有效降低了网络成本和 CPU 消耗，同时提供了卓越的性能和低延迟。此外，Cilium 的可观察性工具（如 Hubble）以及网络策略功能也受到了用户的广泛好评。\n\n## 未来展望\n\n![Cilium 2025 年发展展望](f4.svg)\n\n展望 2025 年，Cilium 的发展势头将持续增强。平台工程和整合趋势正在重塑组织管理 Kubernetes 网络的方式，而 Cilium 正处于这场变革的核心。我们预计：\n\n- Cilium 堆栈将进一步整合网络功能。\n- Tetragon 在高级安全可观察性方面的应用将更加普及。\n- Cilium 将更深入地集成外部和传统工作负载至 Kubernetes 环境。\n- Cilium 不仅会被广泛用作 CNI，更将作为全面的 Kubernetes 网络解决方案。\n- Tetragon 将不断进化，提供更强大的检测能力和更具行动力的威胁响应方案。\n- Cilium 的混合云和多云集成将在 2025 年发挥更大的作用。\n\nCilium 对外部工作负载、4 层负载均衡以及 BGP 增强功能的支持将弥合 Kubernetes 原生系统与传统系统之间的鸿沟。\n\n## 总结\n\nCilium 项目在 2024 年取得了巨大成功，确立了其在 Kubernetes 网络领域的领导地位。Cilium 不仅仅是一个 CNI，更是一个涵盖网络、可观察性和安全性的综合 Kubernetes 网络解决方案。随着云原生技术的不断发展，Cilium 将继续引领行业创新，为用户提供更强大、更可靠的云原生网络解决方案。\n\n**注**：本文中的图片利用 [napkin.ai](https:\/\/www.napkin.ai\/) 制作。\n', '\/blog\/cilium-annual-report-2024\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">Cilium 2024 年度报告回顾成就与技术创新，展望其在云原生网络与安全领域的发展。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-ambient-packet-lifecycle-optimization/">Istio Ambient 模式中的数据包生命周期及流量优化</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2025/01/07</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio Ambient 模式中的数据包生命周期及流量优化', '解析 Istio Ambient 模式下初始数据包的详细处理与后续数据包的快速转发及流量优化策略。', '\n本文围绕 Istio Ambient 模式下的数据包生命周期进行深入剖析，从初始数据包的流量拦截与目标解析，到后续数据包的快速转发与优化策略，帮助读者理解 Ambient 模式背后的技术逻辑和性能实践。\n\n## 数据包生命周期概览：从内核态到用户态\n\n在 Ambient 模式中，数据包的处理路径从 Pod 内核态网络栈开始，经由 \u0060iptables\u0060 规则被拦截后进入 ztunnel 的用户态处理逻辑。ztunnel 负责透明代理、策略验证、加密隧道建立等任务，最终将数据包通过内核态网络再次转发给目标服务或下一个 ztunnel。其核心思想是通过首次数据包的详细解析和标记，为后续数据包铺路，从而减少重复开销。\n\n下图展示了 Istio Ambient 模式中从 Pod 到 ztunnel 的数据包生命周期：\n\n\u0060\u0060\u0060mermaid \u0022Istio Ambient 模式中从 Pod 到 ztunnel 的数据包生命周期\u0022\nsequenceDiagram\n    participant App as 应用程序\n    participant PodKernel as Pod内核态网络栈\n    participant ipt as iptables\n    participant ztunnel as ztunnel 用户态处理\n    participant HostKernel as 主机内核态\n    participant Service as 目标服务或下一个 ztunnel\n\n    rect rgb(240, 249, 255)\n    note over App: 首个数据包路径\n    App-\u003e\u003ePodKernel: 发出首个数据包\n    PodKernel-\u003e\u003eipt: 检查iptables重定向规则\n    ipt-\u003e\u003eztunnel: 将数据包重定向至zTunnel透明代理端口\n    ztunnel-\u003e\u003eztunnel: 提取目标地址 \u0026 策略验证 \u0026 建立隧道\/连接\n    ztunnel-\u003e\u003eHostKernel: 返回处理后的数据包\n    HostKernel-\u003e\u003eService: 转发至目标服务或下一个 ztunnel\n    end\n\n    rect rgb(240, 255, 240)\n    note over App: 后续数据包路径\n    App-\u003e\u003ePodKernel: 发出后续数据包\n    PodKernel-\u003e\u003ePodKernel: 利用 conntrack 匹配已有连接\n    PodKernel-\u003e\u003eztunnel: 数据包直接进入 ztunnel inbound socket（无需iptables重定向）\n    ztunnel-\u003e\u003eztunnel: 无需重复解析 \u0026 复用已有隧道\/连接\n    ztunnel-\u003e\u003eHostKernel: 返回数据包\n    HostKernel-\u003e\u003eService: 转发至目标服务或下一个 ztunnel\n    end\n\u0060\u0060\u0060\n\n![Istio Ambient 模式中从 Pod 到 ztunnel 的数据包生命周期](4c7d5e7ac5168314a5c5de34a39a4f9c.svg)\n\n接下来，我们将详细介绍首个数据包与后续数据包的处理路径，并分析其中的技术要点与优化手段。\n\n## 首个数据包路径：从拦截到目标解析\n\n当应用程序在 Pod 内发出数据包（如 HTTP 请求），数据包首先经过 Pod 的网络命名空间和内核态网络栈进行处理。\n\n### 透明拦截与目标解析\n\n\u0060iptables\u0060 规则对出站流量进行筛选，若发现目标地址为非本地资源且数据包未携带特定标记，则将数据包重定向至 ztunnel 的透明代理端口（如 \u006015006\u0060 或 \u006015008\u0060）。借助 \u0060IP_TRANSPARENT\u0060 和 \u0060SO_ORIGINAL_DST\u0060 选项，ztunnel 可提取数据包的原始目标地址，实现无缝透明代理。\n\n### 用户态处理：策略验证与加密隧道\n\n数据包进入 ztunnel 用户态后，将经历以下处理流程：\n\n1. **策略验证**：RBAC 验证、mTLS 加密判定。\n2. **目标流量处理**：对网格内部流量，通过 HTTP\/2 CONNECT 隧道（HBONE）加密与跨节点传输；对网格外流量，直接通过本地 TCP 连接透传。\n\n完成处理后，ztunnel 基于数据包解析结果建立出站连接（如 HTTP\/2 隧道或明文 TCP），并将数据包送回内核态，最终转发至目标服务或下一个 ztunnel。\n\n## 后续数据包路径：利用 Conntrack 与隧道复用\n\n首个数据包完成解析与策略验证后，Linux 内核的连接跟踪（\u0060conntrack\u0060）记录连接状态与标记。后续数据包无需再次经历复杂的拦截与解析，直接进入 ztunnel 的 inbound socket。\n\n### 连接跟踪与快速转发\n\n后续数据包基于 \u0060conntrack\u0060 跟踪机制，快速到达 ztunnel 的 inbound socket。ztunnel 可直接识别目标地址与安全策略，避免重复的解析与验证。\n\n### 隧道与明文连接优化\n\n1. **HBONE 隧道**：支持多路复用，提高加密流量处理效率。\n2. **明文连接**：对无需加密的流量，直接复用现有 TCP 连接，进一步减少处理开销。\n\n## 技术要点与优化策略\n\n- **透明代理**：利用 \u0060IP_TRANSPARENT\u0060 实现透明流量捕获与目标解析。\n- **内核与用户态高效协作**：首个数据包通过用户态完成深度处理，后续数据包借助 \u0060conntrack\u0060 与 inbound socket 实现快速转发，降低上下文切换成本。\n- **多路复用**：借助 HTTP\/2 隧道实现高效加密与负载均衡，优化传输性能。\n\n## 实践建议\n\n1. **多平台适配**：根据平台特性调整透明代理实现。\n2. **调优与监控**：结合 ztunnel 日志与服务网格监控工具，优化流量路径与性能表现。\n\n## 总结\n\nIstio Ambient 模式通过数据包生命周期设计，在透明代理、性能优化与安全策略间实现平衡。zTunnel 通过高效的用户态处理与内核态快速转发，将应用程序的透明体验与底层网络优化有效结合，助力服务网格的实践与推广。\n', '\/blog\/istio-ambient-packet-lifecycle-optimization\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">解析 Istio Ambient 模式下初始数据包的详细处理与后续数据包的快速转发及流量优化策略。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/istio-ambient-mode-ztunnel-shutdown/">[译] Istio Ambient 模式中 Ztunnel 停止运行时的流量处理机制</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2025/01/07</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://blog.howardjohn.info/posts/ztunnel-shutdown/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio Ambient 模式中 Ztunnel 停止运行时的流量处理机制', '了解 Istio Ambient 模式中 Ztunnel 停止运行的过程、流量处理机制及如何减少连接中断风险。', '\n关于 Istio 的 Ambient 模式，一个常见的问题是它如何在升级或重启期间处理流量。\n\n在 Sidecar 模型中，代理和应用程序是 1:1 的关系，这种情况下无需担心此类问题——代理在应用程序停止时会关闭，并在应用程序启动时加载最新版本。\n\n然而，Ambient 模式中，每个节点都有一个专用代理（“Ztunnel”），这意味着我们可能需要在应用程序运行时对其进行升级。\n\n## 停止运行的过程\n\nZtunnel 遵循标准的滚动更新流程。也就是说，当我们需要引入新版本时，会按照以下步骤进行：\n\n1. 启动新版本\n2. 当新版本准备就绪后，开始关闭旧版本\n3. 在一段时间内，两个版本会同时运行\n4. 最终，旧版本被关闭\n\n对于 Ztunnel，有两种类型的流量需要考虑：\n\n第一种是当同时运行多个实例时，*新建*连接会发生什么。在非常短的时间内，两个实例都会接受连接（利用 \u0060SO_REUSEPORT\u0060），这些连接由内核随机分配。然而，一旦新实例完全准备就绪，就会通知旧实例停止接受新连接，这样新实例可以开始处理所有新建连接。\n\n第二种是对于我们正在关闭的实例上的*现有*连接会发生什么。虽然应用协议通常具有通知对端停止使用的机制，例如 HTTP\/1.1 可以发送 \u0060Connection: close\u0060 标头，HTTP\/2 可以发送 \u0060GOAWAY\u0060，但 Ztunnel 在 L4 层工作，TCP 本身并没有这样的机制。为此，Ztunnel 使用了一种宽限期机制。只要仍有活动连接，旧实例就会继续运行并服务这些连接（但正如前面提到的，不再处理任何新连接）。最终，如果超出了可配置的宽限期，任何剩余的连接都会被发送 \u0060RST\u0060（连接复位）。\n\n结合起来，从“蓝色版本”升级到“绿色版本”的生命周期如下图所示：\n\n![Ztunnel 升级时间线](ztunnel-shutdown.png)\n\n第一条时间轴显示哪个实例正在积极接受连接。可以看到，这个状态从“蓝色”切换到“绿色”，其中有一个短暂的时间段内两个实例都在接受连接。\n\n第二和第三条时间轴分别显示旧实例和新实例的状态。旧实例在新实例准备就绪后开始其宽限期，最终强制终止所有剩余连接。\n\n## 我的应用程序会受到影响吗？\n\n对大多数人来说，重要的不是内部运作的细节，而是他们的应用程序是否会受到影响。简短的答案是：这取决于情况。\n\n如果你的应用程序存在比宽限期更长的连接，这些连接可能会被重置。具体影响取决于你的应用程序——有些能够更优雅地处理这种情况，而有些则不行。\n\n需要特别注意的是，**在任何时候，新建连接都不会失败**。因此，如果你的应用程序在连接终止后尝试重新建立新连接（这是正确的做法！），那么这个过程始终可以成功。\n\n## 如何减少连接重置的影响？\n\n如果你的应用程序无法很好地处理连接重置，有两种主要的方法可以缓解问题：\n\n第一种方法是确保 Ztunnel 的宽限期比你的最大连接时长更长。许多使用长连接的场景（例如连接池）可以配置连接的最大时长，并在达到最大时长后重新建立连接。如果需要，可以将此值设置得更短。此外，Ztunnel 的宽限期可以通过配置其 \u0060terminationGracePeriodSeconds\u0060 设置来调整——这个值可以设置得相当高，甚至是数小时。\n\n另一种更具侵入性但非常安全的选项是，确保升级过程中节点上没有运行应用程序。这可以通过[给节点打上隔离标记](https:\/\/kubernetes.io\/docs\/reference\/kubectl\/generated\/kubectl_cordon\/)来实现。在大多数情况下，这种方法可能过于繁琐，但如果你将 TCP 连接视为“宠物”（需要精心维护），这种方式可能是值得的。\n\n\u003e 你可能会好奇，为什么节点隔离\/关闭可以 100% 避免连接终止，而 Ztunnel 升级却不能？问题在于，Ztunnel 升级时无法通知应用程序优雅地关闭或终止连接。然而，当应用程序关闭时，它会收到 \u0060SIGTERM\u0060 信号，可以利用该信号进行优雅的关闭。当然，你的应用程序必须正确处理该信号才能获得任何好处！\n', '\/trans\/istio-ambient-mode-ztunnel-shutdown\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">了解 Istio Ambient 模式中 Ztunnel 停止运行的过程、流量处理机制及如何减少连接中断风险。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/envoy-ext-proc-guide/">深入解析 Envoy 外部处理过滤器（ext_proc）</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/12/20</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/envoy"> 
             Envoy
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('深入解析 Envoy 外部处理过滤器（ext_proc）', '本文详细介绍了 Envoy 的 ext_proc 外部处理过滤器的功能、配置与性能优化策略。通过示例演示，展示了如何配置 Envoy 与实现外部处理服务器，帮助开发人员灵活处理请求与响应。', '\n在微服务架构中，API 网关通常需要对请求和响应进行高级别的处理，如身份验证、数据转换和安全检查。Envoy 提供的 \u0060ext_proc\u0060 外部处理过滤器，是一个强大的工具，通过与 gRPC 服务交互，实现灵活的请求与响应处理。本文将深入解析该过滤器的功能、配置与性能优化策略，帮助开发人员和 DevOps 工程师高效应用该特性。\n\n## ext_proc 与其他过滤器的关系\n\n[\u0060ext_proc\u0060](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-v3\/extensions\/filters\/http\/ext_proc\/v3\/ext_proc.proto) 和 Envoy 中的其他 gRPC 接口过滤器（如 [\u0060ext_authz\u0060](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-v3\/extensions\/filters\/http\/ext_authz\/v3\/ext_authz.proto)）在功能上有相似之处，但 \u0060ext_proc\u0060 提供了更强大的功能，支持完整的请求和响应处理。这使其特别适用于需要深度内容检查和修改的应用场景。\n\n你可以通过下面的 Envoy 外部处理过滤器思维导图快速了解 \u0060ext_proc\u0060。\n\n![Envoy ext_proc 思维导图](envoy-ext-proc.svg)\n\n这张思维导图展示了 Envoy \u0060ext_proc\u0060 外部处理过滤器的核心结构和功能模块。\u0060ext_proc\u0060 通过 gRPC 双向流协议与外部服务交互，可灵活处理 HTTP 请求和响应的各个阶段，并支持同步与异步处理。\n\n## ext_proc 工作原理与配置\n\n### 定义与功能\n\n\u0060ext_proc\u0060 是 Envoy 提供的 HTTP 过滤器，支持将请求和响应外包给 gRPC 服务进行处理，允许在外部服务中实现复杂的逻辑，灵活应对业务需求。例如，在安全场景中，\u0060ext_proc\u0060 可用于执行身份验证和授权检查；在数据转换场景中，可以实现数据格式转换与内容过滤。此外，还可用于记录审计日志、动态请求重写以及内容增强等功能，适用于各种企业应用环境中的深度流量管理。\n\n### 工作原理\n\n\u0060ext_proc\u0060 使用双向 gRPC 流与外部服务通信，实现请求和响应处理的实时交互。这使得 Envoy 可以将复杂任务（如身份验证、数据转换和自定义 Header 操作）卸载到外部服务，从而提高灵活性和可扩展性。\n\nEnvoy 发送 \u0060ProcessingRequest\u0060 消息，外部服务返回 \u0060ProcessingResponse\u0060 消息。需要注意的是，每个 HTTP 请求流都会创建一个独立的 gRPC 流，而不会在多个请求之间共享。每个由 Envoy 处理的 HTTP 请求都会创建其专属的 gRPC 流，从而确保请求与响应的隔离和精确管理。\n\n这种设计允许外部服务在请求与响应生命周期的不同阶段进行干预，甚至能够生成全新的响应内容。\u0060\u0060\n\n下图概述 Envoy 外部处理过滤器的处理过程：\n\n\u0060\u0060\u0060mermaid \u0022Envoy ext_proc 流程\u0022\nsequenceDiagram\nparticipant Downstream as 下游服务\nparticipant Envoy as Envoy 网关\nparticipant ExtProc as 外部处理服务\nparticipant Upstream as 上游应用\n\nDownstream-\u003e\u003eEnvoy: 发送请求头\nEnvoy-\u003e\u003eExtProc: 提取请求头信息，发送到外部处理服务\nExtProc--\u003e\u003eEnvoy: 修改、添加或删除请求头，返回修改结果\nEnvoy-\u003e\u003eUpstream: 更新请求头，转发到上游应用\n\u0060\u0060\u0060\n\n![Envoy ext_proc 流程](622cc6601c811db8cc3254fe80f347e3.svg)\n\n### 关键功能\n\n- 请求和响应处理：读取和修改 HTTP 请求和响应的头部、主体和尾部。\n- 灵活性：根据业务需求定义自定义逻辑，弥补内置功能的不足。\n- 异步处理：支持异步处理模式，防止请求阻塞。\n\n### Envoy 配置示例\n\n以下是一个基本的 Envoy 配置示例：\n\n{{\u003cinclude_code  file=\u0022envoy.yaml\u0022\u003e}}\n\n为了理解 Envoy 配置与 gRPC 服务之间的关联，我们需要了解以下配置项如何影响流量处理：\n\n- **grpc_service**: 定义与 gRPC 服务通信的目标地址和集群名，对应 Envoy 配置中的 \u0060ext_proc_cluster\u0060。\n- **processing_mode**: 控制请求头、请求体和响应头等处理阶段的触发行为，决定了何时调用 gRPC 服务。\n- **failure_mode_allow**: 指定当 gRPC 服务失败时是否继续请求处理，确保服务在部分失败场景下的高可用性。\n- **listeners**: 定义了 Envoy 接收请求的网络地址和端口。\n- **filter_chains**: 配置请求的处理链，包括 HTTP 连接管理器和外部处理过滤器。\n- **http_filters**: 列出启用的过滤器，如 \u0060ext_proc\u0060 和 \u0060router\u0060。\n- **clusters**: 定义上游服务和外部处理 gRPC 服务的位置。\n\n详细的配置说明请参考 [Envoy 文档](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-v3\/extensions\/filters\/http\/ext_proc\/v3\/ext_proc.proto)。\n\nEnvoy 使用这些配置选项将请求和响应外包给 gRPC 服务，处理结果通过双向流协议返回，影响请求的转发行为。\n\n### gRPC 服务示例\n\n以下是一个简单的 gRPC 外部处理服务器实现，演示如何通过 \u0060ext_proc\u0060 添加自定义响应头。该实现展示了核心方法的选择和设计决策，例如使用 \u0060Process\u0060 方法持续接收请求和发送响应，确保处理过程的连续性。此外，采用 \u0060HeaderMutation\u0060 配置修改 HTTP 响应头，展现了 gRPC 消息结构与 Envoy 配置的紧密集成，便于动态扩展和灵活管理。\n\n{{\u003cinclude_code file=\u0022ext_proc_demo\/main.go\u0022\u003e}}\n\n预期结果：请求返回状态码 200，响应头中包含自定义头 \u0060x-extproc-hello: Hello from ext_proc\u0060。如果缺少该头，检查以下内容：\n\n- **gRPC 服务是否正常运行**：确认 gRPC 服务器是否已启动并监听端口 \u0060:9000\u0060。\n- **Envoy 配置是否正确**：检查 Envoy 配置文件，确保 \u0060ext_proc\u0060 过滤器已启用，并且 \u0060ext_proc_cluster\u0060 配置无误。\n- **日志和错误排查**：查看 Envoy 和 gRPC 服务器的日志，排查潜在错误。\n\n在本地运行 Envoy 和  gRPC 服务后，使用 \u0060curl\u0060 进行测试：\n\n\u0060\u0060\u0060\nenvoy -c envoy.yaml\ngo run main.go\ncurl -v http:\/\/localhost:8080\n\u0060\u0060\u0060\n\n你将看到包含自定义头 \u0060x-extproc-hello: Hello from ext_proc\u0060 的响应。\n\n你将看到如下图所示的结果。\n\n![示例结果](https:\/\/jimmysong.io\/img\/blog\/envoy-ext-proc-guide\/warp.png)\n\n在 curl 请求的响应中包含了我们自定义的 header \u0060x-extproc-hello: Hello from ext_proc\u0060。\n\n## 统计与监控\n\n\u0060ext_proc\u0060 输出的统计信息位于 \u0060http.\u003cstat_prefix\u003e.ext_proc.\u0060 命名空间，其中 \u0060stat_prefix\u0060 是 HTTP 连接管理器的前缀。常用统计信息包括：\n\n| 指标名称                   | 类型    | 描述                           |\n| -------------------------- | ------- | ------------------------------ |\n| streams_started            | Counter | 启动的 gRPC 流数量             |\n| streams_msgs_sent          | Counter | 发送的消息数量                 |\n| streams_msgs_received      | Counter | 接收的消息数量                 |\n| spurious_msgs_received     | Counter | 接收的违反协议的意外消息数量   |\n| streams_closed             | Counter | 成功关闭的流数量               |\n| streams_failed             | Counter | 产生 gRPC 错误的流数量         |\n| failure_mode_allowed       | Counter | 错误被忽略的次数（根据配置）   |\n| message_timeouts           | Counter | 配置超时内未收到响应的消息数量 |\n| rejected_header_mutations  | Counter | 被拒绝的头部更改数量           |\n| clear_route_cache_ignored  | Counter | 忽略的清理路由缓存请求数量     |\n| clear_route_cache_disabled | Counter | 被禁用的清理路由缓存请求数量   |\n\n详见 [Envoy 文档](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/configuration\/http\/http_filters\/ext_proc_filter#statistics)。\n\n## 应用场景与优化策略\n\n### 常见应用场景\n\n- 身份验证：外部身份验证服务检查用户凭证。\n- 数据审计：记录请求和响应的数据以满足合规要求。\n- 流量管理：根据动态分析调整流量路由策略。\n\n### 配置说明与优化策略\n\n- 故障恢复与负载均衡：部署多实例 gRPC 服务，使用负载均衡自动转移请求。\n\n- 消息超时与重试配置：\n\n  \u0060\u0060\u0060yaml\n  http_filters:\n    - name: envoy.filters.http.ext_proc\n      config:\n        grpc_service:\n          envoy_grpc:\n            cluster_name: ext_proc_server\n        processing_mode:\n          request_header_mode: SEND\n          response_header_mode: SEND\n        message_timeout: 500ms\n        max_message_timeout: 1000ms\n        failure_mode_allow: false\n  \u0060\u0060\u0060\n\n- 元数据选项与安全策略：\n\n  \u0060\u0060\u0060yaml\n  metadata_options:\n    forwarding_namespaces:\n      untyped: [\u0022custom_namespace\u0022]\n  \u0060\u0060\u0060\n\n## 总结\n\nEnvoy 的 \u0060ext_proc\u0060 过滤器通过灵活的请求和响应处理能力，为微服务架构中的服务治理、数据转换和请求检查提供了强大的支持。正确配置和优化 \u0060ext_proc\u0060 可以显著提高系统的灵活性和可扩展性，满足多样化的业务需求。\n\n## 参考\n\n- [External Processing](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/configuration\/http\/http_filters\/ext_proc_filter)\n- [External Processing Filter (proto)](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-v3\/extensions\/filters\/http\/ext_proc\/v3\/ext_proc.proto)\n- [go-control-plane](https:\/\/github.com\/envoyproxy\/go-control-plane)\n', '\/blog\/envoy-ext-proc-guide\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文详细介绍了 Envoy 的 ext_proc 外部处理过滤器的功能、配置与性能优化策略。通过示例演示，展示了如何配置 Envoy 与实现外部处理服务器，帮助开发人员灵活处理请求与响应。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-ambient-l7-flow-analysis/">深入 Istio Ambient 模式：从 ztunnel 到 Waypoint 代理的 L7 流量路径解析</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/12/12</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('深入 Istio Ambient 模式：从 ztunnel 到 Waypoint 代理的 L7 流量路径解析', '深入解析 Istio Ambient 模式中的 L7 流量路径，从 ztunnel 到 Waypoint 代理的透明拦截与策略应用。', '\n在 Istio Ambient 模式下，ztunnel 是节点级安全代理，在 L4 层拦截并加密服务间流量。但不负责 L7（如 HTTP）层处理。Ambient 模式中，L7 处理由 Waypoint 代理负责。当 ztunnel 发现目标服务需 L7 处理时，通过 HBONE 协议将流量转发给 Waypoint 代理进行 HTTP 层策略应用和可观察性处理，再由 Waypoint 代理经 ztunnel 转发给目标 Pod，本文将详细阐述这条 L7 流量转发链路。\n\n## Waypoint 代理的角色与责任\n\n在 Istio Ambient 模式中：\n\n- **ztunnel** 负责透明捕获 Pod 间的 L4 流量，提供 mTLS 加密和身份认证。\n\n- **Waypoint 代理** 是一个基于 Envoy 的 L7 代理，处理 HTTP 层的高级路由、策略和可观察性。\n\n当一个请求需要 L7 层策略时（如 \u0060productpage\u0060 调用 \u0060reviews-v1\u0060 服务），**ztunnel 将流量通过 HBONE 隧道转发到 Waypoint Proxy**，由 Waypoint 执行 HTTP 路由和策略。\n\n## L7 流量在 Ambient 模式中的处理路径\n\n下图展示了 L7 流量在 Ambient 模式中的处理路径。\n\n\u0060\u0060\u0060mermaid \u0022L7 流量在 Ambient 模式中的处理路径\u0022\nsequenceDiagram\n    participant SP as 源 Pod (productpage)\n    participant ZT1 as ztunnel (源节点)\n    participant WP as Waypoint Proxy\n    participant ZT2 as ztunnel (目标节点)\n    participant DP as 目标 Pod (reviews-v1)\n\n    SP-\u003e\u003eZT1: 发出请求 (HTTP\/1.1)\n    note over SP,ZT1: 流量被源节点上的 ztunnel 拦截\n    ZT1-\u003e\u003eWP: 封装为 HBONE 请求 (mTLS)\n    note over ZT1,WP: ztunnel 执行透明拦截和加密\n    WP-\u003e\u003eZT2: 应用 L7 策略后转发流量 (mTLS)\n    note over WP,ZT2: Waypoint 应用 L7 策略后发送请求\n    ZT2-\u003e\u003eDP: 解封装并转发到 Pod 应用端口 (TCP)\n    note over ZT2,DP: ztunnel 在目标节点执行流量重定向\n    DP--\u003e\u003eZT2: 响应数据 (TCP)\n    note over DP,ZT2: Pod 返回响应\n    ZT2-\u003e\u003eWP: 封装为 HBONE 响应 (mTLS)\n    WP-\u003e\u003eZT1: 应用 L7 策略后的响应 (mTLS)\n    note over WP,ZT1: Waypoint 应用 L7 策略后的响应数据\n    ZT1-\u003e\u003eSP: 解封装并返回响应 (HTTP\/1.1)\n    note over ZT1,SP: ztunnel 在源节点解封装并返回响应\n\u0060\u0060\u0060\n\n![L7 流量在 Ambient 模式中的处理路径](022a72b18c3091c40cf01bb4fad208a2.svg)\n\n下面两张图片分别展示了源 Pod 和目标 Pod 在同节点和跨节点情况下的 L7 流量处理路径。\n\n![源 pod 和目标 pod 在同一节点上的 L7 流量路径](hbone-same-node.svg)\n\n![源 pod 和目标 pod 在不同节点上的 L7 流量路径](hbone-cross-node.svg)\n\n下面是详细的流量路径。\n\n### 1. 应用请求发出\n\n假设 productpage 应用需要访问 reviews 服务。productpage Pod 内的应用向 \u0060reviews.default.svc.cluster.local:9080\u0060 发起 HTTP 请求。\n\n### 2. ztunnel L4 透明捕获与识别\n\nproductpage Pod 的出站请求首先被所在节点上的 ztunnel 拦截。ztunnel 查看从 Istio 控制面下发的配置，根据目标服务（reviews）的身份和策略，得知该服务需要经过 Waypoint 代理进行 L7 层处理。\n\n### 3. 通过 HBONE 协议转发至 Waypoint\n\nztunnel 并非使用传统的 Envoy-to-Envoy XDS 或原生 TCP\u002bmTLS 隧道，而是通过 **HBONE 协议** 与 Waypoint 代理通信。HBONE 是 Istio Ambient 模式中专门设计的无 Sidecar L7 路由协议，基于 HTTP\/2，可在透明模式下对流量进行叠加转发，从而实现灵活的服务拓扑和策略控制。\n\n在这一阶段，ztunnel 会将 L4 流量封装到 HBONE 隧道中，发送给相应的 Waypoint 代理。\n\n### 4. Waypoint 代理的 L7 策略与遥测处理\n\nWaypoint 代理（目前仍基于 Envoy 实现）收到通过 HBONE 隧道传来的流量后，通过 TLS 配置和客户端证书校验，确保下游（ztunnel）是已被认证的受信主体。它将下游客户端的身份信息（SPIFFE ID）和其他上下文元数据提取出来，以便在 L7 层策略决策中使用。\n\n执行的操作包括：\n\n- 基于 HTTP Path\/Host 的路由和流量拆分\n- 基于 Headers 的访问控制和认证策略\n- 故障注入、熔断、限流\n- 遥测数据收集（请求时延、错误率、Tracing、Metrics、Logs）\n\n完成 L7 处理后，Waypoint 代理再通过 HBONE 将流量传回到目标节点的 ztunnel。\n\n### 5. 流量到达目标 Pod\n\n目标节点上的 ztunnel 会从 Waypoint 代理接收处理过的流量（同样通过 HBONE 隧道传递），然后解封装并将流量传递给对应的 reviews Pod 中的应用容器端口。\n\n## 洞察与关键点总结\n\n### 1. Waypoint 并不知道 ztunnel 的存在\n\n- Waypoint 代理只知道目标 Pod 的 IP 地址，但目标端口被重写为 \u006015008\u0060。\n- Kubernetes \u0060iptables\u0060 规则将流量透明重定向到 ztunnel。\n\n### 2. 流量安全性：端到端加密与身份认证\n\n- 双向 TLS（mTLS）和 SPIFFE ID 校验确保了端到端安全。\n- 无法绕过 ztunnel，确保了零信任架构的完整实施。\n\n### 3. 完全透明的流量控制\n\n- 应用开发人员无需更改任何代码。\n- 流量控制、策略和可观察性完全在数据面层面透明执行。\n\n## 如何调试？\n\n在 Ambient 模式下，调试方式也有了一些变化：\n\n- **ztunnel 调试**：\n  - Istio 引入了新的 \u0060istioctl ztunnel\u0060 子命令来协助查看和调试 ztunnel 的配置与状态。\n\n- **waypoint 调试**：\n  - 虽然 Waypoint 代理仍然是 Envoy，所以仍然可以使用 \u0060istioctl pc\u0060 和 \u0060istioctl ps\u0060 来查看其路由、集群和监听器配置。\n  - \u0060istioctl waypoint\u0060 提供了更直观的配置查看和状态检查功能。\n\n## 总结\n\nIstio Ambient 模式通过 ztunnel 来处理 L4 流量并实现零信任加密与传输，再通过 Waypoint 代理为需要 L7 策略的请求提供集中处理。两者之间通过 HBONE 协议进行高效、透明的通信，实现比传统 Sidecar 模式更轻量且易于运维的架构。\n', '\/blog\/istio-ambient-l7-flow-analysis\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">深入解析 Istio Ambient 模式中的 L7 流量路径，从 ztunnel 到 Waypoint 代理的透明拦截与策略应用。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
          <div class="col-12">
 
 
 
 
 
 
 
 
 
 
 
 <nav aria-label="Page navigation">
   <ul class="pagination justify-content-center">
     
     
     
     
     
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item page-item active ">
           <a href="/blog/" class="page-link">
             1
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item">
           <a href="/blog/page/2/" class="page-link">
             2
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item">
           <a href="/blog/page/3/" class="page-link">
             3
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item">
           <a href="/blog/page/4/" class="page-link">
             4
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item">
           <a href="/blog/page/5/" class="page-link">
             5
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
     
     
     <li class="page-item">
       <a href="/blog/page/2/" class="page-link">
         »
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a class="page-link" href="/blog/page/30/">
         »»
       </a>
     </li>
     
   </ul>
 </nav>
 
</div>

        </div>
      </div>
      <!-- sidebar -->
      <aside class="col-lg-4 order-1 order-lg-2 d-none d-sm-block">
          <div class="sidebar">
          <!-- categories -->
<div class="blog-categories mb-4">
  <p class="sidebar-title">
      专栏
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/istio" class="sidebar-item">
            <span>Istio</span>
            <span>(85)</span>
        </a>
      
        <a href="/categories/service-mesh" class="sidebar-item">
            <span>Service Mesh</span>
            <span>(42)</span>
        </a>
      
        <a href="/categories/kubernetes" class="sidebar-item">
            <span>Kubernetes</span>
            <span>(25)</span>
        </a>
      
        <a href="/categories/%e9%9a%8f%e7%ac%94" class="sidebar-item">
            <span>随笔</span>
            <span>(22)</span>
        </a>
      
        <a href="/categories/%e5%85%b6%e4%bb%96" class="sidebar-item">
            <span>其他</span>
            <span>(20)</span>
        </a>
      
        <a href="/categories/envoy" class="sidebar-item">
            <span>Envoy</span>
            <span>(18)</span>
        </a>
      
        <a href="/categories/%e4%b8%9a%e6%80%81" class="sidebar-item">
            <span>业态</span>
            <span>(17)</span>
        </a>
      
        <a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f" class="sidebar-item">
            <span>云原生</span>
            <span>(14)</span>
        </a>
      
        <a href="/categories/ai" class="sidebar-item">
            <span>AI</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%ae%89%e5%85%a8" class="sidebar-item">
            <span>安全</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%bc%80%e6%ba%90" class="sidebar-item">
            <span>开源</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%b7%a5%e5%85%b7" class="sidebar-item">
            <span>工具</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e6%97%85%e8%a1%8c" class="sidebar-item">
            <span>旅行</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e5%8f%af%e8%a7%82%e6%b5%8b%e6%80%a7" class="sidebar-item">
            <span>可观测性</span>
            <span>(6)</span>
        </a>
  </div>
</div>

<div class="blog-categories mb-4">
  <p class="sidebar-title">
      资料
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/%e5%87%ba%e7%89%88%e7%89%a9" class="sidebar-item">
            <span>出版物</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e7%94%b5%e5%ad%90%e4%b9%a6" class="sidebar-item">
            <span>翻译电子书</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e6%96%87%e6%a1%a3" class="sidebar-item">
            <span>翻译文档</span>
            <span>(7)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>翻译图书</span>
            <span>(6)</span>
        </a>
      
        <a href="/categories/%e5%8e%9f%e5%88%9b%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>原创图书</span>
            <span>(2)</span>
        </a>
      
        <a href="/categories/%e6%95%99%e7%a8%8b%e6%89%8b%e5%86%8c" class="sidebar-item">
            <span>教程手册</span>
            <span>(2)</span>
        </a>
  </div>
</div>





          </div>
      </aside>
      <!-- /sidebar -->
    </div>
  </div>
</section>




<footer>
  
  <div class="footer bg-footer section-sm border-bottom overlay ">
    <div class="container-xl">
      <div class="row">
        <div class="col col-xl-4 d-sm-none mb-2 mb-lg-0 d-xl-block d-none">
          
          <p class="h3 text-white mb-4 text-uppercase">联系</p>
          
          <ul class="list-unstyled">
            
            
            <li class="mb-4 text-color">微信公众号</li>
            
            
            <li class="mb-4"><img src="/images/servicemesher-wechat.webp" width="118px" height="118px" alt="footer image"></li>
            
            
            
          
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">博客</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/blog/istio-ambient-terminology/">Istio Ambient 模式：图解及概念解读</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/free-ai-drawing-tool-raphael/">免费的 AI 绘图工具推荐：Raphael.app</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/cloud-native-observability-devops/">探索云原生可观测性：技术与团队协作的深度结合</a></li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">链接</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://istio.io/latest/zh/" target="_blank" rel="noopener noreferrer">
                  Istio 服务网格
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://tetrate.io/?jimmysong" target="_blank" rel="noopener noreferrer">
                  Tetrate 公司
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener noreferrer">
                  云原生学院|Bilibili
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/awesome-cloud-native/" target="_blank" rel="noopener noreferrer">
                  云原生开源项目大全
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://cloudnative.to" target="_blank" rel="noopener noreferrer">
                  云原生社区（中国）
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">教程</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/envoy-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Envoy 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/istio-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Istio 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/kubernetes-handbook/" >
                  Kubernetes 基础教程
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/envoy-made-simple/" >
                  简明 Envoy 教程
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">通知</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/notice/kcd-beijing-2025/">KCD Beijing 2025 - 提交议题及参会报名</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/cloud-native-community-domain-migration/">云原生社区网站域名变更通知</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/nist-sp-800-233-service-mesh-proxy-models/">资料分享：云原生应用服务网格代理模型的威胁分析指南</a></li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>

  
  <div class="copyright py-4 bg-footer overlay">
    <div class="container-xl">
      <div class="row">
        <div class="col-sm-6 text-sm-left text-center">
          <p class="mb-0 text-color">© 2017-2025 Jimmy Song 保留所有权利</p>
        </div>
        <div class="col-sm-6 text-sm-right text-center">
          <ul class="list-inline">
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://twitter.com/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-x-twitter text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/contact/" >
                    <i class="fa-brands fa-weixin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://github.com/rootsongjc" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-github text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://linkedin.com/in/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-linkedin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="mailto:rootsongjc@gmail.com" >
                    <i class="fa-solid fa-envelope text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/blog/index.xml" >
                    <i class="fa-solid fa-rss text-white"></i>
              </a>
            </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>


<!-- JS Plugins -->

<script src="/plugins/popper/popper.min.js"></script>

<script src="/plugins/bootstrap/bootstrap.min.js"></script>

<script src="/plugins/slick/slick.min.js"></script>

<script src="/plugins/filterizr/jquery.filterizr.min.js"></script>

<script src="/plugins/search/fuse.min.js"></script>

<script src="/plugins/search/mark.js"></script>

<script src="/plugins/hex_md5/hex_md5.js"></script>

<script src="/plugins/anchor/anchor.min.js"></script>

<script src="/plugins/tocbot/tocbot.min.js"></script>

<script src="/plugins/bigger-picture/bigger-picture.min.js"></script>


<!-- Main Script -->

<script src="/js/script.min.f94c22b1d478bfc9e2e0a7d954429e47b7e6d36edd423758482e04154ae1842e.js"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-ESY906ZWZ0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ESY906ZWZ0');
</script>


<!-- Baidu analysis -->
<meta name="baidu-site-verification" content="g8IYR9SNLF" />





<script>
    anchors.add();
</script>






<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>










<script src="/js/wowchemy-search.min.7a37268e7bbe4a9160c2e4c33b749816.js" type="module"></script>
<script id="search-hit-fuse-template" type="text/x-template">
  <div class="search-hit" id="summary-{{key}}">
    <div class="search-hit-content border-bottom">
      <div class="search-hit-name">
        <div class='search-hit-link'><a href="{{relpermalink}}">{{title}}</a></div>
        <div class="search-hit-metadata d-flex">
            <span class="mr-1"><i class="fa-regular fa-calendar mr-1"></i>{{date}}</span>
            <span class="mr-1"><i class="fa-regular fa-folder-open mr-1"></i>{{section}}</span>
            <span class="d-sm-block d-none"><i class="fa-solid fa-link mr-1"></i>{{relpermalink}}</span>
        </div>
        <div class="search-hit-description">{{snippet}}</div>
      </div>
    </div>
  </div>
</script>



    </body>
</html>
