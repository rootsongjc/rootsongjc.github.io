<!DOCTYPE html>
<html lang="zh"><head>
  <meta charset="utf-8">
  
  <title>博客 - Jimmy Song</title>
  

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta name="description" content="专注开源技术、云原生与生活随笔的分享与思考。">
  <meta name="author" content="Jimmy Song">
  <meta name="generator" content="Hugo 0.136.0">

  <!-- CSS plugins -->
  
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
  
  <link rel="preload" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" as="style">
  <link rel="stylesheet" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" media="screen">
  

  <!-- Main Stylesheet -->
  
  <link rel="preload" href="/scss/style.min.784204edcd29c092198e88494fa2ae755eba9ae231d6fa7faf8e7da3207b4623.css" as="style">
  <link rel="stylesheet" href="/scss/style.min.784204edcd29c092198e88494fa2ae755eba9ae231d6fa7faf8e7da3207b4623.css" media="screen">

  <!-- Bigger picture css -->
  
  <link rel="stylesheet" href="/plugins/bigger-picture/bigger-picture.min.css" media="print" onload="this.media='all'">
  <!--Favicon generate by https://realfavicongenerator.net-->
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="200x200" href="/images/favicon.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">

  <link href='/opensearchdescription.xml' rel='search' title='Content search' type='application/opensearchdescription+xml'/>

  <!--Twitter card-->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="jimmysong.io" />
  <meta name="twitter:creator" content="@jimmysongio" />
  <meta property="og:url" content="https://jimmysong.io/blog/" />
  <meta property="og:title" content="博客 | Jimmy Song" />
  <meta property="twitter:title" content="博客 | Jimmy Song" />

  
  <meta property="og:description" content="专注开源技术、云原生与生活随笔的分享与思考。" />
  <meta property="twitter:description" content="专注开源技术、云原生与生活随笔的分享与思考。" />

  
  <meta property="og:image" content="https://jimmysong.io/images/banner/default.jpg" />
  <meta property="twitter:image" content="https://jimmysong.io/images/banner/default.jpg" />

  
  
</head>
<body>
<header class="fixed-top header">
  
  
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa fa-arrow-circle-up" aria-hidden="true"></i></button>
  
  <div class="navigation w-100 ">
    <div class="container-xl">
      <nav class="navbar navbar-expand-lg navbar-light p-0">
        <a class="navbar-brand" href="/">
            
            <b>JIMMY SONG</b>
            
        </a>
        <button class="navbar-toggler rounded-0" type="button" data-toggle="collapse" data-target="#navigation"
          aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse text-center" id="navigation">
          <ul class="navbar-nav ml-auto">
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/blog">博客</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/book">资料</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/tags">标签</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/notice">公告</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/contact">联系</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/about">关于</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/community/">社区</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener">视频 <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i></a>
              
            </li>
            
            

          
          
          <li class="nav-item">
            
            
            
              
              
                
                
                
                  
                    
                    <a class="nav-link" href="/en/blog/">English</a>
                    
                  
                
              
              
              
                
                  
                    
                    
                  
                
                
                
              
          </li>
          
          
          <!-- search -->
           <button type="button" class="search-btn js-search" id="searchOpen" aria-label="Search">
              <div class="search-container d-flex justify-content-center">
              <span class="search-content">
                  <i class="fa fa-search"></i>
                  <span>搜索</span>
              </span>
              <span class="search-shortcuts d-none d-sm-block">
                  <kbd class="cmd-key">⌘</kbd>
                  <kbd class="k-key">K</kbd>
              </span>
              </div>
          </button>
          
          </ul>
        </div>
      </nav>
    </div>
  </div>
</header>


            <aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between">
        <div class="col-6 search-title">
          <p>站内搜索</p> 
        </div>
        <div class="col-6 col-search-close">
          <div class="js-search" aria-label="关闭"><i class="fa-solid fa-circle-xmark text-muted" aria-hidden="true"></i></div>
        </div>
      </div>

      <div id="search-box">
        <i class="fa-solid fa-magnifying-glass" id="search-icon" aria-hidden="true"></i>
        <input name="q" id="search-query" placeholder="请输入搜索词" autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control" aria-label="请输入搜索词">
        
        <div class="mt-4">
          <span>搜索类型: </span>
          <span>
            <input type="radio" id="all" name="search_type" value="all" checked>
            <label for="all">所有</label>
            
              <input type="radio" id="blog" name="search_type" value="blog">
              <label for="blog">原创</label>
              <input type="radio" id="trans" name="search_type" value="trans">
              <label for="trans">译文</label>
            
            <input type="radio" id="book" name="search_type" value="book">
            <label for="book">资料</label>
            <input type="radio" id="notice" name="search_type" value="notice">
            <label for="notice">公告</label>
          </span>
        </div>
      </div>
      
    </section>
    <section class="section-search-results">
      <div id="search-results-count" class="search-results-count"></div>
      <div id="search-hits">
        
      </div>
    </section>
  </div>
</aside>

        
        
            

<section class="bg-cover page-title-section overlay" style="background-image: url('/images/backgrounds/circle.svg'),url('/images/backgrounds/page-title.webp');background-size: cover;">
    <div class="container-xl">
        <div class="row">
            <div class="col-12">
                <p class="h1">
                    博客
                </p>
                <p class="page-description">
                    专注开源技术、云原生与生活随笔的分享与思考。
                </p>
                
            </div>
        </div>
    </div>
</section>

        


<section class="section-sm book-list-section bg-gray">
  <div class="container-xl">
    <div class="row">
      <div class="col-lg-8 order-2 order-lg-1">
        <div class="row">
          
          
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/seamless-cross-cluster-access-istio/">多集群 Istio 服务网格的跨集群无缝访问指南</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/07/11</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('多集群 Istio 服务网格的跨集群无缝访问指南', '探索如何在 Istio 多集群网格中利用 SPIRE 联邦、DNS 代理和东西向网关技术，有效实现服务的跨集群无缝访问。本指南将提供详细的配置示例和步骤，帮助你克服部署中的挑战，确保服务间的高效、安全通信。', '\n## 前言\n\n随着企业信息系统越来越多地采用微服务架构，如何在多集群环境中实现服务的高效、安全地跨集群访问成为了一个重要的挑战。Istio 作为一种流行的服务网格解决方案，提供了丰富的功能来支持跨集群服务的无缝连接。\n\n在部署和使用多集群服务网格时有以下难点：\n\n- 跨集群的服务注册发现与路由\n- 集群间服务的身份识别与认证\n\n本文将深入探讨如何在多集群多网格的 Istio 部署中，通过实施 SPIRE 联邦和东西向网关暴露服务的方式，实现跨集群的无缝访问。通过一系列配置和部署示例，本文旨在为读者提供一个清晰的指南，帮助理解和解决多集群服务网格部署中遇到的常见问题和挑战。\n\n## Istio 的部署模型\n\n[Istio 文档](https:\/\/istio.io\/latest\/docs\/setup\/install\/multicluster\/)中根据集群、网络、控制平面、网格、信任域及租户等维度划分了多种部署模型，我将其总结并附上适用场景说明如下表所示。\n\n{{\u003ctable \u0022Istio 的多维度部署模型及适用场景\u0022\u003e}}\n\n| 维度         | 单一配置                                   | 多元配置                                             | 适用场景说明                                                 |\n| ------------ | ------------------------------------------ | ---------------------------------------------------- | ------------------------------------------------------------ |\n| **集群**     | 一个集群托管所有服务与控制平面。           | 跨多个集群分布服务，可以共享或分离控制平面。         | 单集群适用于资源需求较小、管理相对简单的环境；多集群适合于需要高可用性、地理冗余或遵守数据驻留政策的大型组织。 |\n| **网络**     | 所有服务在单一网络内通信，无需跨网络通信。 | 服务跨越多个网络，需通过 Istio 网关进行通信。        | 单网络适用于网络简单、无复杂跨网络通信需求的场景；多网络适合在多云、混合云环境中部署，或需要跨行政边界部署的场景。 |\n| **控制平面** | 一个控制平面管理所有服务。                 | 每个控制平面管理一个或多个集群，增强隔离与可用性。   | 单控制平面适用于小型至中型部署，易于管理；多控制平面适用于大规模部署，需要高度的容错能力和安全隔离。 |\n| **网格**     | 所有服务在一个连续的服务网格中。           | 服务网格之间通过联盟进行通信，适用于不同组织或区域。 | 单网格适用于组织内部密切协作的服务；多网格适合于需要隔离不同业务线或合作伙伴间的服务，或实施强隔离的大型组织。 |\n| **信任域**    | 所有服务使用同一套密钥和证书体系。         | 不同信任域使用不同的密钥和证书，需进行信任链交换。   | 单信任域适用于信任级别统一的环境；多信任域适用于需要严格隔离、满足不同安全级别需求的复杂组织或多方合作场景。 |\n| **租户**    | 整个网格为单一租户或用户服务。             | 通过命名空间隔离，支持多个租户在同一网格中运行服务。 | 单租户适用于所有资源和服务由单一组织管理的场景；多租户适用于云服务提供商或需要在同一物理基础设施上运营多个客户的场景。 |\n\n{{\u003c\/table\u003e}}\n\n选择合适的部署模型需要考虑到实际的业务需求、安全要求、管理复杂度以及成本等因素。在生产环境中，往往是对多种部署模型的组合使用。\n\n{{\u003ctable \u0022Istio 的部署模型组合\u0022\u003e}}\n\n下表展示了在实际应用中如何结合不同的部署模型来满足更复杂的业务和技术需求：\n\n| **混合部署模型**                             | **描述**                                                     | **适用场景**                                                 |\n| -------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| **多集群 \u002b 多网格 \u002b 多控制平面**             | 不同的集群可以配置成不同的网格，每个网格都有自己的控制平面。通过网格联邦共享服务和策略。 | 适合大型组织，其中不同的业务单位需要独立运行并管理自己的服务，同时需要一定级别的服务共享和协作。 |\n| **多信任域联邦 \u002b 命名空间隔离的多租户**      | 不同的网格可以拥有不同的信任域，通过信任域联邦共享密钥和证书。同时在一个网格内部通过命名空间实现租户隔离。 | 适用于需要强隔离但又要求跨组织或跨业务线协作的环境，如跨国公司或合作伙伴网络。 |\n| **多集群 \u002b 单网格 \u002b 多控制平面**             | 多个集群共享一个服务网格，但每个集群拥有自己的控制平面来管理本地服务的配置。 | 适用于需要高可用性和灾难恢复能力的应用，各地区的集群可以独立运行，减少单点故障风险。 |\n| **多集群 \u002b 多网格 \u002b 单控制平面**             | 多个集群分布在不同的网格中，但所有网格共享一个中心控制平面。 | 适用于中心化管理的大规模部署，可以减少管理的复杂性，但对控制平面的可用性要求极高。 |\n| **多信任域 \u002b 多网格 \u002b 命名空间隔离的多租户** | 各网格拥有独立的信任域，增强安全性和隔离性。在单个网格内使用命名空间来隔离不同的租户。 | 适用于提供云服务的组织，需要隔离不同客户的数据和服务，同时在不同的法律和合规环境下操作。 |\n\n{{\u003c\/table\u003e}}\n\n这些混合模型提供了高度的灵活性和可扩展性，能够满足各种复杂的部署要求。在选择混合模型时，组织需要考虑到管理复杂性、成本、安全要求以及业务需求，以确定最合适的部署策略。通过适当的规划和设计，Istio 的灵活部署模型可以帮助组织构建出既安全又高效的服务网格架构。在大多数场景下，单信任域的多集群 \u002b 单网格 \u002b 多控制平面已足够满足需要。\n\n本文将聚焦多集群 \u002b 多网格 \u002b 多控制平面 \u002b 多信任域的混合部署模型，这是一种相当复杂的场景，如果你可以完成这种场景的部署，那么其他场景也就不在话下了。\n\n## 多集群 Istio 服务网格中的 FQDN\n\n网格间的服务要想互相访问，必须了解各自的 FQDN。FQDN 通常由服务名、命名空间和顶级域（如 \u0060svc.cluster.local\u0060）组成。在 Istio 的多集群或多网格设置中，可以通过不同的机制（如\u0060ServiceEntry\u0060、\u0060VirtualService\u0060、\u0060Gateway\u0060 配置）来控制和管理服务的路由和访问，而不是通过修改 FQDN 来实现。\n\n多集群服务网格中的 FQDN 与单集群并没有什么不同，通常遵循以下格式：\n\n\u0060\u0060\u0060\n\u003cservice-name\u003e.\u003cnamespace\u003e.svc.cluster.local\n\u0060\u0060\u0060\n\n也许你会想到通过 \u0060meshID\u0060 来区分网格？\u0060meshID\u0060 主要用于区分和管理在同一环境中或跨环境的多个 Istio 网格，\u0060meshID\u0060 并不用于直接构造服务的 FQDN。\n\n{{\u003ccallout note  \u0022\u0060meshID\u0060 的主要作用\u0022\u003e}}\n- **网格级的遥测数据聚合**：区分不同网格的数据，以便在统一平台上进行监控和分析。\n- **网格联邦**：在网格之间建立联邦关系，允许网格间共享一些配置和服务。\n- **跨网格的策略实施**：识别和应用特定于网格的策略，如安全策略和访问控制。\n{{\u003c\/callout\u003e}}\n\n## 跨集群的服务注册发现与路由\n\n在 Istio 多网格环境中，东西向网关（East-West Gateway）起着关键作用，它不仅处理网格间的入口和出口流量，还支持服务的发现和连接。当一个集群需要访问另一个集群中的服务时，它通过这个网关路由到目标服务。\n\n下图展示了跨集群的服务注册发现与路由的过程。\n\n在跨集群的 Istio 网格配置中，服务注册、发现和路由的流程是至关重要的，它们确保了不同集群中的服务可以相互发现并通信。以下是跨集群 Istio 网格中服务注册、发现与路由的基本流程：\n\n### 1. 服务注册\n\n在每个 Kubernetes 集群中，当一个服务被部署时，它的信息会被注册到 Kubernetes 的 API Server。这包括服务的名称、标签、选择器、端口等信息。\n\n### 2. 同步到 Istiod\n\nIstiod，作为控制平面，负责监控 Kubernetes API Server 的状态变化。每当有新的服务被注册或现有服务被更新时，Istiod 会自动检测到这些变化。Istiod 接着提取必要的服务信息并构建内部的服务和端点的配置。\n\n### 3. 跨集群服务发现\n\n为了使一个集群中的服务能够发现并通信到另一个集群的服务，Istiod 需要将服务端点信息同步到所有相关集群。这通常通过以下两种方式之一实现：\n   - **DNS 解析**：Istio 可配置为利用 CoreDNS 或类似服务，在 DNS 查询中返回跨集群的服务端点。当一个服务尝试解析另一个集群中的服务时，DNS 查询会返回可以访问的远程服务的 IP 地址。在本文中我们将启用 Istio 的 [DNS 代理](https:\/\/istio.io\/latest\/docs\/ops\/configuration\/traffic-management\/dns-proxy\/)实现跨集群的服务发现。在一个服务同时存在于本地和远程集群中时，在本地执行 DNS 查询只会返回本地服务的 ClusterIP，若该服务只存在于远程集群中时，DNS 查询将返回远程服务所在集群的东西向网关的负载均衡器地址，该特性也可以用于跨集群的故障恢复。\n   - **服务入口同步**：通过设置特定的 ServiceEntry 配置，使得一个集群的 Envoy 代理知道如何通过东西向网关找到并路由到另一个集群的服务。\n\n### 4. 路由和负载均衡\n\n当服务 A 需要与服务 B 通信时，它的 Envoy 代理首先解析服务 B 的名称获取 IP 地址，即服务 B 所在集群的东西向网关的负载均衡器地址。接着该东西向网关将请求路由到目标服务。Envoy 代理可以根据配置的负载均衡策略（如轮询、最少连接数等），选择最佳的服务实例来发送请求。\n\n### 5. 流量管理\n\nIstio 提供了丰富的流量管理功能，例如请求路由、故障注入、流量复制等。这些规则在 Istio 的控制平面中定义，并推送到各个 Envoy 代理执行。这样可以在跨集群环境中灵活地控制和优化服务间的通信。\n\n## 集群间服务的身份识别与认证\n\n当不同集群中运行的服务需要相互通信时，正确的身份认证和授权是确保服务安全的关键。使用 SPIFFE 可以帮助标识和验证服务的身份，但在多集群环境中需要确保这些身份是唯一且可验证的。\n\n为此，我们将设置 SPIRE 联邦来为多集群的服务分配身份并实现跨集群的身份认证：\n\n- **使用 SPIFFE 来标识服务身份**：在 SPIFFE 框架下，每个服务都会被分配一个格式为\u0060spiffe:\/\/\u003ctrust-domain\u003e\/\u003cnamespace\u003e\/\u003cservice\u003e\u0060的唯一标识符。在多集群环境中，可以通过包括集群名称在内的“trust domain”来确保身份的唯一性。例如，可以设置\u0060spiffe:\/\/foo.com\/ns\/default\/svc\/service1\u0060和\u0060spiffe:\/\/bar.com\/ns\/default\/svc\/service1\u0060，以区分不同集群中相同名称的服务。\n- **使用 SPIRE 联邦来管理集群间的证书**：它可以增强多集群服务网格中的安全性。SPIRE（SPIFFE Runtime Environment）提供了一个高度可配置的平台，用于服务身份验证和证书颁发。当使用 SPIRE 联邦时，可以实现跨集群的服务认证，通过为每个 SPIRE 集群创建 Trust Bundle 实现跨集群的身份认证。\n\n以下是实现 SPIRE 联邦的步骤说明。\n\n### 1.  配置 Trust Domain\n\n每个集群都配置为一个单独的 trust domain。这样，每个集群内的服务都将具有基于其所在 trust domain 的唯一 SPIFFE ID。例如，集群 1 的服务可能拥有 ID \u0060spiffe:\/\/cluster1\/ns\/default\/svc\/service1\u0060，而集群 2 的相同服务则为 \u0060spiffe:\/\/cluster2\/ns\/default\/svc\/service1\u0060。\n\n### 2. 建立 Trust Bundle\n\n在 SPIRE 中配置 trust relationships 以允许不同 trust domain 的节点和工作负载相互验证。这涉及到 trust domain 之间交换和接受彼此的 CA 证书或 JWT keys，确保跨集群通信的安全性。\n\n### 3. 配置 SPIRE Server 和 Agent\n\n在每个集群中部署 SPIRE Server 和 SPIRE Agent。SPIRE Server 负责管理证书颁发和续签，而 SPIRE Agent 负责将证书和密钥安全地分发给集群内的服务。\n\n{{\u003ccallout warning \u0022Istio 使用 SPIRE 联邦时的工作负载注册兼容性问题\u0022\u003e}}\n在本文中，我们将在 SPRIE Server 中使用传统的 Kubernetes Workload Registrar 来负责集群中的工作负载注册。从 SPIRE v1.5.4 起弃用了 Kubernetes Workload Registrar，转而是使用 SPIRE Controller Manager 代替，经我测试并不能与 Istio 很好的运行。\n{{\u003c\/callout\u003e}}\n\n### 4. 使用 Workload API\n\n服务可以通过 SPIRE 的 Workload API 请求和更新其身份证书。这样，服务即使在不同集群中运行，也能持续验证其身份，并安全地与其他服务通信。我们将配置 Istio 网格中的代理共享 SPIRE Agent 中的 Unix Domain Socket，从而访问 Workload API 来管理证书。\n\n### 5. 自动化证书轮换\n\n我们将使用 cert-manager 作为 SPIRE 的 [UpstreamAuthority](https:\/\/github.com\/spiffe\/spire\/blob\/v1.9.5\/doc\/plugin_server_upstreamauthority_cert_manager.md)，配置 SPIRE 自动轮换服务证书和密钥，增强系统的安全性。通过自动化轮换，即使证书被泄露，攻击者也只能在很短的时间内利用这些证书。\n\n通过这些步骤，你可以建立一个跨集群的、安全的服务身份验证框架，使得各个集群的服务能够安全地识别和通信，从而有效地降低安全风险并简化证书管理。这样的配置不仅增强了安全性，还通过分散的信任域提高了系统的可扩展性和灵活性。\n\n## 部署多集群\n\n下图展示了 Istio 多集群及 SPIRE 联邦的部署模型。\n\n![多集群网格部署模型](multi-cluster-deployment.svg)\n\n下面我将演示如何在多集群 Istio 网格中实现无缝地跨集群无缝访问。\n\n1. 在 GKE 中创建两个 Kubernetes 集群，分别命名为 \u0060cluster-1\u0060 和 \u0060cluster-2\u0060\n2. 分别在这两个集群中部署 SPIRE 并设置联邦\n3. 分别在两个集群中安装 Istio，注意配置信任域、东西向网关、入口网关、 \u0060sidecarInjectorWebhook\u0060 挂载 SPIFFE UDS 的 \u0060workload-socket\u0060，并启用 DNS 代理\n4. 部署测试应用并验证跨集群的无缝访问\n\n我们部署的各组件版本如下：\n\n- Kubernetes: v1.29.4\n- Istio: v1.22.1\n- SPIRE: v1.5.1\n- cert-manager: v1.15.1\n\n我将所有命令及步骤说明保存在 Github 上：[rootsongjc\/istio-multi-cluster](https:\/\/github.com\/rootsongjc\/istio-multi-cluster)，你可以按照该项目中的说明操作。下面是对各主要步骤的说明。\n\n### 1. 准备 Kubernetes 集群\n\n打开 Google Cloud Shell 或本地终端，并确保你已经安装了 \u0060gcloud\u0060 CLI。使用以下命令创建两个集群：\n\n\u0060\u0060\u0060bash\ngcloud container clusters create cluster-1 --zone us-central1-a --num-nodes 3\ngcloud container clusters create cluster-2 --zone us-central1-b --num-nodes 3\n\u0060\u0060\u0060\n\n### 2. 部署 cert-manager\n\n使用 cert-manager 作为根 CA 为 istiod 和 SPIRE 颁发证书。\n\n\u0060\u0060\u0060bash\n.\/cert-manager\/install-cert-manager.sh\n\u0060\u0060\u0060\n\n### 3. 部署 SPIRE 联邦\n\nSPIRE 联邦的基本信息如下：\n\n| Cluster Alias | Trust Domain |\n| ------------- | ------------ |\n| cluster-1     | foo.com      |\n| cluster-2     | bar.com      |\n\n注意：信任域不需要与 DNS 名称一致，但需要与 Istio Operator 配置中的信任域相同。\n\n执行下面的命令部署 SPIRE 联邦：\n\n\u0060\u0060\u0060bash\n.\/spire\/install-spire.sh\n\u0060\u0060\u0060\n\n想了解 Istio 中使用 SPIRE 进行身份管理的详情，请参考[使用 cert-manager 和 SPIRE 管理 Istio 中的证书](\/blog\/cert-manager-spire-istio\/)。\n\n### 4. 安装 Istio\n\n我们将使用 IstioOperator 来安装 Istio，其中为每个集群配置了：\n\n- 自动 Sidecar 注入\n- 入口网关\n- 东西向网关\n- DNS 代理\n- SPIRE 集成\n- 访问远程 Kubernetes 集群的 Secret\n\n执行下面的命令安装 Istio：\n\n\u0060\u0060\u0060bash\nistio\/install-istio.sh\n\u0060\u0060\u0060\n\n## 验证流量联邦\n\n为了验证多集群安装的正确性，我们将在两个集群中分别部署不同版本的 \u0060helloworld\u0060 应用，然后在 \u0060cluster-1\u0060 中访问 \u0060helloworld\u0060 服务，以测试以下跨集群访问场景：\n\n1. 东西向流量联邦：跨集群的服务冗余\n2. 东西向流量联邦：处理非本地目标服务\n3. 南北向流量联邦：通过远程入口网关访问服务\n\n执行下面的命令在两个集群中部署 \u0060helloworld\u0060 应用：\n\n\u0060\u0060\u0060bash\n.\/example\/deploy-helloword.sh\n\u0060\u0060\u0060\n\n### 东西向流量联邦：跨集群的服务冗余\n\n部署完成 \u0060helloworld\u0060 应用后，从 \u0060cluster-1\u0060 的 \u0060sleep\u0060 pod 访问 \u0060hellowrold\u0060 服务：\n\n\u0060\u0060\u0060bash\nkubectl exec --context=cluster-1 -n sleep deployment\/sleep -c sleep \\\n\t-- sh -c \u0022while :; do curl -sS helloworld.helloworld:5000\/hello; sleep 1; done\u0022\n\u0060\u0060\u0060\n\n下图展示的是该场景下的部署架构及流量路由路径。\n\n![东西向流量联邦：跨集群的服务冗余](east-west-traffic-federation-between-clusters-without-dns-proxying.svg)\n\n从请求结果既有 \u0060helloworld-v1\u0060 又有 \u0060helloworld-v2\u0060 的响应来看，说明跨集群的服务冗余生效了。\n\n**验证 DNS**\n\n此时，因为 \u0060helloworld\u0060 服务既存在于本地又在远程集群中，若你在 \u0060cluster-1\u0060 中查询 \u0060helloworld\u0060 服务的 DNS 名称：\n\n\u0060\u0060\u0060bash\nkubectl exec -it deploy\/sleep --context=cluster-1 -n sleep -- nslookup helloworld.helloworld.svc.cluster.local\n\u0060\u0060\u0060\n\n你将得到  \u0060cluster-1\u0060 集群中的 \u0060helloworld\u0060 服务的 ClusterIP。\n\n**验证流量路由**\n\n接下来我们将通过查看 Envoy 代理配置来验证跨集群的流量路由路径。\n\n在 \u0060cluster-1\u0060 中查看 \u0060helloworld\u0060 服务的端点：\n\n\u0060\u0060\u0060bash\nistioctl proxy-config endpoints deployment\/sleep.sleep --context=cluster-1 --cluster \u0022outbound|5000||helloworld.helloworld.svc.cluster.local\u0022\n\u0060\u0060\u0060\n\n你将得到类似下面的输出：\n\n\u0060\u0060\u0060\nENDPOINT               STATUS      OUTLIER CHECK     CLUSTER\n10.76.3.22:5000        HEALTHY     OK                outbound|5000||helloworld.helloworld.svc.cluster.local\n34.136.67.85:15443     HEALTHY     OK                outbound|5000||helloworld.helloworld.svc.cluster.local\n\u0060\u0060\u0060\n\n这两个端点，一个是 \u0060cluster-1\u0060 中的 \u0060helloworld\u0060 服务的端点，另一个是 \u0060cluster-2\u0060 的 \u0060istio-eastwestgateway\u0060 服务的负载均衡器地址。Istio 将为跨集群的 TLS 连接设置 SNI，在 \u0060cluster-2\u0060 中将通过 SNI 区分目标服务。\n\n执行下面的命令，在 \u0060cluster-2\u0060 中查询前面 SNI 的端点：\n\n\u0060\u0060\u0060bash\nistioctl proxy-config endpoints deploy\/istio-eastwestgateway.istio-system --context=cluster-2 --cluster \u0022outbound_.5000_._.helloworld.helloworld.svc.cluster.local\u0022\n\u0060\u0060\u0060\n\n你将得到类似下面的结果：\n\n\u0060\u0060\u0060\nENDPOINT           STATUS      OUTLIER CHECK     CLUSTER\n10.88.2.4:5000     HEALTHY     OK                outbound_.5000_._.helloworld.helloworld.svc.cluster.local\n\u0060\u0060\u0060\n\n这个端点就是 \u0060helloworld\u0060 服务在 \u0060cluster-2\u0060 集群中的端点。\n\n通过以上步骤，你应该了解了跨集群冗余服务的流量路径。接下来我们将删除 \u0060cluster-1\u0060 中的 \u0060helloworld\u0060 服务，不需要对 Istio 做任何配置，就可以自动实现故障转移。\n\n### 东西向流量联邦：故障转移\n\n执行下面的命令将 \u0060cluster-1\u0060  中的 \u0060helloworld\u0060 副本数量缩容为 0：\n\n\u0060\u0060\u0060bash\nkubectl -n helloworld scale deploy helloworld-v1 --context=cluster-1 --replicas 0\n\u0060\u0060\u0060\n\n再次从 \u0060cluster-1\u0060 中访问 \u0060helloworld\u0060 服务：\n\n\u0060\u0060\u0060bash\nkubectl exec --context=cluster-1 -n sleep deployment\/sleep -c sleep \\\n\t-- sh -c \u0022while :; do curl -sS helloworld.helloworld:5000\/hello; sleep 1; done\u0022\n\u0060\u0060\u0060\n\n依然可以获得来自 \u0060helloworld-v2\u0060 的响应。\n\n现在，直接删除 \u0060cluster-1\u0060 中的 \u0060helloworld\u0060 服务：\n\n\u0060\u0060\u0060bash\nkubectl delete service helloworld -n helloworld --context=cluster-1\n\u0060\u0060\u0060\n\n依然可以获得来自 \u0060helloworld-v2\u0060 的响应，这说明跨集群的故障转移生效了。\n\n下图展示了该场景下的流量路径。\n\n![东西向流量联邦：故障转移](east-west-traffic-federation-between-clusters-failover.svg)\n\n**验证 DNS**\n\n此时，因为 \u0060helloworld\u0060 服务既存在于本地又在远程集群中，若你在 \u0060cluster-1\u0060 中查询 \u0060helloworld\u0060 服务的 DNS 名称：\n\n\u0060\u0060\u0060bash\nkubectl exec -it deploy\/sleep --context=cluster-1 -n sleep -- nslookup helloworld.helloworld.svc.cluster.local\n\u0060\u0060\u0060\n\n你将得到  \u0060cluster-2\u0060 集群中东西向网关的地址和 15443 端口。\n\n### 南北向流量联邦：通过远程入口网关访问服务\n\n通过入口网关访问远程集群中的服务，是最传统的跨集群访问方式，下图展示了该场景下的流量路径。\n\n![南北向流量联邦：通过远程入口网关访问服务](north-south-traffic-federation-between-clusters.svg)\n\n执行下面的命令在 \u0060cluster-2\u0060 中创建 Gateway 和 VirtualService：\n\n\u0060\u0060\u0060bash\nkubectl apply --context=cluster-2 \\\n\t-f .\/examples\/helloworld-gateway.yaml -n helloworld\n\u0060\u0060\u0060\n\n获取 \u0060cluster-2\u0060 中的入口网关地址：\n\n\u0060\u0060\u0060bash\nGATEWAY_URL=$(kubectl -n istio-ingress --context=cluster-2 get service istio-ingressgateway -o jsonpath=\u0027{.status.loadBalancer.ingress[0].ip}\u0027)\n\u0060\u0060\u0060\n\n执行下面的验证可以通过远程入口网关访问服务：\n\n\u0060\u0060\u0060bash\nkubectl exec --context=\u0022${CTX_CLUSTER1}\u0022 -n sleep deployment\/sleep -c sleep \\\n\t-- sh -c \u0022while :; do curl -s http:\/\/$GATEWAY_URL\/hello; sleep 1; done\u0022\n\u0060\u0060\u0060\n\n你将得到来自 \u0060helloworld-v2\u0060 的响应。\n\n## 验证身份\n\n执行下面的命令获取 \u0060cluster-1\u0060 集群中 \u0060sleep\u0060 pod 中的证书：\n\n\u0060\u0060\u0060bash\nistioctl proxy-config secret deployment\/sleep -o json --context=cluster-1| jq -r \u0027.dynamicActiveSecrets[0].secret.tlsCertificate.certificateChain.inlineBytes\u0027 | base64 --decode \u003e chain.pem\nsplit -p \u0022-----BEGIN CERTIFICATE-----\u0022 chain.pem cert-\nopenssl x509 -noout -text -in cert-ab\nopenssl x509 -noout -text -in cert-aa\n\u0060\u0060\u0060\n\n如果在输出的消息中看到下面的字段，说明身份分配正确：\n\n\u0060\u0060\u0060\nSubject: C=US, O=SPIFFE\n\nURI:spiffe:\/\/foo.com\/ns\/sample\/sa\/sleep\n\u0060\u0060\u0060\n\n查看 SPIRE 中的身份信息：\n\n\u0060\u0060\u0060bash\nkubectl --context=cluster-1 exec -i -t -n spire spire-server-0 -c spire-server \\\n\t-- .\/bin\/spire-server entry show -socketPath \/run\/spire\/sockets\/server.sock --spiffeID spiffe:\/\/foo.com\/ns\/sleep\/sa\/sleep\n\u0060\u0060\u0060\n\n你将看到类似下面的输出：\n\n\u0060\u0060\u0060\nFound 1 entry\nEntry ID         : 9b09080d-3b67-44c2-a5b8-63c42ee03a3a\nSPIFFE ID        : spiffe:\/\/foo.com\/ns\/sleep\/sa\/sleep\nParent ID        : spiffe:\/\/foo.com\/k8s-workload-registrar\/cluster-1\/node\/gke-cluster-1-default-pool-18d66649-z1lm\nRevision         : 1\nX509-SVID TTL    : default\nJWT-SVID TTL     : default\nSelector         : k8s:node-name:gke-cluster-1-default-pool-18d66649-z1lm\nSelector         : k8s:ns:sleep\nSelector         : k8s:pod-uid:6800aca8-7627-4a30-ba30-5f9bdb5acdb2\nFederatesWith    : bar.com\nDNS name         : sleep-86bfc4d596-rgdkf\nDNS name         : sleep.sleep.svc\n\u0060\u0060\u0060\n\n## 生产环境建议\n\n对于生产环境，建议使用[统一网关](https:\/\/docs.tetrate.io\/service-bridge\/howto\/gateway\/unified-gateway)，通过 Tier-2 架构，在 Tier-1 边缘网关配置全局的流量路由，该边缘网关将把转写的 Istio 配置下发给 Tier-2 集群中的各个入口网关。\n\n下图展示了使用 TSB 部署的 Tier2 架构的 Istio 服务网格，其中使用 SPIRE 联邦。\n\n![使用 SPIRE、Tier2 架构的 TSB 部署的多集群 Istio 服务网格架构图](tsb-multi-cluster-architeture.svg)\n\n我们将这四个 Kubernetes 集群分为 Tier1 集群（\u0060tier1\u0060）和 Tier2 集群（\u0060cp-cluster-1\u0060、\u0060cp-cluster-2\u0060 和 \u0060cp-cluster-3\u0060）。在 T1 中安装 Edge Gateway，而在 T2 中安装 bookinfo 和 httpbin 应用程序。每个集群将拥有独立的信任域，所有这些集群将构成 SPIRE 联邦。\n\n下图展示了用户通过入口网关访问 bookinfo 和 httpbin 服务的流量路由。\n\n![统一网关架构图](tsb-unified-gateway.svg)\n\n你需要在 Istio 之上创建一个适用于多集群的逻辑抽象层，关于 TSB 中的统一网关的详细信息，请参考 [TSB 文档](https:\/\/docs.tetrate.io\/service-bridge\/howto\/gateway\/unified-gateway#scenario-1-cluster-based-routing-with-http-path-and-header-match).\n\n## 总结\n\n本文详细介绍了在 Istio 多集群网格环境中实现服务身份验证、DNS 解析和跨集群流量管理的关键技术和方法。通过精确配置 Istio 和 SPIRE 联邦，我们不仅增强了系统的安全性，还提高了服务间通信的效率和可靠性。遵循这些步骤，你将能够构建一个强大的、可扩展的多集群服务网格，满足现代应用的复杂需求。\n\n## 参考\n\n- [Deploying a Federated SPIRE Architecture - spiffe.io](https:\/\/spiffe.io\/docs\/latest\/architecture\/federation\/readme\/)\n- [Install Multi-Primary on different networks -istio.io](https:\/\/istio.io\/latest\/docs\/setup\/install\/multicluster\/multi-primary_multi-network\/)\n- [Istio SPIRE Integration - istio.io](https:\/\/istio.io\/latest\/docs\/ops\/integrations\/spire)\n- [DNS Proxying - istio.io](https:\/\/istio.io\/latest\/docs\/ops\/configuration\/traffic-management\/dns-proxy\/)\n- [Attesting Istio workload identities with SPIFFE and SPIRE - developer.ibm.com](https:\/\/developer.ibm.com\/articles\/istio-identity-spiffe-spire\/)\n- [Expanding into New Frontiers - Smart DNS Proxying in Istio - istio.io](https:\/\/istio.io\/latest\/blog\/2020\/dns-proxy\/)\n- [使用 cert-manager 和 SPIRE 管理 Istio 中的证书 - jimmysong.io](https:\/\/jimmysong.io\/blog\/cert-manager-spire-istio\/)', '\/blog\/seamless-cross-cluster-access-istio\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">探索如何在 Istio 多集群网格中利用 SPIRE 联邦、DNS 代理和东西向网关技术，有效实现服务的跨集群无缝访问。本指南将提供详细的配置示例和步骤，帮助你克服部署中的挑战，确保服务间的高效、安全通信。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/gateway-api-istio-ingress-evolution/">探索 Kubernetes Ingress、Gateway API 与 Istio 的演进和转型</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/07/02</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('探索 Kubernetes Ingress、Gateway API 与 Istio 的演进和转型', '本文深入分析了 Kubernetes Gateway API、Istio 与 Ingress 的联系、差异及迁移策略。', '\n随着 Istio 1.22 版本的发布，Istio API 已正式升级至 v1 版本，同期，Kubernetes Gateway API 也更新至 v1.1 版本。本篇文章旨在深入探索 Ingress API、Istio API 与 Kubernetes Gateway API 之间的联系与区别，并详述它们在现实应用中的选择及迁移策略。\n\n## 前言\n\n之前，我曾撰写一篇文章，讨论了 [为何 Gateway API 是 Kubernetes 与服务网格入口中的未来方向](\/blog\/why-gateway-api-is-the-future-of-ingress-and-mesh\/)。文章中指出，作为 Kubernetes 的初始入口网关，Ingress 的资源模型由于过于简单，难以满足当下的可编程网络需求。作为其接班人，Gateway API 近年来发展迅速，获得了广泛支持，包括众多新兴的开源网关项目如 [Envoy Gateway](https:\/\/gateway.envoyproxy.io) 也选择基于 Gateway API 开发。此外，一些传统网关项目也开始适配 Gateway API，或通过 [ingress2gateway](https:\/\/github.com\/kubernetes-sigs\/ingress2gateway) 这样的工具进行迁移。\n\nGateway API，作为 Kubernetes 入口网关的最新成果，通过角色划分来分离关注点，并支持跨 namespace，更适合多云环境。它整合了入口网关（南北向）与服务网格（东西向，集群内路由）的重叠功能，为云原生时代的统一流量管理提供了新的参考模型。\n\nIngress API、Gateway API 与 Istio API 都能实现网关功能，它们之间具体有何联系与区别？本文将为你揭晓这一迷题，并提供 Kubernetes 环境中网关的选择和迁移策略。\n\n## Kubernetes 中的流量管理\n\n随着微服务架构的广泛应用和日益增长的复杂性，Kubernetes 的流量管理工具也在不断演进以适应各种技术需求。Ingress API、Istio API 与 Kubernetes Gateway API 分别标志着这一演变的不同阶段。\n\n**Ingress API** 提供了 Kubernetes 的基本流量管理功能，允许用户通过定义简单的路由规则（例如 HTTP 和 HTTPS）来管理外部访问集群内服务的流量。其设计虽简洁，但功能有限，主要适用于规模较小、结构较简单的应用场景。\n\n相比之下，**Istio API** 作为服务网格的一部分，提供了一系列高级流量管理功能，如流量镜像、金丝雀发布和断路器，适合于需要复杂流量管理的大规模微服务架构。\n\n为了克服 Ingress API 的局限性并集成类似 Istio 的高级功能，**Kubernetes Gateway API** 因应而生。它不仅在设计上提供了更高的灵活性和扩展性，还通过社区的广泛支持，成为连接传统 Ingress 实现和现代服务网格技术如 Istio 的桥梁，目前主流的开源网关都是基于 Gateway API 或已进行适配。\n\n以下表格概述了这三者的核心特点和推荐使用场景：\n\n| API 名称    | 对象类型                    | 状态                    | 推荐使用场景                                                 |\n| ----------- | --------------------------- | ----------------------- | ------------------------------------------------------------ |\n| Ingress API | \u0060Ingress\u0060                   | 稳定 (Kubernetes v1.19) | 适用于小规模和简单的应用场景，主要用于基本的路由配置         |\n| Istio API   | \u0060VirtualService\u0060、\u0060Gateway\u0060 | 稳定 (Istio 1.22)       | 适用于高度复杂的微服务架构，需细粒度控制和高级流量管理特性的场景 |\n| Gateway API | \u0060HTTPRoute\u0060、\u0060Gateway\u0060      | 稳定 (Gateway API v1.1) | 适用于新部署或现有部署，需提高灵活性和可扩展性的场景，特别是结合 Istio 使用 |\n\n[Gateway API v1.1](https:\/\/kubernetes.io\/blog\/2024\/05\/09\/gateway-api-v1-1\/) 的推出，特别是其在提升与现有 Ingress 配置兼容性方面的改进，为用户提供了一个平稳的迁移途径，使从传统的 Ingress 解决方案向更现代的、功能更全面的 Gateway API 的过渡变得更为顺畅。\n\n## 从 Ingress 迁移到 Kubernetes Gateway API\n\n若想从 Ingress 迁移到 Gateway API，请按以下步骤操作：\n\n1. **理解关键差异**：与 Ingress 相比，Gateway API 引入了多种新的概念和资源类型，如 \u0060Gateway\u0060、\u0060HTTPRoute\u0060 和 \u0060TLSRoute\u0060。这些资源提供了更多的配置选项和灵活性，请参阅 [Gateway API 文档](https:\/\/gateway-api.sigs.k8s.io\/guides\/)以了解其配置。\n2. **配置入口点**：创建 \u0060Gateway\u0060 资源配置，明确定义如何接收外部流量，包括配置协议、端口和 TLS 终端。\n3. **映射旧资源**：将现有的 Ingress 资源映射到对应的 Gateway API 资源。例如，Ingress 中的 host 和 path 规则需要转换为 HTTPRoute 中的路由规则。\n4. **测试与部署**：在正式迁移之前，在测试环境中验证新的 Gateway API 配置，确保所有流量路由正常，无安全漏洞。\n\n为了简化迁移过程，你可以使用工具如 [ingress2gateway](https:\/\/github.com\/kubernetes-sigs\/ingress2gateway)，该工具能自动将 Ingress 配置转换为 Gateway API 格式。\n\n## 实际迁移示例\n\n以下是一个简单的 HTTP 网关配置示例，展示了如何将 Ingress 迁移到 Gateway API。\n\n假设现有一个 Ingress 配置如下：\n\n\u0060\u0060\u0060yaml\napiVersion: networking.k8s.io\/v1\nkind: Ingress\nmetadata:\n  name: example-ingress\nspec:\n  rules:\n  - host: example.com\n    http:\n      paths:\n      - path: \/\n        pathType: Prefix\n        backend:\n          service:\n            name: example-service\n            port:\n              number: 80\n\u0060\u0060\u0060\n\n要将其迁移到 Gateway API，首先需要创建一个 Gateway 对象：\n\n\u0060\u0060\u0060yaml\napiVersion: gateway.networking.k8s.io\/v1\nkind: Gateway\nmetadata:\n  name: example-gateway\nspec:\n  gatewayClassName: example-gateway-class\n  listeners:\n    - name: http\n      protocol: HTTP\n      port: 80\n      allowedRoutes:\n        kinds\n          - kind: HTTPRoute\n\u0060\u0060\u0060\n\n请确保 \u0060gatewayClassName\u0060 指向你集群中配置的有效 GatewayClass。GatewayClass 通常由集群管理员设置，是一个为 Gateway 提供配置的资源。\n\n接下来，创建 HTTPRoute 资源来定义路由规则，将流量路由到后端服务：\n\n\u0060\u0060\u0060yaml\napiVersion: gateway.networking.k8s.io\/v1\nkind: HTTPRoute\nmetadata:\n  name: example-httproute\nspec:\n  parentRefs:\n  - name: example-gateway\n  hostnames:\n  - \u0022example.com\u0022\n  rules:\n  - matches:\n    - path:\n        type: PathPrefix\n        value: \u0022\/\u0022\n    backendRefs:\n    - name: example-service\n      port: 80\n\u0060\u0060\u0060\n\n在此示例中，我们看到：\n\n- \u0060Ingress\u0060 对象中的规则被直接映射到 \u0060HTTPRoute\u0060 对象中。\n- 路由规则中的主机名匹配、路径匹配以及后端服务配置保持不变，只是对象和字段名称有所不同。\n\n## 考虑的挑战\n\n虽然可以将 Ingress 迁移到 Gateway API，并可能同时运行它们，但需要考虑以下挑战和迁移的必要性：\n\n- **功能差异**：某些 Ingress 控制器的特定功能可能在 Gateway API 中没有直接对应，可能需要通过额外的配置或自定义资源来实现。\n- **多资源管理**：Gateway API 的使用可能涉及比 Ingress 更多的资源类型和更复杂的配置，这可能增加管理的复杂性。\n\n对于现有的 Ingress 和 Istio API 用户，是否需要迁移到 Gateway API 取决于具体情况。以下是一些迁移建议：\n\n- **新部署**：建议直接采用 Gateway API，以便利用其先进特性和预见未来的发展。\n- **现有部署**：如果现有系统运行稳定且无需高级特性，可以继续使用现有 API；如果希望利用 Gateway API 的新特性或计划未来长期发展，逐步迁移则是一个理智的选择。\n\n对于不同网关对 Gateway API 的支持情况，可以参考 [Gateway API 实现项目的一致性报告](https:\/\/gateway-api.sigs.k8s.io\/implementations\/v1.1\/)了解详细信息。\n\n## 总结\n\nIngress API、Istio API 和 Kubernetes Gateway API 各具特色，适应不同的应用场景和需求。选择合适的 API，进行合理的规划和管理，可以显著提高系统的灵活性和稳定性。随着 Gateway API 的持续发展和成熟，它将越来越成为未来流量管理的主流选择。\n\n选择合适的网关技术，结合你的具体需求和现有架构，可以更好地管理和优化流量，确保应用的高效和稳定运行。随着技术的进步和社区的发展，Gateway API 提供了一个强大且灵活的框架，使得从传统的 Ingress 迁移到更现代的解决方案变得更为简单和高效。\n\n## 参考\n\n- [Migrating from Ingress - gateway-api.sigs.k8s.io](https:\/\/gateway-api.sigs.k8s.io\/guides\/migrating-from-ingress\/)\n- [Extending Gateway API support in Istio - istio.io](https:\/\/istio.io\/latest\/blog\/2022\/gateway-api-beta\/)', '\/blog\/gateway-api-istio-ingress-evolution\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文深入分析了 Kubernetes Gateway API、Istio 与 Ingress 的联系、差异及迁移策略。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/everything-you-need-to-know-about-llama-3-most-powerful-open-source-model-yet-concepts-to-usage/">[译] 了解 Llama 3：迄今最强大的免费开源大模型从概念到使用</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/07/01</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/ai"> 
             AI
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://www.unite.ai/everything-you-need-to-know-about-llama-3-most-powerful-open-source-model-yet-concepts-to-usage/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('了解 Llama 3：迄今最强大的免费开源大模型从概念到使用', '探索 Llama 3：Meta 推出的创新开源 LLM，介绍其架构、训练和实践应用，助力 AI 开发者。', '\nMeta 公司最近发布了 [Llama 3](https:\/\/ai.meta.com\/blog\/meta-llama-3\/)，这是其最新一代尖端开源大型语言模型（LLM）。基于其前身的基础之上，Llama 3 旨在提升 Llama 2 作为与 ChatGPT 竞争的重要开源产品的能力，如文章 [Llama 2: 深入探索开源挑战者 ChatGPT](https:\/\/www.unite.ai\/llama-2-a-deep-dive-into-the-open-source-challenger-to-chatgpt\/) 中全面回顾的那样。\n\n在本文中，我们将讨论 Llama 3 背后的核心概念，探索其创新架构和训练过程，并提供关于如何负责任地访问、使用和部署这一开创性模型的实际指导。无论你是研究人员、开发者还是 AI 爱好者，这篇文章都将为你提供利用 Llama 3 为你的项目和应用赋能的知识和资源。\n\n## Llama 的演变：从 Llama 2 到 Llama 3\n\nMeta 的 CEO，Mark Zuckerberg，在 [Threads.net](https:\/\/www.threads.net\/@zuck\/post\/C56MFEKxl-x) 上宣布了 Llama 3 的首次亮相，这是 Meta AI 开发的最新 AI 模型。这个尖端模型现在已开源，旨在提升 Meta 的各种产品，包括 Messenger 和 Instagram。Zuckerberg 强调，Llama 3 使 Meta AI 成为最先进的[免费可用的 AI 助手](https:\/\/about.fb.com\/news\/2024\/04\/meta-ai-assistant-built-with-llama-3\/)。\n\n在我们讨论 Llama 3 的具体细节之前，让我们简要回顾一下它的前身，Llama 2。Llama 2 于 2022 年推出，是开源 LLM 领域的一个重要里程碑，提供了一个强大而高效的模型，可以在消费者硬件上运行。\n\n然而，尽管 Llama 2 取得了显著的成就，但它也有其局限性。用户报告了一些问题，如错误拒绝（模型拒绝回答无害的提示）、有限的帮助性，以及在推理和代码生成等领域的改进空间。\n\n进入 Llama 3：Meta 对这些挑战和社区的反馈做出了回应。通过 Llama 3，Meta 设定了与当今市场上顶级专有模型相媲美的最佳开源模型的目标，同时也优先考虑了负责任的开发和部署实践。\n\n## Llama 3：架构和训练\n\nLlama 3 的一项关键创新是其分词器，特点是显著扩展的词汇表，**128,256 个 token**（从 Llama 2 的 32,000 个增加）。这更大的词汇表允许更有效的文本编码，无论是输入还是输出，可能导致更强的多语言能力和整体性能的提升。\n\nLlama 3 还采用了**分组查询注意力**（GQA），这是一种提高可扩展性的有效表示技术，有助于模型更有效地处理更长的上下文。**8B** 版本的 Llama 3 使用了 GQA，而**8B** 和 **70B** 模型都可以处理长达 **8,192 个 token**的序列。\n\n### 训练数据和扩展\n\n用于 Llama 3 的训练数据是其性能提升的关键因素。Meta 精心策划了一个包含超过 **15 万亿** token 的庞大数据集，来自公开可获得的在线来源，是用于 Llama 2 的数据集的七倍。这个数据集还包括了超过 5% 的高质量非英语数据，涵盖了 **30 多种语言**，为未来的多语言应用做准备。\n\n为了确保数据质量，Meta 采用了先进的过滤技术，包括启发式过滤器、NSFW 过滤器、语义去重和训练在 Llama 2 上预测数据质量的文本分类器。团队还进行了广泛的实验，以确定预训练的最佳数据来源组合，确保 Llama 3 在广泛的用例上表现良好，包括琐事、STEM、编码和历史知识。\n\n放大预训练是 Llama 3 开发的另一个关键方面。Meta 开发了缩放法则，使他们能够在实际训练之前预测其最大模型在关键任务上的性能，如代码生成。这些信息指导了关于数据组合和计算分配的决策，最终导致了更有效和有效的培训。\n\nLlama 3 最大的模型是在两个定制构建的 24,000 GPU 集群上训练的，利用数据并行、模型并行和流水线并行技术的组合。Meta 的先进训练堆栈自动化了错误检测、处理和维护，最大化了 GPU 的运行时间，使训练效率比 Llama 2 提高了大约三倍。\n\n### 指令微调和性能\n\n为了充分发挥 Llama 3 在聊天和对话应用中的潜力，Meta 创新了其指令微调方法。其方法结合了**监督微调**（SFT）、拒绝抽样、**近端政策优化**（PPO）和**直接偏好优化**（DPO）。\n\nSFT 中使用的提示质量和在 PPO 和 DPO 中使用的偏好排名在对齐模型的性能中起着关键作用。Meta 的团队精心策划了这些数据，并对由人类注释者提供的注释进行了多轮质量保证。\n\n通过 PPO 和 DPO 对偏好排名进行训练还显著提高了 Llama 3 在推理和编码任务上的性能。Meta 发现，即使模型在直接回答推理问题时遇到困难，它仍然可能产生正确的推理迹象。通过偏好排名的训练，模型学会了如何从这些迹象中选择正确的答案。\n\n![对比结果](f2.jpg)\n\n成果显而易见：Llama 3 在常见的行业基准测试中表现优于许多可用的开源聊天模型，为 LLM 的 8B 和 70B 参数级别建立了新的最佳性能。\n\n![](f3.png)\n\n## 负责任的开发和安全考虑\n\n在追求尖端性能的同时，Meta 也优先考虑了负责任的开发和部署实践，用于 Llama 3。该公司采用了系统级方法，将 Llama 3 模型视为更广泛生态系统的一部分，使开发者能够设计和定制模型以满足其特定用例和安全要求。\n\n![](f4.png)\n\nMeta 进行了广泛的红队演习，执行了对抗评估，并实施了安全缓解技术，以降低其指令调优模型中的残余风险。然而，该公司承认可能仍会存在残余风险，并建议开发者在其特定用例的背景下评估这些风险。\n\n为支持负责任的部署，Meta 更新了其负责任使用指南，为开发者提供了一个全面的资源，以实施模型和系统级安全最佳实践，用于他们的应用。该指南涵盖了内容审查、风险评估和使用安全工具（如 Llama Guard 2 和 Code Shield）等主题。\n\nLlama Guard 2，基于 MLCommons 分类法构建，旨在对 LLM 输入（提示）和响应进行分类，检测可能被视为不安全或有害的内容。CyberSecEval 2 在其前身的基础上增加了措施，以防止模型的代码解释器被滥用、攻击性网络安全能力和对提示注入攻击的易感性。\n\nCode Shield 是 Llama 3 新推出的一个介绍，增加了推断时间的不安全代码过滤，减轻了不安全代码建议、代码解释器滥用和安全命令执行等风险。\n\n## 访问和使用 Llama 3\n\n随着 Meta AI 的 Llama 3 发布，已推出了几种开源工具，可在各种操作系统上进行本地部署，包括 Mac、Windows 和 Linux。本节详细介绍了三个值得注意的工具：Ollama、Open WebUI 和 LM Studio，每个工具都提供了利用 Llama 3 功能的独特功能。\n\n**Ollama**：适用于 Mac、Linux 和 Windows，[Ollama](https:\/\/ollama.com\/download) 简化了在个人计算机上操作 Llama 3 和其他大型语言模型的过程，即使是那些硬件较弱的设备也是如此。它包括一个包管理器，便于模型管理，并支持跨平台的下载和运行模型的命令。\n\n**Open WebUI with Docker**：这个工具提供了一个用户友好的、基于 [Docker](https:\/\/docs.docker.com\/desktop\/) 的界面，兼容 Mac、Linux 和 Windows。它与 Ollama 注册表中的模型无缝集成，允许用户在本地 Web 界面内部署和交互，例如 Llama 3。\n\n**LM Studio**：面向 Mac、Linux 和 Windows 的用户，[LM Studio](https:\/\/lmstudio.ai\/) 支持一系列模型，基于 llama.cpp 项目构建。它提供了一个聊天界面，便于直接与各种模型进行交互，包括 Llama 3 8B Instruct 模型。\n\n这些工具确保用户可以在个人设备上高效利用 Llama 3，满足技术技能和需求的不同范围。每个平台都提供了设置和模型交互的分步过程，使先进的人工智能更加易于开发者和爱好者接触。\n\n## 大规模部署 Llama 3\n\n除了直接提供模型权重外，Meta 还与各种云提供商、模型 API 服务和硬件平台合作，实现 Llama 3 的无缝部署。\n\nLlama 3 的一大优势是其改进的 token 效率，这要归功于新的分词器。基准测试显示，与 Llama 2 相比，Llama 3 需要的 token 减少了 **15%**，从而实现了更快、更经济的推断。\n\nGrouped Query Attention (GQA) 的整合在 Llama 3 的 8B 版本中有助于保持与 Llama 2 的 7B 版本相当的推断效率，尽管参数数量增加了。\n\n为简化部署流程，Meta 提供了 Llama Recipes 代码库，其中包含开源代码和微调、部署、模型评估等示例。这个代码库为开发者提供了一个宝贵的资源，帮助他们利用 Llama 3 的能力来应用到他们的应用中。\n\n对于那些有兴趣探索 Llama 3 性能的人来说，Meta 已经将其最新模型整合到 Meta AI 中，这是一个以 Llama 3 技术构建的领先人工智能助手。用户可以通过各种 Meta 应用程序，如 Facebook、Instagram、WhatsApp、Messenger 和 Web 与 Meta AI 进行交互，以完成任务、学习、创造和与他们关心的事物建立联系。\n\n## Llama 3 接下来会怎样？\n\n尽管 8B 和 70B 模型标志着 Llama 3 发布的开始，但 Meta 对这款开创性 LLM 的未来有雄心勃勃的计划。\n\n在未来几个月，我们可以期待看到新功能的引入，包括多模态（能够处理和生成不同数据模态，如图像和视频）、多语言支持（支持多种语言）和更长的上下文窗口，以提高在需要广泛上下文的任务上的性能。\n\n此外，Meta 计划发布更大的模型大小，包括目前正在训练中的超过 4000 亿参数的模型，这些模型在性能和能力方面展现出了有前途的趋势。\n\n为了进一步推进该领域的发展，Meta 还将发布关于 Llama 3 的详细研究论文，与广泛的 AI 社区分享其发现和见解。\n\n作为即将推出的内容的预览，Meta 分享了一些其最大 LLM 模型在各种基准上的早期性能快照。尽管这些结果是基于早期检查点的，并且可能会发生变化，但它们提供了一个激动人心的展望，展示了 Llama 3 的未来潜力。\n\n## 结论\n\nLlama 3 代表了开源大型语言模型演变的一个重要里程碑，推动了性能、能力和负责任开发实践的边界。凭借其创新架构、庞大的训练数据集和尖端的微调技术，Llama 3 为 LLM 的 8B 和 70B 参数级别建立了新的最佳性能基准。\n\n然而，Llama 3 不仅仅是一个强大的语言模型；它还体现了 Meta 致力于培养一个开放和负责任的 AI 生态系统的承诺。通过提供全面的资源、安全工具和最佳实践，Meta 授权开发者充分利用 Llama 3 的潜力，同时确保根据其特定用例和受众的需求实现负责任的部署。\n\n随着 Llama 3 之旅的继续，随着新的能力、模型大小和研究发现的出现，AI 社区热切期待从这款开创性 LLM 中涌现出的创新应用和突破。\n\n无论你是一名推动自然语言处理边界的研究人员、一名构建下一代智能应用的开发者还是对最新进展感到好奇的 AI 爱好者，Llama 3 都承诺成为你工具箱中的强大工具，开启新的大门并解锁一系列可能性。\n', '\/trans\/everything-you-need-to-know-about-llama-3-most-powerful-open-source-model-yet-concepts-to-usage\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">探索 Llama 3：Meta 推出的创新开源 LLM，介绍其架构、训练和实践应用，助力 AI 开发者。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/multiple-wechat-instances-on-mac/">如何在 Mac 电脑上实现微信多开</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/06/26</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e9%9a%8f%e7%ac%94"> 
             随笔
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('如何在 Mac 电脑上实现微信多开', '本文详细介绍了如何在 Mac 电脑上通过简单的技巧实现微信的多开功能，适用于需要同时管理多个微信账号的用户。', '\n微信是我们在日常生活和工作中不可或缺的通讯工具，许多用户都有在同一台设备上登录多个微信账号的需求。尽管官方客户端不直接支持这一功能，但通过一些简单的技巧，你可以在 Mac 电脑上实现微信的多开功能。\n\n你可能看到过一些介绍如何在 Mac 上实现微信多开的文章或视频，那些技巧大多已经失效，有的可用的也只能在一台电脑上同时登录两个微信，本文将详细介绍如何在 Mac 上同时运行任意多个微信实例。\n\n下面是演示视频。\n\n{{\u003c responsive_video src=\u0022\/\/player.bilibili.com\/player.html?isOutside=true\u0026aid=1755949960\u0026bvid=BV1w4421D7rJ\u0026cid=1596875705\u0026p=1\u0022 aspectRatio=\u002262.5%\u0022 \u003e}}\n\n下面是详细步骤。\n\n## 步骤一：创建微信的副本\n\n首先，你需要在应用程序文件夹中找到微信应用程序（WeChat.app）并创建启动命令副本：\n\n1. 打开访达（Finder）后，按下快捷键 \u0060CMD \u002b Shift \u002b G\u0060\n2. 在弹出的输入框中输入目录 \u0060\/Applications\/WeChat.app\/Contents\/MacOS\u0060\n3. 在新打开的目录中选中 \u0060WeChat\u0060，鼠标右键选择 \u0060创建别名（Make Alias）\u0060 即创建了一个启动微信的副本。你也可以通过安装 \u0060OPT \u002b CMD\u0060 按钮拖动 \u0060WeChat\u0060 文件到当前或另个目录比如桌面上来创建一个别名（快捷方式）。\n\n![创建微信副本](https:\/\/jimmysong.io\/img\/blog\/multiple-wechat-instances-on-mac\/mac-screenshot-wechat-alias.webp)\n\n## 步骤二：启动多个微信实例\n\n如果你想同时登录 N 个微信，则依次双击刚创建的微信副本 N \u002b 1 次。比如你想同时登录 3 个微信，那就打开这个副本 4 次。\n\n保持这些窗口在运行状态，你可以将它们最小化，但是不要关闭它们。在这个过程中，你可能会注意到，系统只会打开两个微信登录界面。\n\n## 步骤三：退出其中一个微信\n\n当两个微信登录界面打开后，手动退出其中一个已经开启的微信。\n\n![退出其中一个微信](https:\/\/jimmysong.io\/img\/blog\/multiple-wechat-instances-on-mac\/mac-screenshot-wechat-quit.webp)\n\n## 步骤四：触发多开功能\n\n关闭一个微信后，系统会再次打开 N-1 个新的微信窗口。现在你就可以通过这些微信的登录界面登录到不同的微信账户了。\n\n![在 Mac 上同时登录三个微信](https:\/\/jimmysong.io\/img\/blog\/multiple-wechat-instances-on-mac\/mac-screenshot-multiple-wechat.webp)\n\n## 总结\n\n以上方法只需要使用最新的官方版本的微信即可，可以做到任意多开。希望这篇指南能帮助你更高效地使用微信，满足你的多账户管理需求。如有任何问题或需要进一步的帮助，欢迎留言讨论。\n', '\/blog\/multiple-wechat-instances-on-mac\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文详细介绍了如何在 Mac 电脑上通过简单的技巧实现微信的多开功能，适用于需要同时管理多个微信账号的用户。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/paris-trip/">感受浪漫巴黎：探索城市风情与文化洞察</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/06/16</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e6%97%85%e8%a1%8c"> 
             旅行
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('感受浪漫巴黎：探索城市风情与文化洞察', '2024 年 3 月，我借参加 KubeCon EU 之机访问巴黎，体验了当地文化、美食和生活细节。', '\n2024 年 3 月，一个特别的机会将我带到了法国巴黎——参加 [KubeCon EU 2024](\/blog\/kubecon-eu-paris-recap\/)。这是一场汇集了来自全球的云计算和开源技术爱好者的盛会。利用这次会议的机会，我不仅深入了解了最新的技术趋势，还抓住机会体验了这座城市的历史、文化和日常生活。我的巴黎之行从 3 月 16 日开始，持续到 3 月 24 日，这期间我尽可能多地探索了这座充满魅力的城市。\n\n## 签证篇章\n\n对于我们中国人来说，无论何时何地，出国的第一步总是签证的申请。尤其是法国申根签证，需要准备众多材料，包括公司证明信、行程单等，但幸好我所在的公司性质让这一切变得相对容易。令人感到略有安慰的是，与申请日本签证相比，法国签证不需要冻结巨额资金或提供庞大的银行存款证明。这次我获得了六个月的签证有效期，这对于我未来的欧洲行计划提供了更多的灵活性和可能性。\n\n## 到达巴黎\n\n从北京直飞巴黎的旅程总是充满期待。我乘坐的法国航空公司航班，从北京时间凌晨起飞，经过长达 13 小时的旅程后，于巴黎时间早晨 6 点多抵达。归途则选择了在伊斯坦布尔转机，让旅行的回忆更添一分异国情调。\n\n## 第一印象\n\n戴高乐机场处处可见的中文标牌，字句优雅，显示了法国人对细节的用心。尽管通关时排队等候了近一个小时，但多样化的人流让巴黎的国际化氛围愈发显著。从机场乘坐穿梭地铁时，我体验了三次才成功挤上车，可见人流之多。使用 Bolt 打车服务时，因为语言不通，还得到了一位好心法国人的帮助，他用法语帮我与司机沟通，这让我深感法国人的友好与热心。\n\n在巴黎戴高乐机场随处可见中文标识，很多地方只有英文、法文和中文三种文字的标识。\n\n![巴黎戴高乐机场](custom.webp)\n\n## 巴黎的生活细节\n\n在巴黎的每一处，都能看到那些独具特色的垃圾桶，它们不仅方便实用，还在安全上做了考虑。例如，一些垃圾桶是为了防爆而设计的，能安全投放玻璃瓶和易拉罐，而另一些仅用透明塑料袋覆盖，也是出于同样的安全考量。这些细节体现了城市管理的精细与周到。\n\n![巴黎街头的垃圾桶](dustbin.webp)\n\n巴黎的垃圾分类采用彩色编码垃圾桶系统，旨在促进适当的废物处理。垃圾箱有不同的颜色：黄色用于纸张和塑料等可回收物，棕色用于可堆肥食物残渣，白色用于酒瓶等玻璃物品，绿色\/灰色用于其他废物。该系统可帮助居民有效地分类垃圾，促进回收利用和适当的废物管理实践。\n\n## 食在巴黎\n\n尽管西餐中的牛排和糕点让人难以抗拒，我还是更偏爱家乡的味道。在巴黎，我找到了一家名为杨小厨的川菜馆，其牛肉面虽与国内有所不同，但味道可口，价格亲民。此外，巴黎街头的水果与我在网上购买的相比，不仅价格合理，而且味道也极佳，特别是我喜爱的啤梨。\n\n![巴黎的中餐、西餐及马卡龙](food.webp)\n\n另外在很多地铁口还有街头巷尾也有社区小摊及烘焙店。\n\n![街头小摊和烘焙店](store.webp)\n\n## 住在巴黎\n\n巴黎，法国的首都，不仅以其浪漫和历史著称，同时其行政区划也具有独特的结构。巴黎市通常被分为“大巴黎”和“小巴黎”。小巴黎指的是巴黎市内环，即第一到二十区，涵盖了大部分著名的历史地标和文化地区，总面积约为 105 平方公里。而大巴黎则包括小巴黎及其周边的郊区，形成一个更为广泛的都市区。\n\n![小巴黎地图](paris-map.webp)\n\n下图中环形道路是 **Boulevard Périphérique**，即巴黎环形高速公路。这条道路环绕着巴黎的 20 个区，这些区域共同构成了所谓的“小巴黎”。\n\n巴黎的 20 个区（arrondissements）按照螺旋状的顺序从市中心向外延伸，包括了市内最核心的商业、居住以及文化区域。这些区域的总面积大约为 105 平方公里（约 40.5 平方英里），从 1 区的市中心向外逐渐扩展至 20 区。\n\n这些区域是巴黎市的行政区划，而“小巴黎”这个名词通常是指的这些内环的区域，即由环形公路所环绕的巴黎市内部区域。因此，图中显示的 20 个区确实组成了“小巴黎”。\n\n相比之下，北京的二环面积约为 62 平方公里，三环面积约为 159 平方公里，小巴黎的面积在二者之间，下图展示了在同等比例尺下的小巴黎和北京三环的地图。\n\n![小巴黎和北京三环面积对比](paris-vs-beijing.webp)\n\n我此行住宿的地点位于巴黎的 15 区，这里是巴黎最大的一个区，位于塞纳河左岸（按塞纳河流向）。15 区不仅居住环境宜人，交通便利，而且距离诸如埃菲尔铁塔等著名景点也非常近，步行大约 20 分钟即可到达。我下榻的住所是一栋三层高的联排公寓，底层设有车库和会客厅，而居住区则分布在二楼和三楼，共有五个房间，旁边还有某国的大使馆官邸，增添了一份特别的国际氛围。\n\n## 行在巴黎\n\n巴黎的道路规划别具一格，道路交错纵横，并非严格的南北走向，加之红绿灯设置在街角，使得初来乍到的人有些不适应。这里的自行车道十分发达，我租了一辆助力自行车，穿行在巴黎的街头巷尾，感受到前所未有的自由与惬意。巴黎的地铁系统复杂多样，但支付方式极为方便，大部分支付都可以通过信用卡完成。\n\n对于游客来说，在小巴黎短距离出行首选方式是自行车。巴黎街头随处可见可供租赁的自行车，你可以下载 App 注册扫码支付后即可使用，注意需要绑定信用卡。有些自行车道是在路的中间，路面上有明确标识自行车道。这些自行车都是助力车，大多维护的比较好，但是也有一些存在故障，需要仔细辨别。另外巴黎的街道较窄，行人也很少遵守红绿灯，可能是因为红绿灯太多了吧。\n\n![巴黎街头的自行车道](bike.webp)\n\n巴黎的地铁票种类繁多，从单次票、日票到周票、月票一应俱全，适应不同游客的需求。然而，许多外地游客在购票环节都会遇到困惑，需要一些时间来熟悉系统。\n\n![巴黎地铁](metro.webp)\n\n巴黎地铁（Métro de Paris）始建于 1900 年，是世界上最早的地铁系统之一。这个广泛的地铁网络包括 16 条线路，覆盖总长度达 225 公里。巴黎地铁不仅连接城市中心和外围区域，还扩展到了一些近郊区域，每年服务数亿乘客，是巴黎公共交通系统的核心部分。因为建造时间比较久远，很多设施都比较老旧，比如车厢陈旧，车厢门要手动打开，运行噪音大，没有电梯等。\n\n## 医疗体验\n\n在巴黎的第二天，我因饮食不当而开始腹泻，持续了两天后才好转。在这期间，我去了当地的药店买药。药店早上 8 点准时开门，门口总是有人排队等候，这种准时和秩序让我印象深刻。\n\n![在巴黎购买的止泻药](drug.webp)\n\n法国的医疗体系被认为是世界上最好的之一，无论是急诊还是药品购买，都非常便捷。药品的质量和种类也相当丰富，能够满足不同病症的需求。\n\n## 游在巴黎\n\n在 KubeCon EU 期间，我利用空闲时间游览了几处巴黎的著名景点。埃菲尔铁塔是必须打卡的地方，我登上了二层平台，俯瞰整个巴黎，景色壮观。卢浮宫则是艺术爱好者的天堂，蒙娜丽莎的微笑吸引了无数游客驻足。虽然巴黎圣母院还在维修中，但夜晚的圣母院依旧散发着无尽的魅力。\n\n**卢浮宫**\n\n卢浮宫（Louvre Museum）是世界上最大和最著名的博物馆之一。它最初建于 12 世纪作为皇宫，直到 1793 年开放为公众博物馆。卢浮宫收藏了超过 38 万件展品，跨越从古代文明到 19 世纪的艺术与历史文物。其中最著名的作品包括《蒙娜丽莎》、《维纳斯的诞生》和《胜利女神像》等。\n\n![卢浮宫](louvre.webp)\n\n卢浮宫里人流量最大的地方就是《蒙娜丽莎》，很多人在那里排起了长龙，只为一睹她那神秘的微笑。\n\n**万神殿**\n\n巴黎万神殿，最初建造为教堂，现作为一个纪念馆，位于法国巴黎的拉丁区。这座建筑最初是为了纪念圣日内瓦瑞，后转变为纪念法国伟大人物的安息之地。建筑风格融合了古典与新古典元素，其宏伟的圆顶和庄严的柱廊使它成为巴黎的一个显著地标。万神殿内部装饰豪华，包括傅科摆锤和许多重要法国历史人物的墓穴。\n\n万神殿内的傅科摆，由法国物理学家利昂·福科于 1851 年设计，以证明地球自转的直接效应。这个简单但引人注目的实验包括一根悬挂的铁球，通过其自由摆动，观察者可以看到摆动平面相对于地面缓慢旋转的现象，这一旋转是地球自转的直接证据。福科摆锤不仅是物理学的一个重要实验，也成为了科学与艺术的结合象征。\n\n![万神殿内的傅科摆](pantheon.webp)\n\n**塞纳河**\n\n清晨的塞纳河如诗如画，漫步在河畔，感受到巴黎的静谧与美好。\n\n![塞纳河](seine.webp)\n\n塞纳河是法国的一条主要河流，流经巴黎市中心。河流全长约 777 公里，起源于勃艮第地区的普拉特高原，最终流入英吉利海峡。塞纳河穿过巴黎时，河两岸布满了历史悠久的桥梁和著名的景点，如巴黎圣母院和埃菲尔铁塔。河流不仅是巴黎的重要交通水道，也是旅游和休闲的热门地点，常有游船在此穿梭，提供观光和餐饮服务。\n\n**马德莱娜教堂**\n\n![马德莱娜教堂](madeleine.webp)\n\n马德莱娜教堂（Église de la Madeleine）是一座罗马天主教的教堂，以其古典希腊神庙风格著称。这座教堂建于 19 世纪初，外部有 52 根科林斯式柱子环绕。虽然外观极其庄严、类似神庙，但内部装饰华丽，拥有精美的雕刻和壁画。马德莱娜教堂不仅是宗教活动的场所，也常用于举行音乐会，特别是古典音乐演出。\n\n**圣心堂**\n\n![圣心堂](basilique.webp)\n\n圣心堂（Basilique du Sacré-Cœur）位于法国巴黎蒙马特高地，是一座罗马天主教教堂，以其白色圆顶著称。这座教堂建于 1875 年至 1914 年间，是为了纪念普法战争中的法国阵亡将士而兴建的。圣心堂采用了罗曼 - 拜占庭风格的建筑设计，内部装饰华丽，拥有壮观的马赛克和雕塑。它不仅是巴黎的一个重要宗教地点，也因其位于城市之巅，提供了俯瞰巴黎全景的绝佳视角。\n\n除此之外，我还在骑行过程中游览了巴黎圣母院、香榭丽舍大道、爱丽舍宫、小皇宫、凯旋门、协和广场、杜乐丽花园、卢森堡公园等，限于篇幅不在此展开。\n\n## 关于奥运会\n\n现代奥运会是法国人在巴黎提倡的，可能是法国人对奥运会已经司空见惯，也有可能是为了尽可能不打扰本地人的生活，此次巴黎之行，感受不到任何奥运会将在巴黎召开的气氛。只有一些标志性建筑旁在搭建一些展台可能是为了供奥运会使用，以及一些商店在售卖奥运会纪念品。\n\n## 评论\n\n最近在中文互联网上，经常看到一些视频介绍巴黎的治安、环境是如何的不堪，比如街道上很多小偷、随地大小便、找不到厕所等。幸运的是我并没有遇到小偷，也没听到同伴有这样的遭遇。但是确实在一些街道尤其是景区周边闻到一些尿骚味，也遭遇了几个流浪汉问我要烟。还有就是卢浮宫里找不到厕所，唯一找到的一个男厕所还在维修中。\n\n![靠近卢浮宫的街道满是垃圾和尿骚味](street.webp)\n\n## 总结\n\n巴黎这座城市以其独特的魅力和丰富的文化底蕴给我留下了深刻的印象。这里的人们热情友好，景色美丽动人。虽然在一些游客密集的地方可能会稍显杂乱，但这也是任何旅游城市难以避免的现象。巴黎之行充满了美好的回忆，让人流连忘返，期待未来再次踏上这片浪漫的土地。也希望这篇游记能对初次踏上这篇土地人有所帮助。\n', '\/blog\/paris-trip\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">2024 年 3 月，我借参加 KubeCon EU 之机访问巴黎，体验了当地文化、美食和生活细节。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/how-to-integrate-third-party-registry-with-istio/">如何在 Istio 中集成第三方服务注册表？</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/06/14</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('如何在 Istio 中集成第三方服务注册表？', '本文详细介绍了如何将第三方服务发现机制如 Consul 和 Eureka 与 Istio 集成，实现服务发现的无缝对接。', '\nIstio 依赖 Kubernetes 来进行服务发现，这通常意味着必须在 Kubernetes 集群中部署微服务并使用 Kubernetes 服务发现。然而，很多现有的微服务项目还在使用如 Consul、Eureka 这样的第三方服务注册表，本文将探讨如何将这些现有的微服务的注册表与 Istio 集成。\n\n## Istio 对非 Kubernetes 服务的支持\n\nIstio 最初只支持 Kubernetes 服务，但随着时间的推移，为了适应更广泛的应用场景，它开始支持像 Consul 这样的第三方服务注册表。通过引入 Mesh Configuration Protocol（MCP），Istio 能够与各种服务发现后端通信，如 Consul，从而管理非 Kubernetes 环境中的服务。在 Istio 1.1 版本中，引入了 ServiceEntry 资源对象，这使得用户可以手动将外部服务添加到 Istio 的服务注册表中，并在 Istio 1.8 中取消了对 Consul 的直接支持，转而通过 [ServiceEntry](https:\/\/istio.io\/latest\/docs\/reference\/config\/networking\/service-entry\/) 提供了一种更灵活的方式来集成和管理所有服务，无论它们是否托管在 Kubernetes 上。\n\n## Istio 代理配置的高层架构\n\n下图展示了 Istio 代理配置的高层架构，揭示了配置如何从各种源被摄取、转换，并最终服务于 Envoy 代理。\n\n\u0060\u0060\u0060mermaid \u0022Istio 代理配置高层架构\u0022\ngraph TD\n    subgraph 配置摄取\n        subgraph 配置存储\n            xcs(XDS 客户端) --\u003e acs(聚合)\n            ccs(CRD 客户端) --\u003e acs(聚合)\n            fcs(文件系统客户端) --\u003e acs(聚合)\n        end\n        subgraph 服务发现\n            kc(Kube Controller) --\u003e sd(聚合)\n            sec(ServiceEntry Controller) --\u003e sd(聚合)\n        end\n    end\n    subgraph 配置转换\n        acs \u0026 sd --\u003e ct(配置转换器)\n    end\n    subgraph \u0022配置服务 (XDS)\u0022\n        ct --\u003e xds(XDS 服务器)\n    end\n    xds --\u003e ep(Envoy 代理)\n\u0060\u0060\u0060\n\n![Istio 代理配置高层架构](ba3ac1f8ffc2b172dd0681013c328a09.svg)\n\n要想详细了解 Istiod 的架构，可以参考 [Istio 架构详解](https:\/\/cloudnative.to\/blog\/istiod-architecture\/)。\n\n### 配置摄取过程详解\n\n- **ConfigStore**: 负责读取多种类型的资源并进行聚合。包括：\n    - **XDS Client**: 通过 xDS 协议读取资源。\n    - **CRD Client**: 从 Kubernetes 自定义资源定义（CRD）读取资源。\n    - **Filesystem Client**: 从文件系统读取资源。\n- **ServiceDiscovery**: 聚合面向服务的内部资源。使用的组件包括：\n    - **Kube Controller**: 依据 Kubernetes 核心类型运行。\n    - **ServiceEntry Controller**: 依据 Istio 类型运行。\n\n### 配置翻译与服务\n\n配置从 ConfigStore 和 ServiceDiscovery 聚合后，由 **Config Translator** 翻译成适合代理的格式，然后通过 **XDS Server** 服务于 Envoy 代理。这是将动态配置应用于代理的最终步骤。\n\n## 第三方注册表同步\n\n为了集成第三方服务注册表，我们可以实现一个 Operator，该 Operator 监视第三方服务注册表并将服务以 ServiceEntry 和 WorkloadEntry 资源形式推送至 Kubernetes API 服务器。以下流程图展示了该同步过程。\n\n\u0060\u0060\u0060mermaid \u0022第三方注册表同步流程图\u0022\nsequenceDiagram\n    participant O as Operator\n    participant CM as 第三方服务注册表\n    participant K8s as Kubernetes API 服务器\n    participant I as Istiod\n    participant EP as Envoy 代理\n\n    O-\u003e\u003e\u002bCM: 查询服务注册表\n    CM--\u003e\u003e-O: 返回服务数据\n    O-\u003e\u003eO: 将服务转换为 ServiceEntry\n    O-\u003e\u003e\u002bK8s: 推送 ServiceEntry\n    K8s--\u003e\u003e-I: 更新 Istio 配置\n    I-\u003e\u003eEP: 更新代理配置\n    Note over EP: Envoy 代理接收新配置\n\n    loop 监控变更\n        O-\u003e\u003e\u002bCM: 检查更新\n        CM--\u003e\u003e-O: 通知变更\n        O-\u003e\u003eO: 转换更新的服务\n        O-\u003e\u003e\u002bK8s: 更新 ServiceEntry\n        K8s--\u003e\u003e-I: 刷新 Istio 配置\n        I-\u003e\u003eEP: 刷新代理配置\n    end\n\u0060\u0060\u0060\n\n![第三方注册表同步流程图](34ee760a4cb26025ecf954077f77eee2.svg)\n\n### 第三方服务注册表同步的步骤说明\n\n1. Operator 向第三方服务注册表发起查询请求。\n2. 第三方服务注册表返回当前注册的服务数据。\n3. Operator 将服务数据转换为 Istio 的 ServiceEntry 对象。\n4. Operator 将 ServiceEntry 推送至 Kubernetes API 服务器。\n5. Kubernetes API 服务器将变更通知 Istiod。\n6. Istiod 更新 Envoy Proxies 的配置。\n7. Operator 定期检查第三方服务注册表以监控服务变化，发现变更后更新 ServiceEntry 并重新推送至 Kubernetes API 服务器，完成服务同步。\n\n## Istio Registry Sync\n\nTetrate 开发的 [Istio Registry Sync](https:\/\/docs.tetrate.io\/istio-subscription\/integrations\/registry-sync\/introduction) 是一个扩展 Operator，可以作为 [TIS](https:\/\/docs.tetrate.io\/istio-subscription\/) 的 add-on 运行。它支持非 Kubernetes 服务注册表（如 AWS Cloud Map 和 Consul）与 Istio 的集成。此工具提供了以下几个使用场景：\n\n- **混合应用集成**: 在混合环境中，如使用 Consul 的传统应用与 AWS Cloud Map 中的微服务可以通过 Istio Registry Sync 实现无缝的服务发现。\n- **动态端点管理**: 在服务频繁扩缩的环境中，Istio Registry Sync 能快速反映来自配置注册表的变更，确保 Istio 服务网格中的流量管理策略准确有效。\n- **统一的监控与安全态势**: 通过将所有环境的服务集成至 Istio，可以利用 Istio 提供的服务健康指标和统一的安全协议，如 mTLS，确保跨所有服务的加密和认证通信。\n\n## 总结\n\n通过上述方法，你可以有效地将 Istio 与第三方服务注册表集成，无论是通过开发自定义的 Operator 还是使用现成的 Istio Registry Sync 工具。这样不仅能够保持服务的现代化，还能确保在不同环境之间的高效协同工作。\n\n## 参考资料\n\n- [Istio Pilot Architecture - github.com](https:\/\/github.com\/istio\/istio\/blob\/master\/pilot\/doc\/architecture.md)\n- [Istio Registry Sync Documentation - docs.tetrate.io](https:\/\/docs.tetrate.io\/istio-subscription\/integrations\/registry-sync\/introduction)\n', '\/blog\/how-to-integrate-third-party-registry-with-istio\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文详细介绍了如何将第三方服务发现机制如 Consul 和 Eureka 与 Istio 集成，实现服务发现的无缝对接。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/istiod-architecture/">[译] Istiod 架构详解</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/06/14</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://github.com/istio/istio/blob/master/architecture/networking/pilot.md" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istiod 架构详解', '本文译自 Istio 官方代码仓库中对 Istiod 架构的解析。描述了 Istio 控制平面——Istiod 的高层架构。Istiod 是一个模块化的单体应用，涵盖了从证书签名、代理配置（XDS）、传统的 Kubernetes 控制器等多种功能。', '\n本文档描述了 Istio 控制平面——Istiod 的高层架构。Istiod 是一个模块化的单体应用，涵盖了从证书签名、代理配置（XDS）、传统的 Kubernetes 控制器等多种功能。\n\n## 代理配置 {#proxy-configuration}\n\nIstiod 的主要角色——以及大部分代码——是动态配置代理（Envoy sidecar、入口、gRPC、ztunnel 等）。这大致包括 3 个部分：\n1. 配置摄取（系统的输入）\n1. 配置翻译\n1. 配置服务（XDS）\n\n### 配置摄取\n\nIstio 从超过 20 种不同的资源类型读取，并将它们聚合在一起构建代理配置。这些资源可以来自 Kubernetes（通过观察）、文件或通过 xDS；尽管如此，Kubernetes 是最常用的。\n\n主要出于历史原因，摄取分为几个组件。\n\n#### ConfigStore\n\n\u0060ConfigStore\u0060 读取多种资源，并通过标准接口（Get、List 等）暴露它们。这些类型被包装在通用的 \u0060config.Config\u0060 结构中，与通常使用每种资源类型的 Kubernetes 客户端形成对比。最常见的是通过 \u0060crdclient\u0060 包从 Kubernetes 读取。\n\n![](.\/output-1.svg)\n\n#### 服务发现 {#ServiceDiscovery}\n\n另一个主要接口是 ServiceDiscovery。类似于 ConfigStore，它也是对多种资源进行聚合。然而，它不提供通用资源访问，而是预计算了多种服务导向的内部资源，如 \u0060model.Service\u0060 和 \u0060model.ServiceInstance\u0060。\n\n这由两个控制器组成——一个由核心 Kubernetes 类型驱动（“Kube Controller”），一个由 Istio 类型驱动（“ServiceEntry 控制器”）。\n\n![](.\/output-2.svg)\n\n大部分情况下这是相当直接的。然而，我们支持 \u0060ServiceEntry\u0060 选择 \u0060Pod\u0060，以及 \u0060Service\u0060 选择 \u0060WorkloadEntry\u0060，这导致跨控制器通信。\n\n注意：\u0060Pods\u0060 不贡献给 Kube 控制器的 \u0060ServiceInstances\u0060 是因为使用了 \u0060Endpoints\u0060，它本身是从 Kubernetes 核心的 \u0060Pod\u0060 派生的。\n\n#### PushContext\n\n\u0060PushContext\u0060 是当前全局状态（SotW）的一个不可变快照。它在每次配置推送时（下面会详细讨论）通常是部分地重新生成的。由于是快照，大多数查找都是无锁的。\n\n\u0060PushContext\u0060 是通过查询上述层构建的。对于一些简单的用例，这和存储类似于 \u0060configstore.List(SomeType)\u0060 的东西一样简单；在这种情况下，与直接暴露 configstore 的唯一区别是要快照当前状态。在其他情况下，一些预计算和索引被计算出来，以便后续访问效率。\n\n#### 端点\n\n端点有一个优化的代码路径，因为它们是迄今为止更新最频繁的资源——在一个稳定的集群中，这通常是*唯一*的变化，由扩缩容引起。\n\n因此，它们不经过 \u0060PushContext\u0060，变化也不会触发 \u0060PushContext\u0060 的重新计算。相反，当前状态是基于来自 \u0060ServiceDiscovery\u0060 的事件增量计算的。\n\n#### 结论\n\n总体而言，配置摄取流程如下：\n\n![](.\/output-3.svg)\n\n### 配置翻译\n\n配置翻译将上述输入转换为连接的 XDS 客户端（通常是 Envoy）消费的实际类型。这通过 \u0060Generators\u0060 完成，这些生成器注册一个函数来构建给定类型。例如，有一个 \u0060RouteGenerator\u0060 负责构建 \u0060Routes\u0060。除了核心 Envoy XDS 类型外，还有一些自定义的 Istio 类型，例如我们用于 DNS 的 \u0060NameTable\u0060 类型，以及调试接口。\n\n\u0060Generators\u0060 的输入是 \u0060Proxy\u0060（当前客户端的表示）、当前的 \u0060PushContext\u0060 快照以及导致更改的配置更新列表。\n\n将 \u0060Proxy\u0060 作为输入参数是重要的，并且与其他一些 XDS 实现的主要区别。我们无法在没有每个客户端信息的情况下静态翻译输入到 XDS。例如，我们依赖于客户端的标签来确定应用的政策集。虽然这是实现 Istio API 的必要条件，但它确实大大限制了性能。\n\n#### 缓存\n\n配置翻译通常占用了 Istiod 的绝大部分资源使用，尤其是 protobuf 编码。因此，引入了缓存，存储给定资源的已编码 \u0060protobuf.Any\u0060。\n\n这种缓存依赖于声明所有输入到给定生成器作为缓存键的一部分。这极其容易出错，因为没有任何东西阻止生成器使用*不*是键部分的输入。当这种情况发生时，不同的客户端将不确定地获得错误的配置。这种类型的错误在历史上导致了 CVE。\n\n有几种方法可以防止这些问题：\n* 只将缓存键本身传入到生成逻辑中，这样就不能使用其他未计入的输入。不幸的是，今天还没有任何生成器这样做。\n* 非常非常小心。\n* 缓存有一个内置测试，通过设置 \u0060UNSAFE_PILOT_ENABLE_RUNTIME_ASSERTIONS=true\u0060 启用，该测试在 CI 中运行。如果任何键以不同的值写入，这将引发 panic。\n\n#### 部分计算\n\n与缓存一样，部分计算是确保我们不需要在每次更改时为每个代理构建（或发送）每个资源的关键性能优化。这将在配置服务部分中更详细讨论。\n\n### 配置服务\n\n配置服务是实际接受代理客户端的层，这些客户端通过双向 gRPC 流连接，并为它们提供所需的配置。\n\n我们将有两种触发发送配置的方式——请求和推送。\n\n#### 请求\n\n来自客户端的请求特别要求一组资源。这可能是在新连接上请求初始资源集，或者来自新的依赖。例如，\u0060Cluster X\u0060 的推送引用 \u0060Endpoint Y\u0060 可能导致请求 \u0060Endpoint Y\u0060（如果客户端尚未知道的话）。\n\n注意客户端实际上可以发送三种类型的消息——请求、对先前推送的 ACKs 和对先前推送的 NACKs。不幸的是，这些在 API 中没有清晰地区分，因此有一些逻辑来分解这些（\u0060shouldRespond\u0060）。\n\n#### 推送\n\n当 Istiod 检测到需要某些配置更新时，会发生推送。这大致与请求的结果相同（新配置推送到客户端），只是由不同的来源触发。\n\n在配置摄取中描述的各种组件可以触发配置更新。这些被批量处理（\u0022debounced\u0022），以避免在连续多次更改时活动过度，并最终排队在推送队列中。\n\n推送队列大部分是一个正常的队列，但它有一些特殊逻辑来合并每个给定代理的推送请求。这导致每个代理有 0 或 1 个未完成的推送请求；如果有更多更新进来，现有的推送请求就会扩展。\n\n另一个任务轮询这个队列并触发每个客户端开始推送。\n\n![](.\/output-4.svg)\n\n在高层次上，每个客户端任务将找到正确的生成器来处理请求，生成所需的配置，并发送。\n\n#### 优化\n\n一个简单的实现将简单地重新生成每个客户端的所有订阅类型的所有资源，无论配置是否更改。然而，这种方式扩展性很差。因此，我们有许多级别的优化以避免做这些工作。\n\n首先，我们有一个 \u0060Full\u0060 推送的概念。只有在更改时 \u0060Full\u0060 推送会重新计算 \u0060PushContext\u0060；否则，这将被跳过，重用最后一个 \u0060PushContext\u0060。注意：即使是 \u0060Full\u0060，我们也尽可能从上一个 \u0060PushContext\u0060 复制。例如，如果只有一个 \u0060WasmPlugin\u0060 发生了变化，我们不会重新计算服务索引。\n\n注意：\u0060Full\u0060 只是指是否需要重新计算 \u0060PushContext\u0060。即使在 \u0060Full\u0060 推送中，我们也会跟踪触发此的配置更新，因此我们可以有 \u0022Config X 的完整更新\u0022 或 \u0022所有配置的完整更新\u0022。\n\n接下来，对于单个代理，我们将检查它是否可能受到更改的影响。例如，我们知道一个 sidecar 从不受 \u0060Gateway\u0060 更新的影响，我们还可以查看限制更新范围的分流（来自 \u0060Sidecar.egress.hosts\u0060）。\n\n一旦我们确定代理可能受到影响，我们将确定哪些*类型*可能受到影响。例如，我们知道 \u0060WasmPlugin\u0060 不影响 \u0060Cluster\u0060 类型，所以在这种情况下我们可以跳过生成 \u0060Cluster\u0060。警告：Envoy 当前有一个错误，*要求* 每当推送对应的 \u0060Cluster\u0060 时必须推送 \u0060Endpoints\u0060，因此这个优化在这个特定情况下故意关闭了。\n\n最后，我们确定我们需要生成类型的哪个子集。XDS 有两种模式 - \u0022State of the World (SotW)\u0022 和 \u0022Delta\u0022。在 SotW 中，我们通常需要生成类型的所有资源，即使只有一个发生了变化。注意我们实际上需要*生成*所有这些，通常是因为我们不存储先前生成的资源（主要因为它们是每个客户端生成的）。这也意味着每当我们确定是否需要更改时，我们都是基于仔细的代码分析，而不是在运行时。\n\n尽管在 SotW 中有这样的期望，由于协议的一个特点，我们实际上可以启用我们最重要的优化之一。XDS 类型形成一棵树，CDS 和 LDS 是 Envoy 的树根。对于根类型，我们*必须*总是生成完整的资源集——缺失的资源被视为删除。\n然而，所有其他类型*不能*显式删除，而是在所有引用被移除时清理。这意味着我们可以为非根类型发送部分更新，而不删除未发送的资源。这有效地允许在 SotW 上进行 delta 更新。这个优化对我们的端点生成器至关重要，确保当一个 pod 扩展时，我们只需要更新该 pod 内的端点。\n\n## 控制器\n\nIstiod 由一系列控制器组成。按 Kubernetes 的说法，\u0022控制器是观察你的集群状态的控制循环，然后在需要时进行或请求更改。\u0022\n\n在 Istio 中，我们更自由地使用这个术语。Istio 的控制器不仅仅观察一个集群的状态——许多控制器从多个集群读取，甚至从外部来源（文件和 XDS）读取。通常，Kubernetes 控制器然后将状态写回到集群；Istio 确实有几个这样的控制器，但大多数控制器都集中在推动[代理配置](#proxy-configuration)。\n\n### 编写控制器\n\nIstio 提供了一些帮助库来开始编写控制器。虽然这些库有帮助，但正确编写（和测试！）一个控制器仍然有很多细微之处。\n\n要开始编写控制器，请查看[示例控制器](https:\/\/github.com\/istio\/istio\/blob\/master\/pkg\/kube\/controllers\/example_test.go)。\n\n### 控制器概览\n\n下面提供了 Istiod 中控制器的高级概览。有关每个控制器的更多信息，建议咨询控制器的 Go 文档。\n\n![](.\/output-5.svg)\n\n正如您所看到的，目前控制器的景观相当广泛。\n\n[服务发现](#ServiceDiscovery) 和 [Config Store](#ConfigStore) 已在上文讨论，因此这里不再赘述。\n\n#### 网格配置\n\n网格配置控制器是一个相当简单的控制器，从 \u0060ConfigMap\u0060（如果使用 \u0060SHARED_MESH_CONFIG\u0060 则为多个）读取，处理并合并这些到类型化的 \u0060MeshConfig\u0060 中。然后它通过一个简单的 \u0060mesh.Watcher\u0060 暴露这个，这只是暴露一种访问当前 \u0060MeshConfig\u0060 的方式并在它改变时获得通知。\n\n#### Ingress\n\n除了 \u0060VirtualService\u0060 和 \u0060Gateway\u0060，Istio 也支持 \u0060Ingress\u0060 核心资源类型。像 CRD 一样，\u0060Ingress\u0060 控制器实现 \u0060ConfigStore\u0060，但有些不同。\u0060Ingress\u0060 资源在即时转换为 \u0060VirtualService\u0060 和 \u0060Gateway\u0060，所以虽然控制器读取 \u0060Ingress\u0060 资源（和一些相关类型如 \u0060IngressClass\u0060），它发出其他类型。这允许其他代码不用关心 Ingress，只关注核心类型。\n\n除了这种转换外，\u0060Ingress\u0060 还需要在状态中写入它可以访问的地址。这由 Ingress 状态控制器完成。\n\n#### Gateway\n\nGateway（指的是 [Kubernetes API](http:\/\/gateway-api.org\/)，不是同名的 Istio 类型）的工作方式与 [Ingress](#ingress) 非常相似。网关控制器也将网关 API 类型转换为 \u0060VirtualService\u0060 和 \u0060Gateway\u0060，实现 \u0060ConfigStore\u0060 接口。\n\n然而，还有一些额外的逻辑。网关类型有广泛的状态报告。与 Ingress 不同，这是状态报告是在主控制器中直接完成的，允许在处理资源的逻辑中直接生成状态。\n\n此外，Gateway 涉及两个组件写入到集群：\n* 网关类控制器是一个简单的控制器，只是写一个描述我们实现的默认 \u0060GatewayClass\u0060 对象。\n* 网关部署控制器使用户能够创建一个实际配置底层资源（部署和服务）的网关。这更像是一个传统的“Operator”。这部分逻辑是确定基于 \u0060istio.io\/rev\u0060 标签哪个 Istiod 修订应该处理资源（反映 sidecar 注入）；因此，这需要依赖“标签观察者”控制器。\n\n#### CRD 观察者\n\n对于针对自定义类型（CRD）的观察，我们希望优雅地处理缺失的 CRD。如果对缺失类型启动 informers，则会导致错误并阻塞启动。相反，我们引入了一个“CRD 观察者”组件，观察集群中的 CRD 以确定它们是否可用。\n\n有两种使用方式：\n* 一些组件只是在做需要的工作之前阻塞 \u0060watcher.WaitForCRD(...)\u0060。\n* \u0060kclient.NewDelayedInformer\u0060 也可以完全抽象这一点，通过提供一个在幕后处理这一点的客户端。\n\n#### Credentials Controller\n\n凭证控制器暴露访问 TLS 证书信息的途径，这些信息存储在集群的 \u0060Secrets\u0060 中。除了简单地访问证书外，它还有一个授权组件，可以验证请求者是否有权读取其命名空间中的 \u0060Secrets\u0060。\n\n#### Discovery Filter\n\n发现过滤器控制器用于实现 \u0060MeshConfig\u0060 的 \u0060discoverySelectors\u0060 字段。这个控制器读取集群中的 \u0060Namespace\u0060 以确定它们是否应该被“选中”。许多控制器使用这个过滤器来只处理配置的一个子集。\n\n#### 多集群\n\n各种控制器从多个集群读取。\n\n这始于多集群密钥控制器，该控制器读取 \u0060kubeconfig\u0060 文件（存储为 \u0060Secrets\u0060），并为每个创建 Kubernetes 客户端。控制器允许注册处理程序，这些处理程序可以处理集群的添加\/更新\/删除。\n\n这有两个实现：\n* 凭证控制器负责读取存储为 Secrets 的 TLS 证书。\n* Kubernetes 服务发现控制器有点像一个大块头，除了核心服务发现控制器之外，还启动了一堆其他子控制器。\n\n由于整体复杂性，看看这个放大一点会有帮助：\n\n![](.\/output-6.svg)\n\n#### 虚拟机\n\n虚拟机支持由两个控制器组成。\n\n自动注册控制器是一个相当独特的控制器——控制器的输入是 XDS 连接。对每个 XDS 连接，创建一个 \u0060WorkloadEntry\u0060 来注册 XDS 客户端（通常是在 VM 上运行的 \u0060istio-proxy\u0060）到网格中。这个 \u0060WorkloadEntry\u0060 与连接的生命周期绑定，有一些逻辑确保临时的停机（重新连接等）不会移除 \u0060WorkloadEntry\u0060。\n\n健康检查控制器还控制 \u0060WorkloadEntry\u0060 的健康状态。健康状态通过 XDS 客户端报告并与 \u0060WorkloadEntry\u0060 同步。\n\n#### Webhook\n\nIstio 包含验证和变更 webhook 配置。这些需要在 \u0060caBundle\u0060 中指定以配置 TLS 信任。因为 Istiod 的 CA 证书有些动态性，这在运行时进行修补（而不是作为安装的一部分）。webhook 控制器处理这种修补。\n\n这些控制器非常相似，但由于各种原因是不同的组件。\n', '\/trans\/istiod-architecture\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文译自 Istio 官方代码仓库中对 Istiod 架构的解析。描述了 Istio 控制平面——Istiod 的高层架构。Istiod 是一个模块化的单体应用，涵盖了从证书签名、代理配置（XDS）、传统的 Kubernetes 控制器等多种功能。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/what-is-new-in-istio-1-22/">深入解析 Istio 1.22：新特性和实际应用建议</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/06/11</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('深入解析 Istio 1.22：新特性和实际应用建议', '探索 Istio 1.22 的新特性与实用建议，包括增量 xDS、路径模板支持及 API 升级等，助力优化服务网格管理。', '\n最近 [Istio 1.22 发布](https:\/\/istio.io\/latest\/news\/releases\/1.22.x\/announcing-1.22\/)包含大量的重大更新，本文将为你分享这个发布带来的新特性及应用建议。\n\n## Ambient 模式进入 Beta 阶段\n\n虽然 Ambient 模式现已进入 Beta 阶段，但这并不意味着我们可以完全告别 Sidecar。尽管 Istio 官方宣称 Ambient 模式可以简化操作并显著减少内存和 CPU 使用，但它仍然存在局限性和潜在的复杂性问题。例如，虽然取消了 Sidecar，但需引入新的 ztunnel 和 waypoint 组件，这可能带来新的挑战。关于 Ambient 模式进入 Beta 模式的详细信息请参阅 [Istio 官方博客](https:\/\/istio.io\/latest\/blog\/2024\/ambient-reaches-beta\/)。\n\n**Ambient 模式带来的新的挑战**\n\n- Ambient mode 对 L7 流量的管理仍未成熟\n- mTLS 被强制在 namespace 级别开启，也就是说使用 Ambient 模式你无法关闭 mTLS\n- Ambient 模式的无宕机升级仍未解决\n- 缺少 与 Sidecar 模式共存和迁移的最佳实践\n\n关于 Sidecar 模式和 Ambient 模式的对比，详见 [Istio Ambient 模式的局限性解析](\/blog\/istio-ambient-mode-limitations\/)。\n\n{{\u003ccallout note \u0022建议\u0022\u003e}}\n如果是刚开始使用 Istio，尤其是你只需要为服务自动开启 mTLS 的情况下，当前阶段可以尝试使用 Ambient 模式。但是对于 L7 功能，建议等到 Ambient 模式完全成熟后再考虑生产上使用。\n{{\u003c\/callout\u003e}}\n\n## Istio API 升级\n\nIstio Istio 1.22 版本中，关键 API 如流量管理、安全、Telemetry 相关的 API 都已正式升级到 \u0060v1\u0060 版本。你只需要将原有配置的 API 版本修改为 \u0060v1\u0060 即可，除此之外不需要任何更改。这些 API 早已成熟，你可以放心的使用 \u0060v1\u0060 版本，对于对稳定性要求较高的环境，Istio 添加了[验证准入策略](https:\/\/kubernetes.io\/docs\/reference\/access-authn-authz\/validating-admission-policy\/)确保只有 \u0060v1\u0060 API 和字段可以在 Istio API 中使用。\n\n例如下面的 AuthorizationPolicy 示例。\n\n\u0060\u0060\u0060yaml {linenos=table,hl_lines=1}\napiVersion: security.istio.io\/v1beta1\nkind: AuthorizationPolicy\nmetadata:\n  name: finance-to-supply-chain\n  namespace: finance\nspec:\n  selector:\n    matchLabels:\n      app: finance-app\n  action: ALLOW\n  rules:\n  - from:\n    - source:\n        namespaces: [\u0022finance\u0022]\n    to:\n    - operation:\n        methods: [\u0022GET\u0022, \u0022POST\u0022]\n        paths: [\u0022\/api\/supply1\u0022, \u0022\/api\/supply2\u0022]\n    when:\n    - key: request.headers[:authority]\n      values: [\u0022supply-chain-service.supply-chain.svc.cluster.local\u0022]\n\u0060\u0060\u0060\n\n其他扩展类的 API 如 \u0060EnvoyFilter\u0060、\u0060WasmPlugin\u0060、\u0060ProxyConfig\u0060 还未成熟，因此还停留在 alpha 或 beta 阶段。关于 API 升级的更多信息，请参考 [v1 API 博客](https:\/\/istio.io\/latest\/blog\/2024\/v1-apis\/)。\n\n{{\u003ccallout note \u0022建议\u0022\u003e}}\n对于常用功能可以放心使用 \u0060v1\u0060 API，扩展类 API 尚未稳定为了保证系统稳定性，可以开启验证准入策略。\n{{\u003c\/callout\u003e}}\n\n## Gateway API 升级\n\n[Gateway API](\/blog\/why-gateway-api-is-the-future-of-ingress-and-mesh\/) 已更新至版本 1.1.0，现已普遍可用。这一更新扩展了 Istio 的流量管理能力，但需要注意 Istio 原生 API 与 Gateway API 的兼容性问题。在迁移到新 API 时应谨慎，以避免依赖尚未完全成熟的特性。更多详情，请查看 [Gateway API v1.1 博客](https:\/\/istio.io\/latest\/blog\/2024\/gateway-mesh-ga\/)。\n\n{{\u003ccallout note \u0022建议\u0022\u003e}}\n对于已经稳定使用 Istio API 的现有部署，可以继续使用，尤其是在需要使用到高级功能的场景下。对于新部署优先考虑使用稳定版的 Gateway API，以利用其现代化的流量管理功能。因为二者现存的兼容性问题，不要冒然迁移到 Gateway API，否则得不偿失。\n{{\u003c\/callout\u003e}}\n\n## 增量 xDS 默认启动\n\nIstio 1.22 版本默认启用了增量 xDS，这是一个优化配置分发的机制。与传统的 State of the World（SotW）模式相比，增量 xDS 仅将变更的配置发送给 Envoy 代理，从而显著减少了网络传输的数据量和控制平面的资源消耗。这一变更尤其适用于配置频繁更新的大规模部署环境，能够提高配置更新的效率和性能。此外，增量 xDS 还有助于在网络环境复杂或配置动态变化的情况下，更高效地管理服务网格的配置更新。\n\n{{\u003ccallout note \u0022建议\u0022\u003e}}\n增量 xDS 早在 Istio 的几个版本前就已经开发完成，只是没有默认开启，现在该功能已经稳定，可以放心使用。\n{{\u003c\/callout\u003e}}\n\n更多关于 xDS 的介绍请参考[Envoy xDS 及 Istio 中的配置分发流程介绍](\/blog\/istio-delta-xds-for-envoy\/)。\n\n### AuthorizationPolicy 的路径模板支持通配符\n\n在 Istio 1.22 中，\u0060AuthorizationPolicy\u0060 新增了对[路径模板](https:\/\/istio.io\/latest\/docs\/reference\/config\/security\/authorization-policy\/#Operation)的支持，极大增强了路径匹配的灵活性和精确性。而在此之前，\u0060AuthorizationPolicy\u0060 的路径配置并不支持通配符。此功能允许使用基于 Envoy 的 URI 模板匹配来定义 HTTP 请求中的路径。路径可以包括简单的通配符（\u0060*\u0060 和 \u0060**\u0060）或具名变量，从而精确匹配单个或多个路径组件。例如，路径模板 \u0060\/foo\/{*}\u0060 能匹配 \u0060\/foo\/bar\u0060 但不匹配 \u0060\/foo\/bar\/baz\u0060，而 \u0060\/foo\/{**}\/\u0060 则可以匹配任何以 \u0060\/foo\/\u0060 开头的路径。这种灵活的路径模板设计，特别适用于动态和复杂的路由规则，进一步加强了 Istio 的安全策略工具箱。\n\n下图展示了 AuthorizationPolicy 的路径匹配的通配符规则。\n\n\u0060\u0060\u0060mermaid \u0022AuthorizationPolicy 的路径匹配通配符规则\u0022\ngraph LR\n    A[AuthorizationPolicy 路径匹配] --\u003e B(定义路径模板)\n    B --\u003e C{路径模板操作符}\n    C --\u003e D[\u0022*（匹配单个段）\u0022]\n    C --\u003e E[\u0022**（匹配多个段）\u0022]\n    C --\u003e F[\u0022{name}（命名变量匹配单个段）\u0022]\n    C --\u003e G[\u0022{name=**}（命名变量匹配多个段）\u0022]\n\n    D --\u003e H[\u0022\/foo\/{*} 匹配 \/foo\/bar\u0022]\n    E --\u003e I[\u0022\/foo\/{**}\/ 匹配 \/foo\/bar\/、\/foo\/bar\/baz.txt\u0022]\n    F --\u003e J[\u0022\/videos\/{file} 匹配 \/videos\/1080p5000_00001.m4s\u0022]\n    G --\u003e K[\u0022\/**.mpd 匹配 \/content\/123\/india\/dash\/55\/manifest.mpd\u0022]\n\u0060\u0060\u0060\n\n![AuthorizationPolicy 的路径匹配通配符规则](f96fd4f3843d3d7b7c13b0a5083f00f4.svg)\n\n了解更多关于路径模板的具体应用和规则，你可以参考 [Envoy 的官方文档](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-v3\/extensions\/path\/match\/uri_template\/v3\/uri_template_match.proto)。\n\n{{\u003ccallout note \u0022提示\u0022\u003e}}\n\u0060AuthorizationPolicy\u0060 中的路径匹配终于支持模板了，你不需要再在配置中一个一个地手动加入路径了。\n{{\u003c\/callout\u003e}}\n\n## 总结\n\nIstio 1.22 版本引入了多项重要更新和改进，尽管某些特性被广泛宣传，但在实际使用中需要进行详细评估和适当的测试。希望本篇博客能帮助你更深入地理解和应用这些新特性，以在实际操作中获得最佳效果。\n\n## 参考\n\n- [Gateway API v1.1: Service mesh, GRPCRoute, and a whole lot more - kubernetes.io](https:\/\/kubernetes.io\/blog\/2024\/05\/09\/gateway-api-v1-1\/)', '\/blog\/what-is-new-in-istio-1-22\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">探索 Istio 1.22 的新特性与实用建议，包括增量 xDS、路径模板支持及 API 升级等，助力优化服务网格管理。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/xinjiang-ili-trip/">自驾伊犁河谷：领略新疆壮美风景</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/06/10</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e6%97%85%e8%a1%8c"> 
             旅行
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('自驾伊犁河谷：领略新疆壮美风景', '端午自驾游伊犁，探索壮美风景与特色美食，记录难忘旅程与心动瞬间。', '\n三年前，我与 Addo [环游了新疆北疆](\/blog\/xinjiang-trip\/)，那次旅行让我久久难忘，尤其是伊犁河谷地带，始终萦绕在心头。这次端午佳节，我决定再赴伊犁，开启一场自驾之旅。\n\n经过精心策划，我从北京出发，途经乌鲁木齐转机，来到美丽的伊宁。在这里，我们租了一辆车，开始了为期一周、总行程 1344 公里的自驾之旅。\n\n## 航拍视频\n\n在这段视频中，你将看到我在旅途中拍摄的壮丽航拍画面。从广阔的草原到清澈的湖泊，从巍峨的雪山到蜿蜒的公路，这些美景都在视频中得到了完美的呈现。\n\n\u0060{{\u003c responsive_video src=\u0022\/\/player.bilibili.com\/player.html?isOutside=true\u0026aid=1205635099\u0026bvid=BV16f421D7Qs\u0026cid=1576995666\u0026p=1\u0022 \u003e}}\u0060\n\n## 伊宁喀赞其\n\n我们的第一站是伊宁市的喀赞其民俗村，这是一个充满民族风情的小镇。这里的街道两旁是独具特色的传统民居，五彩斑斓的墙壁和蓝色的大门，仿佛童话世界。喀赞其的生活气息浓厚，街上随处可见当地居民的日常生活场景。\n\n![伊宁喀赞其](kazanqi.jpg)\n\n## 伊犁河\n\n从喀赞其出发，我们前往了伊犁河。伊犁河的河水清澈见底，两岸绿树成荫，广阔的湿地景色宜人。我们在伊犁湿地公园观看了一场壮美的日落，沉醉于大自然的美景中。\n\n![伊犁河](ili-river.jpg)\n\n## 喀拉峻\n\n第三站是喀拉峻草原。广阔的草原上，牛羊成群，远处的雪山与蓝天白云相映成趣，构成了一幅绝美的自然画卷。这里平均海拔 2000 多米，空气格外清新，每一口呼吸都让人感到无比的舒畅。我在这里露营了一晚，经过了一夜的风雨，第二天雨过天晴日出时，阳光洒在身上暖洋洋的，眺望远处的日照金山。\n\n![喀拉峻草原](kalajun.jpg)\n\n## 琼库什台\n\n接下来，我们来到了琼库什台。这个哈萨克族的原始村庄虽然多了一些商业气息，但依然保留着原始的魅力。草原和河谷里新开的民宿和饭店让更多游客慕名而来。我们骑马前往后山，体验了最纯粹的自然风光。尤其是夕阳西下时，在山顶看着连绵起伏的草原和远处的雪山交相辉映，相映成趣。\n\n![琼库什台](qiongkushitai.jpg)\n\n## 夏塔古道\n\n夏塔古道是此次行程中的重要景点。古道曾是丝绸之路上的一部分，沿途高山峡谷景色壮丽。尽管景区尚未开放，我们还是通过无人机航拍领略了这里的冰川河谷。\n\n![夏塔古道](xiata.jpg)\n\n## 伊昭公路\n\n伊昭公路被誉为新疆最美的公路之一。沿途风景从高山到草原，从森林到湖泊，变幻多姿。行驶在悬崖峭壁上，不禁感叹开路人的艰辛。\n\n![伊昭公路](yizhao-highway.jpg)\n\n## 赛里木湖\n\n最后一站是赛里木湖，位于博尔塔拉蒙古自治州。这个高山湖泊的湖水清澈见底，碧蓝如普鲁士蓝，四周环绕着雪山和草原，景色如诗如画。我们在湖边漫步，夜宿赛里木湖西岸，感受这座号称“大西洋的最后一滴眼泪”的静谧与壮丽。\n\n![赛里木湖](sayram-lake.jpg)\n\n这次新疆伊犁自驾之旅不仅让我领略了壮丽的自然风光，还体验了当地独特的民族文化。通过航拍镜头，我记录下了这一路的美景，制作成了一个视频与大家分享。\n\n## 美食\n\n伊犁不仅风景如画，美食也令人垂涎。红柳烤肉的鲜香、辣子肉的香辣（当地人将它作为早餐，配合花卷一起吃）、椒麻鸡的麻辣、赛里木湖的高山鲑鱼籽炒饭的鲜香，都是我旅途中难忘的味道。\n\n![顺时针方向分别为高山鲑鱼籽炒饭、红柳烤肉、辣子肉、椒麻鸡](food.jpg)\n\n另外新疆的干果、奶酪和牛肉干也是不错的伴手礼。\n\n## 总结\n\n这次旅程将成为我人生中一段难忘的回忆。新疆伊犁的美景与魅力，让我深深地爱上了这片土地。如果有机会，我一定会再来这里，探索更多未尽的风景。\n\n希望这篇游记能带给你一些关于新疆伊犁的美好回忆。如果你也有机会去新疆旅行，一定不要错过这些美丽的景点。\n', '\/blog\/xinjiang-ili-trip\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">端午自驾游伊犁，探索壮美风景与特色美食，记录难忘旅程与心动瞬间。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-delta-xds-for-envoy/">Envoy xDS 及 Istio 中的配置分发流程介绍</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/06/04</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/envoy"> 
             Envoy
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Envoy xDS 及 Istio 中的配置分发流程介绍', '本文分享了 xDS 的组成及 Istio 中配置分发的流程，还有 xDS 的两种模式 SotW 和 Delta xDS。', '\n在 Istio 项目的早期采用全局状态（State of the World，简称 SotW）的方式推送配置给 Envoy 代理。一旦有一个服务变更，就要将全局配置推送给所有 Sidecar，造成巨大的网络负担及控制平面的性能损耗。Istio 社区从几年前就开始开发增量 xDS 以解决此问题，并在最近几个 Istio 版本中支持了增量 xDS。在最近的 [Istio 1.22 发布](https:\/\/istio.io\/latest\/news\/releases\/1.22.x\/announcing-1.22\/)中，增量 xDS 成为默认开启的功能。本文将为你介绍 xDS、增量 xDS 及 Istio 的配置分发方式。\n\n## 什么是 xDS？{#what-is-xds}\n\nxDS（Extensible Discovery Service）是一种通信协议，用于在微服务架构中管理服务发现和动态配置。这种机制被广泛用于 Envoy 代理和 Istio 服务网格中，以管理各种类型的资源配置，如路由、服务发现、负载均衡设置等。\n\n### xDS 包含哪些发现服务？{#xds-services}\n\nxDS 包括以下主要的发现服务，每种服务都负责不同类型的网络资源配置：\n\n1. **LDS（Listener Discovery Service）**：管理 Envoy 监听器的配置，这些监听器定义了如何接收和处理入站连接。\n2. **RDS（Route Discovery Service）**：提供路由信息，定义了如何根据指定规则将请求路由到不同的服务。\n3. **CDS（Cluster Discovery Service）**：管理集群信息，集群代表一组逻辑上类似的后端服务实例。\n4. **EDS（Endpoint Discovery Service）**：提供具体服务实例的网络地址，这些服务实例组成了 CDS 中定义的集群。\n5. **SDS（Secret Discovery Service）**：管理安全相关的配置，如 TLS 证书和私钥。\n6. **VHDS（Virtual Host Discovery Service）**：为 RDS 提供虚拟主机配置，允许动态更新虚拟主机而不重启连接。\n7. **SRDS（Scoped Route Discovery Service）**：管理路由作用域，提供基于不同条件（如请求头部）的动态路由选择。\n8. **RTDS（Runtime Discovery Service）**：提供运行时配置，这些配置可用于实验性功能或精细调整系统行为。\n9. **ECDS（Extension Config Discovery Service）**：为特定过滤器提供动态配置更新的服务。目前，网络过滤器、HTTP 过滤器和监听器过滤器都支持 ECDS。\n\n这些服务共同支持动态配置的分发和更新，使得基于 Envoy 的应用架构能够实时适应变化，提高可扩展性和灵活性。每种服务的实现可以独立进行，也可以通过聚合方式（如 ADS）进行统一管理。CNCF 也成立了 [xDS API 工作组](https:\/\/github.com\/cncf\/xds)来推动 xDS API 为 L4\/L7 数据平面配置提供事实上的标准，类似于 SDN 中 OpenFlow 在 L2\/L3\/L4 中所扮演的角色。\n\n{{\u003ccallout note 提示\u003e}}\n关于 xDS  协议的详细介绍，如 xDS 协议的 RPC 服务和变体方法，以及 xDS 请求流程，请参考 [Envoy 代理文档](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-docs\/xds_protocol)。\n{{\u003c\/callout\u003e}}\n\n### xDS 协议的变体 {#xds-variants}\n\nxDS 协议主要包括以下变体：\n1. **State of the World (SotW)**：单独的 gRPC 流为每种资源类型提供完整数据，通常在 Envoy 代理初次启动时使用，也是 Istio 最早使用的 xDS 协议类型。\n2. **增量 xDS（Delta xDS）**：为每种资源类型提供变化的部分数据，从 2021 年开始开发，在 Istio 1.22 版本中开始默认开启。\n3. **聚合发现服务（ADS）**：一个 gRPC 流聚合所有资源类型的数据。\n4. **增量 ADS（Delta ADS）**：一个 gRPC 流聚合所有资源类型的增量数据。\n\n下表概述了 xDS 协议的四种变体，包括对每个变体的解释、使用场景以及优缺点的对比。这些变体为不同的网络环境和服务需求提供了多种选择，可以根据具体情况选择最合适的协议变体以优化服务的性能和资源使用。\n\n{{\u003ctable \u0022xDS 协议的四种变体介绍\u0022\u003e}}\n| 变体类型  | 解释                                                         | 使用场景                                                     | 优点                                                     | 缺点                                                         |\n| --------- | ------------------------------------------------------------ | ------------------------------------------------------------ | -------------------------------------------------------- | ------------------------------------------------------------ |\n| SotW      | 每次都发送所有配置数据，不论是否有变化。                     | 适用于配置较少变化的稳定环境。                               | 简单易实现，易于理解和维护。                             | 数据传输量大，不适合频繁更新配置的环境。                     |\n| Delta xDS | 只传输变更的配置数据，而不是全部数据。                       | 适用于配置频繁变化，需要快速响应变更的环境。                 | 减少了不必要的数据传输，提高了效率。                     | 实现复杂，需要客户端和服务端管理配置状态。                   |\n| ADS       | 通过单一的 gRPC 流来管理所有配置数据，无需为每种资源类型建立独立的连接。 | 适用于需要同时管理多种类型资源的复杂服务架构。               | 减少了网络连接数，简化了资源管理。                       | 对于网络或服务质量差的情况，单点故障可能导致所有配置更新失败。 |\n| Delta ADS | 结合了 ADS 和增量 xDS 的优点，通过一个 gRPC 流聚合并且只传输变化部分的资源。 | 适用于既需要管理多种资源类型，又需要频繁更新配置的极其动态的环境。 | 提供了最大的灵活性和效率，适合大规模和高动态的服务架构。 | 实现最为复杂，对于配置管理的逻辑要求高，需要精确控制资源的变更和传输。 |\n\n{{\u003c\/table\u003e}}\n\n使用 xDS 协议的服务网格可以更灵活地管理微服务之间的通信和配置，减少了配置变更的延迟，提高了系统的响应速度和可靠性。\n\n在 Istio 中，DiscoveryServer 作为 Envoy 的 xDS API 的实现，负责监听 gRPC 接口并根据 Envoy 的需求动态推送配置。它能够处理各种资源类型的请求，并根据服务的变更实时更新 Envoy 配置。此外，它还支持安全特性，如验证客户端证书，确保只有合法的服务实例可以接收配置数据。\n\n### xDS 变体的配置示例 {#xds-config}\n\n使用 xDS 协议的变体通常涉及在 Envoy 代理或与之类似的服务网格配置中指定 xDS 服务器的详细信息。虽然不同的服务网格和代理服务器的配置细节可能有所不同，下面是一些通用的 YAML 配置示例，说明如何指定 xDS 服务器以及如何使用这些协议变体。\n\n#### State of the World (SotW)\n\n在 Envoy 的配置中，你可以通过静态资源或通过 API 动态获取资源的方式来使用 SotW。这里是一个简单的 Envoy 配置示例，显示了如何静态定义集群和监听器：\n\n{{\u003chighlight yaml \u0022linenos=table,hl_lines=24\u0022\u003e}}\nstatic_resources:\n  listeners:\n    - address:\n        socket_address: { address: 0.0.0.0, port_value: 80 }\n      filter_chains:\n        - filters:\n            - name: envoy.http_connection_manager\n              config:\n                stat_prefix: ingress_http\n                codec_type: auto\n                route_config:\n                  name: local_route\n                  virtual_hosts:\n                    - name: local_service\n                      domains: [\u0022*\u0022]\n                      routes:\n                        - match: { prefix: \u0022\/\u0022 }\n                          route: { cluster: local_service }\n                    http_filters:\n                      - name: envoy.router\n                  clusters:\n        - name: local_service\n            connect_timeout: 0.25s\n            type: STATIC\n            lb_policy: ROUND_ROBIN\n            hosts: [{ socket_address: { address: 127.0.0.1, port_value: 80 } }]\n{{\u003c\/highlight\u003e}}\n\n####  增量 xDS {#axds}\n\n增量 xDS 的配置需要在 xDS 服务端支持增量协议，并在客户端配置中指定使用增量 xDS。Envoy 启动配置中需要添加 API 版本来启用增量 xDS：\n\n{{\u003chighlight yaml \u0022linenos=table,hl_lines=4 10\u0022\u003e}}\ndynamic_resources:\n  cds_config:\n    api_config_source:\n      api_type: DELTA_GRPC\n      grpc_services:\n        envoy_grpc:\n          cluster_name: xds_cluster\n  lds_config:\n    api_config_source:\n      api_type: DELTA_GRPC\n      grpc_services:\n        envoy_grpc:\n          cluster_name: xds_cluster\n{{\u003c\/highlight\u003e}}\n\n#### 聚合发现服务 (ADS) {#ads}\n\n使用 ADS 时，所有资源类型的配置通过一个单一的 API 端点聚合。这在 Envoy 配置中指定：\n\n{{\u003chighlight yaml \u0022linenos=table,hl_lines=6 7\u0022\u003e}}\ndynamic_resources:\n  cds_config:\n    ads: {}\n  lds_config:\n    ads: {}\n  ads_config:\n    api_type: GRPC\n    grpc_services:\n      envoy_grpc:\n        cluster_name: xds_cluster\n{{\u003c\/highlight\u003e}}\n\n####  增量 ADS {#adds}\n\n增量 ADS 通过在 ADS 配置中指定增量 API 类型，可以实现更为细粒度的更新：\n\n{{\u003chighlight yaml \u0022linenos=table,hl_lines=8 9\u0022\u003e}}\ndynamic_resources:\n  cds_config:\n    ads: {}\n    resource_api_version: V3\n  lds_config:\n    ads: {}\n    resource_api_version: V3\n  ads_config:\n    api_type: DELTA_GRPC\n    grpc_services:\n      envoy_grpc:\n        cluster_name: xds_cluster\n{{\u003c\/highlight\u003e}}\n\n这些配置示例需要根据你的具体环境和需求进行调整。更多细节和高级配置，你可以参考 [Envoy 文档](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-v3\/config\/core\/v3\/config_source.proto#envoy-v3-api-enum-config-core-v3-apiconfigsource-apitype)。\n\n## Istio 如何发送配置给 Envoy sidecar？\n\n得益于 xDS 协议，如 Istio、Envoy Gateway 等可以通过 API 远程动态分发配置到 Envoy 代理。下图展示了 Istio 的配置分发流程（Sidecar 模式）。\n\n\u0060\u0060\u0060mermaid \u0022Istio 的配置分发流程图\u0022\nflowchart TB\n    Declarative_Configuration[声明式配置] --\u003e Kubernetes\n    Kubernetes \u003c--\u003e Istiod\n\n    subgraph Istiod [Istiod]\n        xDS_API[xDS API]\n    end\n\n    xDS_API \u003c--\u003e Pod1\n    xDS_API \u003c--\u003e Pod2\n    xDS_API \u003c--\u003e Pod3\n\n    subgraph Pod1 [Pod]\n        Envoy_Proxy1[Envoy Proxy] \u003c--\u003e Application1[Application]\n    end\n\n    subgraph Pod2 [Pod]\n        Envoy_Proxy2[Envoy Proxy] \u003c--\u003e Application2[Application]\n    end\n\n    subgraph Pod3 [Pod]\n        Envoy_Proxy3[Envoy Proxy] \u003c--\u003e Application3[Application]\n    end\n\u0060\u0060\u0060\n\n![Istio 的配置分发流程图](0fa133ccdbeb372a413ad1ecc99ff9f0.svg)\n\nIstio 中配置分发的主要流程说明：\n\n1. **声明式配置**：用户通过 YAML 文件或其他配置管理工具定义服务网格的配置。这些配置可以包括路由规则、安全策略、遥测设置等。\n2. **Kubernetes**：Istio 配置文件被提交到 Kubernetes 集群中，通常是通过 \u0060kubectl apply\u0060 命令或其他 CI\/CD 工具。Kubernetes 接收到配置文件并将其存储在 etcd 数据库中。\n3. **Istiod**：Istiod 是 Istio 的控制平面组件，负责管理和分发配置。它监听从 Kubernetes API 服务器中传入的事件，获取相关配置变更，并对其进行处理。Istiod 解析配置文件，生成相应的路由规则和策略，并通过 xDS API 将这些配置分发到数据平面（Envoy 代理）。\n4. **xDS API**：Istiod 使用 xDS API 将配置下发到各个 Envoy 代理中。\n5. **Envoy Proxy**：Envoy 是 Istio 的数据平面组件，运行在每个服务的旁路（sidecar）容器中，拦截并管理所有入站和出站流量。Envoy 代理通过 xDS API 接收来自 Istiod 的配置，并根据这些配置进行流量管理、策略执行和遥测数据收集。\n6. **Pod**：每个服务实例运行在一个 Pod 中，Pod 内部包含一个应用容器和一个 Envoy 代理容器。Envoy 代理拦截应用容器的所有网络流量，并根据配置进行处理。\n\n这个配置分发流程确保了 Istio 能够动态管理和配置服务网格中的所有服务实例，提供一致的流量管理和策略执行。\n\n## xDS 的发展与 Istio 中的 Delta xDS 实现\n\n起初，xDS 采用了“全局状态”（State of the World，简称 SotW）的设计，这意味着任何一个配置的更改都需要向 Envoy 发送所有配置的完整状态。这种方法在网络和控制平面上造成了巨大的负担，尤其是在大规模服务部署时。\n\n在 2021 年的 EnvoyCon 上，Aditya Prerepa 和 John Howard 分享了 Istio 如何实现 Delta xDS，这是一种增量式的 xDS 实现。与传统的 SotW xDS 相比，Delta xDS 只发送变更的配置，显著减少了需要通过网络发送的配置数据量，从而提高了效率和性能。这种方法特别适用于那些配置频繁变更的环境，因为它只更新变化的部分而不是整个配置。\n\n在实现 Delta xDS 的过程中，Istio 团队面临了多个挑战，包括如何确保配置更新的正确性以及避免潜在的资源泄漏。他们通过采用干运行（Dry-run）模式来并行运行 SotW 和 Delta 生成器，逐步发现并修复了实现中的缺陷。此外，他们还引入了新的 Envoy 类型，如虚拟主机发现服务（Virtual Host Discovery Service），以支持更细粒度的配置分发。\n\n### Delta xDS 增量配置\n\n下图展示了 Delta xDS 增量配置的流程。\n\n\u0060\u0060\u0060mermaid \u0022Delta xDS 增量配置流程图\u0022\nsequenceDiagram\n    participant CP as 控制平面\n    participant P as 代理\n    CP-\u003e\u003eP: 初始完整配置\n    P-\u003e\u003eCP: 订阅配置变更\n    Note over CP,P: 发生任何配置变更\n    CP-\u003e\u003eP: 检查配置变更\n    CP-\u003e\u003eP: 计算差异\n    CP-\u003e\u003eP: 仅发送差异\n    Note over P: 代理使用差异进行更新\n\u0060\u0060\u0060\n\n![Delta xDS 增量配置流程图](835038abb9bb83ba223974c525293468.svg)\n\nDelta xDS 配置流程如下：\n\n1. **初始完整配置**：控制平面向代理发送初始完整配置，此时使用的是 StoW 模式。\n2. **订阅配置变更**：代理从控制平面订阅配置变更。\n4. **检查配置变更**：控制平面检查相对于代理已知状态的配置变更。\n5. **计算差异**：控制平面计算当前配置与代理持有的前一配置之间的差异（增量）。\n6. **仅发送差异**：控制平面仅发送变更的配置（差异）给代理，代理应用这些差异增量更新其配置。\n\n该流程确保只有必要的变更被传输和应用，提高了效率并减少了网络和代理资源的负载。\n\n### SotW vs Delta xDS\n\n虽然 Delta xDS 解决了在大规模网络下的配置分发的性能问题，但是 SotW 模式依然有它存在的意义，比如在初次下发配置的情况下。下表对比了 Istio 中的两种配置分发方式：SotW (State of the World) 和 Delta xDS。\n\n{{\u003ctable \u0022Istio 中的全局状态和增量 xDS 配置分发方式对比\u0022\u003e}}\n| 对比项         | SotW                                                     | Delta XDS                                    |\n| -------------- | -------------------------------------------------------- | -------------------------------------------- |\n| **数据传输量** | 每次传输完整的配置数据，不管配置是否有变更。             | 仅传输发生变化的配置数据，减少了数据传输量。 |\n| **效率**       | 在小型或变更少的环境中效率可接受。                       | 在大型环境或频繁变更的环境中更高效。         |\n| **复杂性**     | 实现简单，易于理解和维护。                               | 实现较为复杂，需要精细的变更跟踪和管理。     |\n| **资源消耗**   | 可能因为重复发送大量未变更的数据而增加服务器和网络负载。 | 更低的资源消耗，因为只处理变更的部分。       |\n| **实时性**     | 配置更新后立即发送全量配置，实时性高。                   | 只发送变更部分，响应更快，减少处理时间。     |\n| **适用场景**   | 适合配置变动不频繁的小型至中型部署。                     | 适合配置频繁变更或大规模部署的场景。         |\n{{\u003c\/table\u003e}}\n\n这个表格从数据传输量、效率、复杂性、资源消耗、实时性以及适用场景等多个角度对 SotW 和 Delta XDS 进行了对比，有助于在不同的使用环境中做出合适的选择。\n\n## 总结\n\n在这篇文章中我分享了 xDS 的组成及 Istio 中配置分发的流程，还有 xDS 的两种模式 SotW 和 Delta xDS。随着 Delta xDS 在 Istio 1.22 版本中成为默认配置，这将有助于用户在大规模网络环境下轻松使用 Istio。\n\n## 参考\n\n- [xDS REST and gRPC protocol - envoyproxy.io](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-docs\/xds_protocol)\n', '\/blog\/istio-delta-xds-for-envoy\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文分享了 xDS 的组成及 Istio 中配置分发的流程，还有 xDS 的两种模式 SotW 和 Delta xDS。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
          <div class="col-12">
 
 
 
 
 
 
 
 
 
 
 
 <nav aria-label="Page navigation">
   <ul class="pagination justify-content-center">
     
     
     <li class="page-item">
       <a class="page-link" href="/blog/">
         ««
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a href="/blog/page/6/" class="page-link">
         «
       </a>
     </li>
     
     
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item">
           <a href="/blog/page/5/" class="page-link">
             5
           </a>
         </li>
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item">
           <a href="/blog/page/6/" class="page-link">
             6
           </a>
         </li>
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item page-item active ">
           <a href="/blog/page/7/" class="page-link">
             7
           </a>
         </li>
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item">
           <a href="/blog/page/8/" class="page-link">
             8
           </a>
         </li>
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item">
           <a href="/blog/page/9/" class="page-link">
             9
           </a>
         </li>
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
     
     
     <li class="page-item">
       <a href="/blog/page/8/" class="page-link">
         »
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a class="page-link" href="/blog/page/30/">
         »»
       </a>
     </li>
     
   </ul>
 </nav>
 
</div>

        </div>
      </div>
      <!-- sidebar -->
      <aside class="col-lg-4 order-1 order-lg-2 d-none d-sm-block">
          <div class="sidebar">
          <!-- categories -->
<div class="blog-categories mb-4">
  <p class="sidebar-title">
      专栏
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/istio" class="sidebar-item">
            <span>Istio</span>
            <span>(87)</span>
        </a>
      
        <a href="/categories/service-mesh" class="sidebar-item">
            <span>Service Mesh</span>
            <span>(42)</span>
        </a>
      
        <a href="/categories/kubernetes" class="sidebar-item">
            <span>Kubernetes</span>
            <span>(25)</span>
        </a>
      
        <a href="/categories/%e9%9a%8f%e7%ac%94" class="sidebar-item">
            <span>随笔</span>
            <span>(22)</span>
        </a>
      
        <a href="/categories/%e5%85%b6%e4%bb%96" class="sidebar-item">
            <span>其他</span>
            <span>(20)</span>
        </a>
      
        <a href="/categories/envoy" class="sidebar-item">
            <span>Envoy</span>
            <span>(18)</span>
        </a>
      
        <a href="/categories/%e4%b8%9a%e6%80%81" class="sidebar-item">
            <span>业态</span>
            <span>(17)</span>
        </a>
      
        <a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f" class="sidebar-item">
            <span>云原生</span>
            <span>(14)</span>
        </a>
      
        <a href="/categories/ai" class="sidebar-item">
            <span>AI</span>
            <span>(10)</span>
        </a>
      
        <a href="/categories/%e5%ae%89%e5%85%a8" class="sidebar-item">
            <span>安全</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%bc%80%e6%ba%90" class="sidebar-item">
            <span>开源</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%b7%a5%e5%85%b7" class="sidebar-item">
            <span>工具</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e6%97%85%e8%a1%8c" class="sidebar-item">
            <span>旅行</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e5%8f%af%e8%a7%82%e6%b5%8b%e6%80%a7" class="sidebar-item">
            <span>可观测性</span>
            <span>(6)</span>
        </a>
  </div>
</div>

<div class="blog-categories mb-4">
  <p class="sidebar-title">
      资料
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/%e5%87%ba%e7%89%88%e7%89%a9" class="sidebar-item">
            <span>出版物</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e7%94%b5%e5%ad%90%e4%b9%a6" class="sidebar-item">
            <span>翻译电子书</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e6%96%87%e6%a1%a3" class="sidebar-item">
            <span>翻译文档</span>
            <span>(7)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>翻译图书</span>
            <span>(6)</span>
        </a>
      
        <a href="/categories/%e5%8e%9f%e5%88%9b%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>原创图书</span>
            <span>(2)</span>
        </a>
      
        <a href="/categories/%e6%95%99%e7%a8%8b%e6%89%8b%e5%86%8c" class="sidebar-item">
            <span>教程手册</span>
            <span>(2)</span>
        </a>
  </div>
</div>





          </div>
      </aside>
      <!-- /sidebar -->
    </div>
  </div>
</section>




<footer>
  
  <div class="footer bg-footer section-sm border-bottom overlay ">
    <div class="container-xl">
      <div class="row">
        <div class="col col-xl-4 d-sm-none mb-2 mb-lg-0 d-xl-block d-none">
          
          <p class="h3 text-white mb-4 text-uppercase">联系</p>
          
          <ul class="list-unstyled">
            
            
            <li class="mb-4 text-color">微信公众号</li>
            
            
            <li class="mb-4"><img src="/images/servicemesher-wechat.webp" width="118px" height="118px" alt="footer image"></li>
            
            
            
          
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">博客</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/blog/mastering-github-copilot-for-open-source/">探索 GitHub Copilot：当 AI 成为你的贴身编码助手</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/beyond-sidecar/">超越 Sidecar：深入解析 Istio Ambient Mode 的流量机制与成本效益</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/istio-installation-deep-dive/">Istio 安装方式深度剖析——选择与实践指南</a></li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">链接</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://istio.io/latest/zh/" target="_blank" rel="noopener noreferrer">
                  Istio 服务网格
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://tetrate.io/?jimmysong" target="_blank" rel="noopener noreferrer">
                  Tetrate 公司
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener noreferrer">
                  云原生学院|Bilibili
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/awesome-cloud-native/" target="_blank" rel="noopener noreferrer">
                  云原生开源项目大全
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://cloudnative.to" target="_blank" rel="noopener noreferrer">
                  云原生社区（中国）
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">教程</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/envoy-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Envoy 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/istio-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Istio 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/kubernetes-handbook/" >
                  Kubernetes 基础教程
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/envoy-made-simple/" >
                  简明 Envoy 教程
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">通知</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/notice/kcd-beijing-2025/">KCD Beijing 2025 - 提交议题及参会报名</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/cloud-native-community-domain-migration/">云原生社区网站域名变更通知</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/nist-sp-800-233-service-mesh-proxy-models/">资料分享：云原生应用服务网格代理模型的威胁分析指南</a></li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>

  
  <div class="copyright py-4 bg-footer overlay">
    <div class="container-xl">
      <div class="row">
        <div class="col-sm-6 text-sm-left text-center">
          <p class="mb-0 text-color">© 2017-2025 Jimmy Song 保留所有权利</p>
        </div>
        <div class="col-sm-6 text-sm-right text-center">
          <ul class="list-inline">
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://twitter.com/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-x-twitter text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/contact/" >
                    <i class="fa-brands fa-weixin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://github.com/rootsongjc" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-github text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://linkedin.com/in/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-linkedin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="mailto:rootsongjc@gmail.com" >
                    <i class="fa-solid fa-envelope text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/blog/index.xml" >
                    <i class="fa-solid fa-rss text-white"></i>
              </a>
            </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>


<!-- JS Plugins -->

<script src="/plugins/popper/popper.min.js"></script>

<script src="/plugins/bootstrap/bootstrap.min.js"></script>

<script src="/plugins/slick/slick.min.js"></script>

<script src="/plugins/filterizr/jquery.filterizr.min.js"></script>

<script src="/plugins/search/fuse.min.js"></script>

<script src="/plugins/search/mark.js"></script>

<script src="/plugins/hex_md5/hex_md5.js"></script>

<script src="/plugins/anchor/anchor.min.js"></script>

<script src="/plugins/tocbot/tocbot.min.js"></script>

<script src="/plugins/bigger-picture/bigger-picture.min.js"></script>


<!-- Main Script -->

<script src="/js/script.min.f94c22b1d478bfc9e2e0a7d954429e47b7e6d36edd423758482e04154ae1842e.js"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-ESY906ZWZ0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ESY906ZWZ0');
</script>


<!-- Baidu analysis -->
<meta name="baidu-site-verification" content="g8IYR9SNLF" />





<script>
    anchors.add();
</script>






<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>










<script src="/js/wowchemy-search.min.7a37268e7bbe4a9160c2e4c33b749816.js" type="module"></script>
<script id="search-hit-fuse-template" type="text/x-template">
  <div class="search-hit" id="summary-{{key}}">
    <div class="search-hit-content border-bottom">
      <div class="search-hit-name">
        <div class='search-hit-link'><a href="{{relpermalink}}">{{title}}</a></div>
        <div class="search-hit-metadata d-flex">
            <span class="mr-1"><i class="fa-regular fa-calendar mr-1"></i>{{date}}</span>
            <span class="mr-1"><i class="fa-regular fa-folder-open mr-1"></i>{{section}}</span>
            <span class="d-sm-block d-none"><i class="fa-solid fa-link mr-1"></i>{{relpermalink}}</span>
        </div>
        <div class="search-hit-description">{{snippet}}</div>
      </div>
    </div>
  </div>
</script>



    </body>
</html>
