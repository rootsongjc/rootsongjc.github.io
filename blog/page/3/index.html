<!DOCTYPE html>
<html lang="zh"><head>
  <meta charset="utf-8">
  
  <title>博客 · Jimmy Song</title>
  

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta name="description" content="Jimmy Song 的原创博客及译文。">
  <meta name="author" content="Jimmy Song">
  <meta name="generator" content="Hugo 0.129.0">

  <!-- CSS plugins -->
  
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
  
  <link rel="preload" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" as="style">
  <link rel="stylesheet" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" media="screen">
  

  <!-- Main Stylesheet -->
  
  <link rel="preload" href="/scss/style.min.595949bd12db88434115e2a1e70965cf2928cc646e73acc6437c4cbbc323f585.css" as="style">
  <link rel="stylesheet" href="/scss/style.min.595949bd12db88434115e2a1e70965cf2928cc646e73acc6437c4cbbc323f585.css" media="screen">

  <!-- Bigger picture css -->
  
  <link rel="stylesheet" href="/plugins/bigger-picture/bigger-picture.min.css" media="print" onload="this.media='all'">
  <!--Favicon generate by https://realfavicongenerator.net-->
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="200x200" href="/images/favicon.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">

  <link href='/opensearchdescription.xml' rel='search' title='Content search' type='application/opensearchdescription+xml'/>

  <!--Twitter card-->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="jimmysong.io" />
  <meta name="twitter:creator" content="@jimmysongio" />
  <meta property="og:url" content="https://jimmysong.io/blog/" />
  <meta property="og:title" content="博客 | Jimmy Song" />
  <meta property="twitter:title" content="博客 | Jimmy Song" />

  
  <meta property="og:description" content="Jimmy Song 的原创博客及译文。" />
  <meta property="twitter:description" content="Jimmy Song 的原创博客及译文。" />

  
  <meta property="og:image" content="https://jimmysong.io/images/banner/default.jpg" />
  <meta property="twitter:image" content="https://jimmysong.io/images/banner/default.jpg" />

  
  
</head>
<body>
<header class="fixed-top header">
  
  
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa fa-arrow-circle-up" aria-hidden="true"></i></button>
  
  <div class="navigation w-100 ">
    <div class="container-xl">
      <nav class="navbar navbar-expand-lg navbar-light p-0">
        <a class="navbar-brand" href="/">
            
            <b>JIMMY SONG</b>
            
        </a>
        <button class="navbar-toggler rounded-0" type="button" data-toggle="collapse" data-target="#navigation"
          aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse text-center" id="navigation">
          <ul class="navbar-nav ml-auto">
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/blog">博客</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/book">资料</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/tags">标签</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/notice">公告</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/contact">联系</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/about">关于</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/community/">社区</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener">视频 <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i></a>
              
            </li>
            
            

          
          
          <li class="nav-item">
            
            
            
              
              
                
                
                
                  
                    
                    <a class="nav-link" href="/en/blog/">English</a>
                    
                  
                
              
              
              
                
                  
                    
                    
                  
                
                
                
              
          </li>
          
          
          <!-- search -->
           <button type="button" class="search-btn js-search" id="searchOpen" aria-label="Search">
              <div class="search-container d-flex justify-content-center">
              <span class="search-content">
                  <i class="fa fa-search"></i>
                  <span>搜索</span>
              </span>
              <span class="search-shortcuts d-none d-sm-block">
                  <kbd class="cmd-key">⌘</kbd>
                  <kbd class="k-key">K</kbd>
              </span>
              </div>
          </button>
          
          </ul>
        </div>
      </nav>
    </div>
  </div>
</header>


            <aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between">
        <div class="col-6 search-title">
          <p>站内搜索</p> 
        </div>
        <div class="col-6 col-search-close">
          <div class="js-search" aria-label="关闭"><i class="fa-solid fa-circle-xmark text-muted" aria-hidden="true"></i></div>
        </div>
      </div>

      <div id="search-box">
        <i class="fa-solid fa-magnifying-glass" id="search-icon" aria-hidden="true"></i>
        <input name="q" id="search-query" placeholder="请输入搜索词" autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control" aria-label="请输入搜索词">
        
        <div class="mt-4">
          <span>搜索类型: </span>
          <span>
            <input type="radio" id="all" name="search_type" value="all" checked>
            <label for="all">所有</label>
            
              <input type="radio" id="blog" name="search_type" value="blog">
              <label for="blog">原创</label>
              <input type="radio" id="trans" name="search_type" value="trans">
              <label for="trans">译文</label>
            
            <input type="radio" id="book" name="search_type" value="book">
            <label for="book">资料</label>
            <input type="radio" id="notice" name="search_type" value="notice">
            <label for="notice">公告</label>
          </span>
        </div>
      </div>
      
    </section>
    <section class="section-search-results">
      <div id="search-results-count" class="search-results-count"></div>
      <div id="search-hits">
        
      </div>
    </section>
  </div>
</aside>

        
        
            

<section class="bg-cover page-title-section overlay" style="background-image: url('/images/backgrounds/circle.svg'),url('/images/backgrounds/page-title.webp');background-size: cover;">
    <div class="container-xl">
        <div class="row">
            <div class="col-12">
                <p class="h1">
                    博客
                </p>
                <p class="page-description">
                    Jimmy Song 的原创博客及译文。
                </p>
                
            </div>
        </div>
    </div>
</section>

        


<section class="section-sm book-list-section bg-gray">
  <div class="container-xl">
    <div class="row">
      <div class="col-lg-8 order-2 order-lg-1">
        <div class="row">
          
          
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/paris-trip/">首次巴黎之旅：探索城市风情与文化洞察</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/06/16</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e6%97%85%e8%a1%8c"> 
             旅行
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('首次巴黎之旅：探索城市风情与文化洞察', '2024 年 3 月，我借参加 KubeCon EU 之机访问巴黎，体验了当地文化、美食和生活细节。', '\n2024 年 3 月，一个特别的机会将我带到了法国巴黎——参加 [KubeCon EU 2024](\/blog\/kubecon-eu-paris-recap\/)。这是一场汇集了来自全球的云计算和开源技术爱好者的盛会。利用这次会议的机会，我不仅深入了解了最新的技术趋势，还抓住机会体验了这座城市的历史、文化和日常生活。我的巴黎之行从 3 月 16 日开始，持续到 3 月 24 日，这期间我尽可能多地探索了这座充满魅力的城市。\n\n## 签证篇章\n\n对于我们中国人来说，无论何时何地，出国的第一步总是签证的申请。尤其是法国申根签证，需要准备众多材料，包括公司证明信、行程单等，但幸好我所在的公司性质让这一切变得相对容易。令人感到略有安慰的是，与申请日本签证相比，法国签证不需要冻结巨额资金或提供庞大的银行存款证明。这次我获得了六个月的签证有效期，这对于我未来的欧洲行计划提供了更多的灵活性和可能性。\n\n## 到达巴黎\n\n从北京直飞巴黎的旅程总是充满期待。我乘坐的法国航空公司航班，从北京时间凌晨起飞，经过长达 13 小时的旅程后，于巴黎时间早晨 6 点多抵达。归途则选择了在伊斯坦布尔转机，让旅行的回忆更添一分异国情调。\n\n## 第一印象\n\n戴高乐机场处处可见的中文标牌，字句优雅，显示了法国人对细节的用心。尽管通关时排队等候了近一个小时，但多样化的人流让巴黎的国际化氛围愈发显著。从机场乘坐穿梭地铁时，我体验了三次才成功挤上车，可见人流之多。使用 Bolt 打车服务时，因为语言不通，还得到了一位好心法国人的帮助，他用法语帮我与司机沟通，这让我深感法国人的友好与热心。\n\n在巴黎戴高乐机场随处可见中文标识，很多地方只有英文、法文和中文三种文字的标识。\n\n![巴黎戴高乐机场](custom.webp)\n\n## 巴黎的生活细节\n\n在巴黎的每一处，都能看到那些独具特色的垃圾桶，它们不仅方便实用，还在安全上做了考虑。例如，一些垃圾桶是为了防爆而设计的，能安全投放玻璃瓶和易拉罐，而另一些仅用透明塑料袋覆盖，也是出于同样的安全考量。这些细节体现了城市管理的精细与周到。\n\n![巴黎街头的垃圾桶](dustbin.webp)\n\n巴黎的垃圾分类采用彩色编码垃圾桶系统，旨在促进适当的废物处理。垃圾箱有不同的颜色：黄色用于纸张和塑料等可回收物，棕色用于可堆肥食物残渣，白色用于酒瓶等玻璃物品，绿色\/灰色用于其他废物。该系统可帮助居民有效地分类垃圾，促进回收利用和适当的废物管理实践。\n\n## 食在巴黎\n\n尽管西餐中的牛排和糕点让人难以抗拒，我还是更偏爱家乡的味道。在巴黎，我找到了一家名为杨小厨的川菜馆，其牛肉面虽与国内有所不同，但味道可口，价格亲民。此外，巴黎街头的水果与我在网上购买的相比，不仅价格合理，而且味道也极佳，特别是我喜爱的啤梨。\n\n![巴黎的中餐、西餐及马卡龙](food.webp)\n\n另外在很多地铁口还有街头巷尾也有社区小摊及烘焙店。\n\n![街头小摊和烘焙店](store.webp)\n\n## 住在巴黎\n\n巴黎，法国的首都，不仅以其浪漫和历史著称，同时其行政区划也具有独特的结构。巴黎市通常被分为“大巴黎”和“小巴黎”。小巴黎指的是巴黎市内环，即第一到二十区，涵盖了大部分著名的历史地标和文化地区，总面积约为 105 平方公里。而大巴黎则包括小巴黎及其周边的郊区，形成一个更为广泛的都市区。\n\n![小巴黎地图](paris-map.webp)\n\n下图中环形道路是 **Boulevard Périphérique**，即巴黎环形高速公路。这条道路环绕着巴黎的 20 个区，这些区域共同构成了所谓的“小巴黎”。\n\n巴黎的 20 个区（arrondissements）按照螺旋状的顺序从市中心向外延伸，包括了市内最核心的商业、居住以及文化区域。这些区域的总面积大约为 105 平方公里（约 40.5 平方英里），从 1 区的市中心向外逐渐扩展至 20 区。\n\n这些区域是巴黎市的行政区划，而“小巴黎”这个名词通常是指的这些内环的区域，即由环形公路所环绕的巴黎市内部区域。因此，图中显示的 20 个区确实组成了“小巴黎”。\n\n相比之下，北京的二环面积约为 62 平方公里，三环面积约为 159 平方公里，小巴黎的面积在二者之间，下图展示了在同等比例尺下的小巴黎和北京三环的地图。\n\n![小巴黎和北京三环面积对比](paris-vs-beijing.webp)\n\n我此行住宿的地点位于巴黎的 15 区，这里是巴黎最大的一个区，位于塞纳河左岸（按塞纳河流向）。15 区不仅居住环境宜人，交通便利，而且距离诸如埃菲尔铁塔等著名景点也非常近，步行大约 20 分钟即可到达。我下榻的住所是一栋三层高的联排公寓，底层设有车库和会客厅，而居住区则分布在二楼和三楼，共有五个房间，旁边还有某国的大使馆官邸，增添了一份特别的国际氛围。\n\n## 行在巴黎\n\n巴黎的道路规划别具一格，道路交错纵横，并非严格的南北走向，加之红绿灯设置在街角，使得初来乍到的人有些不适应。这里的自行车道十分发达，我租了一辆助力自行车，穿行在巴黎的街头巷尾，感受到前所未有的自由与惬意。巴黎的地铁系统复杂多样，但支付方式极为方便，大部分支付都可以通过信用卡完成。\n\n对于游客来说，在小巴黎短距离出行首选方式是自行车。巴黎街头随处可见可供租赁的自行车，你可以下载 App 注册扫码支付后即可使用，注意需要绑定信用卡。有些自行车道是在路的中间，路面上有明确标识自行车道。这些自行车都是助力车，大多维护的比较好，但是也有一些存在故障，需要仔细辨别。另外巴黎的街道较窄，行人也很少遵守红绿灯，可能是因为红绿灯太多了吧。\n\n![巴黎街头的自行车道](bike.webp)\n\n巴黎的地铁票种类繁多，从单次票、日票到周票、月票一应俱全，适应不同游客的需求。然而，许多外地游客在购票环节都会遇到困惑，需要一些时间来熟悉系统。\n\n![巴黎地铁](metro.webp)\n\n巴黎地铁（Métro de Paris）始建于 1900 年，是世界上最早的地铁系统之一。这个广泛的地铁网络包括 16 条线路，覆盖总长度达 225 公里。巴黎地铁不仅连接城市中心和外围区域，还扩展到了一些近郊区域，每年服务数亿乘客，是巴黎公共交通系统的核心部分。因为建造时间比较久远，很多设施都比较老旧，比如车厢陈旧，车厢门要手动打开，运行噪音大，没有电梯等。\n\n## 医疗体验\n\n在巴黎的第二天，我因饮食不当而开始腹泻，持续了两天后才好转。在这期间，我去了当地的药店买药。药店早上 8 点准时开门，门口总是有人排队等候，这种准时和秩序让我印象深刻。\n\n![在巴黎购买的止泻药](drug.webp)\n\n法国的医疗体系被认为是世界上最好的之一，无论是急诊还是药品购买，都非常便捷。药品的质量和种类也相当丰富，能够满足不同病症的需求。\n\n## 游在巴黎\n\n在 KubeCon EU 期间，我利用空闲时间游览了几处巴黎的著名景点。埃菲尔铁塔是必须打卡的地方，我登上了二层平台，俯瞰整个巴黎，景色壮观。卢浮宫则是艺术爱好者的天堂，蒙娜丽莎的微笑吸引了无数游客驻足。虽然巴黎圣母院还在维修中，但夜晚的圣母院依旧散发着无尽的魅力。\n\n**卢浮宫**\n\n卢浮宫（Louvre Museum）是世界上最大和最著名的博物馆之一。它最初建于 12 世纪作为皇宫，直到 1793 年开放为公众博物馆。卢浮宫收藏了超过 38 万件展品，跨越从古代文明到 19 世纪的艺术与历史文物。其中最著名的作品包括《蒙娜丽莎》、《维纳斯的诞生》和《胜利女神像》等。\n\n![卢浮宫](louvre.webp)\n\n卢浮宫里人流量最大的地方就是《蒙娜丽莎》，很多人在那里排起了长龙，只为一睹她那神秘的微笑。\n\n**万神殿**\n\n巴黎万神殿，最初建造为教堂，现作为一个纪念馆，位于法国巴黎的拉丁区。这座建筑最初是为了纪念圣日内瓦瑞，后转变为纪念法国伟大人物的安息之地。建筑风格融合了古典与新古典元素，其宏伟的圆顶和庄严的柱廊使它成为巴黎的一个显著地标。万神殿内部装饰豪华，包括傅科摆锤和许多重要法国历史人物的墓穴。\n\n万神殿内的傅科摆，由法国物理学家利昂·福科于 1851 年设计，以证明地球自转的直接效应。这个简单但引人注目的实验包括一根悬挂的铁球，通过其自由摆动，观察者可以看到摆动平面相对于地面缓慢旋转的现象，这一旋转是地球自转的直接证据。福科摆锤不仅是物理学的一个重要实验，也成为了科学与艺术的结合象征。\n\n![万神殿内的傅科摆](pantheon.webp)\n\n**塞纳河**\n\n清晨的塞纳河如诗如画，漫步在河畔，感受到巴黎的静谧与美好。\n\n![塞纳河](seine.webp)\n\n塞纳河是法国的一条主要河流，流经巴黎市中心。河流全长约 777 公里，起源于勃艮第地区的普拉特高原，最终流入英吉利海峡。塞纳河穿过巴黎时，河两岸布满了历史悠久的桥梁和著名的景点，如巴黎圣母院和埃菲尔铁塔。河流不仅是巴黎的重要交通水道，也是旅游和休闲的热门地点，常有游船在此穿梭，提供观光和餐饮服务。\n\n**马德莱娜教堂**\n\n![马德莱娜教堂](madeleine.webp)\n\n马德莱娜教堂（Église de la Madeleine）是一座罗马天主教的教堂，以其古典希腊神庙风格著称。这座教堂建于 19 世纪初，外部有 52 根科林斯式柱子环绕。虽然外观极其庄严、类似神庙，但内部装饰华丽，拥有精美的雕刻和壁画。马德莱娜教堂不仅是宗教活动的场所，也常用于举行音乐会，特别是古典音乐演出。\n\n**圣心堂**\n\n![圣心堂](basilique.webp)\n\n圣心堂（Basilique du Sacré-Cœur）位于法国巴黎蒙马特高地，是一座罗马天主教教堂，以其白色圆顶著称。这座教堂建于 1875 年至 1914 年间，是为了纪念普法战争中的法国阵亡将士而兴建的。圣心堂采用了罗曼 - 拜占庭风格的建筑设计，内部装饰华丽，拥有壮观的马赛克和雕塑。它不仅是巴黎的一个重要宗教地点，也因其位于城市之巅，提供了俯瞰巴黎全景的绝佳视角。\n\n除此之外，我还在骑行过程中游览了巴黎圣母院、香榭丽舍大道、爱丽舍宫、小皇宫、凯旋门、协和广场、杜乐丽花园、卢森堡公园等，限于篇幅不在此展开。\n\n## 关于奥运会\n\n现代奥运会是法国人在巴黎提倡的，可能是法国人对奥运会已经司空见惯，也有可能是为了尽可能不打扰本地人的生活，此次巴黎之行，感受不到任何奥运会将在巴黎召开的气氛。只有一些标志性建筑旁在搭建一些展台可能是为了供奥运会使用，以及一些商店在售卖奥运会纪念品。\n\n## 评论\n\n最近在中文互联网上，经常看到一些视频介绍巴黎的治安、环境是如何的不堪，比如街道上很多小偷、随地大小便、找不到厕所等。幸运的是我并没有遇到小偷，也没听到同伴有这样的遭遇。但是确实在一些街道尤其是景区周边闻到一些尿骚味，也遭遇了几个流浪汉问我要烟。还有就是卢浮宫里找不到厕所，唯一找到的一个男厕所还在维修中。\n\n![靠近卢浮宫的街道满是垃圾和尿骚味](street.webp)\n\n## 总结\n\n巴黎这座城市以其独特的魅力和丰富的文化底蕴给我留下了深刻的印象。这里的人们热情友好，景色美丽动人。虽然在一些游客密集的地方可能会稍显杂乱，但这也是任何旅游城市难以避免的现象。巴黎之行充满了美好的回忆，让人流连忘返，期待未来再次踏上这片浪漫的土地。也希望这篇游记能对初次踏上这篇土地人有所帮助。\n', '\/blog\/paris-trip\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">2024 年 3 月，我借参加 KubeCon EU 之机访问巴黎，体验了当地文化、美食和生活细节。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/how-to-integrate-third-party-registry-with-istio/">如何在 Istio 中集成第三方服务注册表？</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/06/14</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('如何在 Istio 中集成第三方服务注册表？', '本文详细介绍了如何将第三方服务发现机制如 Consul 和 Eureka 与 Istio 集成，实现服务发现的无缝对接。', '\nIstio 依赖 Kubernetes 来进行服务发现，这通常意味着必须在 Kubernetes 集群中部署微服务并使用 Kubernetes 服务发现。然而，很多现有的微服务项目还在使用如 Consul、Eureka 这样的第三方服务注册表，本文将探讨如何将这些现有的微服务的注册表与 Istio 集成。\n\n## Istio 对非 Kubernetes 服务的支持\n\nIstio 最初只支持 Kubernetes 服务，但随着时间的推移，为了适应更广泛的应用场景，它开始支持像 Consul 这样的第三方服务注册表。通过引入 Mesh Configuration Protocol（MCP），Istio 能够与各种服务发现后端通信，如 Consul，从而管理非 Kubernetes 环境中的服务。在 Istio 1.1 版本中，引入了 ServiceEntry 资源对象，这使得用户可以手动将外部服务添加到 Istio 的服务注册表中，并在 Istio 1.8 中取消了对 Consul 的直接支持，转而通过 [ServiceEntry](https:\/\/istio.io\/latest\/docs\/reference\/config\/networking\/service-entry\/) 提供了一种更灵活的方式来集成和管理所有服务，无论它们是否托管在 Kubernetes 上。\n\n## Istio 代理配置的高层架构\n\n下图展示了 Istio 代理配置的高层架构，揭示了配置如何从各种源被摄取、转换，并最终服务于 Envoy 代理。\n\n\u0060\u0060\u0060mermaid \u0022Istio 代理配置高层架构\u0022\ngraph TD\n    subgraph 配置摄取\n        subgraph 配置存储\n            xcs(XDS 客户端) --\u003e acs(聚合)\n            ccs(CRD 客户端) --\u003e acs(聚合)\n            fcs(文件系统客户端) --\u003e acs(聚合)\n        end\n        subgraph 服务发现\n            kc(Kube Controller) --\u003e sd(聚合)\n            sec(ServiceEntry Controller) --\u003e sd(聚合)\n        end\n    end\n    subgraph 配置转换\n        acs \u0026 sd --\u003e ct(配置转换器)\n    end\n    subgraph \u0022配置服务 (XDS)\u0022\n        ct --\u003e xds(XDS 服务器)\n    end\n    xds --\u003e ep(Envoy 代理)\n\u0060\u0060\u0060\n\n![Istio 代理配置高层架构](ba3ac1f8ffc2b172dd0681013c328a09.svg)\n\n要想详细了解 Istiod 的架构，可以参考 [Istio 架构详解](https:\/\/cloudnative.to\/blog\/istiod-architecture\/)。\n\n### 配置摄取过程详解\n\n- **ConfigStore**: 负责读取多种类型的资源并进行聚合。包括：\n    - **XDS Client**: 通过 xDS 协议读取资源。\n    - **CRD Client**: 从 Kubernetes 自定义资源定义（CRD）读取资源。\n    - **Filesystem Client**: 从文件系统读取资源。\n- **ServiceDiscovery**: 聚合面向服务的内部资源。使用的组件包括：\n    - **Kube Controller**: 依据 Kubernetes 核心类型运行。\n    - **ServiceEntry Controller**: 依据 Istio 类型运行。\n\n### 配置翻译与服务\n\n配置从 ConfigStore 和 ServiceDiscovery 聚合后，由 **Config Translator** 翻译成适合代理的格式，然后通过 **XDS Server** 服务于 Envoy 代理。这是将动态配置应用于代理的最终步骤。\n\n## 第三方注册表同步\n\n为了集成第三方服务注册表，我们可以实现一个 Operator，该 Operator 监视第三方服务注册表并将服务以 ServiceEntry 和 WorkloadEntry 资源形式推送至 Kubernetes API 服务器。以下流程图展示了该同步过程。\n\n\u0060\u0060\u0060mermaid \u0022第三方注册表同步流程图\u0022\nsequenceDiagram\n    participant O as Operator\n    participant CM as 第三方服务注册表\n    participant K8s as Kubernetes API 服务器\n    participant I as Istiod\n    participant EP as Envoy 代理\n\n    O-\u003e\u003e\u002bCM: 查询服务注册表\n    CM--\u003e\u003e-O: 返回服务数据\n    O-\u003e\u003eO: 将服务转换为 ServiceEntry\n    O-\u003e\u003e\u002bK8s: 推送 ServiceEntry\n    K8s--\u003e\u003e-I: 更新 Istio 配置\n    I-\u003e\u003eEP: 更新代理配置\n    Note over EP: Envoy 代理接收新配置\n\n    loop 监控变更\n        O-\u003e\u003e\u002bCM: 检查更新\n        CM--\u003e\u003e-O: 通知变更\n        O-\u003e\u003eO: 转换更新的服务\n        O-\u003e\u003e\u002bK8s: 更新 ServiceEntry\n        K8s--\u003e\u003e-I: 刷新 Istio 配置\n        I-\u003e\u003eEP: 刷新代理配置\n    end\n\u0060\u0060\u0060\n\n![第三方注册表同步流程图](34ee760a4cb26025ecf954077f77eee2.svg)\n\n### 第三方服务注册表同步的步骤说明\n\n1. Operator 向第三方服务注册表发起查询请求。\n2. 第三方服务注册表返回当前注册的服务数据。\n3. Operator 将服务数据转换为 Istio 的 ServiceEntry 对象。\n4. Operator 将 ServiceEntry 推送至 Kubernetes API 服务器。\n5. Kubernetes API 服务器将变更通知 Istiod。\n6. Istiod 更新 Envoy Proxies 的配置。\n7. Operator 定期检查第三方服务注册表以监控服务变化，发现变更后更新 ServiceEntry 并重新推送至 Kubernetes API 服务器，完成服务同步。\n\n## Istio Registry Sync\n\nTetrate 开发的 [Istio Registry Sync](https:\/\/docs.tetrate.io\/istio-subscription\/integrations\/registry-sync\/introduction) 是一个扩展 Operator，可以作为 [TIS](https:\/\/docs.tetrate.io\/istio-subscription\/) 的 add-on 运行。它支持非 Kubernetes 服务注册表（如 AWS Cloud Map 和 Consul）与 Istio 的集成。此工具提供了以下几个使用场景：\n\n- **混合应用集成**: 在混合环境中，如使用 Consul 的传统应用与 AWS Cloud Map 中的微服务可以通过 Istio Registry Sync 实现无缝的服务发现。\n- **动态端点管理**: 在服务频繁扩缩的环境中，Istio Registry Sync 能快速反映来自配置注册表的变更，确保 Istio 服务网格中的流量管理策略准确有效。\n- **统一的监控与安全态势**: 通过将所有环境的服务集成至 Istio，可以利用 Istio 提供的服务健康指标和统一的安全协议，如 mTLS，确保跨所有服务的加密和认证通信。\n\n## 总结\n\n通过上述方法，你可以有效地将 Istio 与第三方服务注册表集成，无论是通过开发自定义的 Operator 还是使用现成的 Istio Registry Sync 工具。这样不仅能够保持服务的现代化，还能确保在不同环境之间的高效协同工作。\n\n## 参考资料\n\n- [Istio Pilot Architecture - github.com](https:\/\/github.com\/istio\/istio\/blob\/master\/pilot\/doc\/architecture.md)\n- [Istio Registry Sync Documentation - docs.tetrate.io](https:\/\/docs.tetrate.io\/istio-subscription\/integrations\/registry-sync\/introduction)\n', '\/blog\/how-to-integrate-third-party-registry-with-istio\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文详细介绍了如何将第三方服务发现机制如 Consul 和 Eureka 与 Istio 集成，实现服务发现的无缝对接。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/istiod-architecture/">[译] Istiod 架构详解</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/06/14</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://github.com/istio/istio/blob/master/architecture/networking/pilot.md" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istiod 架构详解', '本文译自 Istio 官方代码仓库中对 Istiod 架构的解析。描述了 Istio 控制平面——Istiod 的高层架构。Istiod 是一个模块化的单体应用，涵盖了从证书签名、代理配置（XDS）、传统的 Kubernetes 控制器等多种功能。', '\n本文档描述了 Istio 控制平面——Istiod 的高层架构。Istiod 是一个模块化的单体应用，涵盖了从证书签名、代理配置（XDS）、传统的 Kubernetes 控制器等多种功能。\n\n## 代理配置 {#proxy-configuration}\n\nIstiod 的主要角色——以及大部分代码——是动态配置代理（Envoy sidecar、入口、gRPC、ztunnel 等）。这大致包括 3 个部分：\n1. 配置摄取（系统的输入）\n1. 配置翻译\n1. 配置服务（XDS）\n\n### 配置摄取\n\nIstio 从超过 20 种不同的资源类型读取，并将它们聚合在一起构建代理配置。这些资源可以来自 Kubernetes（通过观察）、文件或通过 xDS；尽管如此，Kubernetes 是最常用的。\n\n主要出于历史原因，摄取分为几个组件。\n\n#### ConfigStore\n\n\u0060ConfigStore\u0060 读取多种资源，并通过标准接口（Get、List 等）暴露它们。这些类型被包装在通用的 \u0060config.Config\u0060 结构中，与通常使用每种资源类型的 Kubernetes 客户端形成对比。最常见的是通过 \u0060crdclient\u0060 包从 Kubernetes 读取。\n\n![](.\/output-1.svg)\n\n#### 服务发现 {#ServiceDiscovery}\n\n另一个主要接口是 ServiceDiscovery。类似于 ConfigStore，它也是对多种资源进行聚合。然而，它不提供通用资源访问，而是预计算了多种服务导向的内部资源，如 \u0060model.Service\u0060 和 \u0060model.ServiceInstance\u0060。\n\n这由两个控制器组成——一个由核心 Kubernetes 类型驱动（“Kube Controller”），一个由 Istio 类型驱动（“ServiceEntry 控制器”）。\n\n![](.\/output-2.svg)\n\n大部分情况下这是相当直接的。然而，我们支持 \u0060ServiceEntry\u0060 选择 \u0060Pod\u0060，以及 \u0060Service\u0060 选择 \u0060WorkloadEntry\u0060，这导致跨控制器通信。\n\n注意：\u0060Pods\u0060 不贡献给 Kube 控制器的 \u0060ServiceInstances\u0060 是因为使用了 \u0060Endpoints\u0060，它本身是从 Kubernetes 核心的 \u0060Pod\u0060 派生的。\n\n#### PushContext\n\n\u0060PushContext\u0060 是当前全局状态（SotW）的一个不可变快照。它在每次配置推送时（下面会详细讨论）通常是部分地重新生成的。由于是快照，大多数查找都是无锁的。\n\n\u0060PushContext\u0060 是通过查询上述层构建的。对于一些简单的用例，这和存储类似于 \u0060configstore.List(SomeType)\u0060 的东西一样简单；在这种情况下，与直接暴露 configstore 的唯一区别是要快照当前状态。在其他情况下，一些预计算和索引被计算出来，以便后续访问效率。\n\n#### 端点\n\n端点有一个优化的代码路径，因为它们是迄今为止更新最频繁的资源——在一个稳定的集群中，这通常是*唯一*的变化，由扩缩容引起。\n\n因此，它们不经过 \u0060PushContext\u0060，变化也不会触发 \u0060PushContext\u0060 的重新计算。相反，当前状态是基于来自 \u0060ServiceDiscovery\u0060 的事件增量计算的。\n\n#### 结论\n\n总体而言，配置摄取流程如下：\n\n![](.\/output-3.svg)\n\n### 配置翻译\n\n配置翻译将上述输入转换为连接的 XDS 客户端（通常是 Envoy）消费的实际类型。这通过 \u0060Generators\u0060 完成，这些生成器注册一个函数来构建给定类型。例如，有一个 \u0060RouteGenerator\u0060 负责构建 \u0060Routes\u0060。除了核心 Envoy XDS 类型外，还有一些自定义的 Istio 类型，例如我们用于 DNS 的 \u0060NameTable\u0060 类型，以及调试接口。\n\n\u0060Generators\u0060 的输入是 \u0060Proxy\u0060（当前客户端的表示）、当前的 \u0060PushContext\u0060 快照以及导致更改的配置更新列表。\n\n将 \u0060Proxy\u0060 作为输入参数是重要的，并且与其他一些 XDS 实现的主要区别。我们无法在没有每个客户端信息的情况下静态翻译输入到 XDS。例如，我们依赖于客户端的标签来确定应用的政策集。虽然这是实现 Istio API 的必要条件，但它确实大大限制了性能。\n\n#### 缓存\n\n配置翻译通常占用了 Istiod 的绝大部分资源使用，尤其是 protobuf 编码。因此，引入了缓存，存储给定资源的已编码 \u0060protobuf.Any\u0060。\n\n这种缓存依赖于声明所有输入到给定生成器作为缓存键的一部分。这极其容易出错，因为没有任何东西阻止生成器使用*不*是键部分的输入。当这种情况发生时，不同的客户端将不确定地获得错误的配置。这种类型的错误在历史上导致了 CVE。\n\n有几种方法可以防止这些问题：\n* 只将缓存键本身传入到生成逻辑中，这样就不能使用其他未计入的输入。不幸的是，今天还没有任何生成器这样做。\n* 非常非常小心。\n* 缓存有一个内置测试，通过设置 \u0060UNSAFE_PILOT_ENABLE_RUNTIME_ASSERTIONS=true\u0060 启用，该测试在 CI 中运行。如果任何键以不同的值写入，这将引发 panic。\n\n#### 部分计算\n\n与缓存一样，部分计算是确保我们不需要在每次更改时为每个代理构建（或发送）每个资源的关键性能优化。这将在配置服务部分中更详细讨论。\n\n### 配置服务\n\n配置服务是实际接受代理客户端的层，这些客户端通过双向 gRPC 流连接，并为它们提供所需的配置。\n\n我们将有两种触发发送配置的方式——请求和推送。\n\n#### 请求\n\n来自客户端的请求特别要求一组资源。这可能是在新连接上请求初始资源集，或者来自新的依赖。例如，\u0060Cluster X\u0060 的推送引用 \u0060Endpoint Y\u0060 可能导致请求 \u0060Endpoint Y\u0060（如果客户端尚未知道的话）。\n\n注意客户端实际上可以发送三种类型的消息——请求、对先前推送的 ACKs 和对先前推送的 NACKs。不幸的是，这些在 API 中没有清晰地区分，因此有一些逻辑来分解这些（\u0060shouldRespond\u0060）。\n\n#### 推送\n\n当 Istiod 检测到需要某些配置更新时，会发生推送。这大致与请求的结果相同（新配置推送到客户端），只是由不同的来源触发。\n\n在配置摄取中描述的各种组件可以触发配置更新。这些被批量处理（\u0022debounced\u0022），以避免在连续多次更改时活动过度，并最终排队在推送队列中。\n\n推送队列大部分是一个正常的队列，但它有一些特殊逻辑来合并每个给定代理的推送请求。这导致每个代理有 0 或 1 个未完成的推送请求；如果有更多更新进来，现有的推送请求就会扩展。\n\n另一个任务轮询这个队列并触发每个客户端开始推送。\n\n![](.\/output-4.svg)\n\n在高层次上，每个客户端任务将找到正确的生成器来处理请求，生成所需的配置，并发送。\n\n#### 优化\n\n一个简单的实现将简单地重新生成每个客户端的所有订阅类型的所有资源，无论配置是否更改。然而，这种方式扩展性很差。因此，我们有许多级别的优化以避免做这些工作。\n\n首先，我们有一个 \u0060Full\u0060 推送的概念。只有在更改时 \u0060Full\u0060 推送会重新计算 \u0060PushContext\u0060；否则，这将被跳过，重用最后一个 \u0060PushContext\u0060。注意：即使是 \u0060Full\u0060，我们也尽可能从上一个 \u0060PushContext\u0060 复制。例如，如果只有一个 \u0060WasmPlugin\u0060 发生了变化，我们不会重新计算服务索引。\n\n注意：\u0060Full\u0060 只是指是否需要重新计算 \u0060PushContext\u0060。即使在 \u0060Full\u0060 推送中，我们也会跟踪触发此的配置更新，因此我们可以有 \u0022Config X 的完整更新\u0022 或 \u0022所有配置的完整更新\u0022。\n\n接下来，对于单个代理，我们将检查它是否可能受到更改的影响。例如，我们知道一个 sidecar 从不受 \u0060Gateway\u0060 更新的影响，我们还可以查看限制更新范围的分流（来自 \u0060Sidecar.egress.hosts\u0060）。\n\n一旦我们确定代理可能受到影响，我们将确定哪些*类型*可能受到影响。例如，我们知道 \u0060WasmPlugin\u0060 不影响 \u0060Cluster\u0060 类型，所以在这种情况下我们可以跳过生成 \u0060Cluster\u0060。警告：Envoy 当前有一个错误，*要求* 每当推送对应的 \u0060Cluster\u0060 时必须推送 \u0060Endpoints\u0060，因此这个优化在这个特定情况下故意关闭了。\n\n最后，我们确定我们需要生成类型的哪个子集。XDS 有两种模式 - \u0022State of the World (SotW)\u0022 和 \u0022Delta\u0022。在 SotW 中，我们通常需要生成类型的所有资源，即使只有一个发生了变化。注意我们实际上需要*生成*所有这些，通常是因为我们不存储先前生成的资源（主要因为它们是每个客户端生成的）。这也意味着每当我们确定是否需要更改时，我们都是基于仔细的代码分析，而不是在运行时。\n\n尽管在 SotW 中有这样的期望，由于协议的一个特点，我们实际上可以启用我们最重要的优化之一。XDS 类型形成一棵树，CDS 和 LDS 是 Envoy 的树根。对于根类型，我们*必须*总是生成完整的资源集——缺失的资源被视为删除。\n然而，所有其他类型*不能*显式删除，而是在所有引用被移除时清理。这意味着我们可以为非根类型发送部分更新，而不删除未发送的资源。这有效地允许在 SotW 上进行 delta 更新。这个优化对我们的端点生成器至关重要，确保当一个 pod 扩展时，我们只需要更新该 pod 内的端点。\n\n## 控制器\n\nIstiod 由一系列控制器组成。按 Kubernetes 的说法，\u0022控制器是观察你的集群状态的控制循环，然后在需要时进行或请求更改。\u0022\n\n在 Istio 中，我们更自由地使用这个术语。Istio 的控制器不仅仅观察一个集群的状态——许多控制器从多个集群读取，甚至从外部来源（文件和 XDS）读取。通常，Kubernetes 控制器然后将状态写回到集群；Istio 确实有几个这样的控制器，但大多数控制器都集中在推动[代理配置](#proxy-configuration)。\n\n### 编写控制器\n\nIstio 提供了一些帮助库来开始编写控制器。虽然这些库有帮助，但正确编写（和测试！）一个控制器仍然有很多细微之处。\n\n要开始编写控制器，请查看[示例控制器](https:\/\/github.com\/istio\/istio\/blob\/master\/pkg\/kube\/controllers\/example_test.go)。\n\n### 控制器概览\n\n下面提供了 Istiod 中控制器的高级概览。有关每个控制器的更多信息，建议咨询控制器的 Go 文档。\n\n![](.\/output-5.svg)\n\n正如您所看到的，目前控制器的景观相当广泛。\n\n[服务发现](#ServiceDiscovery) 和 [Config Store](#ConfigStore) 已在上文讨论，因此这里不再赘述。\n\n#### 网格配置\n\n网格配置控制器是一个相当简单的控制器，从 \u0060ConfigMap\u0060（如果使用 \u0060SHARED_MESH_CONFIG\u0060 则为多个）读取，处理并合并这些到类型化的 \u0060MeshConfig\u0060 中。然后它通过一个简单的 \u0060mesh.Watcher\u0060 暴露这个，这只是暴露一种访问当前 \u0060MeshConfig\u0060 的方式并在它改变时获得通知。\n\n#### Ingress\n\n除了 \u0060VirtualService\u0060 和 \u0060Gateway\u0060，Istio 也支持 \u0060Ingress\u0060 核心资源类型。像 CRD 一样，\u0060Ingress\u0060 控制器实现 \u0060ConfigStore\u0060，但有些不同。\u0060Ingress\u0060 资源在即时转换为 \u0060VirtualService\u0060 和 \u0060Gateway\u0060，所以虽然控制器读取 \u0060Ingress\u0060 资源（和一些相关类型如 \u0060IngressClass\u0060），它发出其他类型。这允许其他代码不用关心 Ingress，只关注核心类型。\n\n除了这种转换外，\u0060Ingress\u0060 还需要在状态中写入它可以访问的地址。这由 Ingress 状态控制器完成。\n\n#### Gateway\n\nGateway（指的是 [Kubernetes API](http:\/\/gateway-api.org\/)，不是同名的 Istio 类型）的工作方式与 [Ingress](#ingress) 非常相似。网关控制器也将网关 API 类型转换为 \u0060VirtualService\u0060 和 \u0060Gateway\u0060，实现 \u0060ConfigStore\u0060 接口。\n\n然而，还有一些额外的逻辑。网关类型有广泛的状态报告。与 Ingress 不同，这是状态报告是在主控制器中直接完成的，允许在处理资源的逻辑中直接生成状态。\n\n此外，Gateway 涉及两个组件写入到集群：\n* 网关类控制器是一个简单的控制器，只是写一个描述我们实现的默认 \u0060GatewayClass\u0060 对象。\n* 网关部署控制器使用户能够创建一个实际配置底层资源（部署和服务）的网关。这更像是一个传统的“Operator”。这部分逻辑是确定基于 \u0060istio.io\/rev\u0060 标签哪个 Istiod 修订应该处理资源（反映 sidecar 注入）；因此，这需要依赖“标签观察者”控制器。\n\n#### CRD 观察者\n\n对于针对自定义类型（CRD）的观察，我们希望优雅地处理缺失的 CRD。如果对缺失类型启动 informers，则会导致错误并阻塞启动。相反，我们引入了一个“CRD 观察者”组件，观察集群中的 CRD 以确定它们是否可用。\n\n有两种使用方式：\n* 一些组件只是在做需要的工作之前阻塞 \u0060watcher.WaitForCRD(...)\u0060。\n* \u0060kclient.NewDelayedInformer\u0060 也可以完全抽象这一点，通过提供一个在幕后处理这一点的客户端。\n\n#### Credentials Controller\n\n凭证控制器暴露访问 TLS 证书信息的途径，这些信息存储在集群的 \u0060Secrets\u0060 中。除了简单地访问证书外，它还有一个授权组件，可以验证请求者是否有权读取其命名空间中的 \u0060Secrets\u0060。\n\n#### Discovery Filter\n\n发现过滤器控制器用于实现 \u0060MeshConfig\u0060 的 \u0060discoverySelectors\u0060 字段。这个控制器读取集群中的 \u0060Namespace\u0060 以确定它们是否应该被“选中”。许多控制器使用这个过滤器来只处理配置的一个子集。\n\n#### 多集群\n\n各种控制器从多个集群读取。\n\n这始于多集群密钥控制器，该控制器读取 \u0060kubeconfig\u0060 文件（存储为 \u0060Secrets\u0060），并为每个创建 Kubernetes 客户端。控制器允许注册处理程序，这些处理程序可以处理集群的添加\/更新\/删除。\n\n这有两个实现：\n* 凭证控制器负责读取存储为 Secrets 的 TLS 证书。\n* Kubernetes 服务发现控制器有点像一个大块头，除了核心服务发现控制器之外，还启动了一堆其他子控制器。\n\n由于整体复杂性，看看这个放大一点会有帮助：\n\n![](.\/output-6.svg)\n\n#### 虚拟机\n\n虚拟机支持由两个控制器组成。\n\n自动注册控制器是一个相当独特的控制器——控制器的输入是 XDS 连接。对每个 XDS 连接，创建一个 \u0060WorkloadEntry\u0060 来注册 XDS 客户端（通常是在 VM 上运行的 \u0060istio-proxy\u0060）到网格中。这个 \u0060WorkloadEntry\u0060 与连接的生命周期绑定，有一些逻辑确保临时的停机（重新连接等）不会移除 \u0060WorkloadEntry\u0060。\n\n健康检查控制器还控制 \u0060WorkloadEntry\u0060 的健康状态。健康状态通过 XDS 客户端报告并与 \u0060WorkloadEntry\u0060 同步。\n\n#### Webhook\n\nIstio 包含验证和变更 webhook 配置。这些需要在 \u0060caBundle\u0060 中指定以配置 TLS 信任。因为 Istiod 的 CA 证书有些动态性，这在运行时进行修补（而不是作为安装的一部分）。webhook 控制器处理这种修补。\n\n这些控制器非常相似，但由于各种原因是不同的组件。\n', '\/trans\/istiod-architecture\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文译自 Istio 官方代码仓库中对 Istiod 架构的解析。描述了 Istio 控制平面——Istiod 的高层架构。Istiod 是一个模块化的单体应用，涵盖了从证书签名、代理配置（XDS）、传统的 Kubernetes 控制器等多种功能。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/what-is-new-in-istio-1-22/">深入解析 Istio 1.22：新特性和实际应用建议</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/06/11</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('深入解析 Istio 1.22：新特性和实际应用建议', '探索 Istio 1.22 的新特性与实用建议，包括增量 xDS、路径模板支持及 API 升级等，助力优化服务网格管理。', '\n最近 [Istio 1.22 发布](https:\/\/istio.io\/latest\/news\/releases\/1.22.x\/announcing-1.22\/)包含大量的重大更新，本文将为你分享这个发布带来的新特性及应用建议。\n\n## Ambient 模式进入 Beta 阶段\n\n虽然 Ambient 模式现已进入 Beta 阶段，但这并不意味着我们可以完全告别 Sidecar。尽管 Istio 官方宣称 Ambient 模式可以简化操作并显著减少内存和 CPU 使用，但它仍然存在局限性和潜在的复杂性问题。例如，虽然取消了 Sidecar，但需引入新的 ztunnel 和 waypoint 组件，这可能带来新的挑战。关于 Ambient 模式进入 Beta 模式的详细信息请参阅 [Istio 官方博客](https:\/\/istio.io\/latest\/blog\/2024\/ambient-reaches-beta\/)。\n\n**Ambient 模式带来的新的挑战**\n\n- Ambient mode 对 L7 流量的管理仍未成熟\n- mTLS 被强制在 namespace 级别开启，也就是说使用 Ambient 模式你无法关闭 mTLS\n- Ambient 模式的无宕机升级仍未解决\n- 缺少 与 Sidecar 模式共存和迁移的最佳实践\n\n关于 Sidecar 模式和 Ambient 模式的对比，详见 [Istio Ambient 模式的局限性解析](\/blog\/istio-ambient-mode-limitations\/)。\n\n{{\u003ccallout note \u0022建议\u0022\u003e}}\n如果是刚开始使用 Istio，尤其是你只需要为服务自动开启 mTLS 的情况下，当前阶段可以尝试使用 Ambient 模式。但是对于 L7 功能，建议等到 Ambient 模式完全成熟后再考虑生产上使用。\n{{\u003c\/callout\u003e}}\n\n## Istio API 升级\n\nIstio Istio 1.22 版本中，关键 API 如流量管理、安全、Telemetry 相关的 API 都已正式升级到 \u0060v1\u0060 版本。你只需要将原有配置的 API 版本修改为 \u0060v1\u0060 即可，除此之外不需要任何更改。这些 API 早已成熟，你可以放心的使用 \u0060v1\u0060 版本，对于对稳定性要求较高的环境，Istio 添加了[验证准入策略](https:\/\/kubernetes.io\/docs\/reference\/access-authn-authz\/validating-admission-policy\/)确保只有 \u0060v1\u0060 API 和字段可以在 Istio API 中使用。\n\n例如下面的 AuthorizationPolicy 示例。\n\n\u0060\u0060\u0060yaml {linenos=table,hl_lines=1}\napiVersion: security.istio.io\/v1beta1\nkind: AuthorizationPolicy\nmetadata:\n  name: finance-to-supply-chain\n  namespace: finance\nspec:\n  selector:\n    matchLabels:\n      app: finance-app\n  action: ALLOW\n  rules:\n  - from:\n    - source:\n        namespaces: [\u0022finance\u0022]\n    to:\n    - operation:\n        methods: [\u0022GET\u0022, \u0022POST\u0022]\n        paths: [\u0022\/api\/supply1\u0022, \u0022\/api\/supply2\u0022]\n    when:\n    - key: request.headers[:authority]\n      values: [\u0022supply-chain-service.supply-chain.svc.cluster.local\u0022]\n\u0060\u0060\u0060\n\n其他扩展类的 API 如 \u0060EnvoyFilter\u0060、\u0060WasmPlugin\u0060、\u0060ProxyConfig\u0060 还未成熟，因此还停留在 alpha 或 beta 阶段。关于 API 升级的更多信息，请参考 [v1 API 博客](https:\/\/istio.io\/latest\/blog\/2024\/v1-apis\/)。\n\n{{\u003ccallout note \u0022建议\u0022\u003e}}\n对于常用功能可以放心使用 \u0060v1\u0060 API，扩展类 API 尚未稳定为了保证系统稳定性，可以开启验证准入策略。\n{{\u003c\/callout\u003e}}\n\n## Gateway API 升级\n\n[Gateway API](\/blog\/why-gateway-api-is-the-future-of-ingress-and-mesh\/) 已更新至版本 1.1.0，现已普遍可用。这一更新扩展了 Istio 的流量管理能力，但需要注意 Istio 原生 API 与 Gateway API 的兼容性问题。在迁移到新 API 时应谨慎，以避免依赖尚未完全成熟的特性。更多详情，请查看 [Gateway API v1.1 博客](https:\/\/istio.io\/latest\/blog\/2024\/gateway-mesh-ga\/)。\n\n{{\u003ccallout note \u0022建议\u0022\u003e}}\n对于已经稳定使用 Istio API 的现有部署，可以继续使用，尤其是在需要使用到高级功能的场景下。对于新部署优先考虑使用稳定版的 Gateway API，以利用其现代化的流量管理功能。因为二者现存的兼容性问题，不要冒然迁移到 Gateway API，否则得不偿失。\n{{\u003c\/callout\u003e}}\n\n## 增量 xDS 默认启动\n\nIstio 1.22 版本默认启用了增量 xDS，这是一个优化配置分发的机制。与传统的 State of the World（SotW）模式相比，增量 xDS 仅将变更的配置发送给 Envoy 代理，从而显著减少了网络传输的数据量和控制平面的资源消耗。这一变更尤其适用于配置频繁更新的大规模部署环境，能够提高配置更新的效率和性能。此外，增量 xDS 还有助于在网络环境复杂或配置动态变化的情况下，更高效地管理服务网格的配置更新。\n\n{{\u003ccallout note \u0022建议\u0022\u003e}}\n增量 xDS 早在 Istio 的几个版本前就已经开发完成，只是没有默认开启，现在该功能已经稳定，可以放心使用。\n{{\u003c\/callout\u003e}}\n\n更多关于 xDS 的介绍请参考[Envoy xDS 及 Istio 中的配置分发流程介绍](\/blog\/istio-delta-xds-for-envoy\/)。\n\n### AuthorizationPolicy 的路径模板支持通配符\n\n在 Istio 1.22 中，\u0060AuthorizationPolicy\u0060 新增了对[路径模板](https:\/\/istio.io\/latest\/docs\/reference\/config\/security\/authorization-policy\/#Operation)的支持，极大增强了路径匹配的灵活性和精确性。而在此之前，\u0060AuthorizationPolicy\u0060 的路径配置并不支持通配符。此功能允许使用基于 Envoy 的 URI 模板匹配来定义 HTTP 请求中的路径。路径可以包括简单的通配符（\u0060*\u0060 和 \u0060**\u0060）或具名变量，从而精确匹配单个或多个路径组件。例如，路径模板 \u0060\/foo\/{*}\u0060 能匹配 \u0060\/foo\/bar\u0060 但不匹配 \u0060\/foo\/bar\/baz\u0060，而 \u0060\/foo\/{**}\/\u0060 则可以匹配任何以 \u0060\/foo\/\u0060 开头的路径。这种灵活的路径模板设计，特别适用于动态和复杂的路由规则，进一步加强了 Istio 的安全策略工具箱。\n\n下图展示了 AuthorizationPolicy 的路径匹配的通配符规则。\n\n\u0060\u0060\u0060mermaid \u0022AuthorizationPolicy 的路径匹配通配符规则\u0022\ngraph LR\n    A[AuthorizationPolicy 路径匹配] --\u003e B(定义路径模板)\n    B --\u003e C{路径模板操作符}\n    C --\u003e D[\u0022*（匹配单个段）\u0022]\n    C --\u003e E[\u0022**（匹配多个段）\u0022]\n    C --\u003e F[\u0022{name}（命名变量匹配单个段）\u0022]\n    C --\u003e G[\u0022{name=**}（命名变量匹配多个段）\u0022]\n\n    D --\u003e H[\u0022\/foo\/{*} 匹配 \/foo\/bar\u0022]\n    E --\u003e I[\u0022\/foo\/{**}\/ 匹配 \/foo\/bar\/、\/foo\/bar\/baz.txt\u0022]\n    F --\u003e J[\u0022\/videos\/{file} 匹配 \/videos\/1080p5000_00001.m4s\u0022]\n    G --\u003e K[\u0022\/**.mpd 匹配 \/content\/123\/india\/dash\/55\/manifest.mpd\u0022]\n\u0060\u0060\u0060\n\n![AuthorizationPolicy 的路径匹配通配符规则](f96fd4f3843d3d7b7c13b0a5083f00f4.svg)\n\n了解更多关于路径模板的具体应用和规则，你可以参考 [Envoy 的官方文档](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-v3\/extensions\/path\/match\/uri_template\/v3\/uri_template_match.proto)。\n\n{{\u003ccallout note \u0022提示\u0022\u003e}}\n\u0060AuthorizationPolicy\u0060 中的路径匹配终于支持模板了，你不需要再在配置中一个一个地手动加入路径了。\n{{\u003c\/callout\u003e}}\n\n## 总结\n\nIstio 1.22 版本引入了多项重要更新和改进，尽管某些特性被广泛宣传，但在实际使用中需要进行详细评估和适当的测试。希望本篇博客能帮助你更深入地理解和应用这些新特性，以在实际操作中获得最佳效果。\n\n## 参考\n\n- [Gateway API v1.1: Service mesh, GRPCRoute, and a whole lot more - kubernetes.io](https:\/\/kubernetes.io\/blog\/2024\/05\/09\/gateway-api-v1-1\/)', '\/blog\/what-is-new-in-istio-1-22\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">探索 Istio 1.22 的新特性与实用建议，包括增量 xDS、路径模板支持及 API 升级等，助力优化服务网格管理。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/xinjiang-ili-trip/">端午新疆自驾之旅：领略新疆壮美风景</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/06/10</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e6%97%85%e8%a1%8c"> 
             旅行
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('端午新疆自驾之旅：领略新疆壮美风景', '端午自驾游伊犁，探索壮美风景与特色美食，记录难忘旅程与心动瞬间。', '\n三年前，我与 Addo [环游了新疆北疆](\/blog\/xinjiang-trip\/)，那次旅行让我久久难忘，尤其是伊犁河谷地带，始终萦绕在心头。这次端午佳节，我决定再赴伊犁，开启一场自驾之旅。\n\n经过精心策划，我从北京出发，途经乌鲁木齐转机，来到美丽的伊宁。在这里，我们租了一辆车，开始了为期一周、总行程 1344 公里的自驾之旅。\n\n## 航拍视频\n\n在这段视频中，你将看到我在旅途中拍摄的壮丽航拍画面。从广阔的草原到清澈的湖泊，从巍峨的雪山到蜿蜒的公路，这些美景都在视频中得到了完美的呈现。\n\n\u0060{{\u003c responsive_video src=\u0022\/\/player.bilibili.com\/player.html?isOutside=true\u0026aid=1205635099\u0026bvid=BV16f421D7Qs\u0026cid=1576995666\u0026p=1\u0022 \u003e}}\u0060\n\n## 伊宁喀赞其\n\n我们的第一站是伊宁市的喀赞其民俗村，这是一个充满民族风情的小镇。这里的街道两旁是独具特色的传统民居，五彩斑斓的墙壁和蓝色的大门，仿佛童话世界。喀赞其的生活气息浓厚，街上随处可见当地居民的日常生活场景。\n\n![伊宁喀赞其](kazanqi.jpg)\n\n## 伊犁河\n\n从喀赞其出发，我们前往了伊犁河。伊犁河的河水清澈见底，两岸绿树成荫，广阔的湿地景色宜人。我们在伊犁湿地公园观看了一场壮美的日落，沉醉于大自然的美景中。\n\n![伊犁河](ili-river.jpg)\n\n## 喀拉峻\n\n第三站是喀拉峻草原。广阔的草原上，牛羊成群，远处的雪山与蓝天白云相映成趣，构成了一幅绝美的自然画卷。这里平均海拔 2000 多米，空气格外清新，每一口呼吸都让人感到无比的舒畅。我在这里露营了一晚，经过了一夜的风雨，第二天雨过天晴日出时，阳光洒在身上暖洋洋的，眺望远处的日照金山。\n\n![喀拉峻草原](kalajun.jpg)\n\n## 琼库什台\n\n接下来，我们来到了琼库什台。这个哈萨克族的原始村庄虽然多了一些商业气息，但依然保留着原始的魅力。草原和河谷里新开的民宿和饭店让更多游客慕名而来。我们骑马前往后山，体验了最纯粹的自然风光。尤其是夕阳西下时，在山顶看着连绵起伏的草原和远处的雪山交相辉映，相映成趣。\n\n![琼库什台](qiongkushitai.jpg)\n\n## 夏塔古道\n\n夏塔古道是此次行程中的重要景点。古道曾是丝绸之路上的一部分，沿途高山峡谷景色壮丽。尽管景区尚未开放，我们还是通过无人机航拍领略了这里的冰川河谷。\n\n![夏塔古道](xiata.jpg)\n\n## 伊昭公路\n\n伊昭公路被誉为新疆最美的公路之一。沿途风景从高山到草原，从森林到湖泊，变幻多姿。行驶在悬崖峭壁上，不禁感叹开路人的艰辛。\n\n![伊昭公路](yizhao-highway.jpg)\n\n## 赛里木湖\n\n最后一站是赛里木湖，位于博尔塔拉蒙古自治州。这个高山湖泊的湖水清澈见底，碧蓝如普鲁士蓝，四周环绕着雪山和草原，景色如诗如画。我们在湖边漫步，夜宿赛里木湖西岸，感受这座号称“大西洋的最后一滴眼泪”的静谧与壮丽。\n\n![赛里木湖](sayram-lake.jpg)\n\n这次新疆伊犁自驾之旅不仅让我领略了壮丽的自然风光，还体验了当地独特的民族文化。通过航拍镜头，我记录下了这一路的美景，制作成了一个视频与大家分享。\n\n## 美食\n\n伊犁不仅风景如画，美食也令人垂涎。红柳烤肉的鲜香、辣子肉的香辣（当地人将它作为早餐，配合花卷一起吃）、椒麻鸡的麻辣、赛里木湖的高山鲑鱼籽炒饭的鲜香，都是我旅途中难忘的味道。\n\n![顺时针方向分别为高山鲑鱼籽炒饭、红柳烤肉、辣子肉、椒麻鸡](food.jpg)\n\n另外新疆的干果、奶酪和牛肉干也是不错的伴手礼。\n\n## 总结\n\n这次旅程将成为我人生中一段难忘的回忆。新疆伊犁的美景与魅力，让我深深地爱上了这片土地。如果有机会，我一定会再来这里，探索更多未尽的风景。\n\n希望这篇游记能带给你一些关于新疆伊犁的美好回忆。如果你也有机会去新疆旅行，一定不要错过这些美丽的景点。\n', '\/blog\/xinjiang-ili-trip\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">端午自驾游伊犁，探索壮美风景与特色美食，记录难忘旅程与心动瞬间。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-delta-xds-for-envoy/">Envoy xDS 及 Istio 中的配置分发流程介绍</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/06/04</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/envoy"> 
             Envoy
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Envoy xDS 及 Istio 中的配置分发流程介绍', '本文分享了 xDS 的组成及 Istio 中配置分发的流程，还有 xDS 的两种模式 SotW 和 Delta xDS。', '\n在 Istio 项目的早期采用全局状态（State of the World，简称 SotW）的方式推送配置给 Envoy 代理。一旦有一个服务变更，就要将全局配置推送给所有 Sidecar，造成巨大的网络负担及控制平面的性能损耗。Istio 社区从几年前就开始开发增量 xDS 以解决此问题，并在最近几个 Istio 版本中支持了增量 xDS。在最近的 [Istio 1.22 发布](https:\/\/istio.io\/latest\/news\/releases\/1.22.x\/announcing-1.22\/)中，增量 xDS 成为默认开启的功能。本文将为你介绍 xDS、增量 xDS 及 Istio 的配置分发方式。\n\n## 什么是 xDS？{#what-is-xds}\n\nxDS（Extensible Discovery Service）是一种通信协议，用于在微服务架构中管理服务发现和动态配置。这种机制被广泛用于 Envoy 代理和 Istio 服务网格中，以管理各种类型的资源配置，如路由、服务发现、负载均衡设置等。\n\n### xDS 包含哪些发现服务？{#xds-services}\n\nxDS 包括以下主要的发现服务，每种服务都负责不同类型的网络资源配置：\n\n1. **LDS（Listener Discovery Service）**：管理 Envoy 监听器的配置，这些监听器定义了如何接收和处理入站连接。\n2. **RDS（Route Discovery Service）**：提供路由信息，定义了如何根据指定规则将请求路由到不同的服务。\n3. **CDS（Cluster Discovery Service）**：管理集群信息，集群代表一组逻辑上类似的后端服务实例。\n4. **EDS（Endpoint Discovery Service）**：提供具体服务实例的网络地址，这些服务实例组成了 CDS 中定义的集群。\n5. **SDS（Secret Discovery Service）**：管理安全相关的配置，如 TLS 证书和私钥。\n6. **VHDS（Virtual Host Discovery Service）**：为 RDS 提供虚拟主机配置，允许动态更新虚拟主机而不重启连接。\n7. **SRDS（Scoped Route Discovery Service）**：管理路由作用域，提供基于不同条件（如请求头部）的动态路由选择。\n8. **RTDS（Runtime Discovery Service）**：提供运行时配置，这些配置可用于实验性功能或精细调整系统行为。\n9. **ECDS（Extension Config Discovery Service）**：为特定过滤器提供动态配置更新的服务。目前，网络过滤器、HTTP 过滤器和监听器过滤器都支持 ECDS。\n\n这些服务共同支持动态配置的分发和更新，使得基于 Envoy 的应用架构能够实时适应变化，提高可扩展性和灵活性。每种服务的实现可以独立进行，也可以通过聚合方式（如 ADS）进行统一管理。CNCF 也成立了 [xDS API 工作组](https:\/\/github.com\/cncf\/xds)来推动 xDS API 为 L4\/L7 数据平面配置提供事实上的标准，类似于 SDN 中 OpenFlow 在 L2\/L3\/L4 中所扮演的角色。\n\n{{\u003ccallout note 提示\u003e}}\n关于 xDS  协议的详细介绍，如 xDS 协议的 RPC 服务和变体方法，以及 xDS 请求流程，请参考 [Envoy 代理文档](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-docs\/xds_protocol)。\n{{\u003c\/callout\u003e}}\n\n### xDS 协议的变体 {#xds-variants}\n\nxDS 协议主要包括以下变体：\n1. **State of the World (SotW)**：单独的 gRPC 流为每种资源类型提供完整数据，通常在 Envoy 代理初次启动时使用，也是 Istio 最早使用的 xDS 协议类型。\n2. **增量 xDS（Delta xDS）**：为每种资源类型提供变化的部分数据，从 2021 年开始开发，在 Istio 1.22 版本中开始默认开启。\n3. **聚合发现服务（ADS）**：一个 gRPC 流聚合所有资源类型的数据。\n4. **增量 ADS（Delta ADS）**：一个 gRPC 流聚合所有资源类型的增量数据。\n\n下表概述了 xDS 协议的四种变体，包括对每个变体的解释、使用场景以及优缺点的对比。这些变体为不同的网络环境和服务需求提供了多种选择，可以根据具体情况选择最合适的协议变体以优化服务的性能和资源使用。\n\n{{\u003ctable \u0022xDS 协议的四种变体介绍\u0022\u003e}}\n| 变体类型  | 解释                                                         | 使用场景                                                     | 优点                                                     | 缺点                                                         |\n| --------- | ------------------------------------------------------------ | ------------------------------------------------------------ | -------------------------------------------------------- | ------------------------------------------------------------ |\n| SotW      | 每次都发送所有配置数据，不论是否有变化。                     | 适用于配置较少变化的稳定环境。                               | 简单易实现，易于理解和维护。                             | 数据传输量大，不适合频繁更新配置的环境。                     |\n| Delta xDS | 只传输变更的配置数据，而不是全部数据。                       | 适用于配置频繁变化，需要快速响应变更的环境。                 | 减少了不必要的数据传输，提高了效率。                     | 实现复杂，需要客户端和服务端管理配置状态。                   |\n| ADS       | 通过单一的 gRPC 流来管理所有配置数据，无需为每种资源类型建立独立的连接。 | 适用于需要同时管理多种类型资源的复杂服务架构。               | 减少了网络连接数，简化了资源管理。                       | 对于网络或服务质量差的情况，单点故障可能导致所有配置更新失败。 |\n| Delta ADS | 结合了 ADS 和增量 xDS 的优点，通过一个 gRPC 流聚合并且只传输变化部分的资源。 | 适用于既需要管理多种资源类型，又需要频繁更新配置的极其动态的环境。 | 提供了最大的灵活性和效率，适合大规模和高动态的服务架构。 | 实现最为复杂，对于配置管理的逻辑要求高，需要精确控制资源的变更和传输。 |\n\n{{\u003c\/table\u003e}}\n\n使用 xDS 协议的服务网格可以更灵活地管理微服务之间的通信和配置，减少了配置变更的延迟，提高了系统的响应速度和可靠性。\n\n在 Istio 中，DiscoveryServer 作为 Envoy 的 xDS API 的实现，负责监听 gRPC 接口并根据 Envoy 的需求动态推送配置。它能够处理各种资源类型的请求，并根据服务的变更实时更新 Envoy 配置。此外，它还支持安全特性，如验证客户端证书，确保只有合法的服务实例可以接收配置数据。\n\n### xDS 变体的配置示例 {#xds-config}\n\n使用 xDS 协议的变体通常涉及在 Envoy 代理或与之类似的服务网格配置中指定 xDS 服务器的详细信息。虽然不同的服务网格和代理服务器的配置细节可能有所不同，下面是一些通用的 YAML 配置示例，说明如何指定 xDS 服务器以及如何使用这些协议变体。\n\n#### State of the World (SotW)\n\n在 Envoy 的配置中，你可以通过静态资源或通过 API 动态获取资源的方式来使用 SotW。这里是一个简单的 Envoy 配置示例，显示了如何静态定义集群和监听器：\n\n{{\u003chighlight yaml \u0022linenos=table,hl_lines=24\u0022\u003e}}\nstatic_resources:\n  listeners:\n    - address:\n        socket_address: { address: 0.0.0.0, port_value: 80 }\n      filter_chains:\n        - filters:\n            - name: envoy.http_connection_manager\n              config:\n                stat_prefix: ingress_http\n                codec_type: auto\n                route_config:\n                  name: local_route\n                  virtual_hosts:\n                    - name: local_service\n                      domains: [\u0022*\u0022]\n                      routes:\n                        - match: { prefix: \u0022\/\u0022 }\n                          route: { cluster: local_service }\n                    http_filters:\n                      - name: envoy.router\n                  clusters:\n        - name: local_service\n            connect_timeout: 0.25s\n            type: STATIC\n            lb_policy: ROUND_ROBIN\n            hosts: [{ socket_address: { address: 127.0.0.1, port_value: 80 } }]\n{{\u003c\/highlight\u003e}}\n\n####  增量 xDS {#axds}\n\n增量 xDS 的配置需要在 xDS 服务端支持增量协议，并在客户端配置中指定使用增量 xDS。Envoy 启动配置中需要添加 API 版本来启用增量 xDS：\n\n{{\u003chighlight yaml \u0022linenos=table,hl_lines=4 10\u0022\u003e}}\ndynamic_resources:\n  cds_config:\n    api_config_source:\n      api_type: DELTA_GRPC\n      grpc_services:\n        envoy_grpc:\n          cluster_name: xds_cluster\n  lds_config:\n    api_config_source:\n      api_type: DELTA_GRPC\n      grpc_services:\n        envoy_grpc:\n          cluster_name: xds_cluster\n{{\u003c\/highlight\u003e}}\n\n#### 聚合发现服务 (ADS) {#ads}\n\n使用 ADS 时，所有资源类型的配置通过一个单一的 API 端点聚合。这在 Envoy 配置中指定：\n\n{{\u003chighlight yaml \u0022linenos=table,hl_lines=6 7\u0022\u003e}}\ndynamic_resources:\n  cds_config:\n    ads: {}\n  lds_config:\n    ads: {}\n  ads_config:\n    api_type: GRPC\n    grpc_services:\n      envoy_grpc:\n        cluster_name: xds_cluster\n{{\u003c\/highlight\u003e}}\n\n####  增量 ADS {#adds}\n\n增量 ADS 通过在 ADS 配置中指定增量 API 类型，可以实现更为细粒度的更新：\n\n{{\u003chighlight yaml \u0022linenos=table,hl_lines=8 9\u0022\u003e}}\ndynamic_resources:\n  cds_config:\n    ads: {}\n    resource_api_version: V3\n  lds_config:\n    ads: {}\n    resource_api_version: V3\n  ads_config:\n    api_type: DELTA_GRPC\n    grpc_services:\n      envoy_grpc:\n        cluster_name: xds_cluster\n{{\u003c\/highlight\u003e}}\n\n这些配置示例需要根据你的具体环境和需求进行调整。更多细节和高级配置，你可以参考 [Envoy 文档](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-v3\/config\/core\/v3\/config_source.proto#envoy-v3-api-enum-config-core-v3-apiconfigsource-apitype)。\n\n## Istio 如何发送配置给 Envoy sidecar？\n\n得益于 xDS 协议，如 Istio、Envoy Gateway 等可以通过 API 远程动态分发配置到 Envoy 代理。下图展示了 Istio 的配置分发流程（Sidecar 模式）。\n\n\u0060\u0060\u0060mermaid \u0022Istio 的配置分发流程图\u0022\nflowchart TB\n    Declarative_Configuration[声明式配置] --\u003e Kubernetes\n    Kubernetes \u003c--\u003e Istiod\n\n    subgraph Istiod [Istiod]\n        xDS_API[xDS API]\n    end\n\n    xDS_API \u003c--\u003e Pod1\n    xDS_API \u003c--\u003e Pod2\n    xDS_API \u003c--\u003e Pod3\n\n    subgraph Pod1 [Pod]\n        Envoy_Proxy1[Envoy Proxy] \u003c--\u003e Application1[Application]\n    end\n\n    subgraph Pod2 [Pod]\n        Envoy_Proxy2[Envoy Proxy] \u003c--\u003e Application2[Application]\n    end\n\n    subgraph Pod3 [Pod]\n        Envoy_Proxy3[Envoy Proxy] \u003c--\u003e Application3[Application]\n    end\n\u0060\u0060\u0060\n\n![Istio 的配置分发流程图](0fa133ccdbeb372a413ad1ecc99ff9f0.svg)\n\nIstio 中配置分发的主要流程说明：\n\n1. **声明式配置**：用户通过 YAML 文件或其他配置管理工具定义服务网格的配置。这些配置可以包括路由规则、安全策略、遥测设置等。\n2. **Kubernetes**：Istio 配置文件被提交到 Kubernetes 集群中，通常是通过 \u0060kubectl apply\u0060 命令或其他 CI\/CD 工具。Kubernetes 接收到配置文件并将其存储在 etcd 数据库中。\n3. **Istiod**：Istiod 是 Istio 的控制平面组件，负责管理和分发配置。它监听从 Kubernetes API 服务器中传入的事件，获取相关配置变更，并对其进行处理。Istiod 解析配置文件，生成相应的路由规则和策略，并通过 xDS API 将这些配置分发到数据平面（Envoy 代理）。\n4. **xDS API**：Istiod 使用 xDS API 将配置下发到各个 Envoy 代理中。\n5. **Envoy Proxy**：Envoy 是 Istio 的数据平面组件，运行在每个服务的旁路（sidecar）容器中，拦截并管理所有入站和出站流量。Envoy 代理通过 xDS API 接收来自 Istiod 的配置，并根据这些配置进行流量管理、策略执行和遥测数据收集。\n6. **Pod**：每个服务实例运行在一个 Pod 中，Pod 内部包含一个应用容器和一个 Envoy 代理容器。Envoy 代理拦截应用容器的所有网络流量，并根据配置进行处理。\n\n这个配置分发流程确保了 Istio 能够动态管理和配置服务网格中的所有服务实例，提供一致的流量管理和策略执行。\n\n## xDS 的发展与 Istio 中的 Delta xDS 实现\n\n起初，xDS 采用了“全局状态”（State of the World，简称 SotW）的设计，这意味着任何一个配置的更改都需要向 Envoy 发送所有配置的完整状态。这种方法在网络和控制平面上造成了巨大的负担，尤其是在大规模服务部署时。\n\n在 2021 年的 EnvoyCon 上，Aditya Prerepa 和 John Howard 分享了 Istio 如何实现 Delta xDS，这是一种增量式的 xDS 实现。与传统的 SotW xDS 相比，Delta xDS 只发送变更的配置，显著减少了需要通过网络发送的配置数据量，从而提高了效率和性能。这种方法特别适用于那些配置频繁变更的环境，因为它只更新变化的部分而不是整个配置。\n\n在实现 Delta xDS 的过程中，Istio 团队面临了多个挑战，包括如何确保配置更新的正确性以及避免潜在的资源泄漏。他们通过采用干运行（Dry-run）模式来并行运行 SotW 和 Delta 生成器，逐步发现并修复了实现中的缺陷。此外，他们还引入了新的 Envoy 类型，如虚拟主机发现服务（Virtual Host Discovery Service），以支持更细粒度的配置分发。\n\n### Delta xDS 增量配置\n\n下图展示了 Delta xDS 增量配置的流程。\n\n\u0060\u0060\u0060mermaid \u0022Delta xDS 增量配置流程图\u0022\nsequenceDiagram\n    participant CP as 控制平面\n    participant P as 代理\n    CP-\u003e\u003eP: 初始完整配置\n    P-\u003e\u003eCP: 订阅配置变更\n    Note over CP,P: 发生任何配置变更\n    CP-\u003e\u003eP: 检查配置变更\n    CP-\u003e\u003eP: 计算差异\n    CP-\u003e\u003eP: 仅发送差异\n    Note over P: 代理使用差异进行更新\n\u0060\u0060\u0060\n\n![Delta xDS 增量配置流程图](835038abb9bb83ba223974c525293468.svg)\n\nDelta xDS 配置流程如下：\n\n1. **初始完整配置**：控制平面向代理发送初始完整配置，此时使用的是 StoW 模式。\n2. **订阅配置变更**：代理从控制平面订阅配置变更。\n4. **检查配置变更**：控制平面检查相对于代理已知状态的配置变更。\n5. **计算差异**：控制平面计算当前配置与代理持有的前一配置之间的差异（增量）。\n6. **仅发送差异**：控制平面仅发送变更的配置（差异）给代理，代理应用这些差异增量更新其配置。\n\n该流程确保只有必要的变更被传输和应用，提高了效率并减少了网络和代理资源的负载。\n\n### SotW vs Delta xDS\n\n虽然 Delta xDS 解决了在大规模网络下的配置分发的性能问题，但是 SotW 模式依然有它存在的意义，比如在初次下发配置的情况下。下表对比了 Istio 中的两种配置分发方式：SotW (State of the World) 和 Delta xDS。\n\n{{\u003ctable \u0022Istio 中的全局状态和增量 xDS 配置分发方式对比\u0022\u003e}}\n| 对比项         | SotW                                                     | Delta XDS                                    |\n| -------------- | -------------------------------------------------------- | -------------------------------------------- |\n| **数据传输量** | 每次传输完整的配置数据，不管配置是否有变更。             | 仅传输发生变化的配置数据，减少了数据传输量。 |\n| **效率**       | 在小型或变更少的环境中效率可接受。                       | 在大型环境或频繁变更的环境中更高效。         |\n| **复杂性**     | 实现简单，易于理解和维护。                               | 实现较为复杂，需要精细的变更跟踪和管理。     |\n| **资源消耗**   | 可能因为重复发送大量未变更的数据而增加服务器和网络负载。 | 更低的资源消耗，因为只处理变更的部分。       |\n| **实时性**     | 配置更新后立即发送全量配置，实时性高。                   | 只发送变更部分，响应更快，减少处理时间。     |\n| **适用场景**   | 适合配置变动不频繁的小型至中型部署。                     | 适合配置频繁变更或大规模部署的场景。         |\n{{\u003c\/table\u003e}}\n\n这个表格从数据传输量、效率、复杂性、资源消耗、实时性以及适用场景等多个角度对 SotW 和 Delta XDS 进行了对比，有助于在不同的使用环境中做出合适的选择。\n\n## 总结\n\n在这篇文章中我分享了 xDS 的组成及 Istio 中配置分发的流程，还有 xDS 的两种模式 SotW 和 Delta xDS。随着 Delta xDS 在 Istio 1.22 版本中成为默认配置，这将有助于用户在大规模网络环境下轻松使用 Istio。\n\n## 参考\n\n- [xDS REST and gRPC protocol - envoyproxy.io](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-docs\/xds_protocol)\n', '\/blog\/istio-delta-xds-for-envoy\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文分享了 xDS 的组成及 Istio 中配置分发的流程，还有 xDS 的两种模式 SotW 和 Delta xDS。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/hugo-instant-search-guide/">如何为你的 Hugo 网站添加即时搜索功能</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/05/31</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e5%bc%80%e6%ba%90"> 
             开源
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('如何为你的 Hugo 网站添加即时搜索功能', '本文介绍了如何为 Hugo 网站添加即时搜索功能，并指明优化方向。', '\n最近我用 Fuse 和 Hugo 导出的全站结构化数据（压缩后仅 2MB）做的即时搜索，还有快捷搜索地址 https:\/\/jimmysong.io\/search\/?q=关键词，定制了下结果展示页面，这就是开源的强大之处，任何地方都可以私人订制。\n\n![搜索结果展示页面](search.webp)\n\n## 概览\n\n下面我将分享下如何为你的 Hugo 网站添加即时搜索功能。大体步骤如下：\n\n1. 导出 Hugo 网站的结构化数据\n2. 使用 Fuse 库构建搜索的 JavaScript 代码\n3. 添加前端搜索模板\n4. 自动化更新网站结构化数据\n5. 进一步优化\n\n{{\u003ccallout note 提示\u003e}}\n\n读者可以参考 [hugo-blox-builder](https:\/\/github.com\/HugoBlox\/hugo-blox-builder) 这个项目中的搜索实现，下面是参考的代码：\n\n- 前端代码：[search.html](https:\/\/github.com\/HugoBlox\/hugo-blox-builder\/blob\/8d25fbed122c2c57d994ebd78d232e1b51683c7d\/modules\/blox-bootstrap\/layouts\/partials\/search.html)\n- 搜索实现：[wowchemy-search.js](https:\/\/github.com\/HugoBlox\/hugo-blox-builder\/blob\/main\/modules\/blox-bootstrap\/assets\/js\/wowchemy-search.js)\n- 样式：[_search.scss](https:\/\/github.com\/HugoBlox\/hugo-blox-builder\/blob\/main\/modules\/blox-bootstrap\/assets\/scss\/wowchemy\/layouts\/_search.scss)\n\n{{\u003c\/callout\u003e}}\n\n## 1. 导出 Hugo 网站的结构化数据\n\n首先，你需要为你的 Hugo 网站创建一个 JSON 文件，它将包含所有页面的必要元数据，如标题、描述、链接等。你可以通过 Hugo 的自定义输出格式来实现这一点。\n\n在你的 Hugo 配置文件（通常是 \u0060config.toml\u0060 或 \u0060config.yaml\u0060）中，添加一个自定义输出格式：\n\n\u0060\u0060\u0060toml\n[outputs]\nhome = [\u0022HTML\u0022, \u0022RSS\u0022, \u0022JSON\u0022]\n\n[outputFormats.JSON]\nmediaType = \u0022application\/json\u0022\nbaseName = \u0022index\u0022\nisPlainText = false\n\u0060\u0060\u0060\n\n然后，在你的内容模板中（如 \u0060layouts\/_default\/list.json.json\u0060），定义输出的 JSON 结构：\n\n\u0060\u0060\u0060json\n{\n  \u0022data\u0022: [\n    {{ range .Pages }}\n    {\n      \u0022title\u0022: \u0022{{ .Title }}\u0022,\n      \u0022url\u0022: \u0022{{ .Permalink }}\u0022,\n      \u0022summary\u0022: \u0022{{ .Summary }}\u0022\n    }\n    {{ if not (eq .Next nil) }},{{ end }}\n    {{ end }}\n  ]\n}\n\u0060\u0060\u0060\n\n这将为你的整个站点生成一个 \u0060index.json\u0060 文件，其中包含所有页面的基本信息。当然你可能不想导出网站的所有页面，可以通过 Hugo 的语法，可定制化导出的 Section 或者不同类型页面。\n\n## 2. 使用 Fuse 库构建搜索的 JavaScript 代码\n\n接下来，使用 [Fuse.js](https:\/\/fusejs.io\/) 库来实现前端的即时搜索功能。首先，你需要在你的网站中包含 Fuse.js 的库文件。你可以从 [jsDelivr](https:\/\/www.jsdelivr.com\/package\/npm\/fuse.js) 等 CDN 加载它：\n\n\u0060\u0060\u0060html\n\u003cscript src=\u0022https:\/\/cdn.jsdelivr.net\/npm\/fuse.js\/dist\/fuse.min.js\u0022\u003e\u003c\/script\u003e\n\u0060\u0060\u0060\n\n然后，在你的 JavaScript 文件中，加载并解析 \u0060index.json\u0060 文件，并使用 Fuse.js 进行搜索：\n\n\u0060\u0060\u0060javascript\nfetch(\u0027\/index.json\u0027)\n  .then(response =\u003e response.json())\n  .then(data =\u003e {\n    const fuse = new Fuse(data.data, {\n      keys: [\u0027title\u0027, \u0027summary\u0027],\n      includeScore: true\n    });\n\n    document.getElementById(\u0027search-input\u0027).addEventListener(\u0027input\u0027, function (e) {\n      const results = fuse.search(e.target.value);\n      displayResults(results);\n    });\n  });\n\nfunction displayResults(results) {\n  const searchResults = document.getElementById(\u0027search-results\u0027);\n  searchResults.innerHTML = \u0027\u0027;\n  results.forEach(result =\u003e {\n    const elem = document.createElement(\u0027div\u0027);\n    elem.innerHTML = \u0060\u003ca href=\u0022${result.item.url}\u0022\u003e${result.item.title}\u003c\/a\u003e\u0060;\n    searchResults.appendChild(elem);\n  });\n}\n\u0060\u0060\u0060\n\n具体实现可以参考 [wowchemy-search.js](https:\/\/github.com\/HugoBlox\/hugo-blox-builder\/blob\/main\/modules\/blox-bootstrap\/assets\/js\/wowchemy-search.js)。\n\n## 3. 添加前端搜索模板\n\n在你的网站中添加一个搜索框和结果显示区域：\n\n\u0060\u0060\u0060html\n\u003cinput type=\u0022text\u0022 id=\u0022search-input\u0022 placeholder=\u0022输入搜索词\u0022\u003e\n\u003cdiv id=\u0022search-results\u0022\u003e\u003c\/div\u003e\n\u0060\u0060\u0060\n\n另外你还可以添加搜索快捷键，一般是组合键 \u0060⌘\/CTRL \u002b K\u0060 来快速打开搜索页面。\n\n具体实现可以参考 [这个前端模板](https:\/\/github.com\/HugoBlox\/hugo-blox-builder\/blob\/8d25fbed122c2c57d994ebd78d232e1b51683c7d\/modules\/blox-bootstrap\/layouts\/partials\/search.html)。\n\n## 4. 自动化更新网站结构化数据\n\n为了保证搜索结果的实时性，可以通过 GitHub Actions 或其他 CI\/CD 工具来自动化 Hugo 网站的构建和部署流程，确保 \u0060index.json\u0060 文件始终是最新的。\n\n创建一个 \u0060.github\/workflows\/hugo_build.yml\u0060 文件，定义自动化流程：\n\n\u0060\u0060\u0060yaml\nname: Build and Deploy\non:\n  push:\n    branches:\n      - main\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n    - name: Checkout\n      uses: actions\/checkout@v2\n    - name: Set up Hugo\n      uses: peaceiris\/actions-hugo@v2\n      with:\n        hugo-version: \u0027latest\u0027\n    - name: Build\n      run: hugo --minify\n    - name: Deploy\n      uses: peaceiris\/actions-gh-pages@v3\n      with:\n        github_token: ${{ secrets.GITHUB_TOKEN }}\n        publish_dir: .\/public\n\u0060\u0060\u0060\n\n另外如果你的网站支持多语言，可以为每种语言分别生成 \u0060index.json\u0060 文件，并在不同的语言页面加载对应的索引文件。\n\n## 5. 进一步优化\n\n- **缓存优化**：为 \u0060index.json\u0060 设置合理的缓存策略，以减少服务器负载和提高响应速度。如果你是会用的是 Github Pages 作为静态网站，那么可以忽略这一步。\n- **数据压缩**：压缩你的 \u0060index.json\u0060 文件，你可以选择导出网站的部分数据，比如某些 Section 的数据，对 Content 进行截取，或者压缩文件成 gz 格式，在 JavaScript 加载后再在前端解压，这样可以减少网络数据传输。\n- **搜索结果高亮**：增加搜索结果中关键词的高亮显示，提升用户体验。\n- **高级搜索选项**：允许用户通过特定字段（如作者、分类）进行过滤搜索。\n- **网络优化**：异步加载用于搜索的 JavaScript 文件，\n\n通过这些步骤，你可以有效地为你的 Hugo 网站添加一个高效且可定制的即时搜索功能。\n\n## 总结\n\n本文介绍了如何为 Hugo 网站添加即时搜索功能，并提供了进一步优化搜索功能的建议，包括缓存优化、搜索结果高亮显示和高级搜索选项。这不仅展示了开源技术的强大自定义能力，也使网站用户能更快更准确地找到所需信息。\n', '\/blog\/hugo-instant-search-guide\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文介绍了如何为 Hugo 网站添加即时搜索功能，并指明优化方向。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/envoy-gateway-oidc/">如何使用 Envoy Gateway 在 API 网关侧基于 OIDC 实现单点登录？</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/05/24</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/envoy"> 
             Envoy
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('如何使用 Envoy Gateway 在 API 网关侧基于 OIDC 实现单点登录？', '本文详细介绍了如何配置 Envoy Gateway 使用 OIDC 实现单点登录。通过 Auth0 作为身份提供商，演示如何在 API 网关端实现安全、高效的单点登录，提升用户体验和系统安全性。', '\n在[微服务中常见的认证方式详解](\/blog\/microservice-auth-methods\/)这篇博客中我们介绍到了 OAuth 2.0 认证，该身份认证协议有多种实现方式，其中最流行的就是 OpenID Connect（OIDC）认证。OIDC 能够为用户提供身份验证和授权。本文将介绍如何使用 Envoy Gateway 在 API 网关级别实现 OIDC 认证。\n\n## Envoy Gateway 支持的认证方式 {#auth-methods}\n\nEnvoy Gateway 是一个使用 Envoy 实现的高性能的 API 网关，支持多种认证方式来保护 API 和微服务：\n\n1. **JWT 认证**: 使用 JSON Web Tokens（JWT）进行认证。\n2. **mTLS（双向 TLS）**: 使用双向 TLS 确保客户端和服务器之间的安全通信。\n3. **HTTP Basic 认证**: 使用用户名和密码进行基本认证。\n4. **OIDC 认证**: 使用 OpenID Connect 协议进行身份验证和授权。\n5. **外部认证**：外部认证调用外部 HTTP 或 gRPC 服务来检查传入的 HTTP 请求是否经过认证。\n\n本文重点介绍如何在 Envoy Gateway 中配置和使用 OIDC 认证从而在网关侧实现单点登录。\n\n## 什么是 OIDC？{#what-is-oidc}\n\nOpenID Connect（OIDC）是一个基于 [OAuth 2.0](\/blog\/microservice-auth-methods\/#oauth-20) 的身份验证协议。它允许客户端通过认证服务器验证用户身份，并获取有关用户的信息。\n\nOIDC 认证流程如下图所示：\n\n\u0060\u0060\u0060mermaid \u0022OIDC 认证流程图\u0022\nsequenceDiagram\n    participant User\n    participant Client\n    participant AuthServer\n    participant ResourceServer\n\n    User -\u003e\u003e Client: 请求访问受保护资源\n    Client -\u003e\u003e AuthServer: 请求认证（带有客户端 ID）\n    AuthServer -\u003e\u003e User: 请求用户登录\n    User -\u003e\u003e AuthServer: 用户登录并授权\n    AuthServer -\u003e\u003e Client: 返回授权码\n    Client -\u003e\u003e AuthServer: 交换授权码获取访问令牌和 ID 令牌\n    AuthServer -\u003e\u003e Client: 返回访问令牌和 ID 令牌\n    Client -\u003e\u003e ResourceServer: 请求受保护资源（带有访问令牌）\n    ResourceServer -\u003e\u003e AuthServer: 验证访问令牌\n    AuthServer -\u003e\u003e ResourceServer: 验证成功\n    ResourceServer -\u003e\u003e Client: 返回受保护资源\n    Client -\u003e\u003e User: 返回受保护资源\n\u0060\u0060\u0060\n\n![OIDC 认证流程图](83b3c4d30c57805947a314f67c7aa8c1.svg)\n\nOIDC 为 OAuth 2.0 增加了身份验证层，通过引入 ID Token 和标准化的 UserInfo Endpoint，使 OAuth 2.0 不仅能够用于授权，还可以用于安全地验证用户身份，从而实现单点登录（SSO）和用户身份信息的获取。\n\n## 为什么要实现单点登录？{#why-sso}\n\n单点登录（Single Sign-On, SSO）是一种身份验证方式，它允许用户使用一个账户登录多个独立的应用系统，通过一次身份验证即可无缝访问所有相关应用，减少重复输入用户名和密码的麻烦，从而提升用户体验。SSO 集中管理用户身份和认证，增强了系统安全性，并简化了 IT 管理流程。\n\n对于微服务架构，SSO 尤其重要，因为它在各个微服务之间实现统一的认证和授权，避免了每个服务单独实现身份验证逻辑的需求，减少了用户重复登录的麻烦，并提高了用户体验。集中管理的方式还可以统一应用安全策略，更有效地监控和响应安全事件，提升系统的整体安全性。同时，通过使用标准化的令牌（如 JWT），SSO 简化了微服务之间的身份验证过程，提高了开发效率，让开发人员能够专注于业务逻辑的实现。\n\n## 示例：使用 Envoy Gateway 和 Auth0 的单点登录 {#demo}\n\n接下来我们将使用 Auth0 作为身份供应商，演示如何使用 Envoy Gateway 在 API 网关端实现单点登录。\n\n你可以在 [Bilibili](https:\/\/www.bilibili.com\/video\/BV11m421K7ZW\/?share_source=copy_web\u0026vd_source=87728cb6b1b0090fc617caf07a40b236) 上查看该示例演示。\n\n{{\u003c responsive_video src=\u0022\/\/player.bilibili.com\/player.html?isOutside=true\u0026aid=1604968380\u0026bvid=BV11m421K7ZW\u0026cid=1557352862\u0026p=1\u0022 aspectRatio=\u002262.5%\u0022 \u003e}}\n\n### 基于 Auth0 实现单点登录 {#auth0-sequence}\n\n首先我们先说明下示例中 Envoy Gateway 基于 Auth0 实现单点登录的详细流程，如下图所示。\n\n\u0060\u0060\u0060mermaid \u0022Envoy Gateway 基于 Auth0 实现单点登录的流程图\u0022\nsequenceDiagram\n    participant 用户\n    participant 浏览器\n    participant Envoy Gateway\n    participant Auth0\n    participant 应用程序\n\n    用户 -\u003e\u003e 浏览器: 打开 https:\/\/www.example.com\n    浏览器 -\u003e\u003e Envoy Gateway: 请求 https:\/\/www.example.com\n    Envoy Gateway -\u003e\u003e 浏览器: 在 cookie 中未找到 ID token\n    Envoy Gateway -\u003e\u003e 浏览器: 重定向到 Auth0\n    浏览器 -\u003e\u003e Auth0: 请求 \/authorize?response_type=code\u0026client_id=${CLIENT_ID}\u0026redirect_uri=https:\/\/www.example.com\/myapp\/oauth2\/callback\n    Auth0 -\u003e\u003e 浏览器: 重定向到用户登录页面\n    浏览器 -\u003e\u003e 用户: 输入用户名和密码\n    用户 -\u003e\u003e 浏览器: 用户登录\n    浏览器 -\u003e\u003e Auth0: 提交凭证\n    Auth0 -\u003e\u003e 浏览器: 重定向到 https:\/\/www.example.com\/myapp\/oauth2\/callback?code=xxxx\u0026state=xxx\n    浏览器 -\u003e\u003e Envoy Gateway: 请求 https:\/\/www.example.com\/myapp\/oauth2\/callback?code=xxxx\n    Envoy Gateway -\u003e\u003e Auth0: 使用代码交换 ID Token\n    Envoy Gateway -\u003e\u003e 浏览器: 设置 cookie: ID Token\n    Envoy Gateway -\u003e\u003e 浏览器: 重定向到 https:\/\/www.example.com\n    浏览器 -\u003e\u003e Envoy Gateway: 请求 https:\/\/www.example.com\n    Envoy Gateway -\u003e\u003e Envoy Gateway: 验证 ID Token\n    Envoy Gateway -\u003e\u003e 应用程序: 路由到 Backend service\n\u0060\u0060\u0060\n\n![Envoy Gateway 基于 Auth0 实现单点登录的流程图](0f2852499a637280acfa600e992fd2c8.svg)\n\n步骤说明：\n\n1. **用户访问网站**：用户通过浏览器访问 \u0060https:\/\/www.example.com\u0060。\n2. **请求转发**：浏览器向 Envoy Gateway 发送 GET 请求。\n3. **检查 ID 令牌**：Envoy Gateway 检查用户请求的 cookie 是否包含有效的 ID 令牌。\n4. **重定向到身份提供商**：如果没有找到 ID 令牌，Envoy Gateway 将用户重定向到身份提供商（Identity Provider，IdP）的授权端点，在这里是 Auth0，关于 Auth0 如何实现 Login 的详细信息请查看 [Auth0 文档](https:\/\/auth0.com\/docs\/api\/authentication#login)。\n5. **用户登录**：用户在身份提供商的登录页面输入用户名和密码，并提交凭证进行登录。\n6. **获取授权码**：用户成功登录后，身份提供商将用户重定向回 Envoy Gateway，并在 URL 中包含授权码。\n7. **交换 ID 令牌**：Envoy Gateway 使用授权码向身份提供商请求 ID 令牌。\n8. **设置 Cookie**：身份提供商返回 ID 令牌，Envoy Gateway 将其设置为用户的 cookie。\n9. **重定向**：Envoy Gateway 将 URL 重定向到 \u0060https:\/\/www.example.com\u0060。\n10. **验证 ID 令牌**：Envoy Gateway 验证用户请求中的 ID 令牌。\n11. **路由请求**：验证通过后，Envoy Gateway 将请求路由到后端应用（App）。\n\n通过上述流程，Envoy Gateway 实现了单点登录功能。用户的 HTTP 请求在没有得到授权的情况下都会被转发单点登录页面。除了 Auth0 以外，Envoy Gateway 还支持多个身份提供商，如 Azure AD、Keycloak、Okta、OneLogin、Salesforce、UAA 等。\n\n下面我们将按照时序图中的流程配置 Auth0 和 Envoy Gateway。\n\n### 在 Auth0 上创建应用 {#auth0}\n\n请参考以下步骤在 Auth0 上设置一个 Regular Web Application：\n\n1. 访问 [Auth0](https:\/\/auth0.com\/) 并注册一个免费账户。\n2. 创建一个新的应用，并选择常规 Web 应用程序。\n3. 在应用设置中，记录或设置以下字段：\n   - **Domain** ：\u0060{DOMAIN}\u0060\n   - **Client ID**：\u0060{CLIENT_ID}\u0060\n   - **Client Secret**：\u0060{CLIENT_SECRET}\u0060\n   - **Allowed Callback URLs**：\u0060https:\/\/www.example.com\/oauth2\/myapp\/callback\u0060\n   - **Allowed Logout URLs**：\u0060https:\/\/www.example.com\/myapp\/logout\u0060\n\n记住上面的 Auth0 字段，我们将用它们来配置 Envoy Gateway 的安全策略。\n\n{{\u003ccallout note 提示\u003e}}\n这里的 Logout URL 不起实际作用，应为在我们的下面示例中的 backend 服务并没有实现 Auth0 的 logout 接口。我们只是按照习惯在此添加该字段，以待未来实现。\n{{\u003c\/callout\u003e}}\n\n下面展示的是 Auth0 的配置页面截图，在设置好用户后并创建普通 Web 应用后，你只需要配置这两个地方。\n\n![Auth0 配置页面 1](auth0-1.webp)\n\n![Auth0 配置页面 2](auth0-2.webp)\n\n以上就是 Auth0 的全部配置，接下来我们将安装和配置 Envoy Gateway。\n\n### 安装 Envoy Gateway {#install-envoy-gateway}\n\n参考 [Envoy Gateway 快速开始](\/blog\/envoy-gateway-introduction\/#envoy-gateway-quick-start)在 minikube 上安装 Envoy Gateway：\n\n\u0060\u0060\u0060bash\nminikube start --driver=docker --cpus=2 --memory=2g\nhelm install eg oci:\/\/docker.io\/envoyproxy\/gateway-helm --version v1.0.1 -n envoy-gateway-system --create-namespace\nkubectl apply -f https:\/\/github.com\/envoyproxy\/gateway\/releases\/download\/v1.0.1\/quickstart.yaml -n default\n\u0060\u0060\u0060\n\n参考安全网关，为 Envoy Gateway 配置 TLS：\n\n\u0060\u0060\u0060bash\n# 创建根证书和私钥来签署证书\nopenssl req -x509 -sha256 -nodes -days 365 -newkey rsa:2048 -subj \u0027\/O=example Inc.\/CN=example.com\u0027 -keyout example.com.key -out example.com.crt\n\n# 为 www.example.com 创建证书和私钥\nopenssl req -out www.example.com.csr -newkey rsa:2048 -nodes -keyout www.example.com.key -subj \u0022\/CN=www.example.com\/O=example organization\u0022\nopenssl x509 -req -days 365 -CA example.com.crt -CAkey example.com.key -set_serial 0 -in www.example.com.csr -out www.example.com.crt\n\n# 将证书\/密钥存储在 Secret 中\nkubectl create secret tls example-cert --key=www.example.com.key --cert=www.example.com.crt\n\u0060\u0060\u0060\n\n更新快速开始中创建的网关，使其包含 \u0060443\u0060 端口并引用 \u0060example-cert\u0060 Secret 的 HTTPS Listener：\n\n\u0060\u0060\u0060bash\necho \u0027[\n  {\n    \u0022op\u0022: \u0022add\u0022,\n    \u0022path\u0022: \u0022\/spec\/listeners\/-\u0022,\n    \u0022value\u0022: {\n      \u0022name\u0022: \u0022https\u0022,\n      \u0022protocol\u0022: \u0022HTTPS\u0022,\n      \u0022port\u0022: 443,\n      \u0022tls\u0022: {\n        \u0022mode\u0022: \u0022Terminate\u0022,\n        \u0022certificateRefs\u0022: [\n          {\n            \u0022kind\u0022: \u0022Secret\u0022,\n            \u0022group\u0022: \u0022\u0022,\n            \u0022name\u0022: \u0022example-cert\u0022\n          }\n        ]\n      }\n    }\n  }\n]\u0027 | kubectl patch gateway eg --type=json --patch-file \/dev\/stdin\n\u0060\u0060\u0060\n\n创建 HTTPRoute，为 \u0060\/myapp\u0060 端点增加一条到\u0060backend\u0060 服务的路由：\n\n\u0060\u0060\u0060bash\ncat \u003c\u003cEOF | kubectl apply -f -\napiVersion: gateway.networking.k8s.io\/v1\nkind: HTTPRoute\nmetadata:\n  name: myapp\nspec:\n  parentRefs:\n  - name: eg\n  hostnames: [\u0022www.example.com\u0022]\n  rules:\n  - matches:\n    - path:\n        type: PathPrefix\n        value: \/myapp\n    backendRefs:\n    - name: backend\n      port: 3000\nEOF\n\u0060\u0060\u0060\n\n### 配置 Envoy Gateway 的 OIDC 认证 {#envoy-gateway-oidc}\n\n创建一个 Kubernetes Secret，用于存储 OAuth Client 的 Client Secret：\n\n\u0060\u0060\u0060bash\nkubectl create secret generic auth0-client-secret --from-literal=client-secret=${CLIENT_SECRET}\n\u0060\u0060\u0060\n\n{{\u003ccallout note 注意\u003e}}\n将 \u0060${CLIENT_SECRET}\u0060 替换成你的 Auth0 Client Secret。\n{{\u003c\/callout\u003e}}\n\n创建一个安全策略（SecurityPolicy）：\n\n\u0060\u0060\u0060bash\ncat \u003c\u003cEOF | kubectl apply -f -\napiVersion: gateway.envoyproxy.io\/v1alpha1\nkind: SecurityPolicy\nmetadata:\n  name: oidc-example\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: eg\n  oidc:\n    provider:\n      issuer: \u0022https:\/\/${DOMAIN}\u0022\n    clientID: \u0022${CLIENT_ID}\u0022\n    clientSecret:\n      name: \u0022auth0-client-secret\u0022\n    redirectURL: \u0022https:\/\/www.example.com\/myapp\/oauth2\/callback\u0022\n    logoutPath: \u0022\/myapp\/logout\u0022\nEOF\n\u0060\u0060\u0060\n\n**注意事项**\n\n- 此处的 \u0060issuer\u0060 应该填写成 Auth0 Domain。\n- \u0060redirectURL\u0060 的值需要出现在 Auth0 配置的 Allowed Callback URLs 中。\n- \u0060logoutPath\u0060 是必须的，即使其 URL 端点并为实现 logout 逻辑。\n\n在这个示例中我们为 Envoy Gateway 网关设置了 OIDC，修改 \u0060targetRef\u0060 到 HTTPRoute，也可以为单个路由设置 OIDC。关于 ODIC 的具体配置，请参考 Envoy Gateway API 文档。\n\n### 验证单点登录：登入 {#login}\n\n将 \u0060www.example.com\u0060 添加到本地的 \u0060\/etc\/hosts\u0060 文件中：\n\n\u0060\u0060\u0060bash\necho \u0022127.0.0.1 www.example.com\u0022 | sudo tee -a \/etc\/hosts\n\u0060\u0060\u0060\n\n配置应用程序的端口转发，以便你可以在本地通过域名访问示例应用：\n\n\u0060\u0060\u0060bash\nexport ENVOY_SERVICE=$(kubectl get svc -n envoy-gateway-system --selector=gateway.envoyproxy.io\/owning-gateway-namespace=default,gateway.envoyproxy.io\/owning-gateway-name=eg -o jsonpath=\u0027{.items[0].metadata.name}\u0027)\n\nsudo kubectl -n envoy-gateway-system port-forward service\/${ENVOY_SERVICE} 443:443\n\u0060\u0060\u0060\n\n现在在浏览器中访问 \u003chttps:\/\/www.example.com\u003e，跳过证书风险提示，页面将跳转到 Auth0 的登录界面，如下图所示，选择使用 Google 账户登录。\n\n![登录界面](login.webp)\n\n在登录完成后，浏览器将跳转会 \u003chttps:\/\/www.example.com\u003e 页面，并展示 HTTP 请求结果，如下面的 JSON 代码所示。\n\n\u0060\u0060\u0060json\n{\n  \u0022path\u0022: \u0022\/\u0022,\n  \u0022host\u0022: \u0022www.example.com\u0022,\n  \u0022method\u0022: \u0022GET\u0022,\n  \u0022proto\u0022: \u0022HTTP\/1.1\u0022,\n  \u0022headers\u0022: {\n    \/*Omit*\/\n    \u0022Authorization\u0022: [\n      \u0022Bearer eyJhbGciOiJkaXIiLCJlbmMiOiJBMjU2R0NNIiwiaXNzIjoiaHR0cHM6Ly9kZXYtYXdoam15MzhnZzVxeng3dS51cy5hdXRoMC5jb20vIn0..IiH9LnxmnrGAVy-q.eQV_0Ssetw9mmrEaJNLlBowGJNX51awhh67WSejPrksuGU9e9-DcPJQqmR67ONFzTXWR6CFy4Rfgs4btsmEtvCtiNTCgrBHP90ddbOTg_pK31WnsQ7NThyRfGwoogSaAtK6hFrC2pxFaLj0XL7XvSPk-OaTzK1Zh1da1IM1cmWAWiBRc3nQiVWRDrExPo8-i5SawFe0jIcwytVSaRiX5Polyd3cZ7A7nlei-vDLCfj0HVzOO605nF7ED2dBSnZyev1sg14q598f3X2Vfhi2oJlnbiulGZIlpXgGbcPhzAJJxyEe6qpRpNg7Hbk8Ya-i8gUTwwNysrgm3.Zu5kD_6DzSfZPvwemttXYQ\u0022\n    ],\n    \u0022Cookie\u0022: [\n      \u0022OauthHMAC-167a6c5=RPdscXEBap0NeSIppJXoxkHt0qvMz4fNHXo2uvgDgIY=; OauthExpires-167a6c5=1716540771; BearerToken-167a6c5=eyJhbGciOiJkaXIiLCJlbmMiOiJBMjU2R0NNIiwiaXNzIjoiaHR0cHM6Ly9kZXYtYXdoam15MzhnZzVxeng3dS51cy5hdXRoMC5jb20vIn0..IiH9LnxmnrGAVy-q.eQV_0Ssetw9mmrEaJNLlBowGJNX51awhh67WSejPrksuGU9e9-DcPJQqmR67ONFzTXWR6CFy4Rfgs4btsmEtvCtiNTCgrBHP90ddbOTg_pK31WnsQ7NThyRfGwoogSaAtK6hFrC2pxFaLj0XL7XvSPk-OaTzK1Zh1da1IM1cmWAWiBRc3nQiVWRDrExPo8-i5SawFe0jIcwytVSaRiX5Polyd3cZ7A7nlei-vDLCfj0HVzOO605nF7ED2dBSnZyev1sg14q598f3X2Vfhi2oJlnbiulGZIlpXgGbcPhzAJJxyEe6qpRpNg7Hbk8Ya-i8gUTwwNysrgm3.Zu5kD_6DzSfZPvwemttXYQ; IdToken-167a6c5=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImFKWkxWbnNrai0tYmhsNlJzVm51OCJ9.eyJpc3MiOiJodHRwczovL2Rldi1hd2hqbXkzOGdnNXF6eDd1LnVzLmF1dGgwLmNvbS8iLCJhdWQiOiJUZzhlNWVoa0xKM2hka3cxTzREMTBQd21QeTcxZHZtdiIsImlhdCI6MTcxNjQ1NDM3MSwiZXhwIjoxNzE2NDkwMzcxLCJzdWIiOiJnb29nbGUtb2F1dGgyfDExMjc0NDc3OTAyMjMzMTA0ODY0MCIsInNpZCI6IjRlSjhDZnZuZjd5Mm1kaE94QXBTY0JiUEhjOS1rZUVLIn0.r9dwIy_HeiO5_I3UlohLkeRES5FGoxqQnwmcA00cA_kdc5mUxgeVopXIhBUjJnTKv7bOUVJvFw21ew4gqVRJfllDyG-s_XfhSW1-lEXmCc2bGYDtOzva6k2S_VRgyMKfG04_DWFuTgO_pLtix28aYq8cGzKJ_VglT_KgRhoktzJu4Js5iCv9JPnydRJmpvRJwX3tDv_Q3mmUSazaLkhOTdiBJFrGlS07qEzJ_iWANZgR8uDNhpXdmlcqpb3MZkkMulr5-jXIgEhBQKpw28tUiSlzh6EpAVuBH9T1w8bUmFRzCc6JPPamJRfflYW5onNgYHDfcU0RpvpsCHRHRAZbdA\u0022\n    ],\n    \/*Omit*\/\n    \u0022User-Agent\u0022: [\n      \u0022Mozilla\/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit\/537.36 (KHTML, like Gecko) Chrome\/125.0.0.0 Safari\/537.36\u0022\n    ],\n    \u0022X-Envoy-Internal\u0022: [\n      \u0022true\u0022\n    ],\n    \u0022X-Forwarded-For\u0022: [\n      \u002210.244.0.51\u0022\n    ],\n    \u0022X-Forwarded-Proto\u0022: [\n      \u0022https\u0022\n    ],\n    \u0022X-Request-Id\u0022: [\n      \u0022c1e64057-c5c8-4fb2-a304-25c291eeed32\u0022\n    ]\n  },\n  \u0022namespace\u0022: \u0022default\u0022,\n  \u0022ingress\u0022: \u0022\u0022,\n  \u0022service\u0022: \u0022\u0022,\n  \u0022pod\u0022: \u0022backend-55d64d8794-4qvgd\u0022\n}\n\u0060\u0060\u0060\n\n此时通过 Chrome 浏览器的  *Inspector - Application - Cookies* 查看到 ID Token 如下图所示：\n\n![在 Chrome Inspector 中查看 ID Token](inspector.webp)\n\n编写代码 Python 代码，\u0060validate_id_token.py\u0060，解析 ID Token 并验证其有效性：\n\n{{\u003c include_code file=\u0022validate_id_token.py\u0022 \u003e}}\n\n安装依赖的包：\n\n\u0060\u0060\u0060bash\npip install pyjwt requests\n\u0060\u0060\u0060\n\n运行代码：\n\n\u0060\u0060\u0060bash\npython validate_id_token.py ${ID_TOKEN}\n\u0060\u0060\u0060\n\n你将看到类似下面的输出：\n\n\u0060\u0060\u0060ini\nToken is valid. Decoded payload:\niss: https:\/\/dev-awhjmy38gg5qzx7u.us.auth0.com\/\naud: Tg8e5ehkLJ3hdkw1O4D10PwmPy71dvmv\niat: 1716470905\nexp: 1716506905\nsub: google-oauth2|112744779022331048640\nsid: 4W_hQNJJ8ftDL8S3Cozp8GEu2Au4_e9N\n\u0060\u0060\u0060\n\n通过该 ID Token 的值可以得出：\n\n- 该令牌由 Auth0 签发（\u0060iss\u0060 字段）。\n- 该令牌的受众是特定的应用或 API（\u0060aud\u0060 字段），对于 Auth0，这个值是 Client ID。\n- 令牌是在 2024 年 5 月 23 日 04:08:25 UTC 签发的（\u0060iat\u0060 字段），并将在 2024 年 5 月 23 日 14:08:25 UTC 过期（\u0060exp\u0060 字段）。\n- 令牌所代表的主体（用户）的唯一标识符是 \u0060google-oauth2|112744779022331048640\u0060（\u0060sub\u0060 字段）。在这里，这个标识符表明使用 Google OAuth2 登录的用户\n- 会话 ID 是 \u00604W_hQNJJ8ftDL8S3Cozp8GEu2Au4_e9N\u0060（\u0060sid\u0060 字段），用于会话管理。\n\n### 验证单点登录：登出 {#logout}\n\n由于我们的示例应用中没有实现 Auth0 的 Logout 逻辑，所以我们需要通过 HTTP 请求明确告知 Auth0 要 logout，在浏览器中访问该 URL：\n\n\u0060\u0060\u0060bash\nhttps:\/\/${DOMAIN}\/v2\/logout?client_id=${CLIENT_ID}\n\u0060\u0060\u0060\n\n请将 \u0060${DOMAIN}\u0060 和 \u0060${CLIENT_ID\u0060 修改为你的 Auth0 应用程序的[配置项](#auth0)。关于 Auth0 如何登出 OIDC 端点的详细说明请查看 [Auth0 文档](https:\/\/auth0.com\/docs\/api\/authentication#logout)。\n\n登出后，页面将再次跳转到登录页面，在登录后，页面将重定向到 \u003chttps:\/\/www.example.com\u003e。\n\n## 总结 {#summary}\n\n通过以上步骤，你可以在 Envoy Gateway 中实现 OIDC 认证，确保 API 的安全性。这种方法不仅能提供灵活的身份验证机制，还能简化应用程序的身份管理。通过集成 Auth0 等身份提供商，Envoy Gateway 可以轻松实现单点登录，提升用户体验和系统安全性。未来，你可以根据需求进一步配置和优化 Envoy Gateway，充分利用其强大的认证和授权功能，以满足更复杂的安全要求和业务需求。\n\n## 参考 {#reference}\n\n- Envoy Gateway OIDC Authentication - gateway.envoyproxy.io\n- [Log Users Out of Auth0 with OIDC Endpoint - auth0.com](https:\/\/auth0.com\/docs\/authenticate\/login\/logout\/log-users-out-of-auth0)\n', '\/blog\/envoy-gateway-oidc\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文详细介绍了如何配置 Envoy Gateway 使用 OIDC 实现单点登录。通过 Auth0 作为身份提供商，演示如何在 API 网关端实现安全、高效的单点登录，提升用户体验和系统安全性。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/microservice-auth-methods/">微服务中常见的认证方式详解</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/05/22</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f"> 
             云原生
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('微服务中常见的认证方式详解', '本文将介绍几种常见的微服务认证方式，帮助你在设计和实现微服务系统时选择合适的认证方案。', '\n在现代微服务架构中，安全性是一个至关重要的方面。随着微服务数量的增加，如何确保服务间的安全通信成为了一个挑战。本文将介绍几种常见的微服务认证方式，帮助你在设计和实现微服务系统时选择合适的认证方案。\n\n## 微服务中常用的认证方式 {#comparation}\n\n下表列出了几种微服务中常用的认证方式，并从优点、缺点、适用场景和现实示例等维度进行比较。\n\n| 认证方式     | 优点                       | 缺点                         | 运行位置         | 适用场景             | 典型用途               | 现实使用场景                                       |\n| ------------ | -------------------------- | ---------------------------- | ---------------- | -------------------- | ---------------------- | -------------------------------------------------- |\n| JWT          | 自包含令牌，减少服务器负担 | 令牌较大，可能会增加带宽开销 | API 网关、服务间 | 微服务之间无状态通信 | 用户认证和授权         | 在微服务架构中，用户认证（如 Auth0、Firebase）     |\n| OAuth 2.0    | 广泛支持，灵活性高         | 实现复杂，需要额外的交互     | API 网关         | 第三方应用授权       | 第三方应用访问用户数据 | Github OAuth，用于第三方应用访问 Github 数据和 API |\n| mTLS         | 高安全性，防止中间人攻击   | 证书管理复杂，性能开销较大   | 服务间           | 高安全性要求的通信   | 安全敏感的服务通信     | 银行系统中的服务通信                               |\n| Basic 认证   | 简单易实现                 | 不安全，容易被拦截           | API 网关、服务间 | 简单的 API 保护      | 简单的内部服务         | Kubernetes API Server 的基本认证                   |\n| API Key 认证 | 简单易用                   | 安全性低，容易被滥用         | API 网关、服务间 | 低安全性要求的场景   | 简单的服务访问控制     | 各种公共 API，如 OpenAI API                        |\n\n下面我们将详细介绍这几种常见的认证方式。\n\n##  JWT 认证 {#jwt}\n\nJWT（JSON Web Token）最早由 IETF JSON Web Token (JWT) 工作组提出，并在 2015 年作为 RFC 7519 标准正式发布。JWT 的设计目标是提供一种紧凑且自包含的方式，用于在各方之间安全地传递信息。由于其易于使用和无状态的特性，JWT 迅速被广泛采用，成为身份验证和信息交换的标准之一，特别是在微服务和现代 Web 应用中。\n\n下图展示的是 JWT 认证流程。\n\n\u0060\u0060\u0060mermaid \u0022JWT 认证流程\u0022\nsequenceDiagram\n    participant User\n    participant Client\n    participant AuthServer\n    participant ResourceServer\n\n    User -\u003e\u003e Client: 提供凭证\n    Client -\u003e\u003e AuthServer: 发送凭证请求访问令牌\n    AuthServer -\u003e\u003e Client: 返回 JWT 令牌\n    Client -\u003e\u003e ResourceServer: 请求受保护资源（带 JWT 令牌）\n    ResourceServer -\u003e\u003e AuthServer: 验证 JWT 令牌\n    AuthServer -\u003e\u003e ResourceServer: 验证成功\n    ResourceServer -\u003e\u003e Client: 返回受保护资源\n\u0060\u0060\u0060\n\n![JWT 认证流程](5dbe313ba5e9704fe2669e7a1ea556a4.svg)\n\nJWT 认证流程说明：\n\n1. 用户提供凭证\n2. 客户端请求访问令牌\n3. 认证服务器返回 JWT 令牌\n4. 客户端带 JWT 令牌请求资源服务器\n5. 资源服务器验证 JWT\n\n### JWT 的格式说明及示例\n\nJWT（JSON Web Token）由三个部分组成：头部（Header）、载荷（Payload）和签名（Signature），分别通过 Base64 编码后用点（.）连接在一起组成。\n\n1. **头部（Header）**：头部包含令牌类型和签名算法。\n\n   \u0060\u0060\u0060json\n   {\n     \u0022alg\u0022: \u0022HS256\u0022,\n     \u0022typ\u0022: \u0022JWT\u0022\n   }\n   \u0060\u0060\u0060\n\n2. **载荷（Payload）**：载荷包含声明（claims），即关于用户或其他数据的断言。\n\n   \u0060\u0060\u0060json\n   {\n     \u0022sub\u0022: \u00221234567890\u0022,\n     \u0022name\u0022: \u0022John Doe\u0022,\n     \u0022iat\u0022: 1516239022\n   }\n   \u0060\u0060\u0060\n\n3. **签名（Signature）**：签名由编码后的头部、编码后的载荷以及一个密钥通过头部中指定的算法生成。\n\n   \u0060\u0060\u0060\n   HMACSHA256(\n     base64UrlEncode(header) \u002b \u0022.\u0022 \u002b\n     base64UrlEncode(payload),\n     secret\n   )\n   \u0060\u0060\u0060\n\n下面是一个 JWT 令牌示例：\n\n\u0060\u0060\u0060jwt\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\n\u0060\u0060\u0060\n\n## OAuth 2.0\n\nOAuth（Open Authorization）协议最早由 Blaine Cook 和 Chris Messina 在 2006 年提出。最初的目标是为 Twitter 提供一个开放的授权标准。OAuth 1.0 于 2007 年发布，提供了一个允许用户授权第三方应用访问其资源的标准化方式，但由于其复杂的签名机制和其他安全问题，受到了一些限制。\n\n为了克服这些缺点，IETF（Internet Engineering Task Force）成立了 OAuth 工作组，旨在开发一个更简化、更灵活的授权协议。2012 年，[OAuth 2.0](https:\/\/oauth.net\/2\/) 正式发布（RFC 6749 和 RFC 6750）。OAuth 2.0 简化了授权流程，增加了多种授权模式，如授权码模式、简化模式、资源所有者密码凭证模式和客户端凭证模式。\n\nOAuth 2.0 迅速成为行业标准，广泛应用于各种网络服务和应用程序，如 Google、Facebook、GitHub 等。在此基础上，出现了多个扩展和补充协议（如 OpenID Connect），进一步增强了 OAuth 2.0 的功能和安全性。\n\nOAuth 2.0 的发展和扩展使其成为现代互联网身份验证和授权的重要基石，提供了灵活和安全的解决方案，满足了不断变化的网络应用需求。\n\n下图展示的是 OAuth 2.0 认证流程。\n\n\u0060\u0060\u0060mermaid \u0022OAuth 2.0 认证流程\u0022\nsequenceDiagram\n    participant User\n    participant Client\n    participant AuthServer\n    participant ResourceServer\n\n    User -\u003e\u003e Client: 请求访问受保护资源\n    Client -\u003e\u003e AuthServer: 请求认证（带有客户端 ID）\n    AuthServer -\u003e\u003e User: 请求用户登录并授权\n    User -\u003e\u003e AuthServer: 用户登录并授权\n    AuthServer -\u003e\u003e Client: 返回授权码\n    Client -\u003e\u003e AuthServer: 交换授权码获取访问令牌\n    AuthServer -\u003e\u003e Client: 返回访问令牌\n    Client -\u003e\u003e ResourceServer: 请求受保护资源（带访问令牌）\n    ResourceServer -\u003e\u003e Client: 返回受保护资源\n\u0060\u0060\u0060\n\n![OAuth 2.0 认证流程](d79d70a5b27686dbaf8eee2e825f3d6c.svg)\n\nOAuth 2.0 认证流程说明：\n\n1. 用户请求访问资源\n2. 客户端请求认证\n3. 用户登录并授权\n4. 认证服务器返回授权码\n5. 客户端交换授权码获取访问令牌\n6. 客户端带访问令牌请求资源服务器\n\n### OAuth 2.0 授权码\n\n在 OAuth 2.0 授权码模式中，授权码是客户端在用户授权后从授权服务器获取的短期凭证，用于交换访问令牌。授权码是一个临时的字符串，可以在授权服务器和客户端之间传递以获得更安全的访问令牌。\n\n### OAuth 2.0 扩展\n\nOAuth 2.0 在发展过程中，为了适应不同的场景，发展出了众多的扩展，下表罗列出一些常用的扩展名称、主要功能及适用场景。\n\n| 扩展名称                                  | 主要功能                                             | 适用场景                                   |\n| ----------------------------------------- | ---------------------------------------------------- | ------------------------------------------ |\n| 授权码 PKCE 扩展                          | 提高授权码模式的安全性，防止授权码拦截攻击           | 公共客户端（如移动应用、单页应用）         |\n| 动态客户端注册协议                        | 允许客户端动态注册和更新客户端信息                   | 自动化和灵活性要求高的系统                 |\n| Token Introspection                       | 允许资源服务器验证和获取访问令牌的详细信息           | 需要验证令牌有效性和获取令牌详细信息的场景 |\n| Token Revocation                          | 提供令牌撤销的标准接口                               | 提高系统安全性和控制能力                   |\n| Device Authorization Grant                | 允许输入受限的设备通过其他设备完成身份验证           | 智能电视、游戏机等输入能力有限的设备       |\n| Mutual TLS Client Authentication          | 基于双向 TLS 的客户端认证                            | 高安全性要求的应用场景                     |\n| Resource Indicators                       | 允许客户端在授权请求中指定访问的资源服务器           | 多资源服务器的支持                         |\n| Step-up Authentication Challenge Protocol | 允许资源服务器按需请求更强的身份验证（如多因素认证） | 高风险操作的高级认证                       |\n\n### OAuth 2.0 授权流程（以 Github 为例）\n\nGitHub 使用 OAuth 2.0 来授权第三方应用访问用户的 GitHub 数据。OAuth 2.0 令牌在 GitHub 上被称为 \u0022access tokens\u0022，用于验证和授权访问 GitHub API。它提供了一种安全、标准化的方法，允许第三方应用在用户授权的情况下访问 GitHub 资源。通过使用访问令牌，应用程序可以代表用户执行各种操作，如读取用户信息、访问仓库、创建 gists 等。这个过程确保了用户的安全和隐私，同时简化了应用程序的认证和授权流程。\n\n以下是使用 GitHub OAuth 2.0 令牌的详细流程和示例：\n\n1. **用户授权**：用户在第三方应用程序的界面上点击“Login with GitHub”按钮。应用程序将用户重定向到 GitHub 的授权页面。\n   \n2. **获取授权码**：用户在 GitHub 授权页面上登录并同意授权，GitHub 会将用户重定向回应用程序，并在 URL 参数中附带一个授权码（authorization code）。\n   \n   示例：\n   \u0060\u0060\u0060\n   https:\/\/yourapp.com\/callback?code=AUTHORIZATION_CODE\n   \u0060\u0060\u0060\n   \n3. **交换访问令牌**：应用程序服务器使用授权码向 GitHub 的授权服务器请求访问令牌。\n   \n   请求示例：\n   \u0060\u0060\u0060bash\n   POST https:\/\/github.com\/login\/oauth\/access_token\n   Content-Type: application\/json\n   Accept: application\/json\n   \n   {\n     \u0022client_id\u0022: \u0022YOUR_CLIENT_ID\u0022,\n     \u0022client_secret\u0022: \u0022YOUR_CLIENT_SECRET\u0022,\n     \u0022code\u0022: \u0022AUTHORIZATION_CODE\u0022,\n     \u0022redirect_uri\u0022: \u0022https:\/\/yourapp.com\/callback\u0022\n   }\n   \u0060\u0060\u0060\n   \n4. **GitHub 返回访问令牌**：GitHub 验证请求并返回访问令牌。\n   \n   响应示例：\n   \u0060\u0060\u0060json\n   {\n     \u0022access_token\u0022: \u0022YOUR_ACCESS_TOKEN\u0022,\n     \u0022token_type\u0022: \u0022bearer\u0022,\n     \u0022scope\u0022: \u0022repo,gist\u0022\n   }\n   \u0060\u0060\u0060\n   \n5. **使用访问令牌访问资源**：应用程序使用获取的访问令牌访问 GitHub API。\n   \n   请求示例：\n   \u0060\u0060\u0060bash\n   curl -H \u0022Authorization: token YOUR_ACCESS_TOKEN\u0022 https:\/\/api.github.com\/user\n   \u0060\u0060\u0060\n   \n   响应示例：\n   \u0060\u0060\u0060json\n   {\n     \u0022login\u0022: \u0022github-user\u0022,\n     \u0022id\u0022: 1,\n     \u0022node_id\u0022: \u0022MDQ6VXNlcjE=\u0022,\n     \u0022avatar_url\u0022: \u0022https:\/\/github.com\/images\/avatar.jpg\u0022,\n     \u0022name\u0022: \u0022Github User\u0022,\n     \u0022company\u0022: \u0022GitHub\u0022,\n     \u0022blog\u0022: \u0022https:\/\/example.com\u0022,\n     \u0022location\u0022: \u0022Earth\u0022,\n     \u0022email\u0022: \u0022github-user@example.com\u0022\n   }\n   \u0060\u0060\u0060\n\n### 访问令牌的特点和使用\n\n1. **权限范围（Scopes）**：访问令牌的权限范围由用户在授权时指定，可以包括读取用户资料、访问用户仓库、管理 gists 等。例如，在上述示例中，\u0060scope\u0060 包含 \u0060repo\u0060 和 \u0060gist\u0060。\n   \n2. **有效期和刷新**：访问令牌的有效期可以是长期的也可以设置时间范围，直到用户主动撤销。\n   \n3. **安全传输**：访问令牌应通过 HTTPS 传输，以确保其不被截获。\n\n## mTLS\n\nmTLS（Mutual TLS）是一种在客户端和服务器之间进行双向身份验证的技术，最早起源于 TLS（传输层安全协议），TLS 的前身 SSL（安全套接层）协议于 1995 年由 Netscape 开发。随着互联网安全需求的增加，TLS 逐步发展为一个高度安全的通信标准，而 mTLS 则在此基础上进一步提升了安全性，通过要求双方互相验证身份，广泛应用于金融、医疗等对安全性要求极高的领域。\n\n下图展示的是 mTLS 认证流程。\n\n\u0060\u0060\u0060mermaid \u0022mTLS 认证流程\u0022\nsequenceDiagram\n    participant Client\n    participant Server\n\n    Client -\u003e\u003e Server: 客户端证书握手请求\n    Server -\u003e\u003e Client: 服务器证书握手请求\n    Client -\u003e\u003e Server: 验证服务器证书\n    Server -\u003e\u003e Client: 验证客户端证书\n    Client -\u003e\u003e Server: 双方握手成功，建立安全连接\n    Client -\u003e\u003e Server: 请求受保护资源\n    Server -\u003e\u003e Client: 返回受保护资源\n\u0060\u0060\u0060\n\n![mTLS 认证流程](6a1cea6c141bda005fd183e0200b0f15.svg)\n\nmTLS 认证流程说明：\n\n1. 客户端与服务器互相发送证书\n2. 双方验证对方证书\n3. 建立安全连接\n\n更多关于 TLS 和 mTLS 的内容请参考博客 [如何理解 Istio 中的 mTLS 流量加密](\/blog\/understanding-the-tls-encryption-in-istio\/#what-is-tls-and-mtls)。\n\n## Basic 认证 {#basic}\n\nBasic 认证是一种最早由 HTTP\/1.0 规范（RFC 1945）定义的简单认证机制，它通过将用户名和密码进行 Base64 编码后附加到 HTTP 请求头中进行身份验证。由于实现简单且易于使用，Basic 认证在早期的 Web 应用中被广泛采用。然而，由于其固有的安全性问题（如明文传输容易被截获），它在现代应用中通常与 HTTPS 一起使用，或被更安全的认证方式所替代。\n\n下图展示的是 Basic 认证流程。\n\n\u0060\u0060\u0060mermaid \u0022Basic 认证流程\u0022\nsequenceDiagram\n    participant User\n    participant Client\n    participant ResourceServer\n\n    User -\u003e\u003e Client: 提供用户名和密码\n    Client -\u003e\u003e ResourceServer: 请求受保护资源（带用户名和密码）\n    ResourceServer -\u003e\u003e Client: 验证用户名和密码\n    ResourceServer -\u003e\u003e Client: 返回受保护资源\n\u0060\u0060\u0060\n\n![Basic 认证流程](e6f9bd871c5b59988c0f251e4cc3af64.svg)\n\nBasic 认证流程说明：\n\n1. 用户提供用户名和密码\n2. 客户端带用户名和密码请求资源服务器\n3. 资源服务器验证\n\n### Basic 示例\n\nBasic 认证使用 Base64 编码的用户名和密码进行认证。下面是使用 \u0060curl\u0060 命令进行 Basic 认证请求的示例：\n\n\u0060\u0060\u0060bash\ncurl -u \u003cusername\u003e:\u003cpassword\u003e https:\/\/api.example.com\/data\n\u0060\u0060\u0060\n\n如果用户名为 \u0060admin\u0060，密码为 \u0060password123\u0060，请求示例如下：\n\n\u0060\u0060\u0060bash\ncurl -u admin:password123 https:\/\/api.example.com\/data\n\u0060\u0060\u0060\n\n## API Key 认证 {#api-key}\n\nAPI Key 认证是一种通过在请求中包含预先分配的唯一密钥来进行身份验证的方法，最早在 2000 年代初随着 Web API 的兴起而流行。API Key 认证由于其简单易用和便于管理的特性，被广泛应用于各种公共和私有 API 中。尽管它的安全性较低，容易被滥用，但在许多场景中仍然是控制访问的一种有效手段，特别是对于不需要高度安全保护的应用。\n\n下图展示的是 API Key 认证流程。\n\n\u0060\u0060\u0060mermaid \u0022API Key 认证流程\u0022\nsequenceDiagram\n    participant Client\n    participant ResourceServer\n\n    Client -\u003e\u003e ResourceServer: 请求受保护资源（带 API Key）\n    ResourceServer -\u003e\u003e Client: 验证 API Key\n    ResourceServer -\u003e\u003e Client: 返回受保护资源\n\u0060\u0060\u0060\n\n![API Key 认证流程](8865798e8d7aea6c02e9913b925b0b2b.svg)\n\nAPI Key 认证流程说明：\n\n1. 客户端带 API Key 请求资源服务器 \n2. 资源服务器验证 API Key\n\n### API Key 示例\n\nAPI Key 是在请求中传递的一个唯一标识符，用于验证客户端身份。API Key 通常通过 HTTP 请求头或 URL 参数传递。\n\nHTTP 请求头中的 API Key 示例：\n\n\u0060\u0060\u0060bash\ncurl -H \u0022Authorization: ApiKey YOUR_API_KEY\u0022 https:\/\/api.example.com\/data\n\u0060\u0060\u0060\n\nURL 参数中的 API Key 示例：\n\n\u0060\u0060\u0060bash\ncurl https:\/\/api.example.com\/data?api_key=YOUR_API_KEY\n\u0060\u0060\u0060\n\nAPI Key 格式通常是一个字符串，包含字母和数字，例如：\n\n\u0060\u0060\u0060\n1234567890abcdef1234567890abcdef\n\u0060\u0060\u0060\n\n## 总结\n\n在微服务架构中选择合适的认证方式至关重要。不同的认证方式在安全性、复杂性和适用场景上各有优劣。本文介绍了 JWT、OAuth 2.0、mTLS、Basic 认证和 API Key 认证五种常见的认证方式，并提供了它们的优缺点和适用场景。此外，其他常见的认证方式如 SAML、LDAP、Kerberos 和 OpenID Connect 也广泛应用于不同的互联网应用场景，特别是在单点登录和跨域认证方面。希望这些信息能帮助你在设计和实现微服务系统时选择最合适的认证方案。\n', '\/blog\/microservice-auth-methods\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文将介绍几种常见的微服务认证方式，帮助你在设计和实现微服务系统时选择合适的认证方案。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-ambient-mode-limitations/">Istio Ambient 模式的局限性解析</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/05/16</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio Ambient 模式的局限性解析', '深入探讨 Istio 1.22 版本中的 Ambient 模式，与传统 Sidecar 模式的对比及其限制。', '\n[Istio 1.22](https:\/\/istio.io\/latest\/news\/releases\/1.22.x\/announcing-1.22\/) 版本的发布标志着 Ambient 模式正式进入 beta 阶段，随之发布了一篇标题为 [告别 Sidecar：Istio 的 Ambient 模式在 v1.22 中达到 Beta](https:\/\/istio.io\/latest\/blog\/2024\/ambient-reaches-beta\/) 的博客，声称 Layer 4 和 Layer 7 的功能现已可用于生产环境。其实社区早在一个月前的 KubeCon EU 上就宣布了这一里程碑。这种激动人心的宣传似乎在暗示我们可以彻底抛弃 Sidecar 模式，但事实真是如此吗？\n\n### 为什么不急于告别 Sidecar 模式？\n\n虽然我对新技术持开放态度，但完全告别 Sidecar 模式可能为时尚早。每种模式都有其特定的应用场景和优缺点。下面，我将详细分享 Ambient 模式相较于 Sidecar 模式的一些限制，帮助大家更好地理解两者之间的差异。\n\n### Ambient 模式与 Sidecar 模式的关键区别\n\n#### 流量管理\n\nAmbient 模式的 L7 流量管理支持尚未成熟，尚未达到生产环境的可用水平。相较之下，Sidecar 模式在这方面更为稳定和可靠。\n\n#### 安全性\n\n在 Ambient 模式下，mTLS 被强制在 namespace 级别开启，而 Sidecar 模式则赋予用户更大的灵活性，可以选择是否启用 mTLS。这种灵活性对于某些应用场景尤为重要。\n\n#### 可观测性\n\n对于 L7 层的遥测数据，Ambient 模式能否像 Sidecar 模式一样对每个 pod 进行精确的监控和追踪仍是一个疑问。Sidecar 模式在可观测性方面已被广泛验证，其能力更为成熟。\n\n#### 运维\n\n部署方面，Ambient 模式推荐使用 Helm，仅支持 Kubernetes 平台，而 Sidecar 模式还支持虚拟机和混合云环境。此外，Ambient 模式尚未得到主要云厂商的官方支持。在升级过程中，Ambient 模式的爆炸半径更大，暂不支持金丝雀发布，推荐使用蓝绿部署。对于从 Sidecar 模式向 Ambient 模式的迁移或二者共存，仍缺乏最佳实践。\n\n#### 扩展性\n\n目前对于 Wasm 插件的支持，Ambient 模式仍不明确，而 Sidecar 模式在这方面已经有了较为完善的支持。\n\n#### 其他功能特性\n\nDual Stack 模式在 Sidecar 模式下虽然仍处于实验阶段，但至少已有一定的实现，而 Ambient 模式是否支持这一特性仍不明朗。\n\n### 总结\n\n虽然 Istio 1.22 带来了令人兴奋的 Ambient 模式，但在完全告别 Sidecar 模式之前，我们需要慎重考虑这些限制和差异。每种模式都有其独特的优势和适用场景，用户应根据自身需求做出明智的选择。我将继续对 Ambient 模式进行测试和追踪，更多深入解读敬请关注本博客。', '\/blog\/istio-ambient-mode-limitations\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">深入探讨 Istio 1.22 版本中的 Ambient 模式，与传统 Sidecar 模式的对比及其限制。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
          <div class="col-12">
 
 
 
 
 
 
 
 
 
 
 
 <nav aria-label="Page navigation">
   <ul class="pagination justify-content-center">
     
     
     <li class="page-item">
       <a class="page-link" href="/blog/">
         ««
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a href="/blog/page/2/" class="page-link">
         «
       </a>
     </li>
     
     
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item">
           <a href="/blog/" class="page-link">
             1
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item">
           <a href="/blog/page/2/" class="page-link">
             2
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item page-item active ">
           <a href="/blog/page/3/" class="page-link">
             3
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item">
           <a href="/blog/page/4/" class="page-link">
             4
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item">
           <a href="/blog/page/5/" class="page-link">
             5
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
     
     
     <li class="page-item">
       <a href="/blog/page/4/" class="page-link">
         »
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a class="page-link" href="/blog/page/25/">
         »»
       </a>
     </li>
     
   </ul>
 </nav>
 
</div>

        </div>
      </div>
      <!-- sidebar -->
      <aside class="col-lg-4 order-1 order-lg-2 d-none d-sm-block">
          <div class="sidebar">
          <!-- categories -->
<div class="blog-categories mb-4">
  <p class="sidebar-title">
      专栏
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/istio" class="sidebar-item">
            <span>Istio</span>
            <span>(69)</span>
        </a>
      
        <a href="/categories/service-mesh" class="sidebar-item">
            <span>Service Mesh</span>
            <span>(38)</span>
        </a>
      
        <a href="/categories/kubernetes" class="sidebar-item">
            <span>Kubernetes</span>
            <span>(24)</span>
        </a>
      
        <a href="/categories/%e9%9a%8f%e7%ac%94" class="sidebar-item">
            <span>随笔</span>
            <span>(20)</span>
        </a>
      
        <a href="/categories/%e4%b8%9a%e6%80%81" class="sidebar-item">
            <span>业态</span>
            <span>(17)</span>
        </a>
      
        <a href="/categories/%e5%85%b6%e4%bb%96" class="sidebar-item">
            <span>其他</span>
            <span>(17)</span>
        </a>
      
        <a href="/categories/envoy" class="sidebar-item">
            <span>Envoy</span>
            <span>(16)</span>
        </a>
      
        <a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f" class="sidebar-item">
            <span>云原生</span>
            <span>(13)</span>
        </a>
      
        <a href="/categories/ai" class="sidebar-item">
            <span>AI</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%ae%89%e5%85%a8" class="sidebar-item">
            <span>安全</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%bc%80%e6%ba%90" class="sidebar-item">
            <span>开源</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%8f%af%e8%a7%82%e6%b5%8b%e6%80%a7" class="sidebar-item">
            <span>可观测性</span>
            <span>(5)</span>
        </a>
      
        <a href="/categories/%e6%97%85%e8%a1%8c" class="sidebar-item">
            <span>旅行</span>
            <span>(4)</span>
        </a>
  </div>
</div>

<div class="blog-categories mb-4">
  <p class="sidebar-title">
      资料
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/%e5%87%ba%e7%89%88%e7%89%a9" class="sidebar-item">
            <span>出版物</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e7%94%b5%e5%ad%90%e4%b9%a6" class="sidebar-item">
            <span>翻译电子书</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e6%96%87%e6%a1%a3" class="sidebar-item">
            <span>翻译文档</span>
            <span>(7)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>翻译图书</span>
            <span>(6)</span>
        </a>
      
        <a href="/categories/%e5%8e%9f%e5%88%9b%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>原创图书</span>
            <span>(2)</span>
        </a>
      
        <a href="/categories/%e6%95%99%e7%a8%8b%e6%89%8b%e5%86%8c" class="sidebar-item">
            <span>教程手册</span>
            <span>(1)</span>
        </a>
  </div>
</div>





          </div>
      </aside>
      <!-- /sidebar -->
    </div>
  </div>
</section>




<footer>
  
  <div class="footer bg-footer section-sm border-bottom overlay ">
    <div class="container-xl">
      <div class="row">
        <div class="col col-xl-4 d-sm-none mb-2 mb-lg-0 d-xl-block d-none">
          
          <p class="h3 text-white mb-4 text-uppercase">联系</p>
          
          <ul class="list-unstyled">
            
            
            <li class="mb-4 text-color">微信公众号</li>
            
            
            <li class="mb-4"><img src="/images/servicemesher-wechat.webp" width="118px" height="118px" alt="footer image"></li>
            
            
            
          
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">博客</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/blog/envoy-gateway-integration-istio-mesh/">集成 Envoy Gateway 作为 Istio 服务网格中的入口网关</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/istio-configuration-safety-common-misconfigurations/">Istio 配置安全：如何避免错误配置</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/securing-istio-addressing-critical-security-gaps-and-best-practices/">保障 Istio 安全：解决关键安全漏洞及最佳实践</a></li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">链接</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://istio.io/latest/zh/" target="_blank" rel="noopener noreferrer">
                  Istio 服务网格
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://tetrate.io/?jimmysong" target="_blank" rel="noopener noreferrer">
                  Tetrate 公司
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener noreferrer">
                  云原生学院|Bilibili
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/awesome-cloud-native/" target="_blank" rel="noopener noreferrer">
                  云原生开源项目大全
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://cloudnative.to" target="_blank" rel="noopener noreferrer">
                  云原生社区（中国）
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">教程</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/envoy-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Envoy 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/istio-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Istio 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/kubernetes-handbook/" >
                  Kubernetes 基础教程
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">通知</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/notice/kubecon-china-2024-panel/">KubeCon China 2024（香港）</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/website-revamp-notice/">网站改版通知</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/cloud-native-meetup-dalian-2024/">2024 大连云原生技术开放日</a></li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>

  
  <div class="copyright py-4 bg-footer overlay">
    <div class="container-xl">
      <div class="row">
        <div class="col-sm-6 text-sm-left text-center">
          <p class="mb-0 text-color">© 2017-2024 Jimmy Song 保留所有权利</p>
        </div>
        <div class="col-sm-6 text-sm-right text-center">
          <ul class="list-inline">
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://twitter.com/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-x-twitter text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/contact/" >
                    <i class="fa-brands fa-weixin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://github.com/rootsongjc" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-github text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://linkedin.com/in/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-linkedin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="mailto:rootsongjc@gmail.com" >
                    <i class="fa-solid fa-envelope text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/blog/index.xml" >
                    <i class="fa-solid fa-rss text-white"></i>
              </a>
            </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>


<!-- JS Plugins -->

<script src="/plugins/popper/popper.min.js"></script>

<script src="/plugins/bootstrap/bootstrap.min.js"></script>

<script src="/plugins/slick/slick.min.js"></script>

<script src="/plugins/filterizr/jquery.filterizr.min.js"></script>

<script src="/plugins/search/fuse.min.js"></script>

<script src="/plugins/search/mark.js"></script>

<script src="/plugins/hex_md5/hex_md5.js"></script>

<script src="/plugins/anchor/anchor.min.js"></script>

<script src="/plugins/tocbot/tocbot.min.js"></script>

<script src="/plugins/bigger-picture/bigger-picture.min.js"></script>


<!-- Main Script -->

<script src="/js/script.min.f94c22b1d478bfc9e2e0a7d954429e47b7e6d36edd423758482e04154ae1842e.js"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-ESY906ZWZ0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ESY906ZWZ0');
</script>


<!-- Baidu analysis -->
<meta name="baidu-site-verification" content="g8IYR9SNLF" />


<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?11f7d254cfa4e0ca44b175c66d379ecc";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>




<script>
    anchors.add();
</script>






<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>










<script src="/js/wowchemy-search.min.7a37268e7bbe4a9160c2e4c33b749816.js" type="module"></script>
<script id="search-hit-fuse-template" type="text/x-template">
  <div class="search-hit" id="summary-{{key}}">
    <div class="search-hit-content border-bottom">
      <div class="search-hit-name">
        <div class='search-hit-link'><a href="{{relpermalink}}">{{title}}</a></div>
        <div class="search-hit-metadata d-flex">
            <span class="mr-1"><i class="fa-regular fa-calendar mr-1"></i>{{date}}</span>
            <span class="mr-1"><i class="fa-regular fa-folder-open mr-1"></i>{{section}}</span>
            <span class="d-sm-block d-none"><i class="fa-solid fa-link mr-1"></i>{{relpermalink}}</span>
        </div>
        <div class="search-hit-description">{{snippet}}</div>
      </div>
    </div>
  </div>
</script>



    </body>
</html>
