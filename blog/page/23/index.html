<!DOCTYPE html>
<html lang="zh"><head>
  <meta charset="utf-8">
  
  <title>博客 - Jimmy Song</title>
  

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta name="description" content="专注开源技术、云原生与生活随笔的分享与思考。">
  <meta name="author" content="Jimmy Song">
  <meta name="generator" content="Hugo 0.136.0">

  <!-- CSS plugins -->
  
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
  
  <link rel="preload" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" as="style">
  <link rel="stylesheet" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" media="screen">
  

  <!-- Main Stylesheet -->
  
  <link rel="preload" href="/scss/style.min.f6911c0ac7d2b5b69c3f2d9f2a2b3b496b5da0608580347fdb4dc11ef74f3ec5.css" as="style">
  <link rel="stylesheet" href="/scss/style.min.f6911c0ac7d2b5b69c3f2d9f2a2b3b496b5da0608580347fdb4dc11ef74f3ec5.css" media="screen">

  <!-- Bigger picture css -->
  
  <link rel="stylesheet" href="/plugins/bigger-picture/bigger-picture.min.css" media="print" onload="this.media='all'">
  <!--Favicon generate by https://realfavicongenerator.net-->
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="200x200" href="/images/favicon.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">

  <link href='/opensearchdescription.xml' rel='search' title='Content search' type='application/opensearchdescription+xml'/>

  <!--Twitter card-->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="jimmysong.io" />
  <meta name="twitter:creator" content="@jimmysongio" />
  <meta property="og:url" content="https://jimmysong.io/blog/" />
  <meta property="og:title" content="博客 | Jimmy Song" />
  <meta property="twitter:title" content="博客 | Jimmy Song" />

  
  <meta property="og:description" content="专注开源技术、云原生与生活随笔的分享与思考。" />
  <meta property="twitter:description" content="专注开源技术、云原生与生活随笔的分享与思考。" />

  
  <meta property="og:image" content="https://jimmysong.io/images/banner/default.jpg" />
  <meta property="twitter:image" content="https://jimmysong.io/images/banner/default.jpg" />

  
  
</head>
<body>
<header class="fixed-top header">
  
  
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa fa-arrow-circle-up" aria-hidden="true"></i></button>
  
  <div class="navigation w-100 ">
    <div class="container-xl">
      <nav class="navbar navbar-expand-lg navbar-light p-0">
        <a class="navbar-brand" href="/">
            
            <b>JIMMY SONG</b>
            
        </a>
        <button class="navbar-toggler rounded-0" type="button" data-toggle="collapse" data-target="#navigation"
          aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse text-center" id="navigation">
          <ul class="navbar-nav ml-auto">
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/blog">博客</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/book">资料</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/tags">标签</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/notice">公告</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/contact">联系</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/about">关于</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/community/">社区</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener">视频 <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i></a>
              
            </li>
            
            

          
          
          <li class="nav-item">
            
            
            
              
              
                
                
                
                  
                    
                    <a class="nav-link" href="/en/blog/">English</a>
                    
                  
                
              
              
              
                
                  
                    
                    
                  
                
                
                
              
          </li>
          
          
          <!-- search -->
           <button type="button" class="search-btn js-search" id="searchOpen" aria-label="Search">
              <div class="search-container d-flex justify-content-center">
              <span class="search-content">
                  <i class="fa fa-search"></i>
                  <span>搜索</span>
              </span>
              <span class="search-shortcuts d-none d-sm-block">
                  <kbd class="cmd-key">⌘</kbd>
                  <kbd class="k-key">K</kbd>
              </span>
              </div>
          </button>
          
          </ul>
        </div>
      </nav>
    </div>
  </div>
</header>


            <aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between">
        <div class="col-6 search-title">
          <p>站内搜索</p> 
        </div>
        <div class="col-6 col-search-close">
          <div class="js-search" aria-label="关闭"><i class="fa-solid fa-circle-xmark text-muted" aria-hidden="true"></i></div>
        </div>
      </div>

      <div id="search-box">
        <i class="fa-solid fa-magnifying-glass" id="search-icon" aria-hidden="true"></i>
        <input name="q" id="search-query" placeholder="请输入搜索词" autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control" aria-label="请输入搜索词">
        
        <div class="mt-4">
          <span>搜索类型: </span>
          <span>
            <input type="radio" id="all" name="search_type" value="all" checked>
            <label for="all">所有</label>
            
              <input type="radio" id="blog" name="search_type" value="blog">
              <label for="blog">原创</label>
              <input type="radio" id="trans" name="search_type" value="trans">
              <label for="trans">译文</label>
            
            <input type="radio" id="book" name="search_type" value="book">
            <label for="book">资料</label>
            <input type="radio" id="notice" name="search_type" value="notice">
            <label for="notice">公告</label>
          </span>
        </div>
      </div>
      
    </section>
    <section class="section-search-results">
      <div id="search-results-count" class="search-results-count"></div>
      <div id="search-hits">
        
      </div>
    </section>
  </div>
</aside>

        
        
            

<section class="bg-cover page-title-section overlay" style="background-image: url('/images/backgrounds/circle.svg'),url('/images/backgrounds/page-title.webp');background-size: cover;">
    <div class="container-xl">
        <div class="row">
            <div class="col-12">
                <p class="h1">
                    博客
                </p>
                <p class="page-description">
                    专注开源技术、云原生与生活随笔的分享与思考。
                </p>
                
            </div>
        </div>
    </div>
</section>

        


<section class="section-sm book-list-section bg-gray">
  <div class="container-xl">
    <div class="row">
      <div class="col-lg-8 order-2 order-lg-1">
        <div class="row">
          
          
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-vm-odysssey/">Istio 对虚拟机支持史话</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2020/12/25</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio 对虚拟机支持史话', '本文将为你介绍 Istio 历史上对虚拟机负载的支持情况，尤其是 Istio 1.8 中引入的智能 DNS 代理及 WorkloadGroup 使得虚拟机与容器在资源抽象层面可以等同视之。我将为你展现一幅 Istio 支持虚拟机的波澜壮阔的奥德赛。', '\n本文将为你介绍 Istio 历史上对虚拟机负载的支持情况，尤其是 Istio 1.8 中引入的智能 DNS 代理及 \u0060WorkloadGroup\u0060 使得虚拟机与容器在资源抽象层面可以等同视之。我将为你展现一幅 Istio 支持虚拟机的波澜壮阔的奥德赛。\n\n## 前言\n\n在我[之前的博客](https:\/\/thenewstack.io\/how-to-integrate-virtual-machines-into-istio-service-mesh\/)中谈到 Istio 1.7 如何支持虚拟机，但那时虚拟机仍然无法无缝的集成到 Istio 中，因为还需要做很多手动的操作。现在，Istio 1.8 新增了 WorkloadGroup 及[智能 DNS 代理](https:\/\/istio.io\/latest\/blog\/2020\/dns-proxy\/)，这使得如虚拟机这样的非 Kubernetes 工作负载可以在 Istio 中成为像 Pod 一样的一等公民。\n\n不论有没有为虚拟机安装 sidecar，虚拟机通常情况下无法直接访问 Kubernetes 集群中的 DNS 服务器以解析 Kubernetes  服务的 Cluster IP 的（虽然你也许可以通过一些黑客的手段做到），这是在 Istio 中集成虚拟的最后一块短板，终于在 Istio 1.8 中完成了突破。\n\n## 为什么要支持虚拟机？\n\n在我们将应用在迁移到云原生架构，不断容器化的过程中，将经历三个阶段，如下图所示。\n\n![云原生应用的三个阶段](0081Kckwly1gm0d6t775lj31s80k8go8.jpg)\n\n- 阶段一：应用全部部署在虚拟机上\n- 阶段二：应用既部署在虚拟机上也部署在容器里，正在从虚拟机向容器中迁移，并使用 Kubernetes 管理容器\n- 阶段三：所有的应用优先部署在容器里，使用 Kubernetes 管理容器，使用 Istio 管理应用间的通信\n\n上图仅是对以上三个阶段的最简化描述，实际上还会有多混合云、多机房、多集群等情况，且阶段三只是个理想化的阶段，容器和虚拟机将是长期共存的，但是容器化趋势不变。\n\n在阶段二中，人们通常会将新业务和少量应用率先实现容器化，并部署到 Kubernetes 中，在应用尚未完全实现容器化的时候，处于过度状态时会遇到很多问题，如何让应用与部署在虚拟机中的服务交互？虚拟机如何访问容器中的服务？在服务迁移的过程中如何保证稳定无缝？是否可以将容器和虚拟机纳入一个统一的控制平面来管理？Istio 从开源初期就考虑并着手解决这一问题。\n\n## Istio 支持虚拟机的历史\n\nIstio 对于虚拟机的支持是个漫长的过程，堪称是一部奥德赛。\n\n### Istio mesh 扩张\n\nIstio 从 0.2 版本开始通过 [Istio Mesh Expansion](https:\/\/istio.io\/v0.2\/docs\/setup\/kubernetes\/mesh-expansion.html) 将虚拟机加入的 Mesh 中，但是需要满足以下前提条件：\n\n- 虚拟机必须可以通过 IP 地址直接访问到应用的 Pod，这就要求容器与 VM 之间通过 VPC 或者 VPN 建立扁平网络，虚拟机不需要访问 Cluster IP，直接对服务的 Endpoint 端点访问即可。\n- 虚拟机必须可以访问到 Istio 的控制平面服务（Pilot、Mixer、CA，现在已正整合为 Istiod），可以通过在 Istio Mesh 中部署负载均衡器将控制平面端点暴露给虚拟机。\n- （可选）虚拟机可以访问到 Mesh 内部的（部署在 Kubernetes 中）的 DNS server。\n\n集成虚拟机的步骤如下：\n\n1. 为 Istio 控制平面服务及 Kubernetes 集群的 DNS 服务创建 Internal 负载均衡器；\n2. 生成 Istio Service CIDR、Service Account token、安全证书、Istio 控制平面服务的 IP（通过 Internal 负载均衡器暴露出来的 IP）的配置文件并发送给虚拟机；\n3. （可选）在虚拟机中安装、配置并启动 Istio 的组件、dnsmaq（用于 DNS 发现），此时虚拟机可以使用   FQDN 访问 mesh 中的服务了，这一步是为了保证虚拟机可以正确解析出 mesh 中服务的 Cluster IP；\n4. 若要在虚拟机中运行服务，需要配置 sidecar，新增需要拦截的 inbound 端口，然后重启 istio，还需要运行 istioctl 为服务注册\n\n下图展示的从集成虚拟机到在 mesh 中访问虚拟机中服务的详细流程。\n\n![图一：从集成虚拟机到在 mesh 中访问虚拟机中服务的详细流程](0081Kckwly1gm0d6rogojj30u00yhdil.jpg)\n\n1. DNS 被虚拟机中部署的 \u0060dnsmasq\u0060 劫持，这使得它可以正确的获取 Istio 服务、Kubernetes 内置 DNS 的端点 IP；\n2. 访问 Kubernetes 的内置 DNS 服务（该服务已通过 Internal 负载均衡器暴露到集群外，可以直接访问）；\n3. 返回 \u0060productpage.bookinfo.svc.cluster.local\u0060 被解析出来的 Cluster IP，注意该 IP 地址无法直接访问，但是如果无法被 DNS 解析的话将导致 VM 对该服务的请求失败；\n4. 虚拟机对 mesh 中服务的访问被 sidecar proxy 劫持；\n5. 因为 proxy 已连接 Istio 控制平面，可通过 xDS 查询到该服务的端点，因此流量将被转发到其中的一个端点。\n6. 要想在 mesh 中访问 VM 中的服务，需要使用 \u0060istioctl register\u0060 命令手动将 VM 中的服务添加到 mesh 中，这本质上是将 VM 中的服务，注册到 Kubernetes 中的 service 和 endpoint；\n7. mesh 中的服务可以使用 VM 注册的服务名称（FQDN，例如 \u0060mysql.vm.svc.cluster.local\u0060）来访问；\n\n以上 Istio 对虚拟机支持的方式一直延续到 Istio 1.0，在 Istio 1.1 的时候引入了新的 API [ServiceEntry](https:\/\/istio.io\/latest\/docs\/reference\/config\/networking\/service-entry\/)，使用它可以在 Istio 的内部服务注册表中添加额外的条目，这样 mesh 中的服务就可以访问\/路由到这些手动指定的服务了，不再需要运行 \u0060istioctl register\u0060 命令，而且该命令在 Istio 1.9 中将被废弃。\n\nIstio 1.5 中增加了 \u0060istioctl experimental add-to-mesh\u0060 命令，可以将虚拟机中的服务添加到 mesh 中，其功能与 \u0060istioctl register\u0060 一样。\n\n### 新增资源抽象\n\nIstio 从 [1.6 版本](https:\/\/istio.io\/latest\/news\/releases\/1.6.x\/announcing-1.6\/)开始在[流量管理](https:\/\/istio.io\/latest\/news\/releases\/1.6.x\/announcing-1.6\/change-notes\/)中引入了新的资源类型 [WorkloadEntry](https:\/\/istio.io\/latest\/docs\/reference\/config\/networking\/workload-entry\/)，用以将虚拟机进行抽象，使得虚拟机在加入 mesh 后可以作为与 Kubernetes 中的 Pod 等同的负载，具备流量管理、安全管理、可视化等能力。通过 \u0060WorkloadEntry\u0060 可以简化虚拟机的网格化配置过程。\u0060WorkloadEntry\u0060 对象可以根据服务条目中指定的标签选择器选择多个工作负载条目和 Kubernetes pod。\n\nIstio 1.8 中增加了 [\u0060WorkloadGroup\u0060](https:\/\/istio.io\/latest\/docs\/reference\/config\/networking\/workload-group\/) 的资源对象，它提供了一个规范，可以同时包括虚拟机和 Kubernetes 工作负载，旨在模仿现有的用于 Kubernetes 工作负载的 sidecar 注入和部署规范模型来引导 Istio 代理。\n\n下面是虚拟机与 Kubernetes 中负载的资源抽象层级对比。\n\n| 对比项         | Kubernetes | 虚拟机        |\n| -------------- | ---------- | ------------- |\n| 基础调度单位   | Pod        | WorkloadEntry |\n| 编排组合       | Deployment | WorkloadGroup |\n| 服务注册与发现 | Service    | ServiceEntry  |\n\n从上面的图表中我们可以看到，对于虚拟机工作负载是可以与 Kubernetes 中的负载一一对对应的。\n\n此时看似一切都比较完美了，但是直接将 Kubernetes 集群中的 DNS server 暴露出来会带来很大的[安全风险](https:\/\/blog.aquasec.com\/dns-spoofing-kubernetes-clusters)，因此我们一般手动将虚拟机需要访问的服务的域名和 Cluster IP 对写到本机的 \u0060\/etc\/hosts\u0060 中，但是对于一个节点数量庞大的分布式集群来说，这种做法又有些不现实。\n\n通过配置虚拟机本地 \u0060\/etc\/hosts\u0060 访问 mesh 内服务的流程，如下图所示。\n\n![图二：通过配置虚拟机本地 \/etc\/hosts 访问 mesh 内服务的流程](0081Kckwly1gm0d6qx2o0j30sq0v440v.jpg)\n\n1. 将虚拟机中的服务注册到 mesh 中；\n2. 将要访问的服务的域名、Cluster IP 对手动写入虚拟机本地的 \u0060\/etc\/hosts\u0060 文件中；\n3. 虚拟机获得访问服务的 Cluster IP；\n4. 流量被 sidecar proxy 拦截并解析出要访问的服务的端点地址；\n5. 访问服务的指定端点；\n\n在 Kubernetes 中我们一般使用 Service 对象来实现服务的注册和发现，每个服务都有一个独立的 DNS 名称，应用程序可以使用服务名称来互相调用。我们可以使用 ServiceEntry 将虚拟机中的服务注册到 Istio 的服务注册表中，但是在 Kubernetes 集群中的 DNS server 无法对 mesh 外部暴露的情况下，虚拟机无法访问 Kubernetes 集群中的 DNS 服务以获取服务的 Cluster IP，从而导致虚拟机访问 mesh 中的服务失败。如果能在虚拟机中增加一个 sidecar 可以透明地拦截 DNS 请求，可获取 mesh 内所有服务的 ClusterIP，类似于图一中的 \u0060dnsmasq\u0060 的角色，这样不就可以解决问题了吗？\n\n### 智能 DNS 代理\n\nIstio 1.8 中引入了[智能 DNS 代理](https:\/\/cloudnative.to\/blog\/istio-dns-proxy\/)，虚拟机访问 mesh 内服务无需再配置 \u0060\/ect\/hosts\u0060，如下图所示。\n\n![图三：引入了智能 DNS 代理后虚拟机访问 mesh 内服务的流程](0081Kckwly1gm0d6sgfpxj30oi0rsjt5.jpg)\n\nDNS proxy 是用 Go 编写的 Istio sidecar 代理。Sidecar 上的 Istio agent 将附带一个由 Istiod 动态编程的缓存 DNS 代理。来自应用程序的 DNS 查询会被 pod 或 VM 中的 Istio 代理透明地拦截和服务，该代理会智能地响应 DNS 查询请求，可以实现虚拟机到服务网格的无缝多集群访问。\n\n至此，Istio 1.8 中引入的 WordloadGroup 及智能 DNS 代理，补足了 Istio 对虚拟机支持的最后一块短板，使得部署在虚拟机中的遗留应用可以跟 Kubernetes 中的 Pod 一样完全等同看待。\n\n## 总结\n\n在这部 Istio 支持虚拟机的奥德赛中，我们可以看到：从最初的将 mesh 中的 DNS server 暴露给外部，在虚拟机中安装配置 \u0060dnsmasq\u0060，到最后的使用智能 DNS 代理，并使用 \u0060WorkloadEntry\u0060、\u0060WorkloadGroup\u0060 和 \u0060ServiceEntry\u0060 等资源抽象，逐步实现了虚拟机和 pod 的统一管理。本文仅仅是针对单集群的情况，在实际的生产中使用还远远不够，我们还需要处理安全、多集群、多租户等诸多问题，欢迎关注 Tetrate 的旗舰产品 [Tetrate Service Bridge](https:\/\/www.tetrate.io\/tetrate-service-bridge\/) 了解更多关于 Istio 应用在生产上的最佳实践。\n', '\/blog\/istio-vm-odysssey\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文将为你介绍 Istio 历史上对虚拟机负载的支持情况，尤其是 Istio 1.8 中引入的智能 DNS 代理及 WorkloadGroup 使得虚拟机与容器在资源抽象层面可以等同视之。我将为你展现一幅 Istio 支持虚拟机的波澜壮阔的奥德赛。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/rbac-vs-abac/">[译] RBAC vs ABAC，两者有何异同？</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2020/12/25</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e5%85%b6%e4%bb%96"> 
             其他
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('RBAC vs ABAC，两者有何异同？', '本文主要研究了 RBAC 和 ABAC 这两种访问能控制之间的异同。', '\n在任何公司，网络用户必须经过认证和授权，才能访问系统中可能导致安全漏洞的部分。获得授权的过程称为访问控制。在本指南中，我将讨论管理系统访问控制的两种主要方法 —— 基于角色的访问控制（RBAC）和基于属性的存取控制（ABAC）它们的差异，以及使用访问权限管理工具的重要性。\n\n## 认证和授权\n\n安全的两个基本方面是认证和授权。在您输入凭证登录电脑或登录应用程序或软件后，设备或应用程序会进行身份验证，以确定您的授权级别。授权可能包括您可以使用哪些账户，您可以访问哪些资源，以及允许您执行哪些功能。\n\n## 基于角色的访问控制（RBAC）与基于属性的访问控制（ABAC）\n\n基于角色的访问控制（RBAC）和基于属性的访问控制（ABAC）是控制认证过程和授权用户的两种方法。RBAC 和 ABAC 之间的主要区别是 RBAC 基于用户角色提供对资源或信息的访问，而 ABAC 基于用户、环境或资源属性提供访问权限。从本质上讲，当考虑 RBAC 与 ABAC 时，RBAC 控制整个组织的广泛访问，而 ABAC 则采取细粒度的方法。\n\n### 什么是 RBAC？\n\n![](0081Kckwly1gm04pyv4mtj30sg0ewgmd.jpg)\n\nRBAC 是基于角色的，所以根据你在组织中的角色而拥有不同的访问权限。这是由管理员决定的，管理员会设置一个角色应该拥有的访问权限，以及用户与角色的对应关系。例如，有的用户可能被分配到一个角色，可以编辑特定的文件，而其他用户可能被限制在一个角色中，只能读取该文件而不能编辑。\n\n用户与角色是一对多的关系，这使得用户拥有可以访问许多不同的文件或能力。比如说有一个团队在做一个大型项目。项目经理可以访问和编辑所有的文件，而开发团队可能只被允许访问代码文件，而无法看到或编辑项目的财务和员工信息。人力资源或管理团队可以访问所有的员工和财务信息，而不能访问编程文件。\n\n组织可能会将 RBAC 用于这样的项目，因为有了 RBAC，不需要在每次一有人离职或更换岗位时都进行更改：他们可以简单地从角色组中删除或分配一个新的角色。这也意味着新员工可以根据他们所履行的组织角色，相对快速地被授予访问权限。\n\n### 什么是 ABAC？\n\n![](0081Kckwly1gm04qu9t1ej30sg0ewq3m.jpg)\n\n基于属性的访问控制利用了一组称为“属性“的特征。这包括**用户属性**、**环境属性**和**资源属性**。\n\n- 用户属性包括用户的姓名、角色、组织、ID 和安全许可等内容。\n- 环境属性包括访问时间、数据的位置和当前组织的威胁等级。\n- 资源属性包括诸如创建日期、资源所有者、文件名和数据敏感性。\n\n基本上，ABAC 比 RBAC 有更多可能的控制变量。ABAC 的实施是为了降低因未经授权的访问而产生的风险，因为它可以在更细粒度地控制安全和访问。例如，ABAC 可以对他们的访问进行进一步的限制，比如只允许在特定的时间或与相关员工相关的某些分支机构进行访问，而不是让人力资源部门的人员总是能够访问员工和工资信息。这样可以减少安全问题，也可以帮助以后的审计过程。\n\n### RBAC 与 ABAC 的比较\n\n一般来说，有 RBAC 就足够了，应该在设置 ABAC 优先考虑使用它。这两个访问控制过程都是过滤器，ABAC 是两个过程中比较复杂的，需要更多的处理能力和时间。如果你不需要，就没有必要使用这种更强大的过滤器 —— 这会产生相应的资源成本。\n\n无论哪种方式，使用最少数量的 RBAC 和 ABAC 过滤器来构建你的访问和安全环境是很重要的。它可以帮助仔细规划你的目录数据和访问方法，以确保你没有使用不必要的过滤器或使事情过于复杂。在许多情况下，RBAC 和 ABAC 可以分级地一起使用，广泛的访问由 RBAC 协议执行，更复杂的访问由 ABAC 管理。这意味着系统将首先使用 RBAC 来确定谁可以访问一个资源，然后由 ABAC 来确定他们可以对资源做什么以及何时可以访问。\n\n## 使用访问管理工具\n\n无论你是使用 RBAC 还是 ABAC，或者是两者的结合，我都强烈建议使用访问权限管理工具。一个好的工具可以简化设置并减少设置和管理过滤器所涉及的管理费用。当涉及到安全问题时，认真规划和监控您的访问控制流程是至关重要的。使用强大的访问管理工具来帮助您设置访问控制，并定期审查您的设置，以确保它仍然符合您的组织需求。\n', '\/trans\/rbac-vs-abac\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文主要研究了 RBAC 和 ABAC 这两种访问能控制之间的异同。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/problem-with-rbac/">[译] 基于角色的访问控制（RBAC）存在的问题</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2020/12/25</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e5%85%b6%e4%bb%96"> 
             其他
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('基于角色的访问控制（RBAC）存在的问题', '本文主要讲述了 RBAC 面临的主要挑战。', '\n直到最近，最流行的授权方法是基于角色的访问控制（RBAC）。这种解决方案涉及到创建一套角色，定义组织内所有的工作描述和功能，然后给用户分配角色，决定他们可以访问的内容（例如，文件、网络、应用程序、网页上的一个字段），以及他们可以执行的操作。\n\n当使用 RBAC 时，系统管理员可以控制用户可以对特定的 IT 资源做什么，以及他们可以访问哪些区域。它的实现很简单，因为只有三个基本原则需要牢记，角色是基于“角色分配”、“角色授权“和“权限授权“的。然而，RBAC 并非没有问题和局限性。其中一个主要问题是，它不是一个自动的过程，这意味着它需要进行艰苦的管理，并且经常涉及大量的人工干预。\n\n例如，假设你的组织结构图已经和你的员工名单以及他们的头衔一起最终确定，你已经准备好推出你的 RBAC 计划。你已经把所有的角色摆在你面前，你很自信，他们都有明确的定义，并且有正确的汇报线和控制范围。突然间，市场部副总裁提到，他们部门里有一些人需要访问某些资源、共享文件夹和专门的应用程序，而这些资源和应用程序只有其他部门的角色才能使用。你不能对副总裁说“不”，所以你检查已有的映射，并试图找到一组额外的符合要求的角色。但这并不容易，因为没有完全匹配的角色。那么你要做什么呢？创建一个额外的角色，然后把它应用到所有有类似需求的员工身上就行了？通常情况下，这可能是你唯一的选择，因为根据内部安全政策，拆分现有角色可能是严格禁止的，因为这样做会削弱 RBAC 模型的有效性。\n\nRBAC 在管理用户身份和访问权限上存在根本性缺陷。其固有的弱点在于它的笨重性、对人工输入的依赖性以及需要持续维护。动态的组织需要动态的访问控制。所有这些因素结合在一起，形成了一个不安全的 IAM 结构。\n\n“大多数基于角色的访问控制项目失败的原因是缺乏基础，“PeaceHealth 的 Christopher Paidhrin 说。“每个组织都需要评估他们是否为基于角色的访问做好了准备。有效的基于角色的访问管理需要做很多工作，在能够有效管理之前，还有很多工作需要进入分析过程”。\n\n我们来看看 RBAC 的主要挑战。\n\n## 问题 1：角色爆炸\n\n如果营销副总裁的访问请求场景听起来很熟悉，那是因为它经常发生。当您的访问控制所需的颗粒度过于详细时，就会发生角色爆炸。角色爆炸很难管理，成本很高，并且使访问控制变得混乱和复杂，降低了访问控制的有效性。此外，当在你的访问控制部署中添加更多的角色时，还有一些其他的问题需要仔细监控。其中一个问题是，当一个用户被分配了太多的角色，然后在公司内部改变了工作或职责时，就会出现这样的问题。IT 系统管理员要么忘记了，要么甚至有意识地决定将旧角色留在原地。角色的数量会导致安全漏洞，而这些漏洞往往难以发现和弥补。\n\n## 问题 2：安全风险承受能力\n\n作为一个系统管理员，了解系统的风险是很重要的。进行安全风险分析，并制定积极的风险防范计划，对 RBAC 的部署至关重要。RBAC 是以数据为中心的；数据被归类为与组织结构相关的数据，这就导致了访问控制角色的定义。如果你的组织对安全风险是被动的，RBAC 可能不是保障网络数据访问安全的最佳方式。**RBAC 要求你在部署前对公司的安全布局和权限授予方式有深入的了解。** 一旦部署后，很难对不断变化的安全威胁和风险做出反应。因此，要小心谨慎，并对您的 RBAC 政策进行“两次测量，一次切割”。在一个由于数据隐私和保护法规不断变化而对安全有效性进行更严格审查的时代，这种安全模式的淡化大大增加了数据泄露的风险，在财务和声誉上都会产生重大后果。\n\n## 问题 3：可扩展性和动态性\n\n是的，在 RBAC 部署之初，你清楚地知道你需要定义哪些角色，以及需要将它们分配给谁。但是，现在已经过了一年，组织已经成长了。更多的人加入了公司，在匆匆忙忙的入职过程中，组织结构图和工作定义没有得到更新或明确定义。\n\n这就是 RBAC 难以维护和管理的地方。这些“死角“限制了你的部署的可扩展性，可能需要重新设计才能回到正轨。更糟糕的是，由于潜在的时间压力，你可能需要实施一个“变通“的解决方案，从长远来看，它可能会助长问题，而不是纠正它。几乎就像一个 IAM whac-a-mole 游戏，你要不断解决新的问题。\n\n这更多的时候是每两到三年一次的重大返工周期，如果有的话，是为了弥补角色分类学缺乏增量管理，以符合组织结构的变化需求，而组织结构仍然是动态的、反应性的，因为它必须对客户的需求和数字世界中更敏捷的业务模式做出反应。\n\n## 问题 4：成本高、实施难\n\n您的公司已经使用计算机并收集数据很长时间了，但从未真正需要任何形式的访问控制作为组织安全政策的一部分。如果你需要堵住漏洞，并决定采用 RBAC，你可能会发现需要复制服务器和其他支持 RBAC 的基础设施，成本过高，增加了复杂性。你还需要考虑在淘汰旧系统的同时将用户迁移到新系统的成本和风险。大多数情况下，迁移会遇到各种困难和不可预见的挑战，并导致两个系统中的安全漏洞以及其他代价高昂的缺陷，如计划外停机和数据丢失。\n\n## 集成 RBAC，实现稳健灵活的访问控制\n\n如果你从来没有计划重新分配员工或与合作伙伴合作，RBAC 本身就是一种管理数据和系统资源访问的好方法。然而，没有一个组织结构是一成不变的，这使得 RBAC 方法在一个动态的商业环境中变得很麻烦。我们经常看到公司在他们的人力资源系统、Active Directory 和 IGA 之间建立集成，以实现同步的角色创建和持续的角色生命周期管理。这些集成不仅昂贵，而且脆弱，难以维护，最终不能产生预期的结果。\n\n但并非所有的希望都落空了。将 RBAC 与其他类型的访问控制方法集成，可以让您创建一个强大的、精细的访问控制策略。\n', '\/trans\/problem-with-rbac\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文主要讲述了 RBAC 面临的主要挑战。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/why-rbac-is-not-enough-for-kubernetes-api-security/">[译] 为什么 RBAC 不足以保障 Kubernetes 的安全？</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2020/12/17</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/kubernetes"> 
             Kubernetes
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('为什么 RBAC 不足以保障 Kubernetes 的安全？', '所有旧有的安全和合规规则和法规都需要以某种方式加装到 Kubernetes 上。不幸的是，像 RBAC 这样的旧的访问控制工具根本无法应对挑战。', '\nKubernetes 不再是（只是）好玩的游戏了。它正在被用于生产；它是关键任务；所有旧有的安全和合规规则和法规都需要以某种方式加装到 Kubernetes 上。不幸的是，像 RBAC 这样的旧的访问控制工具根本无法应对挑战。 \n\n## 概述\n\n- **Kubernetes API 的设计与大多数现代 API 不同。** 它是基于意图的，这意味着使用 API 的人考虑的是他们想要 Kubernetes 做什么，而不是如何实现。其结果是一个令人难以置信的可扩展性、弹性，和一个强大而流行的系统。\n- **同时，其基于意图的 API 给安全带来了挑战。** 标准的访问控制解决方案（基于角色的访问控制、基于属性的访问控制、访问控制列表或 IAM 策略）都不够强大，无法强制执行基本的策略，比如谁可以更改 pod 上的标签，或者哪些镜像存储库是安全的。\n- **Kubernetes Admission Control 就是为了解决这个问题而设计的。** Kubernetes Admission Controller 并不能解决开箱即用的访问控制问题，但它们允许你使用 Webhook 来解决授权挑战与解耦策略。\n\n## Kubernetes 基于意图的 API\n\nKubernetes API 接受了一个与我们大家习惯的 API 范式截然不同的 API。今天的大多数 API 都是所谓的 *基于行动的（action-based）*，这意味着当你想到一个 API 调用时，你正在考虑你想要执行的行动，以改变软件的运行方式。例如，如果你想让一个应用程序暴露在互联网上，你可能会运行 API openport (443)，改变应用程序上的网络设置，使端口 443 打开。\n\n相比之下，Kubernetes 有所谓的 *基于意图的（intent-based）* API（最近在网络领域流行，例如 [SDXCentral](https:\/\/medium.com\/r\/?url=https%3A%2F%2Fwww.sdxcentral.com%2Fsdn%2Fdefinitions%2Fwhat-is-intent-based-networking%2F)），这意味着当你想要进行一个 API 调用时，你要考虑的是你希望该系统处于何种状态。你并不关心用什么操作来实现这种希望的状态。你只需告诉系统你想要什么（你的意图），系统就会想出如何实现它 —— 采取哪些动作将系统过渡到期望的状态。例如，你可以说你的应用程序应该运行 1.7 版本的二进制文件，应该使用带加密的持久存储，并且应该连接到互联网。系统会计算出如何升级或降级二进制文件，如何开启加密，以及如何重新配置网络以允许互联网连接。\n\n架构上的关键区别在于，*基于意图的* 系统既能理解系统当前所处的状态（有时称为 *实际状态* ），也能理解你对系统应该处于何种状态的意图（*期望状态*）。系统不断地计算两者之间的差距，并采取任何必要的行动使实际状态变成期望状态。用户可以直接通过 API 调用来改变期望状态，而依靠系统本身来改变实际状态。\n\n![](0081Kckwly1glqzp7lpo7j30l20ept9z.jpg)\n\nKubernetes 的 API 是基于意图的。每个 API 调用都允许你指定 Kubernetes 众多对象中的一个对象的期望状态：pod、service、ingress、configmap 等。例如，下面是你为一个 nginx 工作负载定义的期望状态。\n\n\u0060\u0060\u0060yaml\n# nginx-pod.yaml\nkind: Pod\napiVersion: v1\nmetadata:\n name: nginx\n labels:\n app: nginx\nspec:\n containers:\n - image: nginx\n name: nginx\t\n\u0060\u0060\u0060\n\n然后要把这个想要的状态发送到 Kubernetes，用 kubectl，把上面的 YAML 文件交给它就行了。\n\n\u0060\u0060\u0060bash\nkubectl apply -f nginx-pod.yaml\n\u0060\u0060\u0060\n\n假设你想改变 nginx 的版本，挂载一个外部卷，或者提供额外的配置，你更新 nginx-pod.yaml 文件到任何你想要的状态，然后再使用 kubectl apply。更新 nginx-pod.yaml 文件到任何需要的状态，然后再使用 kubectl apply。\n\n\u0060\u0060\u0060bash\nkubectl apply -f nginx-pod.yaml\n\u0060\u0060\u0060\n\n这里的关键要点是，你不是在运行像 updateVersion 或 mountVolume 这样的 API，而是在改变一些描述系统应该处于什么状态的 YAML，并通过运行 apply 来说\u0022 使之如此 \u0022。\n\nKubernetes 的 API 模型有几个优势：\n\n- **减少学习曲线**。你要学习每个对象的 YAML 格式和一系列动作，如创建、应用、获取、描述、删除。无论如何，你都需要学习每个对象的 YAML 配置格式（这样你才能读懂它）。相比之下，*基于动作的* API 还需要你学习可能是 1,000 个动作。\n- **可扩展性**。Kubernetes 支持自定义资源定义（CRD）。因此，除了所有常见的 pod、service、ingress 等，你还可以定义自己的资源。这是可能的，因为 API 表面不需要扩展来处理新的资源类型。你只需要写一些描述资源的 YAML，然后调用同样的十几个动作，例如：创建、应用、获取、描述、删除。\n- **分布式系统**。在使用商用硬件构建的云上运行大规模系统，要求在面对故障时具有难以置信的弹性。Kubernetes 基于意图的架构让它知道自己应该做什么，所以当比如说发生硬件故障时，它可以尝试进行补偿。Brian Grant（Google Kubernetes 的联合技术负责人）曾就 [声明式应用管理](https:\/\/docs.google.com\/document\/d\/1cLPGweVEYrVqQvBLJg6sxV-TrE5Rm2MNOBA_cxZP2WU\/edit) 和 [Kubernetes 资源管理](https:\/\/docs.google.com\/document\/d\/1RmHXdLhNbyOWPW_AtnnowaRfGejw-qlKQIuLKQWlwzs\/edit) 写过大量文章，并指出 Kubernetes API 是解决许多分布式系统问题的关键：故障、分布、自动伸缩、多所有者、可用性、性能、可逆性。\n\n## 为什么 RBAC 不足以保证 Kubernetes 的 API 安全？\n\n基于 Kubernetes 意图的 API 的挑战来自于你想要保护和保障 API 的安全时 —— 当你想要控制哪些人可以使用该 API 做什么时。想象一下，你是 Kubernetes 管理员，负责集群的运维、安全和合规性。新手 Kubernetes 开发人员需要护栏；安全团队需要控制和可见性；合规团队需要帮助将古老的规定映射到这个全新的系统；你从自己的经验中知道你需要采用哪些 Kubernetes 最佳实践。\n\n理想情况下，你会在 Kubernetes 本身内部通过设置访问控制来执行这些规则、法规和最佳实践。基于角色的访问控制（RBAC）是几十年来的解决方案，使你能够控制哪些用户可以在哪些资源上运行哪些 API。Kubernetes RBAC（自 [2017 年末](https:\/\/kubernetes.io\/blog\/2017\/10\/using-rbac-generally-available-18\/) 开始提供）是你的第一道防线。它可以让你为特定的用户组提供对资源的只读访问。它让你通过给不同的用户组分配 Kubernetes 的不同部分（也就是 *namespace*）来隔离不同的用户组（虽然不是完全隔离）。它可以让你限制 service account\n的权限。所有这些都是有价值的。\n\n但与基于动作的系统相比，RBAC 处理了绝大部分的访问控制需求，Kubernetes 中的 RBAC 由于其基于意图的 API，提供的控制 *要少得多*。从 API 的角度来看，只有十几个动作，这意味着如果 alice 可以更新一个资源，她就可以更新这个资源的任何部分。\n\n例如，SRE 需要读取集群中的大部分资源，以便在出现问题时能够诊断出问题。但当 SRE 发现某个节点上出现问题时，例如邻居有噪音，她可能需要对该节点进行排空（drain），以便将工作负载转移到不同的节点上，缓解问题。不幸的是，API 没有 drain 动作 —— 那些是 CLI 提供的宏，只是更新节点上的注释。使用 RBAC 试图达到这个级别的粒度是繁琐而复杂的，以至于不切实际。\n\n下面的基于意图的 K8s RBAC 图从概念上显示了你必须使用 RBAC 的工作内容 —— 你可以选择哪些用户 \/ 操作 \/ 资源组合是允许的。\n\n![](0081Kckwly1glr08337z4j30b908s75g.jpg)\n\n相反，想象一下，如果 Kubernetes 是基于动作的（例如，它包括 cordon、drain、setImage、mountVolume、openPort 等 API）。那么我们就可以使用 RBAC 来授予读以及 cordon 和 drain，但没有其他的功能。基于动作的 API 只是有更多的名字，你可以在编写 RBAC 策略时使用。\n\n![](0081Kckwly1glr0978kbej30bc0d5wgf.jpg)\n\n简而言之，Kubernetes API 提供了一个强大的、可扩展的、统一的资源模型，但也正是这个资源模型使得 RBAC 对于很多用例来说过于粗粒度。RBAC 所能提供的控制是非常宝贵的，但比起其他系统，RBAC 还远不能满足 Kubernetes 的需要。\n\n### 我们需要什么来保证 K8s 的 API 安全？\n\n那么如果 RBAC 不能提供足够的控制，我们该怎么做呢？我们来看一个例子。\u0022所有的 pod 必须只使用来自受信任的存储库的镜像\u0022（比如说，hooli.com）任何时候有人运行，比如说，kubectl apply，访问控制系统需要根据用户、动作 apply 和描述 pod 的 YAML 做出决定。\n\n\u0060\u0060\u0060yaml\nkind: Pod\nmetadata:\n  labels:\n    app: nginx\n  name: nginx-1493591563-bvl8q\n  namespace: production\nspec:\n  containers:\n  - image: nginx\n    name: nginx\n    securityContext:\n      privileged: true\n  - image: hooli.com\/frontend\n    name: frontend\n    securityContext:\n      privileged: true \n dnsPolicy: ClusterFirst\n restartPolicy: Always\n\u0060\u0060\u0060\n\n为了做出正确的决策，访问控制系统需要提取镜像名称列表（如\u0060nginx\u0060和\u0060hooli.com\/frontend\u0060），并进行字符串操作以提取仓库的名称（如默认的 repo 和 hooli.com）。\n\n一种方案是将一堆关于 Kubernetes 资源的知识构建到访问控制系统本身。然后管理员可以写一个策略，比如谁可以 \u0060update-labels\u0060，\u0060permitted-image-registries\u0060 是什么，等等。这就是大多数系统的做法 —— 发明一堆权限，然后在上面建立一个自定义的访问控制系统。\n\n但是构建一个自定义的访问控制系统对于 Kubernetes 来说是行不通的，因为它允许用户和厂商发明自己的 YAML 格式（自定义资源定义），并安装实现这些格式的代码。所以 Kubernetes 的资源可扩展性要求任何定制的 Kubernetes 访问控制系统本身都是可扩展的。\n\n所以，不管我们做什么，我们都需要一个访问控制系统，让管理员编写策略：\n\n- 通过 YAML 文件的层次结构进行递减。\n- 对数组中的元素进行迭代。\n- 操作字符串、IP、数字等。\n\n标准的访问控制范式都不能满足这些要求。这包括基于角色的访问控制（RBAC）、基于属性的访问控制（ABAC）、访问控制列表（ACL），甚至是 IAM 风格的策略。\n\n### 使用准许控制来应急\n\n幸运的是，Kubernetes 团队预见到了这个问题，并创建了一个 [Admission Control](https:\/\/medium.com\/r\/?url=https%3A%2F%2Fkubernetes.io%2Fdocs%2Freference%2Faccess-authn-authz%2Fadmission-controllers%2F) 机制，在这里你可以把控制的范围远远超过 RBAC 和标准的访问控制机制。Kubernetes API 服务器提供了一条访问控制的管道，分为 Authorization（如 RBAC），和 Admission。\n\n![](0081Kckwly1glr2h345xpj30rg06rq42.jpg) \n\n授权（Authorization）发生在每次 API 调用上，而准许（Addmission）只发生在更新（创建、更新和删除）上。通过授权，你将获得以下信息以做出决定：\n\n- **用户**：用户、组、认证提供的额外属性。\n- **动作**：路径、API 动词、HTTP 动词。\n- **资源**：资源、子资源、命名空间、API 组。\n\n通过 Admission，你会得到一个 YAML 中的 AdmissionReview 对象。它包括所有关于资源被修改的信息，以做出任何你想要的决定（见下面的 \u0060request.object\u0060）。\n\n\u0060\u0060\u0060yaml\napiVersion: admission.k8s.io\/v1beta1\nkind: AdmissionReview\nrequest:\n  kind:\n    group: \u0027\u0027\n    kind: Pod\n    version: v1\n  namespace: frontend\n  object:\n    metadata:\n      creationTimestamp: \u00272018-10-27T02:12:20Z\u0027\n      labels:\n        app: nginx\n      name: nginx\n      namespace: frontend\n      uid: bbfee96d-d98d-11e8-b280-080027868e77\n    spec:\n      containers:\n      - image: nginx\n        imagePullPolicy: Always\n        name: nginx\n        resources: {}\n        terminationMessagePath: \u0022\/dev\/termination-log\u0022\n        terminationMessagePolicy: File\n        volumeMounts:\n        - mountPath: \u0022\/var\/run\/secrets\/kubernetes.io\/serviceaccount\u0022\n        name: default-token-tm9v8\n        readOnly: true\n      dnsPolicy: ClusterFirst\n      restartPolicy: Always\n      schedulerName: default-scheduler\n      securityContext: {}\n      serviceAccount: default\n      serviceAccountName: default\n      terminationGracePeriodSeconds: 30\n      tolerations:\n      - effect: NoExecute\n        key: node.kubernetes.io\/not-ready\n        operator: Exists\n        tolerationSeconds: 300\n      - effect: NoExecute\n        key: node.kubernetes.io\/unreachable\n        operator: Exists\n        tolerationSeconds: 300\n      volumes:\n      - name: default-token-tm9v8\n        secret:\n          secretName: default-token-tm9v8\n    status:\n      phase: Pending\n      qosClass: BestEffort\n    oldObject: \n    operation: CREATE\n    resource:\n      group: \u0027\u0027\n      resource: pods\n      version: v1\n    uid: bbfeef88-d98d-11e8-b280-080027868e77\n    userInfo:\n      groups:\n      - system:masters\n      - system:authenticated\n      username: minikube-user \n\u0060\u0060\u0060\n\n当然，你可以通过编写、部署和维护实现准入控制 webhook 协议（一个简单的 HTTP\/json API）的自定义代码，编写任何你喜欢的逻辑来保护你的 API。现在，如果你不想支持和维护自定义代码，你可以使用 [Open Policy Agent](https:\/\/medium.com\/r\/?url=https%3A%2F%2Fwww.openpolicyagent.org) 作为 Kubernetes [准入控制器](https:\/\/www.openpolicyagent.org\/docs\/latest\/kubernetes-tutorial\/)，并利用其声明式策略语言。该语言包括上述所需的表达能力：迭代、点注和 50 多个内置的可用于字符串操纵等。更多信息，请参见 [\u0022 利用 Open Policy Agent 确保 Kubernetes API 安全 \u0022 一文](https:\/\/blog.openpolicyagent.org\/securing-the-kubernetes-api-with-open-policy-agent-ce93af0552c3)。\n\n## 总结\n\n在这篇文章中，我们深入研究了 Kubernetes 所面临的 API 安全挑战，并重点介绍了以下几个关键要点：\n\n- Kubernetes 基于意图的 API 让用户专注于他们希望 Kubernetes 处于什么状态，而不是如何实现它。\n- 基于意图的方法的核心好处之一是，它使 Kubernetes 在面对故障时具有弹性。因为系统知道自己应该做什么，所以当故障发生时，Kubernetes 知道如何恢复。\n- Kubernetes 的 API 还提供了巨大的可扩展性。用户可以创建自己的自定义资源，而无需扩展 API。\n- Kubernetes 的 API 所面临的挑战是，一个访问控制决策可能需要分析一个任意的 YAML 文档，例如使用点符号、迭代和字符串操纵。标准的访问控制系统，如 RBAC、ABAC、ACLs 和 IAM，根本没有足够的表达能力。\n- Kubernetes 团队引入了准入控制（Admission Control），以赋予用户控制 API 的额外权力。你可以使用声明式授权解决方案（如 Open Policy Agent）作为 Kubernetes Admission Controller，为你提供所需的表达能力，以克服这些新的访问挑战，并提供真正有效的粒度。\n', '\/trans\/why-rbac-is-not-enough-for-kubernetes-api-security\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">所有旧有的安全和合规规则和法规都需要以某种方式加装到 Kubernetes 上。不幸的是，像 RBAC 这样的旧的访问控制工具根本无法应对挑战。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/introducing-amazon-eks-distro/">[译] 亚马逊 EKS 发行版（EKS-D）介绍</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2020/12/01</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/kubernetes"> 
             Kubernetes
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('亚马逊 EKS 发行版（EKS-D）介绍', '本文介绍 EKS Distro，并使用合作伙伴生态系统中的例子来解释开始使用 EKS Distro 的不同方法。', '\n今天，我们发布了 [Amazon EKS Distro](https:\/\/distro.eks.amazonaws.com\/)（EKS-D），这是一个基于 [Amazon Elastic Kubernetes Service](https:\/\/amazonaws-china.com\/eks\/)（Amazon EKS）的 Kubernetes 发行版，并由 Amazon EKS 用于创建可靠和安全的 Kubernetes 集群。通过 EKS-D，你可以依赖 EKS 部署的相同版本的 Kubernetes 及其依赖项。这包括最新的上游更新以及扩展的安全补丁支持。EKS-D 遵循与亚马逊 EKS 相同的 Kubernetes 版本发布周期，我们以 [GitHub 上的开源项目的方式](https:\/\/github.com\/aws\/eks-distro) 提供。\n\n在这篇文章中，我们将介绍 EKS Distro，并使用合作伙伴生态系统中的例子来解释开始使用 EKS Distro 的不同方法。\n\n## 什么是 EKS-D？\n\n通过 EKS Distro，你现在可以在通过 EKS 提供的相同 Kubernetes 发行版上实现标准化。这意味着你现在可以手动部署可靠和安全的集群，而无需持续测试和跟踪 Kubernetes 更新、依赖性和安全补丁。每个 EKS Distro 版本都遵循 [EKS](https:\/\/docs.aws.amazon.com\/eks\/latest\/userguide\/kubernetes-versions.html#kubernetes-release-calendar) 验证新 Kubernetes 版本兼容性的 [流程](https:\/\/docs.aws.amazon.com\/eks\/latest\/userguide\/kubernetes-versions.html#kubernetes-release-calendar)。你还可以选择使用提供的构建环境设置、工具和我们发布的镜像的哈希值重现 EKS Distro 的构建，以确认你的下载在传输过程中没有被篡改。通过 EKS-D，我们为社区支持到期后的 Kubernetes 版本提供了扩展支持，更新了以前版本的构建，现在有了最新的安全补丁。\n\n在过去两年大规模运营 Amazon EKS 之后（我们说的是全球数百万个各种规模的集群），我们现在能够确定哪些工作、[哪些组件要运行以及如何运行](https:\/\/kccncna19.sched.com\/event\/Uaav\/living-with-the-pathology-of-the-cloud-how-aws-runs-lots-of-clusters-micah-hausler-amazon)。我们已经了解到，客户希望在企业内部和云端获得一致的体验，以便进行迁移或实现混合云设置。例如，客户有一个用例，由于数据主权的原因，部分工作负载驻留在内部的 Kubernetes 集群中，而其他部分则运行在 EKS 上。现在你手头就有了基于 EKS 的解决方案参考系。\n\n![](0081Kckwgy1glhwzwpf3fj30rs0fst9y.jpg)\n\n对于 EC2 上的 EKS，你可以 [自己](https:\/\/docs.aws.amazon.com\/eks\/latest\/userguide\/worker.html) 管理节点，也可以使用 [托管节点组](https:\/\/docs.aws.amazon.com\/eks\/latest\/userguide\/managed-node-groups.html)。\n\n为了解决一致性的要求，我们想到了 EKS Distro，我们基于 EKS 的 Kubernetes 发行版，你可以在任何环境下运行，无论是裸机还是虚拟机。EKS-D 将上游的（未修改的）Kubernetes 和包，按照一定的、特意的方式进行配置，称为 [Kubernetes 发行版](https:\/\/github.com\/cncf\/k8s-conformance\/blob\/master\/faq.md)，并将这些 [作为开源](https:\/\/github.com\/aws\/eks-distro) 提供。fork 和 distribution 之间的区别很重要：fork 是一个替代上游的代码库。另一方面，发行版是一个特定的下游代码库，比如 Linux 发行版有 Ubuntu 和 Amazon Linux 2，比如 Hadoop 发行版，EMR 中有由 Cloudera 提供的并发行版。\n\n从高层的角度来看，EKS Distro 的情况如下（考虑到一些上游的开源项目，包括 Kubernetes 和 etcd）。\n\n![](0081Kckwgy1glhwzx24n5j30sg0p1q45.jpg)\n\n通过 EKS Distro，你可以通过单一供应商安全地访问可安装、可复制的 Kubernetes 构建，以创建集群，并在社区支持到期后提供 Kubernetes 版本的扩展安全补丁支持。我们将根据 Amazon EKS 版本生命周期政策提供长达 14 个月的 Kubernetes 扩展维护支持，为你提供必要的时间窗口来更新你的基础设施，使其与你的软件生命周期保持一致。\n\n## 开始使用 EKS-D\n\n我们与一些 [合作伙伴合作](https:\/\/amazonaws-china.com\/eks\/eks-distro)，提供安装方法以及与 EKS Distro 的集成。下面，我们将重点介绍几家合作伙伴，以及他们为帮助你开始使用 EKS-D 所做的工作。\n\n### Weaveworks\n\nWeave Kubernetes Platform（WKP）为 Amazon EKS Distro（EKS-D）带来了 GitOps，并为内部安装、创建和管理 EKS-D 集群提供支持。与任何 Kubernetes 发行版一样，EKS-D 需要配置、升级以及额外的组件和附加组件，如日志、跟踪和指标。WKP 通过将 GitOps 添加到你的 Kubernetes 环境的每一层，为 EKS-D 或任何其他云端和企业内部的发行版解决了这些问题。通过利用 Cluster API 项目，GitOps 工作流可以管理整个集群生命周期，包括维护、升级和补丁，以及 Prometheus 和 Grafana 等平台组件的集群配置。通过 WKP 交付和管理 EKS-D 集群，应用开发团队可以获得最新的 GitOps 功能，从而实现更频繁的部署，缩短价值实现时间，提高可靠性和可重复性。平台团队还可以获得对内部部署 EKS-D 的全面洞察和观察能力。Weaveworks [发布的博客文章](https:\/\/weave.works\/blog\/on-prem-kubernetes-gitops-eks-distro) 进一步详细描述了 EKS-D 和 WKP 之间的关系。另外一篇文章则是 [在 EKS-D 和 EKS-D 混合场景下的 WKP 演示](https:\/\/weave.works\/blog\/multicluster-gitops-eks-d-wkp)。\n\n### Kubestack\n\nKubestack 就是要为 Terraform 和 Kubernetes 提供最佳的 GitOps 开发者体验，从本地开发，一直到生产。通过他们 [发布博文](https:\/\/dev.to\/kubestack\/localhost-eks-development-environments-with-eks-d-and-kubestack-4p6) 了解如何使用 Kubestack 管理 EKS-D 集群，你也可以找到一个 [视频 demo](https:\/\/www.youtube.com\/watch?v=TcVwtfFww4w)。\n\n### Kubermatic\n\n你可以使用 Kubermatic 的 [KubeOne](https:\/\/www.kubermatic.com\/products\/kubeone\/) 安装 EKS-D。KubeOne 是一个基础设施对等的开源 Kubernetes 集群生命周期管理工具，可以自动部署和 Day 2 操作单个 Kubernetes 集群。了解如何使用 Kubermatic 的开源集群生命周期管理工具 KubeOne 在 AWS 和 Amazon Linux 2 上 [安装 EKS-D](https:\/\/www.kubermatic.com\/blog\/run-amazon-eks-distro-with-kubeone)。\n\n### Aqua Security\n\n为了保护 EKS-D 的安全，你需要一个整体的方法来征服 Kubernetes 的复杂性。Aqua 提供 KSPM（Kubernetes 安全态势管理）来提高可观测性和补救错误配置，以及先进的、无代理的 Kubernetes 运行时保护。你还可以使用 Kubernetes 原生功能，为你的 Kubernetes 应用实现策略驱动的全生命周期保护和合规性。了解更多关于 [Aqua 的 EKS-D 集成的信息](https:\/\/blog.aquasec.com\/aws-security-eks-distro)。\n\n### Sysdig\n\nSysdig 提供安全和可视性，以检测和响应运行时威胁，验证合规性，并监控和排除 EKS-D 上的容器。查看他们的 [发布博客文章](https:\/\/sysdig.com\/blog\/security-compliance-visibility-amazon-eks-d)，了解更多关于使用 CNCF Falco 和 Sysdig Secure 管理 EKS-D 工作负载中的运行时安全的信息。\n\n### Tetrate\n\nTetrate Service Bridge（TSB）[可在 EKS 和 EKS-D 上实现跨工作负载的统一应用连接和安全](https:\/\/www.tetrate.io\/blog\/tetrate-expands-aws-partnership-to-bring-enterprise-grade-istio-for-eks-and-eks-distro\/)。TSB 为企业级（上游或符合 FIPS 标准）Istio 和 Envoy Proxy 提供了便捷的访问和操作性。多租户、流量管理、网状和应用级可观测性、端到端 mTLS（相互传输层安全）、细粒度授权和应用安全是 TSB 的关键要素。\n\n一系列合作伙伴一直在开展更多与 EKS-D 有关的活动，包括：\n\n### 供应和管理\n\n- 了解如何 使用 Rancher 的 RKE2 部署 EKS-D\n-  [看看使用 Canonical 的 MicroK8s 安装 EKS-D](https:\/\/snapcraft.io\/eks) 有多简单 [，一目了](https:\/\/snapcraft.io\/eks) 然\n- 探索如何使用 [Rafay 的托管 Kubernetes 平台（MKP）来管理 EKS-D 集群](https:\/\/rafay.co\/the-kubernetes-current\/how-to-provision-and-manage-amazons-eks-distribution-using-rafay)\n- 查看如何 [使用 Pulumi 配置 EKS-D 集群](https:\/\/pulumi.com\/blog\/amazon-eks-distro)\n- [Upbound Cloud 使 EKS-D 用户可以轻松地将集群的配置整合](https:\/\/blog.upbound.io\/eks-d-and-upbound\/) 到一个与环境无关的 Crossplane 配置库中。利用这些配置，集群就可以通过一个统一的 API 接口在企业内部、云端或边缘进行配置。\n\n### 观察性\n\n- 通过 Instana，你可以 [自动监控和可视化](https:\/\/instana.com\/blog\/instana-brings-best-in-class-observability-with-the-new-amazon-kubernetes-distribution\/) EKS-D 的工作负载\n- Sumo Logic 展示了他们如何 [与 EKS-D 一起工作](https:\/\/www.sumologic.com\/blog\/monitor-aws-kubernetes-service\/)\n- Epsagon 使你能够 [监控 EKS-D 工作负载](https:\/\/epsagon.com\/announcements\/amazon-eks-distro\/)，包括控制平面指标\n- Datadog 提供了跨内部、混合和云计算基础设施的虚拟机、容器和无服务器环境的健康状况的可视性。了解有关 [EKS-D 支持](https:\/\/www.datadoghq.com\/blog\/amazon-eks-distro-monitoring\/) 的更多信息。\n- Splunk 基础设施监控为所有 Kubernetes 环境 —— 云原生 Amazon EKS、与 Amazon Outposts 的混合 [环境](https:\/\/www.splunk.com\/en_us\/blog\/devops\/monitor-amazon-eks-distro-eks-d-with-splunk.html) 以及内部 [自我管理的 EKS-D 环境](https:\/\/www.splunk.com\/en_us\/blog\/devops\/monitor-amazon-eks-distro-eks-d-with-splunk.html) 提供了企业级监控解决方案。\n\n### 安全\n\n- 了解 [Nirmata 的 EKS 管理器与 EKS-D 的集成](https:\/\/nirmata.com\/2020\/11\/20\/nirmata-delivers-consistent-hybrid-cloud-kubernetes-with-aws\/)，以及如何使用它来加强你的安全态势\n- Alcide 为跨越 EKS、Outposts 和 [新增加的 EKS-D 的](https:\/\/blog.alcide.io\/alcide-and-amazon-eks-distro) 混合部署提供集中统一的安全覆盖\n- 查看 Tigera 围绕 Calico 和 Calico Enterprise 支持所 做的工作 ，以实现运行 EKS-D 的集群的强大安全性和合规性。\n\n你可以想象，这只是旅程的开始。你可能会问，下一步是什么？\n\n## 下一步\n\n要开始使用 EKS Distro，请访问 [https:\/\/distro.eks.amazonaws.com](https:\/\/distro.eks.amazonaws.com\/)，并使用 kops 或 kubeadm 或上述任何一个合作伙伴提供的解决方案亲自尝试。\n\n你可以通过 GitHub 提供反馈和 PR，成为 EKS-D 社区的一员。如果你喜欢更多的互动交流，可以在 Kubernetes Slack 社区通过 #eks 频道或 AWS 开发者 Slack 频道加入我们，我们在那里设置了 #eks-d 频道。\n\n我们很高兴了解你使用 EKS Distro 的情况，并听取你的反馈和建议。\n', '\/trans\/introducing-amazon-eks-distro\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文介绍 EKS Distro，并使用合作伙伴生态系统中的例子来解释开始使用 EKS Distro 的不同方法。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-18-release/">Istio 1.8——用户至上的选择</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2020/11/20</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio 1.8——用户至上的选择', 'Istio 信守了年初的承诺，从 1.1 开始，几乎每三个月一个版本，更能体会用户的需求了。此次是 2020 年的最后一个版本，引入了 WorkloadGroup 和 DNS proxy，对如虚拟机的非 Kubernetes 负载的支持更进了一步。', '\n今天 [Istio 1.8](https:\/\/istio.io\/latest\/news\/releases\/1.8.x\/announcing-1.8\/) 发布了，这是 Istio 在 2020 年发布的最后一个版本，按照 Istio 社区在[今年初设定的目标](https:\/\/istio.io\/latest\/blog\/2020\/tradewinds-2020\/)继续推进，该版本主要有以下更新：\n\n- 支持使用 Helm 3 进行安装和升级\n- 正式移除了 Mixer\n- 新增了 Istio DNS proxy，透明地拦截应用程序的 DNS 查询，实现智能应答\n- 新增了 \u0060WorkloadGroup\u0060 以简化对虚拟机的引入\n\n\u0060WorkloadGroup \u0060是一个新的 API 对象，旨在与虚拟机等非 Kubernetes 工作负载一起使用，模仿现有的用于 Kubernetes 工作负载的 sidecar 注入和部署规范模型来引导 Istio 代理。\n\n## 安装与升级\n\nIstio 从 1.5 版本开始弃用了 Helm，使用 \u0060istioctl manifest\u0060 方式安装，后来又改成了 \u0060istioctl install\u0060，现在又重新回归了 Helm，Helm 作为 Kubernetes 环境下最常用的应用安装管理组件，此次回归也是倾听用户声音，优化安装体验的的反应吧，不过 Istio Operator 依然将是 Istio 安装的最终形式，从 1.8 版本开始 Istio 支持使用 [Helm](https:\/\/istio.io\/latest\/docs\/setup\/install\/helm\/) 进行 in-place 升级和 canary 升级。\n\n## 增强 Istio 的易用性\n\n\u0060istioctl\u0060 命令行工具新的了 bug reporting 功能（\u0060istioctl bug-report\u0060），可以用来收集调试信息和获取集群状态。\n\n[安装 add-on](https:\/\/istio.io\/latest\/blog\/2020\/addon-rework\/) 的方式变了，在 1.7 中已经不推荐使用 istioctl 来安装，在 1.8 中直接被移除了，这样有利于解决 add-on 落后于上游及难以维护的问题。\n\n正式移除了 Mixer，推荐使用 [WebAssembly](https:\/\/istio.io\/latest\/blog\/2020\/wasm-announce\/) 通过扩展 Envoy 的方式来扩展 Istio，也推荐大家使用 [GetEnvoy Toolkit](https:\/\/www.getenvoy.io\/reference\/getenvoy_extension_toolkit_reference\/) 来进行 Envoy 的扩展开发。\n\n## 对虚拟机的支持\n\n在我[之前的博客](https:\/\/thenewstack.io\/how-to-integrate-virtual-machines-into-istio-service-mesh\/)中谈到 Istio 1.7 如何支持虚拟机，在 Istio 1.8 中新增了[智能 DNS 代理](https:\/\/istio.io\/latest\/blog\/2020\/dns-proxy\/)，它是由 Go 编写的 Istio sidecar 代理，sidecar 上的 Istio agent 将附带一个由 Istiod 动态编程的缓存 DNS 代理。来自应用程序的 DNS 查询会被 pod 或 VM 中的 Istio 代理透明地拦截和服务，该代理会智能地响应 DNS 查询请求，可以实现虚拟机到服务网格的无缝多集群访问。\n\n新增了 [WorkloadGroup](https:\/\/istio.io\/latest\/docs\/reference\/config\/networking\/workload-group\/) ，它描述了工作负载实例的集合。提供了一个规范，工作负载实例可以用来引导它们的代理，包括元数据和身份。它只打算与虚拟机等非 Kubernetes 工作负载一起使用，旨在模仿现有的用于 Kubernetes 工作负载的 sidecar 注入和部署规范模型来引导 Istio 代理。\n\n在 [Tetrate](https:\/\/tetrate.io)，我们在客户的多集群部署中广泛使用这种机制，以使 sidecar 能够为暴露在网格中所有集群的入口网关的主机解析 DNS，并通过 mTLS 访问。\n\n## 总结\n\n总而言之，Istio 团队履行了[年初的承诺](https:\/\/istio.io\/latest\/blog\/2020\/tradewinds-2020\/)，自 2018 年发布 1.1 版本发布起，保持了固定的发布节奏，每 3 个月发布一个版本，在性能、用户体验上持续优化，以满足 brownfiled 应用与 greenfield 应用在 Istio 上的无缝体验。我们期待 Istio 在 2021 年可以给我们带来更多惊喜。\n\n最后，感谢[马若飞](https:\/\/github.com\/malphi)对本文的审阅。', '\/blog\/istio-18-release\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">Istio 信守了年初的承诺，从 1.1 开始，几乎每三个月一个版本，更能体会用户的需求了。此次是 2020 年的最后一个版本，引入了 WorkloadGroup 和 DNS proxy，对如虚拟机的非 Kubernetes 负载的支持更进了一步。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/how-to-integrate-virtual-machines-into-istio-service-mesh/">如何在 Istio Service Mesh 中集成虚拟机？</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2020/11/02</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('如何在 Istio Service Mesh 中集成虚拟机？', '将基于虚拟机的工作负载更好地集成到服务网格中，是 Istio 团队今年的一大重点。Tetrate 还通过其产品 Tetrate Service Bridge 提供了无缝的多云连接、安全性和可观测性，包括针对虚拟机的。本文将带您了解为什么 Istio 需要与虚拟机整合，以及如何整合。', '\nIstio 是目前最流行的服务网格，用于连接、保护、控制和观察服务。当其 2017 年开源时，Kubernetes 已赢得容器编排之战，Istio 为了满足组织转向微服务的需求。虽然 Istio 声称支持异构环境，如 Nomad、Consul、Eureka、Cloud Foundry、Mesos 等，但实际上，它一直与 Kubernetes 合作得最好–它的服务发现就是基于 Kubernetes。\n\nIstio 在发展初期就因为一些问题而饱受诟病，比如组件数量多、安装和维护复杂、调试困难、由于引入了太多的新概念和对象（多达 50 个 CRD）而导致学习曲线陡峭，以及 Mixer 组件对性能的影响。但这些问题正在被 Istio 团队逐渐克服。从 2020 年初发布的[路线图](https:\/\/istio.io\/latest\/zh\/blog\/2020\/tradewinds-2020\/)中可以看出，Istio 已经取得了长足的进步。\n\n将基于虚拟机的工作负载更好地集成到服务网格中，是 Istio 团队今年的一大重点。Tetrate 还通过其产品 [Tetrate Service Bridge](https:\/\/www.tetrate.io\/tetrate-service-bridge\/) 提供了无缝的多云连接、安全性和可观测性，包括针对虚拟机的。本文将带您了解为什么 Istio 需要与虚拟机整合，以及如何整合。\n\n## Istio 为什么要支持虚拟机？\n\n虽然现在容器和 Kubernetes 已经被广泛使用，但仍然有很多部署在虚拟机上的服务和 Kubernetes 集群之外的 API 需要由 Istio mesh 来管理。如何将棕地环境与绿地环境统一管理，这是一个巨大的挑战。\n\n## 将虚拟机引入到网格中需要具备什么条件？\n\n在介绍如何集成虚拟机之前，我先介绍一下将虚拟机添加到 Mesh 中需要什么条件。在支持虚拟机流量时，Istio 必须知道几件事：哪些虚拟机的服务要添加到 Mesh 中，以及如何访问虚拟机。每个虚拟机还需要一个身份，以便与服务网格的其他部分安全地通信。这些需求可以和 Kubernetes CRD 一起工作，也可以和 Consul 这样的完整的服务注册表一起工作。而基于服务账户的身份引导机制，为没有平台身份的虚拟机分配工作负载身份。对于有平台身份的虚拟机（如 EC2、GCP、Azure 等），Istio 正在进行这方面的工作，将平台身份与 Kubernetes 身份进行交换，方便设置 mTLS 通信。\n\n## Istio 如何支持虚拟机？\n\nIstio 对虚拟机的支持始于其服务注册表机制。Istio mesh 中的服务和实例信息来自 Istio 的服务注册表，到目前为止，Istio 的服务注册表只关注或跟踪 pod。在新的版本中，Istio 现在有资源类型来跟踪和观察虚拟机。网格内的 sidecar 无法观察和控制网格外服务的流量，因为它们没有任何信息。\n\nIstio 社区和 [Tetrate](https:\/\/www.tetrate.io\/) 在 Istio 对虚拟机的支持上做了[很多工作](https:\/\/www.tetrate.io\/blog\/istio-bringing-vms-into-the-mesh-with-cynthia-coan\/)。1.6 版本中增加了 WorkloadEntry，它允许你像描述 Kubernetes 中运行的主机一样描述虚拟机。在 1.7 版本中，该版本开始增加了通过令牌将虚拟机自动引导到 service mesh 中的基础，Istio 做了大量的工作。Istio 1.8 将首次推出另一个名为 WorkloadGroup 的抽象，它类似于 Kubernetes Deployment 对象 —— 但适用于虚拟机。\n\n下图显示了 Istio 如何在网格中对服务进行建模。最主要的信息来源来自于 Kubernetes 这样的平台服务注册表，或者 Consul 这样的系统。此外，ServiceEntry 作为用户定义的服务注册表，对虚拟机上的服务或组织外部的服务进行建模。\n\n![Istio 中的服务注册发现模型](0081Kckwly1gkc4ldbqzhj30p30ehwf5.jpg)\n\n**为什么不直接使用 ServiceEntry 引入虚拟机中的服务，却还要大费周折在虚拟机中安装 Istio？**\n\n使用 ServiceEntry，你可以让网格内部的服务发现和访问外部服务；此外，还可以管理这些外部服务的流量。结合 VirtualService，你还可以为相应的外部服务配置访问规则，比如请求超时、故障注入等，从而实现对指定外部服务的控制访问。即便如此，它也只能控制客户端的流量，而不能控制引入的外部服务对其他服务的访问。也就是说，它不能控制作为调用发起者的服务的行为。在虚拟机中部署 sidecar，通过工作负载选择器引入虚拟机工作负载，可以像 Kubernetes 中的 pod 一样，对虚拟机进行无差别管理。\n\n## Demo\n\n在下面这个 demo 中我们将使在 GKE 中部署 Istio 并运行 bookinfo 示例，其中 ratings 服务的后端使用的是部署在虚拟机上的 MySQL，该示例可以在 Istio 官方文档中找到，我作出了部分改动，最终的流量路由如下图所示。\n\n![Bookinfo 示例中的流量示意图](0081Kckwly1gkc4lch5epj318g0avwfx.jpg)\n\n### 安装流程\n\n下面是示例的安装步骤：\n\n1. 在 Google Cloud 中部署 Kubernetes 集群，Kubernetes 版本是 1.16.13；\n2. 在 GKE 中安装 Istio 1.7.1；\n3. 在 Google Cloud 中启动一台虚拟机并配置 Istio，将其加入到 Istio Mesh 中，这一步需要很多手动操作，生成证书、创建 token、配置 hosts 等；\n4. 在 Istio Mesh 中部署 bookinfo 示例；\n5. 在虚拟机中安装 MySQL；\n6. 为虚拟机设置 VPC 防火箱规则；\n7. 将虚拟机中的 MySQL 服务作为 ServiceEntry 引入到 Mesh 中并作为 rating 服务的后端；\n8. 修改 MySQL 表中的数据，验证 bookinfo 中的 rating 相应的行为符合预期；\n\n## 未来方向\n\n从 bookinfo 的演示中可以看出，在这个过程中涉及到的人工工作太多，很容易出错。在未来，Istio 会改进虚拟机测试的可操作性，根据平台身份自动引导，改进 DNS 支持和 istioctl 调试等。大家可以关注 [Istio 环境工作组](https:\/\/github.com\/istio\/community\/blob\/master\/WORKING-GROUPS.md)，了解更多关于虚拟机支持的细节。\n\n## 参考阅读\n\n- [Virtual Machine Installation](https:\/\/istio.io\/latest\/docs\/setup\/install\/virtual-machine\/)\n- Virtual Machines in Single-Network Meshes\n- [Istio: Bringing VMs into the Mesh (with Cynthia Coan)](https:\/\/www.tetrate.io\/blog\/istio-bringing-vms-into-the-mesh-with-cynthia-coan\/)\n- [Bridging Traditional and Modern Workloads](https:\/\/www.tetrate.io\/blog\/bridging-traditional-and-modern-workloads\/)\n\n', '\/blog\/how-to-integrate-virtual-machines-into-istio-service-mesh\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">将基于虚拟机的工作负载更好地集成到服务网格中，是 Istio 团队今年的一大重点。Tetrate 还通过其产品 Tetrate Service Bridge 提供了无缝的多云连接、安全性和可观测性，包括针对虚拟机的。本文将带您了解为什么 Istio 需要与虚拟机整合，以及如何整合。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/must-read-for-cloud-native-beginner/">云原生初学者入门必读</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2020/10/18</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f"> 
             云原生
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('云原生初学者入门必读', '这篇文章将助于各位有志于从事云原生领域工作或需要了解该领域背景的人群快速入门 Kubernetes 和云原生。', '\n## 为什么写这篇文章\n\n看到这个标题后，大家可能会问“都已经 2020 年了，Kubernetes 开源有 6 年时间了，为什么还要写一篇 Kubernetes 入门的文章？”我想说的是，Kubernetes 还远远没有达到我们想象的那么普及。众多的开发者，平时忙于各自的业务开发，学习新技术的时间有限；还有大量的学生群体，可能还仅仅停留在“知道有这门技术”的阶段，远远没有入门。这篇文章将助于各位有志于从事云原生领域工作或需要了解该领域背景的人群快速入门 Kubernetes 和云原生。\n\n因为云原生的知识体系过于庞杂，本文主要讲解容器、Kubernetes 及服务网格的入门概念，关于云原生的更多细节将在后续文章中推出。\n\n## 引言\n\n[Kubernetes](https:\/\/kubernetes.io\/) 一词来自希腊语，意思是“飞行员”或“舵手”。这个名字很贴切，Kubernetes 可以帮助你在波涛汹涌的容器海洋中航行。\n\nKubernetes 是做什么的？什么是 Docker？什么是容器编排？Kubernetes 是如何工作和扩展的？你可能还有很多其他的问题，本文将一一为你解答。\n\n这篇文章适合初学者，尤其是那些工作忙碌，没有办法抽出太多时间来了解 Kubernetes 和云原生的开发者们，希望本文可以帮助你进入 Kubernetes 的世界。\n\n简而言之，Kubernetes 提供了一个平台或工具来帮助你快速协调或扩展容器化应用，特别是在 [Docker](https:\/\/docker.com\/) 容器。让我们深入了解一下这些概念。\n\n## 容器和容器化\n\n那么什么是容器呢？\n\n要讨论容器化首先要谈到虚拟机 (VM)，顾名思义，虚拟机就是可以远程连接的虚拟服务器，比如 AWS 的 EC2 或阿里云的 ECS。\n\n接下来，假如你要在虚拟机上运行一个网络应用——包括一个 MySQL 数据库、一个 Vue 前端和一些 Java 库，在 Ubuntu 操作系统 (OS) 上运行。你不用熟悉其中的每一个技术——你只要记住，一个应用程序由各种组件、服务和库组成，它们运行在操作系统上。\n\n现在，将应用程序打包成一个虚拟机镜像，这个镜像中包括了 Ubuntu 操作系统。这使得虚拟机变得非常笨重——通常有几个 G 的大小。\n\n虚拟机镜像包含了整个操作系统及所有的库，对应用程序来说，这个镜像过于臃肿，其中大部分组件并没有被应用程序直接调用。如果你需要重新创建、备份或扩展这个应用程序，就需要复制整个环境（虚拟机镜像），在新环境中启动应用通常需要几十秒甚至几分钟时间。如果你想单独升级应用中的某个组件，比如说 Vue 应用，就需要重建整个虚拟机镜像。另外，如果你的两个应用依赖同一个底层镜像，升级底层镜像会同时影响这两个应用，而有时候，你只需要升级其中一个应用的依赖而已。这就是所谓的“依赖陷阱”。\n\n解决这个问题的办法就是容器。容器是继虚拟机之后更高层次的抽象，在这层抽象中，整个应用程序的每个组件被单独打包成一个个独立的单元，这个单元就是所谓的容器。通过这种方式，可以将代码和应用服务从底层架构中分离出来，实现了完全的可移植性（在任何操作系统或环境上运行应用的能力）。所以在上面的例子中，Ubuntu 操作系统就是一个单元（容器）。MySQL 数据库是另一个容器，Vue 环境和随之而来的库也是一个容器。\n\n但是，MySQL 数据库是如何自己“运行”的？数据库本身肯定也要在操作系统上运行吧？没错！\n\n更高层次的容器，比如 MySQL 容器，实际上会包含必要的库来与底层的操作系统容器通信和集成。所以你可以把容器看成是整个应用堆栈中的一层，每层都依赖于下层的单元。而这就类似于船舶或港口中集装箱的堆叠方式，每个容器的稳定性都依赖于下面的容器的支持。所以应用容器的核心是一个受控的执行环境。它们允许你从头开始定义整个环境，从操作系统开始，到你要使用的各个版本的库，再到你要添加的代码版本。\n\n与容器相关的一个重要概念是**微服务**。将应用程序的各个组件拆分并打包成独立的服务，这样每个组件都可以很容易地被替换、升级、调试。上面的例子中，我们会为 Vue 前端创建一个微服务，为 MySQL 数据库创建另一个微服务，为 Java 中间件部分创建另一个微服务，以此类推。很明显，微服务与容器化是相辅相成的。\n\n## 从 Docker 开始\n\n现在你已经对容器有一定了解了吧？Docker 是最常用的容器化工具，也是最流行的容器运行时。\n\nDocker 开源于 2013 年。用于打包和创建容器，管理基于容器的应用。所有 Linux 发行版、Windows 和 macOS 都支持 Docker。\n\n还有其他的容器化工具，如 [CoreOS rkt](https:\/\/coreos.com\/rkt\/)、[Mesos Containerizer](http:\/\/mesos.apache.org\/documentation\/latest\/mesos-containerizer\/) 和 [LXC](https:\/\/linuxcontainers.org\/)。但是目前，绝大多数的容器化应用都是在 Docker 上运行的。\n\n## 再到 Kubernetes\n\n首先，简单介绍一下历史。Kubernetes 是 Google 基于其内部容器调度平台 Borg 的经验开发的。2014 年开源，并作为 CNCF（云原生计算基金会）的核心发起项目。\n\n那么 Kubernetes 又跟容器是什么关系呢？让我们再回到上面的例子。假设我们的应用爆火，每天的注册用户越来越多。\n\n现在，我们需要增加后端资源，使浏览我们网站的用户在浏览页面时加载时间不会过长或者超时。最简单的方式就是增加容器的数量，然后使用负载均衡器将传入的负载（以用户请求的形式）分配给容器。\n\n这样做虽然行之有效，但也只能在用户规模有限的情况下使用。当用户请求达到几十万或几百万时，这种方法也是不可扩展的。你需要管理几十个也许是几百个负载均衡器，这本身就是另一个令人头疼的问题。如果我们想对网站或应用进行任何升级，也会遇到问题，因为负载均衡不会考虑到应用升级的问题。我们需要单独配置每个负载均衡器，然后升级该均衡器所服务的容器。想象一下，当你有 20 个负载均衡器和每周 5 或 6 个小的更新时，你将不得不进行大量的手工劳动。\n\n我们需要的是一种可以一次性将变更传递给所有受控容器的方法，同时也需要一种可以轻松地调度可用容器的方法，这个过程还必须要是自动化的，这正是 Kubernetes 所做的事情。\n\n接下来，我们将探讨 Kubernetes 究竟是如何工作的，它的各种组件和服务，以及更多关于如何使用 Kubernetes 来编排、管理和监控容器化环境。为了简单起见，假设我们使用的是 Docker 容器，尽管如前所述，Kubernetes 除了支持 Docker 之外，还支持其他几种容器平台。\n\n## Kubernetes 架构和组件\n\n首先，最重要的是你需要认识到 Kubernetes 利用了“期望状态”原则。就是说，你定义了组件的期望状态，而 Kubernetes 要将它们始终调整到这个状态。\n\n例如，你想让你的 Web 服务器始终运行在 4 个容器中，以达到负载均衡的目的，你的数据库复制到 3 个不同的容器中，以达到冗余的目的。这就是你想要的状态。如果这 7 个容器中的任何一个出现故障，Kubernetes 引擎会检测到这一点，并自动创建出一个新的容器，以确保维持所需的状态。\n\n现在我们来定义一些 Kubernetes 的重要组件。\n\n当你第一次设置 Kubernetes 时，你会创建一个集群。所有其他组件都是集群的一部分。你也可以创建多个虚拟集群，称为命名空间 (namespace)，它们是同一个物理集群的一部分。这与你可以在同一物理服务器上创建多个虚拟机的方式非常相似。如果你不需要，也没有明确定义的命名空间，那么你的集群将在始终存在的默认命名空间中创建。\n\nKubernetes 运行在节点 (node) 上，节点是集群中的单个机器。如果你有自己的硬件，节点可能对应于物理机器，但更可能对应于在云中运行的虚拟机。节点是部署你的应用或服务的地方，是 Kubernetes 工作的地方。有 2 种类型的节点——master 节点和 worker 节点，所以说 Kubernetes 是主从结构的。\n\n主节点是一个控制其他所有节点的特殊节点。一方面，它和集群中的任何其他节点一样，这意味着它只是另一台机器或虚拟机。另一方面，它运行着控制集群其他部分的软件。它向集群中的所有其他节点发送消息，将工作分配给它们，工作节点向主节点上的 API Server 汇报。\n\nMaster 节点本身也包含一个名为 API Server 的组件。这个 API 是节点与控制平面通信的唯一端点。API Server 至关重要，因为这是 worker 节点和 master 节点就 pod、deployment 和所有其他 Kubernetes API 对象的状态进行通信的点。\n\nWoker 节点是 Kubernetes 中真正干活的节点。当你在应用中部署容器或 pod（稍后定义）时，其实是在将它们部署到 worker 节点上运行。Worker 节点托管和运行一个或多个容器的资源。\n\nKubernetes 中的逻辑而非物理的工作单位称为 pod。一个 pod 类似于 Docker 中的容器。记得我们在前面讲到，容器可以让你创建独立、隔离的工作单元，可以独立运行。但是要创建复杂的应用程序，比如 Web 服务器，你经常需要结合多个容器，然后在一个 pod 中一起运行和管理。这就是 pod 的设计目的——一个 pod 允许你把多个容器，并指定它们如何组合在一起来创建应用程序。而这也进一步明确了 Docker 和 Kubernetes 之间的关系——一个 Kubernetes pod 通常包含一个或多个 Docker 容器，所有的容器都作为一个单元来管理。\n\nKubernetes 中的 service 是一组逻辑上的 pod。把一个 service 看成是一个 pod 的逻辑分组，它提供了一个单一的 IP 地址和 DNS 名称，你可以通过它访问服务内的所有 pod。有了服务，就可以非常容易地设置和管理负载均衡，当你需要扩展 Kubernetes pod 时，这对你有很大的帮助，我们很快就会看到。\n\nReplicationController 或 ReplicaSet 是 Kubernetes 的另一个关键功能。它是负责实际管理 pod 生命周期的组件——当收到指令时或 pod 离线或意外停止时启动 pod，也会在收到指示时杀死 pod，也许是因为用户负载减少。所以换句话说，ReplicationController 有助于实现我们所期望的指定运行的 pod 数量的状态。\n\n## 什么是 Kubectl？\n\nkubectl 是一个命令行工具，用于与 Kubernetes 集群和其中的 pod 通信。使用它你可以查看集群的状态，列出集群中的所有 pod，进入 pod 中执行命令等。你还可以使用 YAML 文件定义资源对象，然后使用 kubectl 将其应用到集群中。\n\n## Kubernetes 中的自动扩展\n\n请记住，我们使用 Kubernetes 而不是直接使用 Docker 的原因之一，是因为 Kubernetes 能够自动扩展应用实例的数量以满足工作负载的需求。\n\n自动缩放是通过集群设置来实现的，当服务需求增加时，增加节点数量，当需求减少时，则减少节点数量。但也要记住，节点是“物理”结构——我们把“物理”放在引号里，因为要记住，很多时候，它们实际上是虚拟机。\n\n无论如何，节点是物理机器的事实意味着我们的云平台必须允许 Kubernetes 引擎创建新机器。各种云提供商对 Kubernetes 支持基本都满足这一点。\n\n我们再继续说一些概念，这次是和网络有关的。\n\n## 什么是 kubernetes Ingress 和 Egress？\n\n外部用户或应用程序与 Kubernetes pod 交互，就像 pod 是一个真正的服务器一样。我们需要设置安全规则允许哪些流量可以进入和离开“服务器”，就像我们为托管应用程序的服务器定义安全规则一样。\n\n进入 Kubernetes pod 的流量称为 Ingress，而从 pod 到集群外的出站流量称为 egress。我们创建入口策略和出口策略的目的是限制不需要的流量进入和流出服务。而这些策略也是定义 pod 使用的端口来接受传入和传输传出数据 \/ 流量的地方。\n\n## 什么是 Ingress Controller？\n\n但是在定义入口和出口策略之前，你必须首先启动被称为 Ingress Controller（入口控制器）的组件；这个在集群中默认不启动。有不同类型的入口控制器，Kubernetes 项目默认只支持 Google Cloud 和开箱即用的 Nginx 入口控制器。通常云供应商都会提供自己的入口控制器。\n\n## 什么是 Replica 和 ReplicaSet？\n\n为了保证应用程序的弹性，需要在不同节点上创建多个 pod 的副本。这些被称为 Replica。假设你所需的状态策略是“让名为 webserver-1 的 pod 始终维持在 3 个副本”，这意味着 ReplicationController 或 ReplicaSet 将监控活动副本的数量，如果其中有任何一个 replica 因任何原因不可用（例如节点的故障），那么 Deployment Controller 将自动创建一个新的系统（定义如下）。\n\n所需状态是在 deployment 中定义的。Master 节点的中有一个子系统叫做 Deployment Controller，负责实际执行并使当前状态不断趋向于所需状态。\n\n因此，举例来说，如果你目前有 2 个 pod 的副本，而你所希望的状态应该有 3 个，那么 Replication Controller 或 ReplicaSet 会自动检测到这个要求，并指示 Deployment Controller 根据预定义的设置部署一个新的 pod。\n\n## 什么是服务网格？\n\n[服务网格 (Service Mesh)](\/blog\/what-is-a-service-mesh\/) 用于管理服务之间的网络流量，是云原生的网络基础设施层，也是 [Kubernetes 次世代的云原生应用](\/blog\/post-kubernetes-era\/) 的重要组成部分。\n\n服务网格利用容器之间的网络设置来控制或改变应用程序中不同组件之间的交互。下面，我们用一个例子来说明。假设你想测试 Nginx 的新版本，检查它是否与你的 Web 应用兼容。你用新的 Nginx 版本创建了一个新的容器 (Container2)，并从当前容器 (Container1) 中复制了当前的 Nginx webserver 配置。但你不想影响组成 web 应用的其他微服务（假设每个容器对应一个单独的微服务）——就是 MySQL 数据库、Node.js 前端、负载均衡器等。\n\n所以使用服务网格，你可以立即只把 webserver 微服务改成 Container2（新 Nginx 版本的那个）进行测试。如果确定它不能工作，比如因为它导致网站出现一些兼容性问题，那么你就调用服务网格来快速切换回原来的 Container1。而这一切都不需要对其他容器进行任何配置变更——这些变更对其他容器是完全透明的。\n\n如果没有服务网格，对容器来说这项工作将十分繁琐，因为这涉及到逐一更改所有其他容器上的配置，将它们所包含的服务从 Container1 指向 Container2，然后在测试失败后，将它们全部改回来。\n\n在前面这部分 Kubernetes 指南中，我们介绍了一些与 Kubernetes 网络相关的概念。Kubernetes 中的网络可能很棘手，很难理解，如果你刚刚开始，你可能需要一些实践来理解这里。\n\n在下一部分中，我们将展开更多关于 Kubernetes 的话题：如何开始学习 Kubernetes，如何在本地安装和测试 Kubernetes，以及 Kubernetes 的一些优秀的监控工具。\n\n## 如何学习 Kubernetes？\n\n自学 Kubernetes 知识基本上有三种不同的途径，我们在这里只提供了一个指导大纲。\n\n### 一、从零开始学习和安装 Kubernetes\n\n要想真正掌握 Kubernetes，最好的办法莫过于自己从头开始安装 Kubernetes。不过要注意的是，从零开始安装 Kubernetes 并不是一件容易的事情。安装 Kubernetes 并不是简单的“下载文件 -\u003e 点击安装”式的操作，Kubernetes 由多个组件组成，这些组件必须单独安装和配置。而在此之前，你也需要相当的技术储备来做安装前的准备，比如熟悉 Linux 操作系统。如果你决定使用这种方式学习的话，推荐你阅读 [Kubernetes Handbook——Kubernetes 中文指南 \/ 云原生架构实践手册](https:\/\/github.com\/rootsongjc\/kubernetes-handbook)。此外，请记住，尽管 Kubernetes 作为一个开源解决方案在技术上是免费的，但它确实有一些隐藏的成本，只不过对初学者来说可能并不明显。\n\n### 二、Kubernetes 自托管解决方案\n\n这些解决方案样是一些工具和实用程序，大大简化了在本地计算机上安装和配置小型 Kubernetes 集群的任务。它们是学习 Kubernetes 的好方法，同时对于新手来说也不会太难，又足够小巧可以到安装在个人电脑上。最流行的自托管 Kubernetes 工具和环境是 [Minikube](https:\/\/github.com\/kubernetes\/minikube)、[MicroK8s](https:\/\/github.com\/ubuntu\/microk8s)、[Docker Desktop](https:\/\/docs.docker.com\/docker-for-windows\/kubernetes\/) 和 [Kind](https:\/\/github.com\/kubernetes-sigs\/kind)。这些解决方案往往有一些限制，例如，Minikube 只允许创建一个节点。尽管有这些缺点，但这些工具还是非常值得推荐，因为它们将易学性和成本效益结合起来，对于刚开始使用 Kubernetes 的初学者来说，是一个很好的选择。\n\n### 三、云托管的解决方案\n\n如今各大云供应商都提供了定制化的 Kubernetes 解决方案来。你也可以通过线上教学平台如 [Katacoda](https:\/\/katacoda.com\/) 上的免费课程来学习 Kubernetes，它们都是云托管的，你不需要自己安装，只不过你需要云供应商的集群需要付费。\n\n## 本地测试和调试 Kubernetes\n\n作为本地安装 Kubernetes 的一部分，你很可能还需要一些测试和调试能力，以确保一切都在顺利运行，特别是定义入口和出口策略等棘手的任务。此外，还有 Kubernetes 附加组件的生态系统，你可能想使用这些组件来扩展 Kubernetes 集群的功能。添加所有这些都需要进行更多的测试，以确保它们能与你的 Kubernetes 集群完美的集成。\n\n用于在本地开发和调试 Kubernetes 服务的工具有：[Microsoft Bridge to Kubernetes](https:\/\/github.com\/microsoft\/mindaro) 和 [telepresence](https:\/\/github.com\/telepresenceio\/telepresence)。这些工具可以让你在本地运行单个服务，同时将该服务连接到远程 Kubernetes 集群。这样你就可以让自己的本地机器作为 Kubernetes 集群中的一部分来运行——这对于在本地而不是在生产集群上开发服务非常有用。\n\nKubernetes 项目也了解到了 Kubernetes 安装对端到端 (E2E) 测试的需求。为此，项目核心团队一直在确保在最近的版本中更恰当地支持 E2E 测试。这包括诸如允许测试重用和纳入更多附加组件和驱动程序的测试等。\n\n## Kubernetes 监控工具\n\nKubernetes 提供了应用程序在集群的每个层次上的资源使用情况的详细信息——容器、pod、服务。这些详细信息使你能够评估应用程序的性能，确定哪些瓶颈可以解决以提高整体性能。\n\n毕竟，监控可以帮助你了解应用和集群运行情况的详细信息，这对于学习 Kubernetes 是十分有帮助的。\n\nKubernetes 包含两个内置度量收集工具用于监控：[资源管道和全度量管道](https:\/\/kubernetes.io\/docs\/tasks\/debug-application-cluster\/resource-usage-monitoring\/)。资源管道是一个较低级和较有限的工具，主要集中在与各种控制器相关的指标上。全指标管道，顾名思义，从几乎所有集群组件中获取并显示更丰富的指标。\n\n还有一些第三方工具可以安装并集成到 Kubernetes 集群中。对于 Kubernetes 来说，最普遍使用的两个工具是 Prometheus 和 Grafana。\n\n### Prometheus 监控\n\nPrometheus 是一个功能丰富的开源监控和警报工具。Prometheus 包含一个内部数据存储用来收集指标，如生成的时间序列数据。Prometheus 还拥有众多插件，允许它将数据暴露给各种外部解决方案，并从其他数据源导入数据，包括所有主要公有云监控解决方案。\n\n### Grafana 仪表盘\n\nGrafana 是一个优秀的仪表盘、分析和数据可视化工具。它没有 Prometheus 的全功能数据收集能力，但 Prometheus 又没有 Grafana 的数据呈现界面。事实上，他们最好是结合在一起使用——Prometheus 负责数据收集和汇总，Grafana 负责数据展示。它们共同创造了一个强大的组合，涵盖了数据收集、基本警报和可视化。\n\n### 高级警报\n\n对于高级警报，你可以添加 [Nagios](https:\/\/www.nagios.org\/) 或 [Prometheus Alertmanager](https:\/\/github.com\/prometheus\/alertmanager) 等工具。这些警报工具通常有大量的集成。你可以为自定义值班团队，然后定义你想要监控的参数，例如“当任何 pod 不可用时”或“当任何节点无法访问时”、“当容量达到 90%”等，然后通过电子邮件、短信、手机应用提醒、电话呼叫等方式向值班人员发送自定义通知。你还可以创建升级策略，比如，如果一个被定义为“危急”的警报在 10 分钟内没有值班人员确认，那么就将警报升级（发送警报）到该人员的经理。\n\n现在，你应该已经对 Docker 和 Kubernetes 有了大体的认识。了解了 Kubernetes 的作用，知道它是如何进行容器化应用部署和管理的。\n\n调试和监控技术不仅仅是运维需要，你也可以把它当作学习方式。有什么比边做边学更好呢？\n\n请记住，如果你的应用规模太小，而且预计用户需求不会有太大变化或重大波动（比如一个只在公司内部使用的应用），那么 Kubernetes 对你来说可能没有必要，这种情况下，直接使用 Docker 就足够了。\n\n## 更多\n\n云原生领域的开源项目众多（见 [Awesome Cloud Native\/云原生开源项目大全](\/awesome-cloud-native)），其中有大量的优秀项目可供我们学习。此外，Kubernetes 开源已经多年时间，网上有大量的学习资料，业界出版过很多书籍，建议大家通过阅读[官方文档](https:\/\/kubernetes.io)和实践来学习，也可以参考我编写的[Kubernetes Handbook——Kubernetes 中文指南 \/ 云原生架构实践手册](\/book\/kubernetes-handbook)。\n\n推荐大家加入我发起创办的[云原生社区](https:\/\/cloudnative.to)，这是一个立足中国，放眼世界的云原生终端用户社区，致力于云原生技术的传播和应用。云原生社区主办的[云原生学院](https:\/\/github.com\/cloudnativeto\/academy)定期邀请云原生和开源领域的大咖在 B 站上进行直播分享，成员自发组织了多个 SIG（特别兴趣小组）进行讨论学习。欢迎加入我们，共同学习和交流云原生技术。\n', '\/blog\/must-read-for-cloud-native-beginner\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">这篇文章将助于各位有志于从事云原生领域工作或需要了解该领域背景的人群快速入门 Kubernetes 和云原生。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/moving-on-from-ant-group/">新的开始——告别蚂蚁，加入 Tetrate</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2020/08/31</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e9%9a%8f%e7%ac%94"> 
             随笔
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('新的开始——告别蚂蚁，加入 Tetrate', '今天是我在蚂蚁的最后一天，明天我就要在 Tetrate 开始新的学期了。', '\n今天是我加入蚂蚁的第 914 天，也是在[蚂蚁](https:\/\/www.antgroup.com\/)的最后一天，明天就是 9 月 1 日了，这一天通常都是学校开学的日子，在阿里巴巴大家都以”同学”相称，明天我将加入 [Tetrate](https:\/\/tetrate.io)，这也算开始我的新学期吧！\n\n## 蚂蚁\/阿里巴巴与云原生社区\n\n迄今为止，蚂蚁\/阿里巴巴集团对我的职业生涯产生了深远影响，尤其是它的企业文化和价值观，阿里巴巴招聘的理念的“寻找同路人”，在创建云原生社区的过程，不也是寻找同路人的过程吗？[云原生社区](https:\/\/cloudnative.to)就像一个小型社会，我不求它有多大的社会价值，只求它可以对个人、对企业、对社会带来微小而美好的改变。我不断得思考作为个人、员工。尤其是社区的发起人，我的使命到底是什么？我在公司中应该担当什么样的角色？这个社区要走向何方？我在摸索中前进，但是因为有你们的支持，使我更加坚定，致力于云原生技术在中国的普及和应用，以外我一个人可能走得更快，但现在与社区在一起，我们将走得更远！\n\n![2019 年 6 月 24 日，上海，KubeCon China 2019](20190624.jpg)\n*2019 年 6 月 24 日，上海，KubeCon China 2019*\n\n## 加入 Tetrate\n\n在过去的两年里，我一直在着力推广 Istio 和 Service Mesh 技术，在蚂蚁集团的资助下，我创办了 ServiceMesher 社区，将 Service Mesh 技术带到了中国，接下来我希望将中国实践带到世界。当然还有今年疫情期间成立的[云原生社区](https:\/\/cloudnative.to)，向开发者和大众普及云原生知识和应用。\n\n作为 Developer Advocate，最重要的一点是不要停止学习，同时要善于倾听和总结。在过去的两年里，我看到无数人对 Service Mesh 表现出浓厚的兴趣，但因对新技术的风险了解的不足及知识匮乏而无从下手。我十分兴奋加入这家专注于 Service Mesh 的初创公司 [Tetrate](https:\/\/tetrate.io)，这是一家全球化远程办公的初创公司，公司的产品围绕开源 [Istio](https:\/\/istio.io)、[Envoy](https:\/\/envoyproxy.io) 和 [Apache SkyWalking](https:\/\/skywalking.apache.org\/) 等开源项目构建，致力于打造云原生的网络基础设施。这里有这些开源项目的多位 Maintainer，如 [吴晟](https:\/\/twitter.com\/wusheng1108)、[Zack Butcher](https:\/\/twitter.com\/ZackButcher)、[周礼赞](https:\/\/twitter.com\/zlizan) 等，我相信跟他们一起，可以帮助大家快速、有效的了解和应用 Service Mesh，跨向云原生。\n\n## 写在最后\n\n今年年初在筹备云原生社区的时候，我就确定了未来三年内的工作方向——云原生、开源和社区。在追求梦想的道路上充满荆棘，不仅需要勇气和毅力，还需要你们做我坚强的后盾，我一定披荆斩棘，一往无前。开源是世界的，要想让世界更理解我们，我们必须更加主动地融入这个世界。希望中国开源的明天会更好，希望 Service Mesh 技术在中国更好的落地，希望云原生能够普惠大众，希望大家都可以找到自己的使命。\n\nTetrate 目前也在[招聘](\/job\/tetrate)中，欢迎投递简历。\n\n', '\/blog\/moving-on-from-ant-group\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">今天是我在蚂蚁的最后一天，明天我就要在 Tetrate 开始新的学期了。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/post-kubernetes-era/">Kubernetes 次世代的云原生应用</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2020/06/01</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f"> 
             云原生
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Kubernetes 次世代的云原生应用', 'Kubernetes 的次世代在于解决 Kubernetes 生态的碎片化问题。', '\nKubernetes 自开源至今已经走过六个年头了，[云原生时代](https:\/\/cloudnative.to\/blog\/cloud-native-era\/)也已到来，我关注云原生领域也四年有余了，最近开始思考云原生的未来走向，特此撰写本文作为[《云原生应用白皮书》](https:\/\/jimmysong.io\/guide-to-cloud-native-app)的开篇，更多关于云原生应用的介绍请转到白皮书中浏览。\n## 重点\n\n- 云原生基础设施已渡过了野蛮生长期，正朝着统一应用标准方向迈进。\n- Kubernetes 的原语无法完整描述云原生应用体系，且在资源的配置上开发与运维功能耦合严重。\n- Operator 在扩展了 Kubernetes 生态的同时导致云原生应用碎片化，亟需一个统一的应用定义标准。\n- OAM 的本质是将云原生应用定义中的研发、运维关注点分离，资源对象进行进一步抽象，化繁为简，包罗万象。\n- “Kubernetes 次世代”是指在 Kubernetes 成为基础设施层标准之后，云原生生态的关注点正在向应用层过度，近两年来火热的 Service Mesh 正是该过程中的一次有力探索，而基于 Kubernetes 的云原生**应用**架构的时代即将到来。\n\nKubernetes 已成为云原生应用的既定运行平台，本文以 Kubernetes 为默认平台展开，包括云原生应用的分层模型。\n\n## 云原生的不同发展阶段\n\nKubernetes 从开源至今已经走过快[六个年头](https:\/\/jimmysong.io\/cloud-native\/memo\/open-source\/)（2014 年 6 月开源）了，可以说是 Kubernetes 的诞生开启了整个云原生的时代。我粗略的将云原生的发展划分为以下几个时期。\n\n![云原生的发展阶段](cloud-native-stages.png)\n\n**第一阶段：孵化期（2014 年）**\n\n2014 年，Google 开源 Kubernetes，在此之前的 2013 年，Docker 开源，DevOps、微服务已变得十分流行，云原生的概念已经初出茅庐。在开源了 Kubernetes 之后，Google 联合其他厂商发起成立了 CNCF，并将 Kubernetes 作为初创项目捐献给了 CNCF。CNCF 作为云原生的背后推手，开始推广 Kubernetes。\n\n**第二阶段：高速发展期（2015 年 - 2016 年）**\n\n这几年间，Kubernetes 保持着高速发展，并于 2017 年打败了 Docker Swarm、Mesos，确立了容器编排工具领导者的地位。CRD 和 Operator 模式的诞生，大大增强了 Kubernetes 的扩展性，促进了周边生态的繁荣。\n\n**第三阶段：野蛮生长期（2017 年 - 2018 年）**\n\n2016 年之后的云原生基本都默认运行在 Kubernetes 平台上，2017、2018 年 Google 主导的 Istio、Knative 相继开源，这些开源项目都大量利用了 Kubernetes 的 Operator 进行了扩展，Istio 刚发布时就有 50 多个 CRD 定义。Istio 号称是[后 Kubernetes 时代的微服务](https:\/\/jimmysong.io\/blog\/service-mesh-the-microservices-in-post-kubernetes-era\/)，它的出现第一次使得云原生以服务（应用）为中心。Knative 是 Google 在基于 Kubernetes 之上开源的 Serverless 领域的一次尝试。2018 年 Kubernetes 正式从 CNCF [毕业](https:\/\/www.cncf.io\/blog\/2018\/03\/06\/kubernetes-first-cncf-project-graduate\/)，Prometheus、Envoy 也陆续从 CNCF 毕业。CNCF 也与 2018 年修改了 charter，对云原生进行了重定义，从原来的三要素：”应用容器化；面向微服务架构；应用支持容器的编排调度“，修改为”云原生技术有利于各组织在公有云、私有云和混合云等新型动态环境中，构建和运行可弹性扩展的应用。云原生的代表技术包括容器、服务网格、微服务、不可变基础设施和声明式 API“。这一年，我曾写过两篇 Kubernetes 及云原生发展的年终总结和展望，见 [2017 年](https:\/\/jimmysong.io\/kubernetes-handbook\/appendix\/kubernetes-and-cloud-native-summary-in-2017-and-outlook-for-2018.html)和 [2018 年](https:\/\/jimmysong.io\/kubernetes-handbook\/appendix\/kubernetes-and-cloud-native-summary-in-2018-and-outlook-for-2019.html)的预测和总结。\n\n**第四阶段：普及推广期（2019 年至今）**\n\n经过几年的发展，Kubernetes 已经得到的大规模的应用，云原生的概念开始深入人心，Kubernetes 号称是云原生的操作系统，基于 Operator 模式的生态大放异彩。整合 Kubernetes 和云基础设施，研发和运维关注点分离。Kubernetes 到 Service Mesh（后 Kubernetes 时代的微服务），基于 Kubernetes 的 Serverless 都在快速发展，OAM 诞生，旨在定义云原生应用标准。\n\n## Kubernetes 开辟了云原生时代\n\nKubernetes 开源之初就继承了 Google 内部调度系统 Borg 的经验，屏蔽掉了底层物理机、虚拟机之间的差异，经过几年时间的发展成为了容器编排标准，进而统一了 PaaS 平台的基础设施层。\n\n下图是 Kubernetes 原生内置的可以应用到一个 Pod 上的所有控制器、资源对象等。\n\n![Kubernetes 概念](kubernetes-concepts.png)\n\n图片来自图书 [Kubernetes Patterns（O’Reilly）](https:\/\/www.redhat.com\/cms\/managed-files\/cm-oreilly-kubernetes-patterns-ebook-f19824-201910-en.pdf)\n\nKubernetes 作为云原生基础设施设计之初遵循了以下原则：\n\n1. 基础设施即代码（声明式 API）\n1. 不可变基础设施\n1. 幂等性\n1. 调节器模式（Operator 的原理）\n\n其中声明式 API 可谓开创了云原生时代的基调，而调节器模式是 Kubernetes 区别于其他[云部署形式](https:\/\/jimmysong.io\/cloud-native-infra\/evolution-of-cloud-native-developments.html)的主要区别之一，这也为后来的 [Operator 框架的诞生](https:\/\/zhuanlan.zhihu.com\/p\/54633203)打下了基础。\n\n### 声明式 API\n\n根据声明式 API 可以做应用编排，定义组件间的依赖，通常使用人类易读的 YAML 文件来表示。但是，YAML 文件声明的字段真的就是最终的状态吗？有没有可能动态改变？\n\n我们在创建 \u0060Deployment\u0060 时会指定 Pod 的副本数，但是其实际副本数并不一定是一成不变的。假如集群中还有定义 HPA，那么 Pod 的副本数就可能随着一些外界因素（比如内存、CPU 使用率或者自定义 metric）而改变，而且如果集群中还有运行自定义的控制器话，那么也有可能修改应用的实例数量。在有多个控制器同时控制某个资源对象时，如何确保控制器之间不会发生冲突，资源对象的状态可预期？可以使用[动态准入控制](https:\/\/kubernetes.io\/zh\/docs\/reference\/access-authn-authz\/extensible-admission-controllers\/#monitoring-admission-webhooks)来达到这一点。\n\n### Kubernetes 原生应用\n\n我们都知道要想运行一个应用至少需要以下几点：\n\n- 应用的业务逻辑（代码）、运行时（可运行的二进制文件、字节码或脚本）。\n- 应用的配置注入（配置文件、环境变量等），身份、路由、服务暴露等满足应用的安全性和可访问性。\n- 应用的生命周期管理（各种 Controller 登场）。\n- 可观测性、可运维、网络和资源及环境依赖、隔离性等。\n\n下图展示了基于 Kubernetes 原语及 PaaS 平台资源的 Kubernetes 原生应用的组成。\n\n![Kubernetes 原生应用](kubernetes-native-application-motion.gif)\n\n我们都知道 Kubernetes 提供了大量的[原语](https:\/\/kubernetes.io\/docs\/concepts\/)，用户可以基于这些原语来编排服务，管理应用的生命周期。上图展示的是基于 Kubernetes 原生应用可以使用的 Kubernetes 原语、扩展及平台层资源，从内向外的对象跟应用程序（业务逻辑）的关联度依次降低，到最外层基本只剩下平台资源依赖，已经与 Kubernetes 几乎没有关系了。该图里仅展示了部分资源和对象（包含阿里巴巴开源的 [OpenKruise](https:\/\/github.com\/openkruise\/kruise)、Istio），实际上 [Operator](https:\/\/operatorhub.io\/) 资源之丰富，也是 Kubernetes 生态如此繁荣的原因之一。\n\nKubernetes 本身的原语、资源对象、配置、常用的 CRD 扩展有几十、上百个之多。开发者需要了解这些复杂的概念吗？我只是想部署一个应用而已！不用所对于应用开发者，即使对于基础实施开发和运维人员也需要很陡峭的学习曲线才能完全掌握它。\n\n我将 Kubernetes 原生应用所需要的定义和资源进行了分层：\n\n- **核心层**：应用逻辑、服务定义、生命周期控制；\n- **隔离与服务访问层**：资源限制与隔离、配置、身份、路由规则等；\n- **调度层**：各种调度控制器，这也是 Kubernetes 原生应用的主要扩展层；\n- **资源层**：提供网络、存储和其他平台资源；\n\n而这些不同的层，完全可以将其职责分配给相应的人员，比如核心层是由应用程序开发者负责，将其职责分离，可以很大程度上降低开发和运维的复杂度。\n\n云原生应用落实到 Kubernetes 平台之上，仅仅利用 Kubernetes 的对象原语已很难描述一个复杂的应用程序，所以诞生了各种各样的 Operator，但这也仅仅解决了单个应用的定义，对于应用的打包封装则无能为力。\n\n同一个资源对象又有多种实现方式，比如 Ingress 就有 [10 多种实现](https:\/\/docs.google.com\/spreadsheets\/d\/1DnsHtdHbxjvHmxvlu7VhzWcWgLAn_Mc5L1WlhLDA__k\/edit#gid=0)，PV 就更不用说，对于对于开发者究竟如何选择，平台如何管理，这都是让人很头疼的问题。而且有时候平台所提供的扩展能力还可能会有冲突，这些能力有的可能互不相干，有的可能会有正交，有的可能完全重合。且应用本身与运维特性之间存在太多耦合，不便于复用。\n\n![资源交集动画](resources-motion.gif)\n\n上图中不同颜色的方框代表不同的资源类别，红线框代表不能为一个资源同时应用该配置，否则会出现冲突，不同的颜色上面是一个动画，展示的是部分资源组合。图中仅包含了部分 Kubernetes 中的原语和 Istio 中的资源对象组合及自定义扩展，实际上用户可以根据应用的自身特点，基于 Kubernetes 原语和 CRD 创建出千变万化的组合。\n\n为了管理这些应用诞生出了众多的 [Operator](https:\/\/github.com\/operator-framework\/awesome-operators)。Kubernetes 1.7 版本以来就引入了[自定义控制器](https:\/\/kubernetes.io\/docs\/concepts\/api-extension\/custom-resources\/)的概念，该功能可以让开发人员扩展添加新功能，更新现有的功能，并且可以自动执行一些管理任务，这些自定义的控制器就像 Kubernetes 原生的组件一样，Operator 直接使用 Kubernetes API 进行开发，也就是说它们可以根据这些控制器内部编写的自定义规则来监控集群、更改 Pods\/Services、对正在运行的应用进行扩缩容。\n\nOperator 的本质是一种调节器模式（Reconciler Pattern）的应用，跟 Kubernetes 本身的实现模式是一样的，用于管理云原生应用，协调应用的实际状态达到预期状态。\n\n调节器模式的四个原则：\n\n1. 所有的输入和输出都使用数据结构。\n1. 确保数据结构是不可变的。\n1. 保持资源映射简单。\n1. 使实际状态符合预期状态。\n\n## 云原生应用走向碎片化\n\n利用声明式 API 及调节器模式，理论上可以在 Kubernetes 上部署任何可声明应用，但是在 Operator 出现之前，管理 Kubernetes 上的有状态应用一直是一个难题，随着 Operator 模式的确立，该难题已得以解决，并促进了 Kubernetes 生态的进一步发展。随着该生态的繁荣，有一种碎片化的特征正在显现。\n\n**云原生应用碎片化的体现**\n\n- Operator 模式将运维人员的反应式经验转化成基于 \u0060Reconcile\u0060 模式的代码，统一了有状态应用的管理模式，极大得扩展了 Kubernetes 应用生态。\n- 开发者在引用 Operator 所提供的能力时没有统一的视图，加大了基础设施运维与开发者之间的沟通成本。\n- Operator 总体上治理松散，没有统一的管控机制，在同时应用时可能导致互相冲突或无法预期的结果发生。\n\n\n### 有状态应用管理难题\n\nKubernetes 对于无状态应用的管理很出色，但是对于有状态应用就不是那么回事了。虽然 StatefulSet 可以帮助管理有状态应用，但是这还远远不够，有状态应用往往有复杂的依赖。声明式的 API 里往往要加载着大量的配置和启动脚本，才能实现一个复杂应用的 Kubernetes 化。\n\n例如在 2017 年初，Operator Framework 出现之前，需要使用大量的 \u0060ConfigMap\u0060、复杂的启动脚本才能[在 Kubernetes 上定义 Hadoop YARN](https:\/\/jimmysong.io\/kubernetes-handbook\/guide\/migrating-hadoop-yarn-to-kubernetes.html) 和[运行 Spark](https:\/\/jimmysong.io\/kubernetes-handbook\/usecases\/running-spark-with-kubernetes-native-scheduler.html)。虽然 [\u0060StatefulSet\u0060](https:\/\/kubernetes.io\/docs\/concepts\/workloads\/controllers\/statefulset\/) 号称可以解决有状态应用的部署问题，但是它主要是保证了 Pod 的在启动、伸缩时的顺序和使 Pod 具有稳定的标识。但是很多分布式应用来说并不仅依靠启动顺序就可以保证其状态，根据其在分布式应用中的角色不同（master\/worker）而需要有大量的自定义配置，在没有 Operator 之前这些配置通常是通过一些自定义脚本来实现，这些脚本可能存在于应用镜像中，也可以通过 \u0060ConfigMap\u0060 挂在到容器运行时，但无论如何这些脚本都可能因为散落在各处，这些脚本还是面向过程的，跟在 Kubernetes 诞生之前的运维方式毫无二致，这极其不便于版本控制和运维管理。\n\n### Operator 统一了 Kubernetes 应用运维框架\n\nOperator 大大增强了 Kubernetes 的可扩展性，丰富了以 Kubernetes 为基础的云原生生态，许多原先不是为 Kubernetes 而构建的应用纷纷通过[构建自己的 Operator](https:\/\/zhuanlan.zhihu.com\/p\/54633203) 迁移到 Kubernetes 上。还有一些直接基于 Kubernetes 构建的 Service Mesh、Serverless 框架，它们应用 Operator 模式（如 [Istio](https:\/\/istio.io)、[Knative](https:\/\/knative.dev)），试图成为云原生应用的基础设施层，补齐 Kubernetes 在服务治理、无服务架构等方面的短板，随着大量的 CRD、Operator 控制器的出现，而 Kubernetes 却无法以应用的视角来管理这些能力及其背后零散的 CRD，这使得云原生应用碎片化。\n\nOperator 百花齐放，在没有一个大一统的视图之前，各个控制器之间存在着这样的关系：\n\n- **独立**：互不干涉，比如 Controller 与服务发现之间就不存在冲突。\n- **可组合**：例如 \u0060Service\u0060、\u0060VirtualService\u0060、\u0060DestinationRule\u0060 同属一类资源（可访问性与路由），就是可组合的（后两者是 Istio 中的 CRD，用于流量管理）。\n- **有冲突**：例如图中的 \u0060CronHorizontalPodAutoscaler\u0060（CRD）、\u0060HorizontalPodAutoscaler\u0060（Kubernetes 内置），同时使用可能导致无法意料的情况发生。\n\n正是以为这样复杂的关系，导致其无法做到开箱即用，还需要基础设施团队基于云原生社区和生态自己构建出来的，比如[应用交付领域](https:\/\/jimmysong.io\/awesome-cloud-native\/#application-delivery)的系列开源项目。\n\n## 云原生应用管理工具 Helm\n\nKubernetes 之上有很多能力缺失，比如应用构建、发布、管理和运维等，Helm 的出现主要补偿了应用打包和版本管理的缺陷。其中云原生应用的配置包括：\n\n- 应用程序启动时加载的配置文件；\n- 应用程序的运维配置，如资源申请限额；\n- 应用程序的服务发现配置；\n- 应用程序的工作负载、发布策略、依赖等；\n\n这些配置可以存在于 \u0060ConfigMap\u0060、\u0060Deployment\u0060、\u0060Service\u0060、\u0060Ingress\u0060 等 Kubernetes 的多个资源文件中，如何保证应用程序的复用性？应用程序之间有依赖该如何解决？这是时候你可能自然的想到了 Helm。\n\n云原生应用打包和发布管理\n\n- Helm 通过 chart 模板，提高了应用程序的复用性并解决了部分依赖问题；\n- Chart 仓库提供了云原生应用程序的统一管控视图；\n- \u0060Release\u0060 概念的引入，使得云原生应用版本化管理进一步加强；\n\nHelm 主要关注的是 [12 因素应用](https:\/\/12factor.net\/zh_cn\/)法则[构建、发布、运行](https:\/\/12factor.net\/zh_cn\/build-release-run)这一原则中的”发布”这一环节。下图是 Helm v3 的架构图。\n\n![Helm3 架构](helm-chart.png)\n\nHelm 可以安装本地或者远程的 chart，当 chart 安装到 Kubernetes 中后就会创建一个 release，每次更新该 chart 的配置并执行 \u0060helm upgrade\u0060，release 的版本数就会加 1，开发者可以升级 chart 或回滚到历史版本。\n\n### 打包、配置和发布\n\nHelm 和 chart 的主要作用是：\n\n- 应用程序封装\n- 版本管理\n- 依赖检查\n- 便于应用程序分发\n\n**打包**\n\nHelm 采用 [Chart](https:\/\/helm.sh\/docs\/topics\/charts\/) 的格式来标准化描述应用，可以将目录打包成版本化的压缩包进行部署理论上一个 Chart 是可以嵌套若干个 Chart 并定义依赖关系，组织形式非常灵活。Helm chart 用于打包 Kubernetes 原生应用。\n\n**配置**\n\n应用配置参数，在 Chart 中由 \u0060values.yaml\u0060 和命令行参数组成。Chart 采用 Go Template 的特性和 \u0060values.yaml\u0060 对部署的模板文件进行参数渲染，也可以通过 \u0060helm\u0060 命令 \u0060--set key=value\u0060 的方式进行参数赋值。\n\n**发布**\n\nRelease 代表 Chart 在集群中的运行实例，Helm 围绕 Release 对应用提供了强大的生命周期管理能力，包括 Release 的查询、安装、更新、删除、回滚等。\n\n## 云原生应用\n\n以上关注的点都是基于 Kubernetes 原语的实现，虽然基于 Kubernetes 构建的 PaaS 平台部分屏蔽了底层基础设施的差异，但是仍有很多云服务是无法通过 Kubernetes 创建，或者需要提前创建供 Kubernetes 原生应用使用的，这些应用通常不运行在 Kubernetes 集群中。因此创建和管理一个云原生应用程序需要考虑以下方面：\n\n- 运行时：ECS、Docker、KataContainer、gVisor 等；\n- 资源隔离性：多租户、VPC、Namespace、防火墙；\n- 资源调度：各种类型的 controller；\n- 网络可达性：Service、Ingress、Egress、Gateway、VirtualService、DestinationRule、LoadBalancer、ServiceEntry 等；\n- 可观测性：日志、分布式追踪、指标；\n- 安全性：SecurityPolicy、NetworkPolicy、AuthorizationPolicy；\n- 平台资源申请：数据库、存储等；\n- 运行与隔离：ECS、Docker、KataContainer 等；\n- 资源分配和调度：各种控制器；\n- 环境隔离：Namespace、多租户、VPC、防火墙、LimitRange、Resources；\n- 可访问性：Service、Ingress、Egress、Gateway、LoadBalancer、VirtualService、DestinationRule、ServiceEntry；\n- 状态管理：Operator；\n- 可观测性：日志、监控、指标；\n- 安全性：SecurityPolicy、ServiceAccount；\n\n### 云原生应用分层模型\n\n那么究竟如何来给云原生应用分层，化繁就简？近几年来，基于 Kubernetes 的应用呈爆炸式发展，光是在[应用交付领域](https:\/\/jimmysong.io\/awesome-cloud-native\/#application-delivery)的开源项目就达几十个之多。下图展示我根据这些项目的特性而绘制的 App Delivery Landscape。\n\n![云原生应用的分层模型](cloud-native-app.png)\n\n- **应用定义和包装**：云原生应用的最上层，直接定义云原生应用的组成形式，解决云原生应用之间的依赖关系，并封装成发布包，如 Helm、CNAB，还有云原生变成语言 Pulumi 和 Ballerina，基于 API 的方式来编排云原生应用；\n- **负载定义**：基于 Kubernetes Operator，大多是 Serverless 负载，既负责了负载的定义又负责了生命周期管理。[Istio](https:\/\/istio.io) 是比较特殊的存在，它不仅管理服务间的流量，还负责安全性、可观测性。\n- **应用发布和上线**：关注应用的构建和发布、GitOps、发布策略等，这也是云原生应用全景中最丰富的部分之一；\n- **Kubernetes 原语**：Kubernetes 本身提供的原语，Operator 基于此构建；\n\n以上为我个人分类的云原生应用全景模型，仅限于 Kubernetes 之上的应用，对于其他非 Kubernetes 应用非本文的考虑范围。另外，CNCF SIG App Delivery 中也给出的云原生应用的分层模型，其模型将非 Kubernetes 应用场景也纳入了考虑，详见：[The Dictionary of Cloud-Native App Delivery](https:\/\/docs.google.com\/document\/d\/1gMhRz4vEwiHa3uD8DqFKHGTSxrVJNgkLG2WZWvi9lXo\/edit#heading=h.h9so53gv5zen)。\n\nPlatform\/Kuberntes，Kubernetes 仅仅是屏蔽了平台的一些差异，但是对于最上层的应用来说，没有涉及，用户需要自己来基于各种开源组件来搭积木。\n\n### OAM（开放应用模型）\n\n那么以上这么多应用有哪些共性，能不能再进一步抽象呢？\n\n- 所有应用是都以容器作为运行时环境（ContainerizedWorkload），这是 OAM 中的核心 Workload 类型；\n- 在应用发布和上线方面，有些是属于应用的运维特征，需要根据实际需求组合和变更，这些是持续变动的部分；\n- 要实现某些复杂的应用管控，需要使用到多个 CRD 的组合，比如 Istio 中的让流量根据百分比切分到不同的而服务，就需要部署 Istio Operator，并声明 \u0060VirtualService\u0060、\u0060DestinationRule\u0060，二者同时使用；\n\n一个 \u0060ApplicationConfiguration\u0060 的 Runtime 的正常流程应该是：\n\n- 应用开发者创建自己的 \u0060Component\u0060，在 \u0060Component\u0060 中描述要应用相关的信息，如应用名称、镜像配置、环境变量等，应用到 Kubernetes cluster 中；\n- 运维创建各种运维策略，如发布策略、网络策略等等，发布时由 AppConfig 对象关联要发布的 \u0060Component\u0060 和本次的运维策略，apply 到集群中，集群的 OAM operator watch 到一次 \u0060ApplicationConfiguration\u0060的下发，生成 \u0060Component\u0060 对应的 \u0060Workload\u0060 和 \u0060Trait\u0060，\u0060Trait\u0060 controller 将本次的 \u0060Trait\u0060 策略应用到本次要管理的 \u0060Workload\u0060 当中，最终到达终态，完成一次发布。\n\nOAM 是对 Kubernetes 友好的，一样采用声明式 API 的理念开发。如果你已经编写了现成的 CRD Operator，可以平滑的接入到 OAM 体系中。OAM 以应用为中心，高度可扩展，扩展点包括：\n\n- Workload：扩展各种运行时类型，不仅限于容器运行时，还可以定义更多其他运行时，比如 Serverless 负载、虚拟机、数据库、网络等；例如，Pod、无服务器函数、数据存储、消息队列或任何其他类型的工作负载，这些都是应用程序开发人员需要设计一个完整的应用程序所需要的，可以直接引用 Kubernetes 的 CRD；\n- Trait：各种运维规则，比如扩缩容、流量控制、安全性；\n\n### 生态\n\n以前 CNCF 的主要关注群体大多是基础设施领域的技术人员，但是自 2019 年 9 月，[CNCF 宣布成立 SIG App Delivery](https:\/\/www.infoq.cn\/article\/Cdw7ISlEqKilGyN9V3Pj) 后，CNCF 正在将应用开发者和运维人员更紧密的联系在一起。[应用交付 SIG](https:\/\/github.com\/cncf\/sig-app-delivery) 的使命是：\n\n- 在与开发、分发、部署、管理和运行安全的云原生应用相关的领域进行合作，目标是以云原生方式交付应用。\n- 发展信息资源，包括指南、教程和白皮书，让社区了解最佳实践和应用交付的价值。\n- 识别合适的项目和现状的差距，定期向 TOC 更新，并以结构化的方式向 TOC 提出行动建议。这包括帮助 TOC 评估和对潜在的新项目进行尽职调查。\n\n目前 OAM 定义的云原生应用模型已有以下项目支持。\n\n- [Crossplane](https:\/\/crossplane.io\/)：这是一个开源的 Kubernetes 扩展组件，适用于主流公有云平台，使用 \u0060kubectl\u0060 配置和管理基础架构、服务和应用。对于 OAM 的支持详见运行应用程序。\n- KPT：Kpt（发音为 \u0022keep\u0022）是一个在资源配置之上构建声明性工作流的开源工具。它的 git \u002b YAML 架构意味着它只需与现有的工具、框架和平台一起工作。Kpt 包括了获取、显示、自定义、更新、验证和应用 Kubernetes 配置的解决方案。对 OAM 的支持详见 使用 kpt 来管理由开放应用模型（OAM）定义的自定义 Kubernetes 应用程序。\n\n应用交付领域相关的开源项目还有很多，详见 [Awesome Cloud Native](https:\/\/jimmysong.io\/awesome-cloud-native\/#application-delivery)。\n\n## 总结\n\n基于 Kubernetes 的云原生生态发展至今已有 6 年时间，当前已步入了普及推广阶段。可以说谁云原生应用定义的制高点，就可以掌握云原生的未来。从前我们是新技术浪潮的追随者，现在我们抓住时代的基于，参与标准制定、引领云原生的浪潮！欢迎加入 [OAM 社区](https:\/\/oam.dev\/)，一起参与进来，把国人参与指定的标准推向世界。\n\n## 参考\n\n- [Do you know what’s in Helm 3? - developer.ibm.com](https:\/\/developer.ibm.com\/technologies\/containers\/blogs\/kubernetes-helm-3\/)\n- [O’Reilly: Kubernetes patterns for designing cloud-native apps - redhat.com](https:\/\/www.redhat.com\/cms\/managed-files\/cm-oreilly-kubernetes-patterns-ebook-f19824-201910-en.pdf)\n- [The Dictionary of Cloud-Native App Delivery - docs.google.com](https:\/\/docs.google.com\/document\/d\/1gMhRz4vEwiHa3uD8DqFKHGTSxrVJNgkLG2WZWvi9lXo\/edit#heading=h.h9so53gv5zen)\n- [CNCF 宣布成立应用交付领域小组，正式开启云原生应用时代 - infoq.cn](https:\/\/www.infoq.cn\/article\/Cdw7ISlEqKilGyN9V3Pj)\n- [OAM v1alpha2 新版发布：平衡标准与可扩展性，灵活接入 CRD operator - mp.weixin.qq.com](https:\/\/mp.weixin.qq.com\/s\/c7A8lOdAKkW25GoqmwOgWg)\n- [Kubernetes API 与 Operator，不为人知的开发者战争 - zhuanlan.zhihu.com](https:\/\/zhuanlan.zhihu.com\/p\/54633203)\n- [云原生时代——投资人视角下的云原生趋势思考 - cloudnative.to](https:\/\/cloudnative.to\/blog\/cloud-native-era\/)\n', '\/blog\/post-kubernetes-era\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">Kubernetes 的次世代在于解决 Kubernetes 生态的碎片化问题。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
          <div class="col-12">
 
 
 
 
 
 
 
 
 
 
 
 <nav aria-label="Page navigation">
   <ul class="pagination justify-content-center">
     
     
     <li class="page-item">
       <a class="page-link" href="/blog/">
         ««
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a href="/blog/page/22/" class="page-link">
         «
       </a>
     </li>
     
     
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item">
           <a href="/blog/page/21/" class="page-link">
             21
           </a>
         </li>
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item">
           <a href="/blog/page/22/" class="page-link">
             22
           </a>
         </li>
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item page-item active ">
           <a href="/blog/page/23/" class="page-link">
             23
           </a>
         </li>
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item">
           <a href="/blog/page/24/" class="page-link">
             24
           </a>
         </li>
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item">
           <a href="/blog/page/25/" class="page-link">
             25
           </a>
         </li>
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
     
     
     <li class="page-item">
       <a href="/blog/page/24/" class="page-link">
         »
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a class="page-link" href="/blog/page/28/">
         »»
       </a>
     </li>
     
   </ul>
 </nav>
 
</div>

        </div>
      </div>
      <!-- sidebar -->
      <aside class="col-lg-4 order-1 order-lg-2 d-none d-sm-block">
          <div class="sidebar">
          <!-- categories -->
<div class="blog-categories mb-4">
  <p class="sidebar-title">
      专栏
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/istio" class="sidebar-item">
            <span>Istio</span>
            <span>(77)</span>
        </a>
      
        <a href="/categories/service-mesh" class="sidebar-item">
            <span>Service Mesh</span>
            <span>(42)</span>
        </a>
      
        <a href="/categories/kubernetes" class="sidebar-item">
            <span>Kubernetes</span>
            <span>(25)</span>
        </a>
      
        <a href="/categories/%e9%9a%8f%e7%ac%94" class="sidebar-item">
            <span>随笔</span>
            <span>(22)</span>
        </a>
      
        <a href="/categories/%e5%85%b6%e4%bb%96" class="sidebar-item">
            <span>其他</span>
            <span>(20)</span>
        </a>
      
        <a href="/categories/envoy" class="sidebar-item">
            <span>Envoy</span>
            <span>(17)</span>
        </a>
      
        <a href="/categories/%e4%b8%9a%e6%80%81" class="sidebar-item">
            <span>业态</span>
            <span>(17)</span>
        </a>
      
        <a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f" class="sidebar-item">
            <span>云原生</span>
            <span>(14)</span>
        </a>
      
        <a href="/categories/ai" class="sidebar-item">
            <span>AI</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%ae%89%e5%85%a8" class="sidebar-item">
            <span>安全</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%bc%80%e6%ba%90" class="sidebar-item">
            <span>开源</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e6%97%85%e8%a1%8c" class="sidebar-item">
            <span>旅行</span>
            <span>(7)</span>
        </a>
      
        <a href="/categories/%e5%8f%af%e8%a7%82%e6%b5%8b%e6%80%a7" class="sidebar-item">
            <span>可观测性</span>
            <span>(5)</span>
        </a>
  </div>
</div>

<div class="blog-categories mb-4">
  <p class="sidebar-title">
      资料
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/%e5%87%ba%e7%89%88%e7%89%a9" class="sidebar-item">
            <span>出版物</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e7%94%b5%e5%ad%90%e4%b9%a6" class="sidebar-item">
            <span>翻译电子书</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e6%96%87%e6%a1%a3" class="sidebar-item">
            <span>翻译文档</span>
            <span>(7)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>翻译图书</span>
            <span>(6)</span>
        </a>
      
        <a href="/categories/%e5%8e%9f%e5%88%9b%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>原创图书</span>
            <span>(2)</span>
        </a>
      
        <a href="/categories/%e6%95%99%e7%a8%8b%e6%89%8b%e5%86%8c" class="sidebar-item">
            <span>教程手册</span>
            <span>(2)</span>
        </a>
  </div>
</div>





          </div>
      </aside>
      <!-- /sidebar -->
    </div>
  </div>
</section>




<footer>
  
  <div class="footer bg-footer section-sm border-bottom overlay ">
    <div class="container-xl">
      <div class="row">
        <div class="col col-xl-4 d-sm-none mb-2 mb-lg-0 d-xl-block d-none">
          
          <p class="h3 text-white mb-4 text-uppercase">联系</p>
          
          <ul class="list-unstyled">
            
            
            <li class="mb-4 text-color">微信公众号</li>
            
            
            <li class="mb-4"><img src="/images/servicemesher-wechat.webp" width="118px" height="118px" alt="footer image"></li>
            
            
            
          
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">博客</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/blog/typora-notion-to-obsidian/">为什么我将笔记从 Notion 迁移到 Obsidian？</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/istio-ambient-traffic-interception/">Istio Ambient 模式中的透明流量拦截过程详解</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/istio-ambient-inpod-iptables/">Istio Ambient 模式中的 Pod 内 iptable 规则注入解析</a></li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">链接</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://istio.io/latest/zh/" target="_blank" rel="noopener noreferrer">
                  Istio 服务网格
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://tetrate.io/?jimmysong" target="_blank" rel="noopener noreferrer">
                  Tetrate 公司
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener noreferrer">
                  云原生学院|Bilibili
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/awesome-cloud-native/" target="_blank" rel="noopener noreferrer">
                  云原生开源项目大全
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://cloudnative.to" target="_blank" rel="noopener noreferrer">
                  云原生社区（中国）
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">教程</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/envoy-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Envoy 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/istio-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Istio 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/kubernetes-handbook/" >
                  Kubernetes 基础教程
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/envoy-made-simple/" >
                  简明 Envoy 教程
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">通知</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/notice/nist-sp-800-233-service-mesh-proxy-models/">资料分享：云原生应用服务网格代理模型的威胁分析指南</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/kubecon-china-2024-panel/">KubeCon China 2024（香港）</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/website-revamp-notice/">网站改版通知</a></li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>

  
  <div class="copyright py-4 bg-footer overlay">
    <div class="container-xl">
      <div class="row">
        <div class="col-sm-6 text-sm-left text-center">
          <p class="mb-0 text-color">© 2017-2024 Jimmy Song 保留所有权利</p>
        </div>
        <div class="col-sm-6 text-sm-right text-center">
          <ul class="list-inline">
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://twitter.com/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-x-twitter text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/contact/" >
                    <i class="fa-brands fa-weixin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://github.com/rootsongjc" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-github text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://linkedin.com/in/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-linkedin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="mailto:rootsongjc@gmail.com" >
                    <i class="fa-solid fa-envelope text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/blog/index.xml" >
                    <i class="fa-solid fa-rss text-white"></i>
              </a>
            </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>


<!-- JS Plugins -->

<script src="/plugins/popper/popper.min.js"></script>

<script src="/plugins/bootstrap/bootstrap.min.js"></script>

<script src="/plugins/slick/slick.min.js"></script>

<script src="/plugins/filterizr/jquery.filterizr.min.js"></script>

<script src="/plugins/search/fuse.min.js"></script>

<script src="/plugins/search/mark.js"></script>

<script src="/plugins/hex_md5/hex_md5.js"></script>

<script src="/plugins/anchor/anchor.min.js"></script>

<script src="/plugins/tocbot/tocbot.min.js"></script>

<script src="/plugins/bigger-picture/bigger-picture.min.js"></script>


<!-- Main Script -->

<script src="/js/script.min.f94c22b1d478bfc9e2e0a7d954429e47b7e6d36edd423758482e04154ae1842e.js"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-ESY906ZWZ0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ESY906ZWZ0');
</script>


<!-- Baidu analysis -->
<meta name="baidu-site-verification" content="g8IYR9SNLF" />





<script>
    anchors.add();
</script>






<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>










<script src="/js/wowchemy-search.min.7a37268e7bbe4a9160c2e4c33b749816.js" type="module"></script>
<script id="search-hit-fuse-template" type="text/x-template">
  <div class="search-hit" id="summary-{{key}}">
    <div class="search-hit-content border-bottom">
      <div class="search-hit-name">
        <div class='search-hit-link'><a href="{{relpermalink}}">{{title}}</a></div>
        <div class="search-hit-metadata d-flex">
            <span class="mr-1"><i class="fa-regular fa-calendar mr-1"></i>{{date}}</span>
            <span class="mr-1"><i class="fa-regular fa-folder-open mr-1"></i>{{section}}</span>
            <span class="d-sm-block d-none"><i class="fa-solid fa-link mr-1"></i>{{relpermalink}}</span>
        </div>
        <div class="search-hit-description">{{snippet}}</div>
      </div>
    </div>
  </div>
</script>



    </body>
</html>
