<!DOCTYPE html>
<html lang="zh"><head>
  <meta charset="utf-8">
  
  <title>博客 - Jimmy Song</title>
  

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta name="description" content="专注开源技术、云原生与生活随笔的分享与思考。">
  <meta name="author" content="Jimmy Song">
  <meta name="generator" content="Hugo 0.129.0">

  <!-- CSS plugins -->
  
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
  
  <link rel="preload" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" as="style">
  <link rel="stylesheet" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" media="screen">
  

  <!-- Main Stylesheet -->
  
  <link rel="preload" href="/scss/style.min.f6911c0ac7d2b5b69c3f2d9f2a2b3b496b5da0608580347fdb4dc11ef74f3ec5.css" as="style">
  <link rel="stylesheet" href="/scss/style.min.f6911c0ac7d2b5b69c3f2d9f2a2b3b496b5da0608580347fdb4dc11ef74f3ec5.css" media="screen">

  <!-- Bigger picture css -->
  
  <link rel="stylesheet" href="/plugins/bigger-picture/bigger-picture.min.css" media="print" onload="this.media='all'">
  <!--Favicon generate by https://realfavicongenerator.net-->
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="200x200" href="/images/favicon.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">

  <link href='/opensearchdescription.xml' rel='search' title='Content search' type='application/opensearchdescription+xml'/>

  <!--Twitter card-->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="jimmysong.io" />
  <meta name="twitter:creator" content="@jimmysongio" />
  <meta property="og:url" content="https://jimmysong.io/blog/" />
  <meta property="og:title" content="博客 | Jimmy Song" />
  <meta property="twitter:title" content="博客 | Jimmy Song" />

  
  <meta property="og:description" content="专注开源技术、云原生与生活随笔的分享与思考。" />
  <meta property="twitter:description" content="专注开源技术、云原生与生活随笔的分享与思考。" />

  
  <meta property="og:image" content="https://jimmysong.io/images/banner/default.jpg" />
  <meta property="twitter:image" content="https://jimmysong.io/images/banner/default.jpg" />

  
  
</head>
<body>
<header class="fixed-top header">
  
  
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa fa-arrow-circle-up" aria-hidden="true"></i></button>
  
  <div class="navigation w-100 ">
    <div class="container-xl">
      <nav class="navbar navbar-expand-lg navbar-light p-0">
        <a class="navbar-brand" href="/">
            
            <b>JIMMY SONG</b>
            
        </a>
        <button class="navbar-toggler rounded-0" type="button" data-toggle="collapse" data-target="#navigation"
          aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse text-center" id="navigation">
          <ul class="navbar-nav ml-auto">
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/blog">博客</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/book">资料</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/tags">标签</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/notice">公告</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/contact">联系</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/about">关于</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/community/">社区</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener">视频 <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i></a>
              
            </li>
            
            

          
          
          <li class="nav-item">
            
            
            
              
              
                
                
                
                  
                    
                    <a class="nav-link" href="/en/blog/">English</a>
                    
                  
                
              
              
              
                
                  
                    
                    
                  
                
                
                
              
          </li>
          
          
          <!-- search -->
           <button type="button" class="search-btn js-search" id="searchOpen" aria-label="Search">
              <div class="search-container d-flex justify-content-center">
              <span class="search-content">
                  <i class="fa fa-search"></i>
                  <span>搜索</span>
              </span>
              <span class="search-shortcuts d-none d-sm-block">
                  <kbd class="cmd-key">⌘</kbd>
                  <kbd class="k-key">K</kbd>
              </span>
              </div>
          </button>
          
          </ul>
        </div>
      </nav>
    </div>
  </div>
</header>


            <aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between">
        <div class="col-6 search-title">
          <p>站内搜索</p> 
        </div>
        <div class="col-6 col-search-close">
          <div class="js-search" aria-label="关闭"><i class="fa-solid fa-circle-xmark text-muted" aria-hidden="true"></i></div>
        </div>
      </div>

      <div id="search-box">
        <i class="fa-solid fa-magnifying-glass" id="search-icon" aria-hidden="true"></i>
        <input name="q" id="search-query" placeholder="请输入搜索词" autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control" aria-label="请输入搜索词">
        
        <div class="mt-4">
          <span>搜索类型: </span>
          <span>
            <input type="radio" id="all" name="search_type" value="all" checked>
            <label for="all">所有</label>
            
              <input type="radio" id="blog" name="search_type" value="blog">
              <label for="blog">原创</label>
              <input type="radio" id="trans" name="search_type" value="trans">
              <label for="trans">译文</label>
            
            <input type="radio" id="book" name="search_type" value="book">
            <label for="book">资料</label>
            <input type="radio" id="notice" name="search_type" value="notice">
            <label for="notice">公告</label>
          </span>
        </div>
      </div>
      
    </section>
    <section class="section-search-results">
      <div id="search-results-count" class="search-results-count"></div>
      <div id="search-hits">
        
      </div>
    </section>
  </div>
</aside>

        
        
            

<section class="bg-cover page-title-section overlay" style="background-image: url('/images/backgrounds/circle.svg'),url('/images/backgrounds/page-title.webp');background-size: cover;">
    <div class="container-xl">
        <div class="row">
            <div class="col-12">
                <p class="h1">
                    博客
                </p>
                <p class="page-description">
                    专注开源技术、云原生与生活随笔的分享与思考。
                </p>
                
            </div>
        </div>
    </div>
</section>

        


<section class="section-sm book-list-section bg-gray">
  <div class="container-xl">
    <div class="row">
      <div class="col-lg-8 order-2 order-lg-1">
        <div class="row">
          
          
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/must-read-for-cloud-native-beginner/">云原生初学者入门必读</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2020/10/18</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f"> 
             云原生
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('云原生初学者入门必读', '这篇文章将助于各位有志于从事云原生领域工作或需要了解该领域背景的人群快速入门 Kubernetes 和云原生。', '\n## 为什么写这篇文章\n\n看到这个标题后，大家可能会问“都已经 2020 年了，Kubernetes 开源有 6 年时间了，为什么还要写一篇 Kubernetes 入门的文章？”我想说的是，Kubernetes 还远远没有达到我们想象的那么普及。众多的开发者，平时忙于各自的业务开发，学习新技术的时间有限；还有大量的学生群体，可能还仅仅停留在“知道有这门技术”的阶段，远远没有入门。这篇文章将助于各位有志于从事云原生领域工作或需要了解该领域背景的人群快速入门 Kubernetes 和云原生。\n\n因为云原生的知识体系过于庞杂，本文主要讲解容器、Kubernetes 及服务网格的入门概念，关于云原生的更多细节将在后续文章中推出。\n\n## 引言\n\n[Kubernetes](https:\/\/kubernetes.io\/) 一词来自希腊语，意思是“飞行员”或“舵手”。这个名字很贴切，Kubernetes 可以帮助你在波涛汹涌的容器海洋中航行。\n\nKubernetes 是做什么的？什么是 Docker？什么是容器编排？Kubernetes 是如何工作和扩展的？你可能还有很多其他的问题，本文将一一为你解答。\n\n这篇文章适合初学者，尤其是那些工作忙碌，没有办法抽出太多时间来了解 Kubernetes 和云原生的开发者们，希望本文可以帮助你进入 Kubernetes 的世界。\n\n简而言之，Kubernetes 提供了一个平台或工具来帮助你快速协调或扩展容器化应用，特别是在 [Docker](https:\/\/docker.com\/) 容器。让我们深入了解一下这些概念。\n\n## 容器和容器化\n\n那么什么是容器呢？\n\n要讨论容器化首先要谈到虚拟机 (VM)，顾名思义，虚拟机就是可以远程连接的虚拟服务器，比如 AWS 的 EC2 或阿里云的 ECS。\n\n接下来，假如你要在虚拟机上运行一个网络应用——包括一个 MySQL 数据库、一个 Vue 前端和一些 Java 库，在 Ubuntu 操作系统 (OS) 上运行。你不用熟悉其中的每一个技术——你只要记住，一个应用程序由各种组件、服务和库组成，它们运行在操作系统上。\n\n现在，将应用程序打包成一个虚拟机镜像，这个镜像中包括了 Ubuntu 操作系统。这使得虚拟机变得非常笨重——通常有几个 G 的大小。\n\n虚拟机镜像包含了整个操作系统及所有的库，对应用程序来说，这个镜像过于臃肿，其中大部分组件并没有被应用程序直接调用。如果你需要重新创建、备份或扩展这个应用程序，就需要复制整个环境（虚拟机镜像），在新环境中启动应用通常需要几十秒甚至几分钟时间。如果你想单独升级应用中的某个组件，比如说 Vue 应用，就需要重建整个虚拟机镜像。另外，如果你的两个应用依赖同一个底层镜像，升级底层镜像会同时影响这两个应用，而有时候，你只需要升级其中一个应用的依赖而已。这就是所谓的“依赖陷阱”。\n\n解决这个问题的办法就是容器。容器是继虚拟机之后更高层次的抽象，在这层抽象中，整个应用程序的每个组件被单独打包成一个个独立的单元，这个单元就是所谓的容器。通过这种方式，可以将代码和应用服务从底层架构中分离出来，实现了完全的可移植性（在任何操作系统或环境上运行应用的能力）。所以在上面的例子中，Ubuntu 操作系统就是一个单元（容器）。MySQL 数据库是另一个容器，Vue 环境和随之而来的库也是一个容器。\n\n但是，MySQL 数据库是如何自己“运行”的？数据库本身肯定也要在操作系统上运行吧？没错！\n\n更高层次的容器，比如 MySQL 容器，实际上会包含必要的库来与底层的操作系统容器通信和集成。所以你可以把容器看成是整个应用堆栈中的一层，每层都依赖于下层的单元。而这就类似于船舶或港口中集装箱的堆叠方式，每个容器的稳定性都依赖于下面的容器的支持。所以应用容器的核心是一个受控的执行环境。它们允许你从头开始定义整个环境，从操作系统开始，到你要使用的各个版本的库，再到你要添加的代码版本。\n\n与容器相关的一个重要概念是**微服务**。将应用程序的各个组件拆分并打包成独立的服务，这样每个组件都可以很容易地被替换、升级、调试。上面的例子中，我们会为 Vue 前端创建一个微服务，为 MySQL 数据库创建另一个微服务，为 Java 中间件部分创建另一个微服务，以此类推。很明显，微服务与容器化是相辅相成的。\n\n## 从 Docker 开始\n\n现在你已经对容器有一定了解了吧？Docker 是最常用的容器化工具，也是最流行的容器运行时。\n\nDocker 开源于 2013 年。用于打包和创建容器，管理基于容器的应用。所有 Linux 发行版、Windows 和 macOS 都支持 Docker。\n\n还有其他的容器化工具，如 [CoreOS rkt](https:\/\/coreos.com\/rkt\/)、[Mesos Containerizer](http:\/\/mesos.apache.org\/documentation\/latest\/mesos-containerizer\/) 和 [LXC](https:\/\/linuxcontainers.org\/)。但是目前，绝大多数的容器化应用都是在 Docker 上运行的。\n\n## 再到 Kubernetes\n\n首先，简单介绍一下历史。Kubernetes 是 Google 基于其内部容器调度平台 Borg 的经验开发的。2014 年开源，并作为 CNCF（云原生计算基金会）的核心发起项目。\n\n那么 Kubernetes 又跟容器是什么关系呢？让我们再回到上面的例子。假设我们的应用爆火，每天的注册用户越来越多。\n\n现在，我们需要增加后端资源，使浏览我们网站的用户在浏览页面时加载时间不会过长或者超时。最简单的方式就是增加容器的数量，然后使用负载均衡器将传入的负载（以用户请求的形式）分配给容器。\n\n这样做虽然行之有效，但也只能在用户规模有限的情况下使用。当用户请求达到几十万或几百万时，这种方法也是不可扩展的。你需要管理几十个也许是几百个负载均衡器，这本身就是另一个令人头疼的问题。如果我们想对网站或应用进行任何升级，也会遇到问题，因为负载均衡不会考虑到应用升级的问题。我们需要单独配置每个负载均衡器，然后升级该均衡器所服务的容器。想象一下，当你有 20 个负载均衡器和每周 5 或 6 个小的更新时，你将不得不进行大量的手工劳动。\n\n我们需要的是一种可以一次性将变更传递给所有受控容器的方法，同时也需要一种可以轻松地调度可用容器的方法，这个过程还必须要是自动化的，这正是 Kubernetes 所做的事情。\n\n接下来，我们将探讨 Kubernetes 究竟是如何工作的，它的各种组件和服务，以及更多关于如何使用 Kubernetes 来编排、管理和监控容器化环境。为了简单起见，假设我们使用的是 Docker 容器，尽管如前所述，Kubernetes 除了支持 Docker 之外，还支持其他几种容器平台。\n\n## Kubernetes 架构和组件\n\n首先，最重要的是你需要认识到 Kubernetes 利用了“期望状态”原则。就是说，你定义了组件的期望状态，而 Kubernetes 要将它们始终调整到这个状态。\n\n例如，你想让你的 Web 服务器始终运行在 4 个容器中，以达到负载均衡的目的，你的数据库复制到 3 个不同的容器中，以达到冗余的目的。这就是你想要的状态。如果这 7 个容器中的任何一个出现故障，Kubernetes 引擎会检测到这一点，并自动创建出一个新的容器，以确保维持所需的状态。\n\n现在我们来定义一些 Kubernetes 的重要组件。\n\n当你第一次设置 Kubernetes 时，你会创建一个集群。所有其他组件都是集群的一部分。你也可以创建多个虚拟集群，称为命名空间 (namespace)，它们是同一个物理集群的一部分。这与你可以在同一物理服务器上创建多个虚拟机的方式非常相似。如果你不需要，也没有明确定义的命名空间，那么你的集群将在始终存在的默认命名空间中创建。\n\nKubernetes 运行在节点 (node) 上，节点是集群中的单个机器。如果你有自己的硬件，节点可能对应于物理机器，但更可能对应于在云中运行的虚拟机。节点是部署你的应用或服务的地方，是 Kubernetes 工作的地方。有 2 种类型的节点——master 节点和 worker 节点，所以说 Kubernetes 是主从结构的。\n\n主节点是一个控制其他所有节点的特殊节点。一方面，它和集群中的任何其他节点一样，这意味着它只是另一台机器或虚拟机。另一方面，它运行着控制集群其他部分的软件。它向集群中的所有其他节点发送消息，将工作分配给它们，工作节点向主节点上的 API Server 汇报。\n\nMaster 节点本身也包含一个名为 API Server 的组件。这个 API 是节点与控制平面通信的唯一端点。API Server 至关重要，因为这是 worker 节点和 master 节点就 pod、deployment 和所有其他 Kubernetes API 对象的状态进行通信的点。\n\nWoker 节点是 Kubernetes 中真正干活的节点。当你在应用中部署容器或 pod（稍后定义）时，其实是在将它们部署到 worker 节点上运行。Worker 节点托管和运行一个或多个容器的资源。\n\nKubernetes 中的逻辑而非物理的工作单位称为 pod。一个 pod 类似于 Docker 中的容器。记得我们在前面讲到，容器可以让你创建独立、隔离的工作单元，可以独立运行。但是要创建复杂的应用程序，比如 Web 服务器，你经常需要结合多个容器，然后在一个 pod 中一起运行和管理。这就是 pod 的设计目的——一个 pod 允许你把多个容器，并指定它们如何组合在一起来创建应用程序。而这也进一步明确了 Docker 和 Kubernetes 之间的关系——一个 Kubernetes pod 通常包含一个或多个 Docker 容器，所有的容器都作为一个单元来管理。\n\nKubernetes 中的 service 是一组逻辑上的 pod。把一个 service 看成是一个 pod 的逻辑分组，它提供了一个单一的 IP 地址和 DNS 名称，你可以通过它访问服务内的所有 pod。有了服务，就可以非常容易地设置和管理负载均衡，当你需要扩展 Kubernetes pod 时，这对你有很大的帮助，我们很快就会看到。\n\nReplicationController 或 ReplicaSet 是 Kubernetes 的另一个关键功能。它是负责实际管理 pod 生命周期的组件——当收到指令时或 pod 离线或意外停止时启动 pod，也会在收到指示时杀死 pod，也许是因为用户负载减少。所以换句话说，ReplicationController 有助于实现我们所期望的指定运行的 pod 数量的状态。\n\n## 什么是 Kubectl？\n\nkubectl 是一个命令行工具，用于与 Kubernetes 集群和其中的 pod 通信。使用它你可以查看集群的状态，列出集群中的所有 pod，进入 pod 中执行命令等。你还可以使用 YAML 文件定义资源对象，然后使用 kubectl 将其应用到集群中。\n\n## Kubernetes 中的自动扩展\n\n请记住，我们使用 Kubernetes 而不是直接使用 Docker 的原因之一，是因为 Kubernetes 能够自动扩展应用实例的数量以满足工作负载的需求。\n\n自动缩放是通过集群设置来实现的，当服务需求增加时，增加节点数量，当需求减少时，则减少节点数量。但也要记住，节点是“物理”结构——我们把“物理”放在引号里，因为要记住，很多时候，它们实际上是虚拟机。\n\n无论如何，节点是物理机器的事实意味着我们的云平台必须允许 Kubernetes 引擎创建新机器。各种云提供商对 Kubernetes 支持基本都满足这一点。\n\n我们再继续说一些概念，这次是和网络有关的。\n\n## 什么是 kubernetes Ingress 和 Egress？\n\n外部用户或应用程序与 Kubernetes pod 交互，就像 pod 是一个真正的服务器一样。我们需要设置安全规则允许哪些流量可以进入和离开“服务器”，就像我们为托管应用程序的服务器定义安全规则一样。\n\n进入 Kubernetes pod 的流量称为 Ingress，而从 pod 到集群外的出站流量称为 egress。我们创建入口策略和出口策略的目的是限制不需要的流量进入和流出服务。而这些策略也是定义 pod 使用的端口来接受传入和传输传出数据 \/ 流量的地方。\n\n## 什么是 Ingress Controller？\n\n但是在定义入口和出口策略之前，你必须首先启动被称为 Ingress Controller（入口控制器）的组件；这个在集群中默认不启动。有不同类型的入口控制器，Kubernetes 项目默认只支持 Google Cloud 和开箱即用的 Nginx 入口控制器。通常云供应商都会提供自己的入口控制器。\n\n## 什么是 Replica 和 ReplicaSet？\n\n为了保证应用程序的弹性，需要在不同节点上创建多个 pod 的副本。这些被称为 Replica。假设你所需的状态策略是“让名为 webserver-1 的 pod 始终维持在 3 个副本”，这意味着 ReplicationController 或 ReplicaSet 将监控活动副本的数量，如果其中有任何一个 replica 因任何原因不可用（例如节点的故障），那么 Deployment Controller 将自动创建一个新的系统（定义如下）。\n\n所需状态是在 deployment 中定义的。Master 节点的中有一个子系统叫做 Deployment Controller，负责实际执行并使当前状态不断趋向于所需状态。\n\n因此，举例来说，如果你目前有 2 个 pod 的副本，而你所希望的状态应该有 3 个，那么 Replication Controller 或 ReplicaSet 会自动检测到这个要求，并指示 Deployment Controller 根据预定义的设置部署一个新的 pod。\n\n## 什么是服务网格？\n\n[服务网格 (Service Mesh)](\/blog\/what-is-a-service-mesh\/) 用于管理服务之间的网络流量，是云原生的网络基础设施层，也是 [Kubernetes 次世代的云原生应用](\/blog\/post-kubernetes-era\/) 的重要组成部分。\n\n服务网格利用容器之间的网络设置来控制或改变应用程序中不同组件之间的交互。下面，我们用一个例子来说明。假设你想测试 Nginx 的新版本，检查它是否与你的 Web 应用兼容。你用新的 Nginx 版本创建了一个新的容器 (Container2)，并从当前容器 (Container1) 中复制了当前的 Nginx webserver 配置。但你不想影响组成 web 应用的其他微服务（假设每个容器对应一个单独的微服务）——就是 MySQL 数据库、Node.js 前端、负载均衡器等。\n\n所以使用服务网格，你可以立即只把 webserver 微服务改成 Container2（新 Nginx 版本的那个）进行测试。如果确定它不能工作，比如因为它导致网站出现一些兼容性问题，那么你就调用服务网格来快速切换回原来的 Container1。而这一切都不需要对其他容器进行任何配置变更——这些变更对其他容器是完全透明的。\n\n如果没有服务网格，对容器来说这项工作将十分繁琐，因为这涉及到逐一更改所有其他容器上的配置，将它们所包含的服务从 Container1 指向 Container2，然后在测试失败后，将它们全部改回来。\n\n在前面这部分 Kubernetes 指南中，我们介绍了一些与 Kubernetes 网络相关的概念。Kubernetes 中的网络可能很棘手，很难理解，如果你刚刚开始，你可能需要一些实践来理解这里。\n\n在下一部分中，我们将展开更多关于 Kubernetes 的话题：如何开始学习 Kubernetes，如何在本地安装和测试 Kubernetes，以及 Kubernetes 的一些优秀的监控工具。\n\n## 如何学习 Kubernetes？\n\n自学 Kubernetes 知识基本上有三种不同的途径，我们在这里只提供了一个指导大纲。\n\n### 一、从零开始学习和安装 Kubernetes\n\n要想真正掌握 Kubernetes，最好的办法莫过于自己从头开始安装 Kubernetes。不过要注意的是，从零开始安装 Kubernetes 并不是一件容易的事情。安装 Kubernetes 并不是简单的“下载文件 -\u003e 点击安装”式的操作，Kubernetes 由多个组件组成，这些组件必须单独安装和配置。而在此之前，你也需要相当的技术储备来做安装前的准备，比如熟悉 Linux 操作系统。如果你决定使用这种方式学习的话，推荐你阅读 [Kubernetes Handbook——Kubernetes 中文指南 \/ 云原生架构实践手册](https:\/\/github.com\/rootsongjc\/kubernetes-handbook)。此外，请记住，尽管 Kubernetes 作为一个开源解决方案在技术上是免费的，但它确实有一些隐藏的成本，只不过对初学者来说可能并不明显。\n\n### 二、Kubernetes 自托管解决方案\n\n这些解决方案样是一些工具和实用程序，大大简化了在本地计算机上安装和配置小型 Kubernetes 集群的任务。它们是学习 Kubernetes 的好方法，同时对于新手来说也不会太难，又足够小巧可以到安装在个人电脑上。最流行的自托管 Kubernetes 工具和环境是 [Minikube](https:\/\/github.com\/kubernetes\/minikube)、[MicroK8s](https:\/\/github.com\/ubuntu\/microk8s)、[Docker Desktop](https:\/\/docs.docker.com\/docker-for-windows\/kubernetes\/) 和 [Kind](https:\/\/github.com\/kubernetes-sigs\/kind)。这些解决方案往往有一些限制，例如，Minikube 只允许创建一个节点。尽管有这些缺点，但这些工具还是非常值得推荐，因为它们将易学性和成本效益结合起来，对于刚开始使用 Kubernetes 的初学者来说，是一个很好的选择。\n\n### 三、云托管的解决方案\n\n如今各大云供应商都提供了定制化的 Kubernetes 解决方案来。你也可以通过线上教学平台如 [Katacoda](https:\/\/katacoda.com\/) 上的免费课程来学习 Kubernetes，它们都是云托管的，你不需要自己安装，只不过你需要云供应商的集群需要付费。\n\n## 本地测试和调试 Kubernetes\n\n作为本地安装 Kubernetes 的一部分，你很可能还需要一些测试和调试能力，以确保一切都在顺利运行，特别是定义入口和出口策略等棘手的任务。此外，还有 Kubernetes 附加组件的生态系统，你可能想使用这些组件来扩展 Kubernetes 集群的功能。添加所有这些都需要进行更多的测试，以确保它们能与你的 Kubernetes 集群完美的集成。\n\n用于在本地开发和调试 Kubernetes 服务的工具有：[Microsoft Bridge to Kubernetes](https:\/\/github.com\/microsoft\/mindaro) 和 [telepresence](https:\/\/github.com\/telepresenceio\/telepresence)。这些工具可以让你在本地运行单个服务，同时将该服务连接到远程 Kubernetes 集群。这样你就可以让自己的本地机器作为 Kubernetes 集群中的一部分来运行——这对于在本地而不是在生产集群上开发服务非常有用。\n\nKubernetes 项目也了解到了 Kubernetes 安装对端到端 (E2E) 测试的需求。为此，项目核心团队一直在确保在最近的版本中更恰当地支持 E2E 测试。这包括诸如允许测试重用和纳入更多附加组件和驱动程序的测试等。\n\n## Kubernetes 监控工具\n\nKubernetes 提供了应用程序在集群的每个层次上的资源使用情况的详细信息——容器、pod、服务。这些详细信息使你能够评估应用程序的性能，确定哪些瓶颈可以解决以提高整体性能。\n\n毕竟，监控可以帮助你了解应用和集群运行情况的详细信息，这对于学习 Kubernetes 是十分有帮助的。\n\nKubernetes 包含两个内置度量收集工具用于监控：[资源管道和全度量管道](https:\/\/kubernetes.io\/docs\/tasks\/debug-application-cluster\/resource-usage-monitoring\/)。资源管道是一个较低级和较有限的工具，主要集中在与各种控制器相关的指标上。全指标管道，顾名思义，从几乎所有集群组件中获取并显示更丰富的指标。\n\n还有一些第三方工具可以安装并集成到 Kubernetes 集群中。对于 Kubernetes 来说，最普遍使用的两个工具是 Prometheus 和 Grafana。\n\n### Prometheus 监控\n\nPrometheus 是一个功能丰富的开源监控和警报工具。Prometheus 包含一个内部数据存储用来收集指标，如生成的时间序列数据。Prometheus 还拥有众多插件，允许它将数据暴露给各种外部解决方案，并从其他数据源导入数据，包括所有主要公有云监控解决方案。\n\n### Grafana 仪表盘\n\nGrafana 是一个优秀的仪表盘、分析和数据可视化工具。它没有 Prometheus 的全功能数据收集能力，但 Prometheus 又没有 Grafana 的数据呈现界面。事实上，他们最好是结合在一起使用——Prometheus 负责数据收集和汇总，Grafana 负责数据展示。它们共同创造了一个强大的组合，涵盖了数据收集、基本警报和可视化。\n\n### 高级警报\n\n对于高级警报，你可以添加 [Nagios](https:\/\/www.nagios.org\/) 或 [Prometheus Alertmanager](https:\/\/github.com\/prometheus\/alertmanager) 等工具。这些警报工具通常有大量的集成。你可以为自定义值班团队，然后定义你想要监控的参数，例如“当任何 pod 不可用时”或“当任何节点无法访问时”、“当容量达到 90%”等，然后通过电子邮件、短信、手机应用提醒、电话呼叫等方式向值班人员发送自定义通知。你还可以创建升级策略，比如，如果一个被定义为“危急”的警报在 10 分钟内没有值班人员确认，那么就将警报升级（发送警报）到该人员的经理。\n\n现在，你应该已经对 Docker 和 Kubernetes 有了大体的认识。了解了 Kubernetes 的作用，知道它是如何进行容器化应用部署和管理的。\n\n调试和监控技术不仅仅是运维需要，你也可以把它当作学习方式。有什么比边做边学更好呢？\n\n请记住，如果你的应用规模太小，而且预计用户需求不会有太大变化或重大波动（比如一个只在公司内部使用的应用），那么 Kubernetes 对你来说可能没有必要，这种情况下，直接使用 Docker 就足够了。\n\n## 更多\n\n云原生领域的开源项目众多（见 [Awesome Cloud Native\/云原生开源项目大全](\/awesome-cloud-native)），其中有大量的优秀项目可供我们学习。此外，Kubernetes 开源已经多年时间，网上有大量的学习资料，业界出版过很多书籍，建议大家通过阅读[官方文档](https:\/\/kubernetes.io)和实践来学习，也可以参考我编写的[Kubernetes Handbook——Kubernetes 中文指南 \/ 云原生架构实践手册](\/book\/kubernetes-handbook)。\n\n推荐大家加入我发起创办的[云原生社区](https:\/\/cloudnative.to)，这是一个立足中国，放眼世界的云原生终端用户社区，致力于云原生技术的传播和应用。云原生社区主办的[云原生学院](https:\/\/github.com\/cloudnativeto\/academy)定期邀请云原生和开源领域的大咖在 B 站上进行直播分享，成员自发组织了多个 SIG（特别兴趣小组）进行讨论学习。欢迎加入我们，共同学习和交流云原生技术。\n', '\/blog\/must-read-for-cloud-native-beginner\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">这篇文章将助于各位有志于从事云原生领域工作或需要了解该领域背景的人群快速入门 Kubernetes 和云原生。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/moving-on-from-ant-group/">新的开始——告别蚂蚁，加入 Tetrate</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2020/08/31</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e9%9a%8f%e7%ac%94"> 
             随笔
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('新的开始——告别蚂蚁，加入 Tetrate', '今天是我在蚂蚁的最后一天，明天我就要在 Tetrate 开始新的学期了。', '\n今天是我加入蚂蚁的第 914 天，也是在[蚂蚁](https:\/\/www.antgroup.com\/)的最后一天，明天就是 9 月 1 日了，这一天通常都是学校开学的日子，在阿里巴巴大家都以”同学”相称，明天我将加入 [Tetrate](https:\/\/tetrate.io)，这也算开始我的新学期吧！\n\n## 蚂蚁\/阿里巴巴与云原生社区\n\n迄今为止，蚂蚁\/阿里巴巴集团对我的职业生涯产生了深远影响，尤其是它的企业文化和价值观，阿里巴巴招聘的理念的“寻找同路人”，在创建云原生社区的过程，不也是寻找同路人的过程吗？[云原生社区](https:\/\/cloudnative.to)就像一个小型社会，我不求它有多大的社会价值，只求它可以对个人、对企业、对社会带来微小而美好的改变。我不断得思考作为个人、员工。尤其是社区的发起人，我的使命到底是什么？我在公司中应该担当什么样的角色？这个社区要走向何方？我在摸索中前进，但是因为有你们的支持，使我更加坚定，致力于云原生技术在中国的普及和应用，以外我一个人可能走得更快，但现在与社区在一起，我们将走得更远！\n\n![2019 年 6 月 24 日，上海，KubeCon China 2019](20190624.jpg)\n*2019 年 6 月 24 日，上海，KubeCon China 2019*\n\n## 加入 Tetrate\n\n在过去的两年里，我一直在着力推广 Istio 和 Service Mesh 技术，在蚂蚁集团的资助下，我创办了 ServiceMesher 社区，将 Service Mesh 技术带到了中国，接下来我希望将中国实践带到世界。当然还有今年疫情期间成立的[云原生社区](https:\/\/cloudnative.to)，向开发者和大众普及云原生知识和应用。\n\n作为 Developer Advocate，最重要的一点是不要停止学习，同时要善于倾听和总结。在过去的两年里，我看到无数人对 Service Mesh 表现出浓厚的兴趣，但因对新技术的风险了解的不足及知识匮乏而无从下手。我十分兴奋加入这家专注于 Service Mesh 的初创公司 [Tetrate](https:\/\/tetrate.io)，这是一家全球化远程办公的初创公司，公司的产品围绕开源 [Istio](https:\/\/istio.io)、[Envoy](https:\/\/envoyproxy.io) 和 [Apache SkyWalking](https:\/\/skywalking.apache.org\/) 等开源项目构建，致力于打造云原生的网络基础设施。这里有这些开源项目的多位 Maintainer，如 [吴晟](https:\/\/twitter.com\/wusheng1108)、[Zack Butcher](https:\/\/twitter.com\/ZackButcher)、[周礼赞](https:\/\/twitter.com\/zlizan) 等，我相信跟他们一起，可以帮助大家快速、有效的了解和应用 Service Mesh，跨向云原生。\n\n## 写在最后\n\n今年年初在筹备云原生社区的时候，我就确定了未来三年内的工作方向——云原生、开源和社区。在追求梦想的道路上充满荆棘，不仅需要勇气和毅力，还需要你们做我坚强的后盾，我一定披荆斩棘，一往无前。开源是世界的，要想让世界更理解我们，我们必须更加主动地融入这个世界。希望中国开源的明天会更好，希望 Service Mesh 技术在中国更好的落地，希望云原生能够普惠大众，希望大家都可以找到自己的使命。\n\nTetrate 目前也在[招聘](\/job\/tetrate)中，欢迎投递简历。\n\n', '\/blog\/moving-on-from-ant-group\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">今天是我在蚂蚁的最后一天，明天我就要在 Tetrate 开始新的学期了。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/post-kubernetes-era/">Kubernetes 次世代的云原生应用</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2020/06/01</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f"> 
             云原生
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Kubernetes 次世代的云原生应用', 'Kubernetes 的次世代在于解决 Kubernetes 生态的碎片化问题。', '\nKubernetes 自开源至今已经走过六个年头了，[云原生时代](https:\/\/cloudnative.to\/blog\/cloud-native-era\/)也已到来，我关注云原生领域也四年有余了，最近开始思考云原生的未来走向，特此撰写本文作为[《云原生应用白皮书》](https:\/\/jimmysong.io\/guide-to-cloud-native-app)的开篇，更多关于云原生应用的介绍请转到白皮书中浏览。\n## 重点\n\n- 云原生基础设施已渡过了野蛮生长期，正朝着统一应用标准方向迈进。\n- Kubernetes 的原语无法完整描述云原生应用体系，且在资源的配置上开发与运维功能耦合严重。\n- Operator 在扩展了 Kubernetes 生态的同时导致云原生应用碎片化，亟需一个统一的应用定义标准。\n- OAM 的本质是将云原生应用定义中的研发、运维关注点分离，资源对象进行进一步抽象，化繁为简，包罗万象。\n- “Kubernetes 次世代”是指在 Kubernetes 成为基础设施层标准之后，云原生生态的关注点正在向应用层过度，近两年来火热的 Service Mesh 正是该过程中的一次有力探索，而基于 Kubernetes 的云原生**应用**架构的时代即将到来。\n\nKubernetes 已成为云原生应用的既定运行平台，本文以 Kubernetes 为默认平台展开，包括云原生应用的分层模型。\n\n## 云原生的不同发展阶段\n\nKubernetes 从开源至今已经走过快[六个年头](https:\/\/jimmysong.io\/cloud-native\/memo\/open-source\/)（2014 年 6 月开源）了，可以说是 Kubernetes 的诞生开启了整个云原生的时代。我粗略的将云原生的发展划分为以下几个时期。\n\n![云原生的发展阶段](cloud-native-stages.png)\n\n**第一阶段：孵化期（2014 年）**\n\n2014 年，Google 开源 Kubernetes，在此之前的 2013 年，Docker 开源，DevOps、微服务已变得十分流行，云原生的概念已经初出茅庐。在开源了 Kubernetes 之后，Google 联合其他厂商发起成立了 CNCF，并将 Kubernetes 作为初创项目捐献给了 CNCF。CNCF 作为云原生的背后推手，开始推广 Kubernetes。\n\n**第二阶段：高速发展期（2015 年 - 2016 年）**\n\n这几年间，Kubernetes 保持着高速发展，并于 2017 年打败了 Docker Swarm、Mesos，确立了容器编排工具领导者的地位。CRD 和 Operator 模式的诞生，大大增强了 Kubernetes 的扩展性，促进了周边生态的繁荣。\n\n**第三阶段：野蛮生长期（2017 年 - 2018 年）**\n\n2016 年之后的云原生基本都默认运行在 Kubernetes 平台上，2017、2018 年 Google 主导的 Istio、Knative 相继开源，这些开源项目都大量利用了 Kubernetes 的 Operator 进行了扩展，Istio 刚发布时就有 50 多个 CRD 定义。Istio 号称是[后 Kubernetes 时代的微服务](https:\/\/jimmysong.io\/blog\/service-mesh-the-microservices-in-post-kubernetes-era\/)，它的出现第一次使得云原生以服务（应用）为中心。Knative 是 Google 在基于 Kubernetes 之上开源的 Serverless 领域的一次尝试。2018 年 Kubernetes 正式从 CNCF [毕业](https:\/\/www.cncf.io\/blog\/2018\/03\/06\/kubernetes-first-cncf-project-graduate\/)，Prometheus、Envoy 也陆续从 CNCF 毕业。CNCF 也与 2018 年修改了 charter，对云原生进行了重定义，从原来的三要素：”应用容器化；面向微服务架构；应用支持容器的编排调度“，修改为”云原生技术有利于各组织在公有云、私有云和混合云等新型动态环境中，构建和运行可弹性扩展的应用。云原生的代表技术包括容器、服务网格、微服务、不可变基础设施和声明式 API“。这一年，我曾写过两篇 Kubernetes 及云原生发展的年终总结和展望，见 [2017 年](https:\/\/jimmysong.io\/kubernetes-handbook\/appendix\/kubernetes-and-cloud-native-summary-in-2017-and-outlook-for-2018.html)和 [2018 年](https:\/\/jimmysong.io\/kubernetes-handbook\/appendix\/kubernetes-and-cloud-native-summary-in-2018-and-outlook-for-2019.html)的预测和总结。\n\n**第四阶段：普及推广期（2019 年至今）**\n\n经过几年的发展，Kubernetes 已经得到的大规模的应用，云原生的概念开始深入人心，Kubernetes 号称是云原生的操作系统，基于 Operator 模式的生态大放异彩。整合 Kubernetes 和云基础设施，研发和运维关注点分离。Kubernetes 到 Service Mesh（后 Kubernetes 时代的微服务），基于 Kubernetes 的 Serverless 都在快速发展，OAM 诞生，旨在定义云原生应用标准。\n\n## Kubernetes 开辟了云原生时代\n\nKubernetes 开源之初就继承了 Google 内部调度系统 Borg 的经验，屏蔽掉了底层物理机、虚拟机之间的差异，经过几年时间的发展成为了容器编排标准，进而统一了 PaaS 平台的基础设施层。\n\n下图是 Kubernetes 原生内置的可以应用到一个 Pod 上的所有控制器、资源对象等。\n\n![Kubernetes 概念](kubernetes-concepts.png)\n\n图片来自图书 [Kubernetes Patterns（O’Reilly）](https:\/\/www.redhat.com\/cms\/managed-files\/cm-oreilly-kubernetes-patterns-ebook-f19824-201910-en.pdf)\n\nKubernetes 作为云原生基础设施设计之初遵循了以下原则：\n\n1. 基础设施即代码（声明式 API）\n1. 不可变基础设施\n1. 幂等性\n1. 调节器模式（Operator 的原理）\n\n其中声明式 API 可谓开创了云原生时代的基调，而调节器模式是 Kubernetes 区别于其他[云部署形式](https:\/\/jimmysong.io\/cloud-native-infra\/evolution-of-cloud-native-developments.html)的主要区别之一，这也为后来的 [Operator 框架的诞生](https:\/\/zhuanlan.zhihu.com\/p\/54633203)打下了基础。\n\n### 声明式 API\n\n根据声明式 API 可以做应用编排，定义组件间的依赖，通常使用人类易读的 YAML 文件来表示。但是，YAML 文件声明的字段真的就是最终的状态吗？有没有可能动态改变？\n\n我们在创建 \u0060Deployment\u0060 时会指定 Pod 的副本数，但是其实际副本数并不一定是一成不变的。假如集群中还有定义 HPA，那么 Pod 的副本数就可能随着一些外界因素（比如内存、CPU 使用率或者自定义 metric）而改变，而且如果集群中还有运行自定义的控制器话，那么也有可能修改应用的实例数量。在有多个控制器同时控制某个资源对象时，如何确保控制器之间不会发生冲突，资源对象的状态可预期？可以使用[动态准入控制](https:\/\/kubernetes.io\/zh\/docs\/reference\/access-authn-authz\/extensible-admission-controllers\/#monitoring-admission-webhooks)来达到这一点。\n\n### Kubernetes 原生应用\n\n我们都知道要想运行一个应用至少需要以下几点：\n\n- 应用的业务逻辑（代码）、运行时（可运行的二进制文件、字节码或脚本）。\n- 应用的配置注入（配置文件、环境变量等），身份、路由、服务暴露等满足应用的安全性和可访问性。\n- 应用的生命周期管理（各种 Controller 登场）。\n- 可观测性、可运维、网络和资源及环境依赖、隔离性等。\n\n下图展示了基于 Kubernetes 原语及 PaaS 平台资源的 Kubernetes 原生应用的组成。\n\n![Kubernetes 原生应用](kubernetes-native-application-motion.gif)\n\n我们都知道 Kubernetes 提供了大量的[原语](https:\/\/kubernetes.io\/docs\/concepts\/)，用户可以基于这些原语来编排服务，管理应用的生命周期。上图展示的是基于 Kubernetes 原生应用可以使用的 Kubernetes 原语、扩展及平台层资源，从内向外的对象跟应用程序（业务逻辑）的关联度依次降低，到最外层基本只剩下平台资源依赖，已经与 Kubernetes 几乎没有关系了。该图里仅展示了部分资源和对象（包含阿里巴巴开源的 [OpenKruise](https:\/\/github.com\/openkruise\/kruise)、Istio），实际上 [Operator](https:\/\/operatorhub.io\/) 资源之丰富，也是 Kubernetes 生态如此繁荣的原因之一。\n\nKubernetes 本身的原语、资源对象、配置、常用的 CRD 扩展有几十、上百个之多。开发者需要了解这些复杂的概念吗？我只是想部署一个应用而已！不用所对于应用开发者，即使对于基础实施开发和运维人员也需要很陡峭的学习曲线才能完全掌握它。\n\n我将 Kubernetes 原生应用所需要的定义和资源进行了分层：\n\n- **核心层**：应用逻辑、服务定义、生命周期控制；\n- **隔离与服务访问层**：资源限制与隔离、配置、身份、路由规则等；\n- **调度层**：各种调度控制器，这也是 Kubernetes 原生应用的主要扩展层；\n- **资源层**：提供网络、存储和其他平台资源；\n\n而这些不同的层，完全可以将其职责分配给相应的人员，比如核心层是由应用程序开发者负责，将其职责分离，可以很大程度上降低开发和运维的复杂度。\n\n云原生应用落实到 Kubernetes 平台之上，仅仅利用 Kubernetes 的对象原语已很难描述一个复杂的应用程序，所以诞生了各种各样的 Operator，但这也仅仅解决了单个应用的定义，对于应用的打包封装则无能为力。\n\n同一个资源对象又有多种实现方式，比如 Ingress 就有 [10 多种实现](https:\/\/docs.google.com\/spreadsheets\/d\/1DnsHtdHbxjvHmxvlu7VhzWcWgLAn_Mc5L1WlhLDA__k\/edit#gid=0)，PV 就更不用说，对于对于开发者究竟如何选择，平台如何管理，这都是让人很头疼的问题。而且有时候平台所提供的扩展能力还可能会有冲突，这些能力有的可能互不相干，有的可能会有正交，有的可能完全重合。且应用本身与运维特性之间存在太多耦合，不便于复用。\n\n![资源交集动画](resources-motion.gif)\n\n上图中不同颜色的方框代表不同的资源类别，红线框代表不能为一个资源同时应用该配置，否则会出现冲突，不同的颜色上面是一个动画，展示的是部分资源组合。图中仅包含了部分 Kubernetes 中的原语和 Istio 中的资源对象组合及自定义扩展，实际上用户可以根据应用的自身特点，基于 Kubernetes 原语和 CRD 创建出千变万化的组合。\n\n为了管理这些应用诞生出了众多的 [Operator](https:\/\/github.com\/operator-framework\/awesome-operators)。Kubernetes 1.7 版本以来就引入了[自定义控制器](https:\/\/kubernetes.io\/docs\/concepts\/api-extension\/custom-resources\/)的概念，该功能可以让开发人员扩展添加新功能，更新现有的功能，并且可以自动执行一些管理任务，这些自定义的控制器就像 Kubernetes 原生的组件一样，Operator 直接使用 Kubernetes API 进行开发，也就是说它们可以根据这些控制器内部编写的自定义规则来监控集群、更改 Pods\/Services、对正在运行的应用进行扩缩容。\n\nOperator 的本质是一种调节器模式（Reconciler Pattern）的应用，跟 Kubernetes 本身的实现模式是一样的，用于管理云原生应用，协调应用的实际状态达到预期状态。\n\n调节器模式的四个原则：\n\n1. 所有的输入和输出都使用数据结构。\n1. 确保数据结构是不可变的。\n1. 保持资源映射简单。\n1. 使实际状态符合预期状态。\n\n## 云原生应用走向碎片化\n\n利用声明式 API 及调节器模式，理论上可以在 Kubernetes 上部署任何可声明应用，但是在 Operator 出现之前，管理 Kubernetes 上的有状态应用一直是一个难题，随着 Operator 模式的确立，该难题已得以解决，并促进了 Kubernetes 生态的进一步发展。随着该生态的繁荣，有一种碎片化的特征正在显现。\n\n**云原生应用碎片化的体现**\n\n- Operator 模式将运维人员的反应式经验转化成基于 \u0060Reconcile\u0060 模式的代码，统一了有状态应用的管理模式，极大得扩展了 Kubernetes 应用生态。\n- 开发者在引用 Operator 所提供的能力时没有统一的视图，加大了基础设施运维与开发者之间的沟通成本。\n- Operator 总体上治理松散，没有统一的管控机制，在同时应用时可能导致互相冲突或无法预期的结果发生。\n\n\n### 有状态应用管理难题\n\nKubernetes 对于无状态应用的管理很出色，但是对于有状态应用就不是那么回事了。虽然 StatefulSet 可以帮助管理有状态应用，但是这还远远不够，有状态应用往往有复杂的依赖。声明式的 API 里往往要加载着大量的配置和启动脚本，才能实现一个复杂应用的 Kubernetes 化。\n\n例如在 2017 年初，Operator Framework 出现之前，需要使用大量的 \u0060ConfigMap\u0060、复杂的启动脚本才能[在 Kubernetes 上定义 Hadoop YARN](https:\/\/jimmysong.io\/kubernetes-handbook\/guide\/migrating-hadoop-yarn-to-kubernetes.html) 和[运行 Spark](https:\/\/jimmysong.io\/kubernetes-handbook\/usecases\/running-spark-with-kubernetes-native-scheduler.html)。虽然 [\u0060StatefulSet\u0060](https:\/\/kubernetes.io\/docs\/concepts\/workloads\/controllers\/statefulset\/) 号称可以解决有状态应用的部署问题，但是它主要是保证了 Pod 的在启动、伸缩时的顺序和使 Pod 具有稳定的标识。但是很多分布式应用来说并不仅依靠启动顺序就可以保证其状态，根据其在分布式应用中的角色不同（master\/worker）而需要有大量的自定义配置，在没有 Operator 之前这些配置通常是通过一些自定义脚本来实现，这些脚本可能存在于应用镜像中，也可以通过 \u0060ConfigMap\u0060 挂在到容器运行时，但无论如何这些脚本都可能因为散落在各处，这些脚本还是面向过程的，跟在 Kubernetes 诞生之前的运维方式毫无二致，这极其不便于版本控制和运维管理。\n\n### Operator 统一了 Kubernetes 应用运维框架\n\nOperator 大大增强了 Kubernetes 的可扩展性，丰富了以 Kubernetes 为基础的云原生生态，许多原先不是为 Kubernetes 而构建的应用纷纷通过[构建自己的 Operator](https:\/\/zhuanlan.zhihu.com\/p\/54633203) 迁移到 Kubernetes 上。还有一些直接基于 Kubernetes 构建的 Service Mesh、Serverless 框架，它们应用 Operator 模式（如 [Istio](https:\/\/istio.io)、[Knative](https:\/\/knative.dev)），试图成为云原生应用的基础设施层，补齐 Kubernetes 在服务治理、无服务架构等方面的短板，随着大量的 CRD、Operator 控制器的出现，而 Kubernetes 却无法以应用的视角来管理这些能力及其背后零散的 CRD，这使得云原生应用碎片化。\n\nOperator 百花齐放，在没有一个大一统的视图之前，各个控制器之间存在着这样的关系：\n\n- **独立**：互不干涉，比如 Controller 与服务发现之间就不存在冲突。\n- **可组合**：例如 \u0060Service\u0060、\u0060VirtualService\u0060、\u0060DestinationRule\u0060 同属一类资源（可访问性与路由），就是可组合的（后两者是 Istio 中的 CRD，用于流量管理）。\n- **有冲突**：例如图中的 \u0060CronHorizontalPodAutoscaler\u0060（CRD）、\u0060HorizontalPodAutoscaler\u0060（Kubernetes 内置），同时使用可能导致无法意料的情况发生。\n\n正是以为这样复杂的关系，导致其无法做到开箱即用，还需要基础设施团队基于云原生社区和生态自己构建出来的，比如[应用交付领域](https:\/\/jimmysong.io\/awesome-cloud-native\/#application-delivery)的系列开源项目。\n\n## 云原生应用管理工具 Helm\n\nKubernetes 之上有很多能力缺失，比如应用构建、发布、管理和运维等，Helm 的出现主要补偿了应用打包和版本管理的缺陷。其中云原生应用的配置包括：\n\n- 应用程序启动时加载的配置文件；\n- 应用程序的运维配置，如资源申请限额；\n- 应用程序的服务发现配置；\n- 应用程序的工作负载、发布策略、依赖等；\n\n这些配置可以存在于 \u0060ConfigMap\u0060、\u0060Deployment\u0060、\u0060Service\u0060、\u0060Ingress\u0060 等 Kubernetes 的多个资源文件中，如何保证应用程序的复用性？应用程序之间有依赖该如何解决？这是时候你可能自然的想到了 Helm。\n\n云原生应用打包和发布管理\n\n- Helm 通过 chart 模板，提高了应用程序的复用性并解决了部分依赖问题；\n- Chart 仓库提供了云原生应用程序的统一管控视图；\n- \u0060Release\u0060 概念的引入，使得云原生应用版本化管理进一步加强；\n\nHelm 主要关注的是 [12 因素应用](https:\/\/12factor.net\/zh_cn\/)法则[构建、发布、运行](https:\/\/12factor.net\/zh_cn\/build-release-run)这一原则中的”发布”这一环节。下图是 Helm v3 的架构图。\n\n![Helm3 架构](helm-chart.png)\n\nHelm 可以安装本地或者远程的 chart，当 chart 安装到 Kubernetes 中后就会创建一个 release，每次更新该 chart 的配置并执行 \u0060helm upgrade\u0060，release 的版本数就会加 1，开发者可以升级 chart 或回滚到历史版本。\n\n### 打包、配置和发布\n\nHelm 和 chart 的主要作用是：\n\n- 应用程序封装\n- 版本管理\n- 依赖检查\n- 便于应用程序分发\n\n**打包**\n\nHelm 采用 [Chart](https:\/\/helm.sh\/docs\/topics\/charts\/) 的格式来标准化描述应用，可以将目录打包成版本化的压缩包进行部署理论上一个 Chart 是可以嵌套若干个 Chart 并定义依赖关系，组织形式非常灵活。Helm chart 用于打包 Kubernetes 原生应用。\n\n**配置**\n\n应用配置参数，在 Chart 中由 \u0060values.yaml\u0060 和命令行参数组成。Chart 采用 Go Template 的特性和 \u0060values.yaml\u0060 对部署的模板文件进行参数渲染，也可以通过 \u0060helm\u0060 命令 \u0060--set key=value\u0060 的方式进行参数赋值。\n\n**发布**\n\nRelease 代表 Chart 在集群中的运行实例，Helm 围绕 Release 对应用提供了强大的生命周期管理能力，包括 Release 的查询、安装、更新、删除、回滚等。\n\n## 云原生应用\n\n以上关注的点都是基于 Kubernetes 原语的实现，虽然基于 Kubernetes 构建的 PaaS 平台部分屏蔽了底层基础设施的差异，但是仍有很多云服务是无法通过 Kubernetes 创建，或者需要提前创建供 Kubernetes 原生应用使用的，这些应用通常不运行在 Kubernetes 集群中。因此创建和管理一个云原生应用程序需要考虑以下方面：\n\n- 运行时：ECS、Docker、KataContainer、gVisor 等；\n- 资源隔离性：多租户、VPC、Namespace、防火墙；\n- 资源调度：各种类型的 controller；\n- 网络可达性：Service、Ingress、Egress、Gateway、VirtualService、DestinationRule、LoadBalancer、ServiceEntry 等；\n- 可观测性：日志、分布式追踪、指标；\n- 安全性：SecurityPolicy、NetworkPolicy、AuthorizationPolicy；\n- 平台资源申请：数据库、存储等；\n- 运行与隔离：ECS、Docker、KataContainer 等；\n- 资源分配和调度：各种控制器；\n- 环境隔离：Namespace、多租户、VPC、防火墙、LimitRange、Resources；\n- 可访问性：Service、Ingress、Egress、Gateway、LoadBalancer、VirtualService、DestinationRule、ServiceEntry；\n- 状态管理：Operator；\n- 可观测性：日志、监控、指标；\n- 安全性：SecurityPolicy、ServiceAccount；\n\n### 云原生应用分层模型\n\n那么究竟如何来给云原生应用分层，化繁就简？近几年来，基于 Kubernetes 的应用呈爆炸式发展，光是在[应用交付领域](https:\/\/jimmysong.io\/awesome-cloud-native\/#application-delivery)的开源项目就达几十个之多。下图展示我根据这些项目的特性而绘制的 App Delivery Landscape。\n\n![云原生应用的分层模型](cloud-native-app.png)\n\n- **应用定义和包装**：云原生应用的最上层，直接定义云原生应用的组成形式，解决云原生应用之间的依赖关系，并封装成发布包，如 Helm、CNAB，还有云原生变成语言 Pulumi 和 Ballerina，基于 API 的方式来编排云原生应用；\n- **负载定义**：基于 Kubernetes Operator，大多是 Serverless 负载，既负责了负载的定义又负责了生命周期管理。[Istio](https:\/\/istio.io) 是比较特殊的存在，它不仅管理服务间的流量，还负责安全性、可观测性。\n- **应用发布和上线**：关注应用的构建和发布、GitOps、发布策略等，这也是云原生应用全景中最丰富的部分之一；\n- **Kubernetes 原语**：Kubernetes 本身提供的原语，Operator 基于此构建；\n\n以上为我个人分类的云原生应用全景模型，仅限于 Kubernetes 之上的应用，对于其他非 Kubernetes 应用非本文的考虑范围。另外，CNCF SIG App Delivery 中也给出的云原生应用的分层模型，其模型将非 Kubernetes 应用场景也纳入了考虑，详见：[The Dictionary of Cloud-Native App Delivery](https:\/\/docs.google.com\/document\/d\/1gMhRz4vEwiHa3uD8DqFKHGTSxrVJNgkLG2WZWvi9lXo\/edit#heading=h.h9so53gv5zen)。\n\nPlatform\/Kuberntes，Kubernetes 仅仅是屏蔽了平台的一些差异，但是对于最上层的应用来说，没有涉及，用户需要自己来基于各种开源组件来搭积木。\n\n### OAM（开放应用模型）\n\n那么以上这么多应用有哪些共性，能不能再进一步抽象呢？\n\n- 所有应用是都以容器作为运行时环境（ContainerizedWorkload），这是 OAM 中的核心 Workload 类型；\n- 在应用发布和上线方面，有些是属于应用的运维特征，需要根据实际需求组合和变更，这些是持续变动的部分；\n- 要实现某些复杂的应用管控，需要使用到多个 CRD 的组合，比如 Istio 中的让流量根据百分比切分到不同的而服务，就需要部署 Istio Operator，并声明 \u0060VirtualService\u0060、\u0060DestinationRule\u0060，二者同时使用；\n\n一个 \u0060ApplicationConfiguration\u0060 的 Runtime 的正常流程应该是：\n\n- 应用开发者创建自己的 \u0060Component\u0060，在 \u0060Component\u0060 中描述要应用相关的信息，如应用名称、镜像配置、环境变量等，应用到 Kubernetes cluster 中；\n- 运维创建各种运维策略，如发布策略、网络策略等等，发布时由 AppConfig 对象关联要发布的 \u0060Component\u0060 和本次的运维策略，apply 到集群中，集群的 OAM operator watch 到一次 \u0060ApplicationConfiguration\u0060的下发，生成 \u0060Component\u0060 对应的 \u0060Workload\u0060 和 \u0060Trait\u0060，\u0060Trait\u0060 controller 将本次的 \u0060Trait\u0060 策略应用到本次要管理的 \u0060Workload\u0060 当中，最终到达终态，完成一次发布。\n\nOAM 是对 Kubernetes 友好的，一样采用声明式 API 的理念开发。如果你已经编写了现成的 CRD Operator，可以平滑的接入到 OAM 体系中。OAM 以应用为中心，高度可扩展，扩展点包括：\n\n- Workload：扩展各种运行时类型，不仅限于容器运行时，还可以定义更多其他运行时，比如 Serverless 负载、虚拟机、数据库、网络等；例如，Pod、无服务器函数、数据存储、消息队列或任何其他类型的工作负载，这些都是应用程序开发人员需要设计一个完整的应用程序所需要的，可以直接引用 Kubernetes 的 CRD；\n- Trait：各种运维规则，比如扩缩容、流量控制、安全性；\n\n### 生态\n\n以前 CNCF 的主要关注群体大多是基础设施领域的技术人员，但是自 2019 年 9 月，[CNCF 宣布成立 SIG App Delivery](https:\/\/www.infoq.cn\/article\/Cdw7ISlEqKilGyN9V3Pj) 后，CNCF 正在将应用开发者和运维人员更紧密的联系在一起。[应用交付 SIG](https:\/\/github.com\/cncf\/sig-app-delivery) 的使命是：\n\n- 在与开发、分发、部署、管理和运行安全的云原生应用相关的领域进行合作，目标是以云原生方式交付应用。\n- 发展信息资源，包括指南、教程和白皮书，让社区了解最佳实践和应用交付的价值。\n- 识别合适的项目和现状的差距，定期向 TOC 更新，并以结构化的方式向 TOC 提出行动建议。这包括帮助 TOC 评估和对潜在的新项目进行尽职调查。\n\n目前 OAM 定义的云原生应用模型已有以下项目支持。\n\n- [Crossplane](https:\/\/crossplane.io\/)：这是一个开源的 Kubernetes 扩展组件，适用于主流公有云平台，使用 \u0060kubectl\u0060 配置和管理基础架构、服务和应用。对于 OAM 的支持详见运行应用程序。\n- KPT：Kpt（发音为 \u0022keep\u0022）是一个在资源配置之上构建声明性工作流的开源工具。它的 git \u002b YAML 架构意味着它只需与现有的工具、框架和平台一起工作。Kpt 包括了获取、显示、自定义、更新、验证和应用 Kubernetes 配置的解决方案。对 OAM 的支持详见 使用 kpt 来管理由开放应用模型（OAM）定义的自定义 Kubernetes 应用程序。\n\n应用交付领域相关的开源项目还有很多，详见 [Awesome Cloud Native](https:\/\/jimmysong.io\/awesome-cloud-native\/#application-delivery)。\n\n## 总结\n\n基于 Kubernetes 的云原生生态发展至今已有 6 年时间，当前已步入了普及推广阶段。可以说谁云原生应用定义的制高点，就可以掌握云原生的未来。从前我们是新技术浪潮的追随者，现在我们抓住时代的基于，参与标准制定、引领云原生的浪潮！欢迎加入 [OAM 社区](https:\/\/oam.dev\/)，一起参与进来，把国人参与指定的标准推向世界。\n\n## 参考\n\n- [Do you know what’s in Helm 3? - developer.ibm.com](https:\/\/developer.ibm.com\/technologies\/containers\/blogs\/kubernetes-helm-3\/)\n- [O’Reilly: Kubernetes patterns for designing cloud-native apps - redhat.com](https:\/\/www.redhat.com\/cms\/managed-files\/cm-oreilly-kubernetes-patterns-ebook-f19824-201910-en.pdf)\n- [The Dictionary of Cloud-Native App Delivery - docs.google.com](https:\/\/docs.google.com\/document\/d\/1gMhRz4vEwiHa3uD8DqFKHGTSxrVJNgkLG2WZWvi9lXo\/edit#heading=h.h9so53gv5zen)\n- [CNCF 宣布成立应用交付领域小组，正式开启云原生应用时代 - infoq.cn](https:\/\/www.infoq.cn\/article\/Cdw7ISlEqKilGyN9V3Pj)\n- [OAM v1alpha2 新版发布：平衡标准与可扩展性，灵活接入 CRD operator - mp.weixin.qq.com](https:\/\/mp.weixin.qq.com\/s\/c7A8lOdAKkW25GoqmwOgWg)\n- [Kubernetes API 与 Operator，不为人知的开发者战争 - zhuanlan.zhihu.com](https:\/\/zhuanlan.zhihu.com\/p\/54633203)\n- [云原生时代——投资人视角下的云原生趋势思考 - cloudnative.to](https:\/\/cloudnative.to\/blog\/cloud-native-era\/)\n', '\/blog\/post-kubernetes-era\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">Kubernetes 的次世代在于解决 Kubernetes 生态的碎片化问题。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/oam-intro/">OAM（开放应用模型）——定义云原生应用标准的野望</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2020/04/22</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f"> 
             云原生
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('OAM（开放应用模型）——定义云原生应用标准的野望', '本文是对 OAM 及 Rudr 的初探，主要介绍了 OAM 诞生的背景和要解决的问题，同时介绍了它在云原生生态中的作用。', '\n[OAM（Open Application Model）](https:\/\/oam.dev\/)是阿里巴巴和微软共同开源的云原生应用规范模型，同时开源了基于 OAM 的实现 [Rudr](https:\/\/github.com\/oam-dev\/rudr)，自 2019 年 10 月宣布开源以来截止本文发稿已经有快半年时间了。\n\n当前可能大部分人才刚刚开始了解 OAM，所以这篇文章将从最基础出发，为大家介绍 OAM 的诞生背景和要解决的问题，以及它在云原生生态中的作用。\n\n## Takeaways\n\n如果你没有兴趣或者时间阅读下面的全文，那么建议阅读下面这些核心观点：\n\n- OAM 的本质是根据软件设计的“兴趣点分离”原则对负责的 DevOps 流程的高度抽象和封装，这背后还是“**康威定律**”在起作用。\n- OAM 仅定义云原生应用的规范，目前推出的 [Rudr](https:\/\/github.com\/oam-dev\/rudr) 可以看做是 OAM 规范的 Kubernetes 解释器（实验实现），将云原生应用定义翻译成 Kubernetes 的资源对象。\n- OAM 与 [Crossplane](https:\/\/crossplane.io\/) 将展开合作，就 Kubernetes 式以 API 为中心的应用定义发扬光大，并深度参与 [CNCF SIG App Delivery](https:\/\/github.com\/cncf\/sig-app-delivery)，以共同定义云原生应用标准。\n\n\u003e **康威定律（Conway’s Law）**\n\u003e\n\u003e [康威定律](https:\/\/zh.wikipedia.org\/zh-hans\/%E5%BA%B7%E5%A8%81%E5%AE%9A%E5%BE%8B)是马尔文·康威（Melvin Conway）1967 年提出的： \u0022设计系统的架构受制于产生这些设计的组织的沟通结构。\u0022 \n\n## OAM 简介\n\nOAM 全称是 Open Application Model，从名称上来看它所定义的就是一种模型，同时也实现了基于 OAM 的我认为这种模型旨在定义了云原生应用的标准。\n\n- 开放（Open）：支持异构的平台、容器运行时、调度系统、云供应商、硬件配置等，总之与底层无关\n- 应用（Application）：云原生应用\n- 模型（Model）：定义标准，以使其与底层平台无关\n\n顺便说下 CNCF 中的也有几个定义标准的「开源项目」，其中有的项目都已经毕业。\n\n- [SMI（Service Mesh Interface）](https:\/\/github.com\/servicemeshinterface\/smi-spec)：服务网格接口\n- [Cloud Events](https:\/\/github.com\/cloudevents\/spec)：Serverless 中的事件标准\n- [TUF](https:\/\/github.com\/theupdateframework\/specification)：更新框架标准\n- [SPIFFE](https:\/\/github.com\/spiffe\/spiffe)：身份安全标准\n\n这其中唯独没有应用标准的定义，[CNCF SIG App delivery](https:\/\/github.com\/cncf\/sig-app-delivery) 即是要做这个的。当然既然要制定标准，自然要对不同平台和场景的逻辑做出更高级别的抽象（这也意味着你在掌握了底层逻辑的情况下还要学习更多的概念），这样才能屏蔽底层差异。本文将默认底层平台为 Kubernetes。\n\n- 是从管理大量 CRD 中汲取的经验。\n- 业务和研发的沟通成本，比如 YAML 配置中很多字段是开发人员不关心的。\n\n### OAM 基本对象\n\nOAM 模型中包含以下基本对象，以本文发稿时的最新 API 版本 \u0060core.oam.dev\/v1alpha2\u0060 为准：\n\n- [**Component**](https:\/\/github.com\/oam-dev\/spec\/blob\/master\/4.component.md)：OAM 中最基础的对象，该配置与基础设施无关，定义负载实例的运维特性。例如一个微服务 [workload](https:\/\/github.com\/oam-dev\/spec\/blob\/master\/3.workload.md) 的定义。\n- [**TraitDefinition**](https:\/\/github.com\/oam-dev\/spec\/blob\/master\/6.traits.md)：一个组件所需的**运维策略与配置**，例如环境变量、Ingress、AutoScaler、Volume 等。（注意：该对象在 \u0060apiVersion: core.oam.dev\/v1alpha1\u0060 中的名称为 \u0060Trait\u0060）。\n- [**ScopeDefinition**](https:\/\/github.com\/oam-dev\/spec\/blob\/master\/5.application_scopes.md)：多个 Component 的共同边界。可以根据组件的特性或者作用域来划分 Scope，一个 Component 可能同时属于多个 Scope。\n- [**ApplicationConfiguration**](https:\/\/github.com\/oam-dev\/spec\/blob\/master\/7.application_configuration.md)：将 Component（必须）、Trait（必须）、Scope（非必须）等组合到一起形成一个完整的应用配置。\n\n###  OAM API 的演变\n\n因为 OAM 还处在发展早起，API 变化较快，以上四个对象在不同的 API 版本中的 \u0060kind\u0060 名称不同，请大家使用时注意区别。\n\n| 名称                      | core.oam.dev\/v1alpha1    | core.oam.dev\/v1alpha2    |\n| ------------------------- | ------------------------ | ------------------------ |\n| Component                 | ComponentSchematic       | Component                |\n| Trait                     | Trait                    | TraitDefinition          |\n| Scope                     | Scope                    | ScopeDefinition          |\n| Application configuration | ApplicationConfiguration | ApplicationConfiguration |\n\n总的来说，OAM 模型对象的定义格式与 [Kubernetes 对象的类型字段](https:\/\/kubernetes.io\/docs\/concepts\/overview\/working-with-objects\/kubernetes-objects\/#required-fields)相似。关于 OAM 的基本概念模型的更多信息请访问 [Overview and Terminology](https:\/\/github.com\/oam-dev\/spec\/blob\/master\/2.overview_and_terminology.md)。\n\n### OAM 工作原理\n\n下图来自阿里云原生应用平台团队孙健波在 **《OAM:云原生时代的应用模型与 下一代 DevOps 技术》** 中的分享，OAM 的工作原理如下图所示，OAM Spec 定义了云原生应用的规范（使用一些列 CRD 定义），Rudr 可以看做是 OAM 规范的解析器，将应用定义翻译为 Kubernetes 中的资源对象。\n\n![OAM 的原理](oam-principle.png)\n\n可以将上图分为三个层次：\n\n- **汇编层**：即人工或者使用工具来根据 OAM 规范定义汇编出一个云原生应用的定义，其中包含了该应用的工作负载和运维能力配置。\n- **转义层**：汇编好的文件将打包为 YAML 文件，由 Rudr 或其他 OAM 的实现将其转义为 Kubernetes 或其他云服务（例如 Istio）上可运行的资源对象。\n- **执行层**：执行经过转义好的云平台上的资源对象并执行资源配置。\n\n## Rudr\n\nRudr 是对  [OAM v1alpha1](https:\/\/github.com\/oam-dev\/spec\/releases\/tag\/v1.0.0-alpha.1) 在 Kubernetes 环境下的实现，OAM 正在与 [Crossplane](https:\/\/github.com\/crossplane\/) 合作\n\n\u003e **Crossplane**\n\u003e\n\u003e 使用 Kubernetes 社区开创的以 API 为中心的声明式配置和自动化方法，使基础设施和应用管理标准化。官方网站：\u003chttps:\/\/crossplane.io\/\u003e。\n\n### 安装 Rudr\n\n请参考 [Rudr 文档](https:\/\/github.com\/oam-dev\/rudr\/blob\/master\/docs\/setup\/install.md)安装，主要依赖以下组件：\n\n- kubectl\n- helm 3\n- Kubernetes 1.15\u002b\n\n执行下面的命令安装 Rudr 和需要的 trait。\n\n\u0060\u0060\u0060bash\n# 克隆项目\ngit clone https:\/\/github.com\/oam-dev\/rudr.git\ncd rudr\n# 创建一个名为 oam 的 namespace\nkubectl create namespace oam\n# 安装 Rudr\nhelm install rudr .\/charts\/rudr --wait -n oam\n# 要使用 ingress trait，推荐安装 Nginx ingress\nhelm repo add stable https:\/\/kubernetes-charts.storage.googleapis.com\/\nhelm install nginx-ingress stable\/nginx-ingress\n# 要使用 autoscaler trait，安装 HorizontalPodAutoscaler\nhelm repo add kedacore https:\/\/kedacore.github.io\/charts\nhelm repo update\nhelm install keda kedacore\/keda -n oam\n\u0060\u0060\u0060\n\n查看当前 oam namespace 下的所有 pod，你会发现已创建了以下 pod。\n\n \u0060\u0060\u0060bash\n$ kubectl get pod -n oam\nNAME                                              READY   STATUS    RESTARTS   AGE\nkeda-operator-b6466c989-pn25n                     1\/1     Running   0          63m\nkeda-operator-metrics-apiserver-6cf88c468-k5wd8   1\/1     Running   0          63m\nnginx-ingress-controller-787bd69d8-n6v8c          1\/1     Running   15         7d\nnginx-ingress-default-backend-7c868597f4-vvddn    1\/1     Running   2          7d\nrudr-c648c9b7b-knj9b                              1\/1     Running   7          7d\n \u0060\u0060\u0060\n\n## 部署示例\n\n我们使用 OAM 官方提供的教程 [Tutorial: Deploy, inspect, and update a Rudr application and its components](https:\/\/github.com\/oam-dev\/rudr\/blob\/master\/docs\/tutorials\/deploy_and_update.md) 中的 Python [flask](https:\/\/palletsprojects.com\/p\/flask\/) 示例，该示例基于 OAM v1alpha1 API，最新版 API 的示例可以参考 [crossplane-oam-sample](https:\/\/github.com\/oam-dev\/crossplane-oam-sample)。\n\n\u0060\u0060\u0060bash\n# 部署 Component\n\nkubectl apply -f examples\/helloworld-python-component.yaml\n\u0060\u0060\u0060\n\n此时 get pod 会发现并没有创建任何新的 pod，因为 [examples\/helloworld-python-component.yaml](https:\/\/github.com\/oam-dev\/rudr\/blob\/master\/examples\/helloworld-python-component.yaml) 文件中只定义了一个名为 \u0060helloworld-python-v1\u0060 的 \u0060ComponentSchematic\u0060，但是 \u0060ComponentSchematic\u0060 是仅仅是定义了一个组件而已，还无法直接创建 pod 的，还需要创建一个 \u0060ApplicationConfiguration\u0060 将其与 \u0060Trait\u0060 绑定才可以创建应用的 pod。\n\n关于该示例的详细信息请参考 [Python flask 示例](https:\/\/github.com\/oam-dev\/rudr\/blob\/master\/docs\/how-to\/create_component_from_scratch.md)的创建步骤。\n\n### 创建应用配置\n\n在部署了 \u0060ComponentSchematic\u0060 之后我们还需要创建一个 \u0060ApplicationConfiguration\u0060 将其与 \u0060Trait\u0060 资源绑定才可以创建应用。\n\n**当前已有的 Trait**\n\n在安装 Rudr 时已在 oam namespace 中部署了一些 trait，使用下面的命令查看。\n\n\u0060\u0060\u0060bash\n$ kubectl get trait -n oam\nNAME             AGE\nauto-scaler      7d1h\nempty            7d1h\ningress          7d1h\nmanual-scaler    7d1h\nvolume-mounter   7d1h\n\u0060\u0060\u0060\n\n在 [examples\/first-app-config.yaml](https:\/\/github.com\/oam-dev\/rudr\/blob\/master\/examples\/first-app-config.yaml) 中将 \u0060ComponentSchematic\u0060 与 ingress \u0060Trait\u0060 联系起来。一个完整的可部署的应用配置 [examples\/first-app-config.yaml](https:\/\/github.com\/oam-dev\/rudr\/blob\/master\/examples\/first-app-config.yaml) 的内容如下所示：\n\n\u0060\u0060\u0060yaml\napiVersion: core.oam.dev\/v1alpha1\nkind: ApplicationConfiguration\nmetadata:\n  name: first-app\nspec:\n  components:\n    - componentName: helloworld-python-v1 # 引用了上文中的 Component\n      instanceName: first-app-helloworld-python-v1\n      parameterValues:\n        - name: target\n          value: Rudr\n        - name: port\n          value: \u00279999\u0027\n      traits:\n        - name: ingress # Ingress 引用，Rudr 已默认创建\n          properties:\n            hostname: example.com\n            path: \/\n            servicePort: 9999\n\u0060\u0060\u0060\n\n执行下面的命令部署应用。\n\n\u0060\u0060\u0060bash\nkubectl apply -f examples\/first-app-config.yaml -n oam\n\u0060\u0060\u0060\n\n若此时查看 oam namespace 下的 pod 将发现有一个新的 pod 创建。\n\n\u0060\u0060\u0060bash\n$ kubectl get pod -o oam\nNAME                                              READY   STATUS    RESTARTS   AGE\nfirst-app-helloworld-python-v1-69945684c7-wfd82   1\/1     Running   0          16m\n...\n\u0060\u0060\u0060\n\n### 测试\n\n执行下面的命令可以测试刚安装的应用。\n\n\u0060\u0060\u0060bash\n# 将 Python flask 应用的 pod 暴露到本机\nexport POD_NAME=$(kubectl get pods -l \u0022oam.dev\/instance-name=first-app-helloworld-python-v1,app.kubernetes.io\/name=first-app\u0022 -o jsonpath=\u0022{.items[0].metadata.name}\u0022)\nkubectl port-forward $POD_NAME 9999:9999\nForwarding from 127.0.0.1:9999 -\u003e 9999\nForwarding from [::1]:9999 -\u003e 9999\n\u0060\u0060\u0060\n\n在浏览器中访问 \u003chttp:\/\/127.0.0.1:9999\u003e 将看到 \u0060Hello Rudr!\u0060 的输出，这表示测试成功。\n\n## 未来\n\n从以上描述中可以看出 OAM 对于定义云原生应用标准的野望，其目标不仅限于 Kubernetes 之上的又一上层抽象，而是对于一切云服务，在基于资源对象的基础上，Trait 来控制 Kubernetes 中的一众高层次非可调度的资源对象，如 AutoScaler、Volume、Ingress，Istio 中的流量配置对象 VirtualService、DestinationRule 等，还可容纳更多的云服务，对于 Serverless 时代的去基础设施化的思想不谋而合，OAM 与 Crossplane 的合作及 CNCF SIG App Delivery 的未来可期。\n\n## 参考\n\n- [OAM 官方网站 - oam.dev](https:\/\/oam.dev)\n', '\/blog\/oam-intro\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文是对 OAM 及 Rudr 的初探，主要介绍了 OAM 诞生的背景和要解决的问题，同时介绍了它在云原生生态中的作用。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/service-mesh-the-microservices-in-post-kubernetes-era/">Service Mesh——后 Kubernetes 时代的微服务</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2020/04/01</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Service Mesh——后 Kubernetes 时代的微服务', '本文是以前所写内容的重新修订并收录于 ServiceMesher 社区的 Istio Handbook 中，其他章节仍在编纂中。', '\n如果你刚听说 Service Mesh 不久，并试用过 [Istio](https:\/\/istio.io) 的话，那么你可能都会有下面几个疑问：\n\n1. 为什么 Istio 要运行在 Kubernetes 上呢？\n1. Kubernetes 和 Service Mesh 分别在云原生中扮演什么角色？\n1. Istio 扩展了 Kubernetes 的哪些方面？解决了哪些问题？\n1. Kubernetes、xDS 协议（[Envoy](https:\/\/github.com\/envoyproxy\/envoy)、[MOSN](https:\/\/github.com\/mosn\/mosn) 等）与 Istio 之间又是什么关系？\n1. 到底该不该上 Service Mesh？\n\n这一节我们将试图带您梳理清楚 Kubernetes、xDS 协议以及 Istio Service Mesh 之间的内在联系。此外，本节还将介绍 Kubernetes 中的负载均衡方式，xDS 协议对于 Service Mesh 的意义以及为什么说及时有了 Kubernetes 还需要 Istio。\n\n使用 Service Mesh 并不是说与 Kubernetes 决裂，而是水到渠成的事情。Kubernetes 的本质是通过声明式配置对应用进行生命周期管理，而 Service Mesh 的本质是提供应用间的流量和安全性管理以及可观测性。假如你已经使用 Kubernetes 构建了稳定的应用平台，那么如何设置服务间调用的负载均衡和流量控制？\n\nEnvoy 创造的 xDS 协议被众多开源软件所支持，如 [Istio](https:\/\/github.com\/istio\/istio)、[MOSN](https:\/github.com\/mosn\/mosn) 等。Envoy 对于 Service Mesh 或云原生来说最大的贡献就是定义了 xDS，Envoy 本质上是一个 proxy，是可通过 API 配置的现代版 proxy，基于它衍生出来很多不同的使用场景，如 API Gateway、Service Mesh 中的 Sidecar proxy 和边缘代理。\n\n**本节包含以下内容**\n\n- 说明 kube-proxy 的作用。\n- Kubernetes 在微服务管理上的局限性。\n- 介绍 Istio Service Mesh 的功能。\n- 介绍 xDS 包含哪些内容。\n- 比较 Kubernetes、Envoy 和 Istio Service Mesh 中的一些概念。\n\n## 重要观点\n\n如果你想要提前了解下文的所有内容，那么可以先阅读下面列出的本文中的一些主要观点：\n\n- Kubernetes 的本质是应用的生命周期管理，具体来说就是部署和管理（扩缩容、自动恢复、发布）。\n- Kubernetes 为微服务提供了可扩展、高弹性的部署和管理平台。\n- Service Mesh 的基础是透明代理，通过 sidecar proxy 拦截到微服务间流量后再通过控制平面配置管理微服务的行为。\n- Service Mesh 将流量管理从 Kubernetes 中解耦，Service Mesh 内部的流量无需 \u0060kube-proxy\u0060 组件的支持，通过为更接近微服务应用层的抽象，管理服务间的流量、安全性和可观测性。\n- xDS 定义了 Service Mesh 配置的协议标准。\n- Service Mesh 是对 Kubernetes 中的 service 更上层的抽象，它的下一步是 serverless。\n\n## Kubernetes vs Service Mesh\n\n下图展示的是 Kubernetes 与 Service Mesh 中的的服务访问关系（每个 pod 一个 sidecar 的模式）。\n\n![kubernetes 对比 service mesh](kubernetes-vs-service-mesh.png)\n\n**流量转发**\n\nKubernetes 集群的每个节点都部署了一个 \u0060kube-proxy\u0060 组件，该组件会与 Kubernetes API Server 通信，获取集群中的 [service](https:\/\/jimmysong.io\/kubernetes-handbook\/concepts\/service.html) 信息，然后设置 iptables 规则，直接将对某个 service 的请求发送到对应的 Endpoint（属于同一组 service 的 pod）上。\n\n**服务发现**\n\n![Service Mesh 中的服务注册](istio-service-registry.png)\n\nIstio 可以沿用 Kubernetes 中的 service 做服务注册，还可以通过控制平面的平台适配器对接其他服务发现系统，然后生成数据平面的配置（使用 CRD 声明，保存在 etcd 中），数据平面的**透明代理**（transparent proxy）以 sidecar 容器的形式部署在每个应用服务的 pod 中，这些 proxy 都需要请求控制平面来同步代理配置。之所以说是透明代理，是因为应用程序容器完全无感知代理的存在，该过程 kube-proxy 组件一样需要拦截流量，只不过 \u0060kube-proxy\u0060 拦截的是进出 Kubernetes 节点的流量，而 sidecar proxy 拦截的是进出该 Pod 的流量，详见[理解 Istio Service Mesh 中 Envoy Sidecar 代理的路由转发](https:\/\/jimmysong.io\/blog\/envoy-sidecar-routing-of-istio-service-mesh-deep-dive\/)。\n\n**Service Mesh 的劣势**\n\n因为 Kubernetes 每个节点上都会运行众多的 Pod，将原先 \u0060kube-proxy\u0060 方式的路由转发功能置于每个 pod 中，因为有 sidecar 拦截流量会多一次跳转时，增加响应延迟，同时大量的配置分发、配置同步，可能会影响应用性能。为了细粒度地进行流量管理，必将添加一系列新的抽象，从而会进一步增加用户的学习成本，但随着技术的普及，这样的情况会慢慢地得到缓解。\n\n**Service Mesh 的优势**\n\n\u0060kube-proxy\u0060 的设置都是全局生效的，无法对每个服务做细粒度的控制，而 Service Mesh 通过 sidecar proxy 的方式将 Kubernetes 中对流量的控制从 service 一层抽离出来，可以做更多的扩展。\n\n## kube-proxy 组件\n\n在 Kubernetes 集群中，每个 Node 运行一个 \u0060kube-proxy\u0060 进程。\u0060kube-proxy\u0060 负责为 \u0060Service\u0060 实现了一种 VIP（虚拟 IP）的形式。在 Kubernetes v1.0 版本，代理完全在 userspace 实现。Kubernetes v1.1 版本新增了 [iptables 代理模式](https:\/\/jimmysong.io\/kubernetes-handbook\/concepts\/service.html#iptables-代理模式)，但并不是默认的运行模式。从 Kubernetes v1.2 起，默认使用 iptables 代理。在 Kubernetes v1.8.0-beta.0 中，添加了 [ipvs 代理模式](https:\/\/jimmysong.io\/kubernetes-handbook\/concepts\/service.html#ipvs-代理模式)。关于 kube-proxy 组件的更多介绍请参考 [kubernetes 简介：service 和 kube-proxy 原理](https:\/\/cizixs.com\/2017\/03\/30\/kubernetes-introduction-service-and-kube-proxy\/) 和 [使用 IPVS 实现 Kubernetes 入口流量负载均衡](https:\/\/jishu.io\/kubernetes\/ipvs-loadbalancer-for-kubernetes\/)。\n\n### kube-proxy 的缺陷\n\n[kube-proxy 的不足之处](https:\/\/cizixs.com\/2017\/03\/30\/kubernetes-introduction-service-and-kube-proxy\/)：\n\n首先，如果转发的 pod 不能正常提供服务，它不会自动尝试另一个 pod，每个 pod 都有一个健康检查的机制，当有 pod 健康状况有问题时，kubelet 会重启对应的 pod，kube-proxy 会删除对应的转发规则。另外，\u0060nodePort\u0060 类型的服务也无法添加 TLS 或者更复杂的报文路由机制。\n\nKube-proxy 实现了流量在 Kubernetes service 多个 pod 实例间的负载均衡，但是如何对这些 service 间的流量做细粒度的控制，比如按照百分比划分流量到不同的应用版本（这些应用都属于同一个 service，但位于不同的 deployment 上），做金丝雀发布（灰度发布）和蓝绿发布？Kubernetes 社区给出了 [使用 Deployment 做金丝雀发布的方法](https:\/\/kubernetes.io\/docs\/concepts\/cluster-administration\/manage-deployment\/#canary-deployments)，该方法本质上就是通过修改 pod 的 [label](https:\/\/jimmysong.io\/kubernetes-handbook\/concepts\/label.html) 来将不同的 pod 划归到 Deployment 的 Service 上。\n\n## Kubernetes Ingress vs Istio Gateway\n\n上文说到 \u0060kube-proxy\u0060 只能路由 Kubernetes 集群内部的流量，而我们知道 Kubernetes 集群的 Pod 位于 [CNI](https:\/\/jimmysong.io\/kubernetes-handbook\/concepts\/cni.html) 创建的网络中，集群外部是无法直接与其通信的，因此 Kubernetes 中创建了 [ingress](https:\/\/jimmysong.io\/kubernetes-handbook\/concepts\/ingress.html) 这个资源对象，它由位于 Kubernetes [边缘节点](https:\/\/jimmysong.io\/kubernetes-handbook\/practice\/edge-node-configuration.html)（这样的节点可以是很多个也可以是一组）的 Ingress controller 驱动，负责管理**南北向流量**，Ingress 必须对接各种 Ingress Controller 才能使用，比如 [nginx ingress controller](https:\/\/github.com\/kubernetes\/ingress-nginx)、[traefik](https:\/\/traefik.io\/)。Ingress 只适用于 HTTP 流量，使用方式也很简单，只能对 service、port、HTTP 路径等有限字段匹配来路由流量，这导致它无法路由如 MySQL、Redis 和各种私有 RPC 等 TCP 流量。要想直接路由南北向的流量，只能使用 Service 的 LoadBalancer 或 NodePort，前者需要云厂商支持，后者需要进行额外的端口管理。有些 Ingress controller 支持暴露 TCP 和 UDP 服务，但是只能使用 Service 来暴露，Ingress 本身是不支持的，例如 [nginx ingress controller](https:\/\/kubernetes.github.io\/ingress-nginx\/user-guide\/exposing-tcp-udp-services\/)，服务暴露的端口是通过创建 ConfigMap 的方式来配置的。\n\nIstio Gateway 的功能与 Kubernetes Ingress 类似，都是负责集群的南北向流量。Istio \u0060Gateway\u0060 描述的负载均衡器用于承载进出网格边缘的连接。该规范中描述了一系列开放端口和这些端口所使用的协议、负载均衡的 SNI 配置等内容。Gateway 是一种 [CRD 扩展](https:\/\/jimmysong.io\/kubernetes-handbook\/concepts\/crd.html)，它同时复用了 sidecar proxy 的能力，详细配置请参考 [Istio 官网](https:\/\/istio.io\/docs\/reference\/config\/networking\/gateway\/)。\n\n## xDS 协议\n\n下面这张图大家在了解 Service Mesh 的时候可能都看到过，每个方块代表一个服务的实例，例如 Kubernetes 中的一个 Pod（其中包含了 sidecar proxy），xDS 协议控制了 Istio Service Mesh 中所有流量的具体行为，即将下图中的方块链接到了一起。\n\n![Service Mesh 示意图](service-mesh-schematic-diagram.png)\n\nxDS 协议是由 [Envoy](https:\/\/envoyproxy.io\/) 提出的，在 Envoy v2 版本 API 中最原始的 xDS 协议指的是 CDS（Cluster Discovery Service）、EDS（Endpoint Discovery service）、LDS（Listener Discovery Service）和 RDS（Route Discovery Service），后来在 v3 版本中又发展出了 Scoped Route Discovery Service（SRDS）、Virtual Host Discovery Service（VHDS）、Secret Discovery Service（SDS）、Runtime Discovery Service（RTDS）等，详见 [xDS REST and gRPC protocol](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-docs\/xds_protocol)。\n\n下面我们以各有两个实例的 service，来看下 xDS 协议。\n\n![xDS 协议](xds-protocol.png)\n\n上图中的箭头不是流量进入 Proxy 后的路径或路由，也不是实际顺序，而是想象的一种 xDS 接口处理顺序，其实 xDS 之间也是有交叉引用的。\n\n支持 xDS 协议的代理通过查询文件或管理服务器来动态发现资源。概括地讲，对应的发现服务及其相应的 API 被称作 *xDS*。Envoy 通过 **订阅（subscription）** 的方式来获取资源，订阅方式有以下三种：\n\n- **文件订阅**：监控指定路径下的文件，发现动态资源的最简单方式就是将其保存于文件，并将路径配置在 ConfigSource 中的 \u0060path\u0060 参数中。\n- **gRPC 流式订阅**：每个 xDS API 可以单独配置 \u0060ApiConfigSource\u0060，指向对应的上游管理服务器的集群地址。\n- **轮询 REST-JSON 轮询订阅**：单个 xDS API 可对 REST 端点进行的同步（长）轮询。\n\n以上的 xDS 订阅方式详情请参考 [xDS 协议解析](https:\/\/jimmysong.io\/istio-handbook\/concepts\/envoy-xds-protocol.html)。Istio 使用 gRPC 流式订阅的方式配置所有的数据平面的 sidecar proxy。\n\n### xDS 协议要点\n\n最后总结下关于 xDS 协议的要点：\n\n- CDS、EDS、LDS、RDS 是最基础的 xDS 协议，它们可以分别独立更新。\n- 所有的发现服务（Discovery Service）可以连接不同的 Management Server，也就是说管理 xDS 的服务器可以是多个。\n- Envoy 在原始 xDS 协议的基础上进行了一些列扩充，增加了 SDS（秘钥发现服务）、ADS（聚合发现服务）、HDS（健康发现服务）、MS（Metric 服务）、RLS（速率限制服务）等 API。\n- 为了保证数据一致性，若直接使用 xDS 原始 API 的话，需要保证这样的顺序更新：CDS --\u003e EDS --\u003e LDS --\u003e RDS，这是遵循电子工程中的**先合后断**（Make-Before-Break）原则，即在断开原来的连接之前先建立好新的连接，应用在路由里就是为了防止设置了新的路由规则的时候却无法发现上游集群而导致流量被丢弃的情况，类似于电路里的断路。\n- CDS 设置 Service Mesh 中有哪些服务。\n- EDS 设置哪些实例（Endpoint）属于这些服务（Cluster）。\n- LDS 设置实例上监听的端口以配置路由。\n- RDS 最终服务间的路由关系，应该保证最后更新 RDS。\n\n## Envoy\n\nEnvoy 是 Istio Service Mesh 中默认的 Sidecar，Istio 在 Envoy 的基础上按照 Envoy 的 xDS 协议扩展了其控制平面，在讲到 Envoy xDS 协议之前我们还需要先熟悉下 Envoy 的基本术语。下面列举了 Envoy 里的基本术语及其数据结构解析，关于 Envoy 的详细介绍请参考 [Envoy 官方文档](https:\/\/cloudnative.to\/envoy\/)，至于 Envoy 在 Service Mesh（不仅限于 Istio）中是如何作为转发代理工作的请参考网易云刘超的这篇[深入解读 Service Mesh 背后的技术细节 ](https:\/\/www.cnblogs.com\/163yun\/p\/8962278.html)以及[理解 Istio Service Mesh 中 Envoy 代理 Sidecar 注入及流量劫持](https:\/\/jimmysong.io\/blog\/envoy-sidecar-injection-in-istio-service-mesh-deep-dive\/)，本文引用其中的一些观点，详细内容不再赘述。\n\n![Envoy proxy 架构图](envoy-arch.jpg)\n\n### 基本术语\n\n下面是您应该了解的 Envoy 里的基本术语：\n\n- **Downstream（下游）**：下游主机连接到 Envoy，发送请求并接收响应，即发送请求的主机。\n- **Upstream（上游）**：上游主机接收来自 Envoy 的连接和请求，并返回响应，即接受请求的主机。\n- **Listener（监听器）**：监听器是命名网地址（例如，端口、unix domain socket 等)，下游客户端可以连接这些监听器。Envoy 暴露一个或者多个监听器给下游主机连接。\n- **Cluster（集群）**：集群是指 Envoy 连接的一组逻辑相同的上游主机。Envoy 通过服务发现来发现集群的成员。可以选择通过主动健康检查来确定集群成员的健康状态。Envoy 通过负载均衡策略决定将请求路由到集群的哪个成员。\n\nEnvoy 中可以设置多个 Listener，每个 Listener 中又可以设置 filter chain（过滤器链表），而且过滤器是可扩展的，这样就可以更方便我们操作流量的行为，例如设置加密、私有 RPC 等。\n\nxDS 协议是由 Envoy 提出的，现在是 Istio 中默认的 sidecar proxy，但只要实现 xDS 协议理论上都是可以作为 Istio 中的 sidecar proxy 的，例如蚂蚁集团开源的 [MOSN](https:\/\/github.com\/mosn\/mosn)。\n\n## Istio Service Mesh\n\n![Istio service mesh 架构图](istio-mesh-arch.png)\n\nIstio 是一个功能十分丰富的 Service Mesh，它包括如下功能：\n\n- 流量管理：这是 Istio 的最基本的功能。\n- 策略控制：通过 Mixer 组件和各种适配器来实现，实现访问控制系统、遥测捕获、配额管理和计费等。\n- 可观测性：在 sidecar proxy 中实现。\n- 安全认证：Citadel 组件做密钥和证书管理。\n\n### Istio 中的流量管理\n\nIstio 中定义了如下的 [CRD](https:\/\/jimmysong.io\/kubernetes-handbook\/concepts\/custom-resource.html) 来帮助用户进行流量管理：\n\n- **Gateway**：[Gateway](https:\/\/istio.io\/docs\/reference\/config\/networking\/gateway\/) 描述了在网络边缘运行的负载均衡器，用于接收传入或传出的 HTTP \/ TCP 连接。\n- **VirtualService**：[VirtualService](https:\/\/istio.io\/docs\/reference\/config\/networking\/virtual-service\/) 实际上将 Kubernetes 服务连接到 Istio Gateway。它还可以执行更多操作，例如定义一组流量路由规则，以便在主机被寻址时应用。\n- **DestinationRule**：[\u0060DestinationRule\u0060](https:\/\/istio.io\/zh\/docs\/reference\/config\/networking\/destination-rule\/) 所定义的策略，决定了经过路由处理之后的流量的访问策略。简单的说就是定义流量如何路由。这些策略中可以定义负载均衡配置、连接池尺寸以及外部检测（用于在负载均衡池中对不健康主机进行识别和驱逐）配置。\n- **EnvoyFilter**：[\u0060EnvoyFilter\u0060](https:\/\/istio.io\/docs\/reference\/config\/networking\/envoy-filter\/) 对象描述了针对代理服务的过滤器，这些过滤器可以定制由 Istio Pilot 生成的代理配置。这个配置初级用户一般很少用到。\n- **ServiceEntry**：默认情况下 Istio Service Mesh 中的服务是无法发现 Mesh 外的服务的，[\u0060ServiceEntry\u0060](https:\/\/istio.io\/docs\/reference\/config\/networking\/service-entry\/) 能够在 Istio 内部的服务注册表中加入额外的条目，从而让网格中自动发现的服务能够访问和路由到这些手工加入的服务。\n\n## Kubernetes vs xDS vs Istio\n\n在阅读完上文对 Kubernetes 的 \u0060kube-proxy\u0060 组件、xDS 和 Istio 中流量管理的抽象概念之后，下面将带您仅就流量管理方面比较下三者对应的组件\/协议（注意，三者不可以完全等同）。\n\n| Kubernetes | xDS      | Istio Service Mesh |\n| ---------- | -------- | ------------------ |\n| Endpoint   | Endpoint | WorkloadEntry      |\n| Service    | Route    | VirtualService     |\n| kube-proxy | Route    | DestinationRule    |\n| kube-proxy | Listener | EnvoyFilter        |\n| Ingress    | Listener | Gateway            |\n| Service    | Cluster  | ServiceEntry       |\n\n## 总结\n\n如果说 Kubernetes 管理的对象是 Pod，那么 Service Mesh 中管理的对象就是一个个 Service，所以说使用 Kubernetes 管理微服务后再应用 Service Mesh 就是水到渠成了，如果连 Service 你也不想管了，那就用如 [knative](https:\/\/github.com\/knative\/) 这样的 serverless 平台，但这就是后话了。\n\nEnvoy\/MOSN 的功能也不只是做流量转发，以上概念只不过是 Istio 在 Kubernetes 之上新增一层抽象层中的冰山一角，但因为流量管理是服务网格最基础也是最重要的功能，所以这将成为本书的开始。\n\n## 参考\n\n- [深入解读 Service Mesh 背后的技术细节 - cnblogs.com](https:\/\/www.cnblogs.com\/163yun\/p\/8962278.html)\n- [理解 Istio Service Mesh 中 Envoy 代理 Sidecar 注入及流量劫持 - jimmysong.io](https:\/\/jimmysong.io\/blog\/envoy-sidecar-injection-in-istio-service-mesh-deep-dive\/)\n- [kubernetes 简介：service 和 kube-proxy 原理 - cizixs.com](https:\/\/cizixs.com\/2017\/03\/30\/kubernetes-introduction-service-and-kube-proxy\/)\n- [使用 IPVS 实现 Kubernetes 入口流量负载均衡 - jishu.io](https:\/\/jishu.io\/kubernetes\/ipvs-loadbalancer-for-kubernetes\/)\n- [xDS REST and gRPC protocol](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-docs\/xds_protocol)\n', '\/blog\/service-mesh-the-microservices-in-post-kubernetes-era\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文是以前所写内容的重新修订并收录于 ServiceMesher 社区的 Istio Handbook 中，其他章节仍在编纂中。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/the-future-of-cloud-native-applications-with-oam-and-dapr/">[译] 利用 OAM 和 Dapr 的云原生应用的未来</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2020/01/26</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f"> 
             云原生
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://hugomsbarona.medium.com/the-future-of-cloud-native-applications-with-oam-and-dapr-ed5766c8d583" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('利用 OAM 和 Dapr 的云原生应用的未来', '本文介绍了基于 OAM 和 Dapr 的云原生应用的未来。', '\n在 2019 年 11 月 4 日至 8 日于佛罗里达州奥兰多举办的[2019 年微软 Ignite 大会上](https:\/\/www.microsoft.com\/en-us\/ignite)，Azure 首席技术官 Mark Russinovich 介绍了微软开发的两个创新和革命性的项目，旨在解决当今 IT 专业人士和开发人员在试图构建基于微服务的应用程序时的一系列现有问题。这场会议被命名为《基于开放应用模型（OAM）和分布式应用运行时（Dapr）的云原生应用的未来》。\n\n## 开放式应用模型（OAM）\n\n因此，其中一个项目与开放应用模型（OAM）有关。它代表了一个开放的标准，允许我们建立云原生应用程序，与平台无关，并遵循关注点分离的原则，通过将应用程序的定义与应用程序的部署和托管基础设施的细节分离，为我们提供一些好处。\n\n将应用程序的定义与操作细节分开，使应用程序开发人员能够专注于其应用程序的关键要素，并将其从部署地点和方式的操作细节中抽象出来。另外，关注点的分离允许平台架构师开发可重复使用的组件，而应用开发者则专注于将这些组件与他们的代码集成，以快速、轻松地构建可靠的应用。在所有这些方面，OAM 在那些有不同角色的场景中特别有用，比如在下面的图片中，构建和管理应用程序，因为它允许你有一个关注点的分离，所以开发和管理你的应用程序的不同角色可以专注于他们任务的关键因素。\n\n![应用程序开发和部署生命周期中的角色](008i3skNly1gx6tisc22aj30vp0hoq5q.jpg)\n\nOAM 引入了几个概念，组成了你的应用程序。其中一个概念是代表你的应用程序的 Component（组件）。这些组件可能是服务，如 SQL 数据库或带有相应负载均衡器的.NET WebAPI。开发人员可以创建代码，将其打包成一个组件，然后创建清单，描述不同组件和其他应用程序之间的关系。有了这个，你就把组件的实现和这些组件如何在一个完整的分布式应用架构中结合起来的描述分开了。\n\n为了将这些组件转化为具体的应用程序，应用程序运维使用这些组件的配置来形成一个可以被部署的应用程序的具体实例。配置资源是使应用程序运维能够从开发人员提供的组件中运行一个真正的应用程序。\n\n最后一个概念是 Trait（特征），而你使用它们的集合来描述你的应用环境的特征和它的能力，如自动扩展和入口等等。这些特征允许你根据要求和背景，将你的应用程序部署到具有不同特征的不同环境。然后，这些特征可以由基础设施运维进行配置，以满足其环境的独特操作要求。\n\n最后但同样重要的是，该规范在设计上是可扩展的。同样，OAM 使平台提供者能够通过 Trait（特征）系统公开其平台的独特特征，这种方式使应用开发者能够在支持必要特征的地方建立跨平台的应用。\n\n## 分布式应用程序运行时（Dapr）\n\nDapr 是一个可移植的、事件驱动的运行时，它使开发人员能够轻松地建立弹性的、无状态和有状态的微服务应用程序，并在云和边缘上运行，并拥抱语言和开发人员框架的多样性。它遵循**Sidecar 架构**，所以它使用一个连接到你的每个组件的 Sidecar 节点，所以它可以扩展和增强你的应用程序的功能，如服务发现、负载均衡、流量管理等。\n\n使用这种编程模型，开发人员能够创建微服务应用程序，而不需要携带那么多在构建分布式应用程序过程中引入复杂性的因素，如弹性、可扩展性、服务身份和发现、负载均衡、状态管理等等。Dapr 将这些复杂的因素从开发人员那里抽象出来，这样他们就可以专注于他们正在编写的代码。\n\nDapr 的另一个重要方面是与托管我们应用程序的平台有关。Dapr 使我们能够在云端、企业内部、甚至是边缘的多种环境中运行我们的应用程序，包括任何可用于托管应用程序的 Kubernetes 集群。\n\n最后，同样重要的是，Dapr 允许你利用你最喜欢的编程语言来构建你的分布式应用，并克服你在现今的一些服务中可能面临的编程语言和版本的限制，以构建基于微服务的应用。\n\n下面的图片提供了一个使用 Dapr 的微服务应用架构的概述。基本上，你使用你喜欢的编程语言或框架，如 Java、Node.js、Python、.NET Core 等，构建构成你的应用程序的服务，然后你的服务使用其可用的标准 API，并使用 HTTP 或 gRPC 协议与 Dapr 通信。\n\n![使用 Dapr 的微服务应用架构](008i3skNly1gx6tov7gp1j312w0ie40c.jpg)\n\n## 总结\n\n因此，我们有 OAM，它代表了一种规范，允许你定义和建立跨平台的应用程序，在云和边缘上运行，为你提供关注点的分离，让你的团队专注于他们任务和责任的关键要素。\n\n然后，我们把 Dapr 作为一个运行时，通过提供关注点的分离和促进一些影响构建这种应用的复杂性的因素，降低了构建基于微服务的分布式应用的复杂性。此外，Dapr 允许应用程序在 \u0022云和边缘 \u0022计算基础设施之间进行移植，并克服目前开发人员在构建此类应用程序时面临的移植问题。\n\n如果你想获得与这些项目有关的更多细节，请看以下资源。\n\n- [Mark Russinovich 介绍 OAM 和 Dapr 的云原生应用的未来](https:\/\/azure.microsoft.com\/en-au\/resources\/videos\/ignite-2019-mark-russinovich-presents-the-future-of-cloud-native-applications-with-oam-and-dapr\/)\n- 开放应用模式（OAM）官方网站 - \u003chttps:\/\/oam.dev\/\u003e\n- 分布式应用程序运行时（Dapr）官方网站 - \u003chttps:\/\/dapr.io\/\u003e\n', '\/trans\/the-future-of-cloud-native-applications-with-oam-and-dapr\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文介绍了基于 OAM 和 Dapr 的云原生应用的未来。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/cloud-native-service-mesh-istio-book/">云原生服务网格 Istio 图书</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2019/08/03</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('云原生服务网格 Istio 图书', '云原生服务网格 Istio（华为云原生技术丛书）图书读后感，原理、实践、架构与源码解析（张超盟、章鑫、徐中虎、徐飞编著）。', '\n[《云原生服务网格 Istio：原理、实践、架构与源码解析（张超盟、章鑫、徐中虎、徐飞编著）》](https:\/\/item.jd.com\/12538407.html)是 2019 年国内出版的第四本 Istio 相关图书，前三本分别是：\n\n- [深入浅出 Istio：Service Mesh 快速入门与实践，崔秀龙 著](https:\/\/item.jd.com\/12527008.html)\n- [Service Mesh 实战：用 Istio 软负载实现服务网格，周遥 著](https:\/\/item.jd.com\/12516473.html)\n- [Istio 入门与实战，毛广献 著](https:\/\/item.jd.com\/12601120.html)\n\n在这四本书刚上市时我都获得了作者的赠书，这本书是由四位华为的同学编写，于 2019 年  7 月第一次印刷，全书共 24 章，606 页，售价 139 元。我是在 KubeCon China 2019 的上海大会现场张超盟亲手赠与我的，张超盟也是 2018 年第三届 Service Mesh Meetup 的讲师。\n\n![右侧是云原生服务网格 Istio（华为云原生技术丛书）作者之一张超盟](006tNc79ly1g60ml3q3i4j30xc0m8wg2.jpg)\n\n## 本书结构\n\n全书共分四个篇章，24 个章节，606 页，每个章节的页数占比统计如下图所示。\n\n![云原生服务网格 Istio：原理、实践、架构与源码解析》图书章节页数占全书百分比 - 表格](006tNc79ly1g5nsbm4pkej30u00uj0vw.jpg)\n\n![《云原生服务网格 Istio：原理、实践、架构与源码解析》图书章节页数占全书百分比 - 饼图](006tNc79ly1g60mjr3lirj30v20u0q5g.jpg)\n\n从统计结果中可以看出书中第 3 章（非侵入的流量治理）、第 14 章（司令官 Pilot）一共占全书的页数百分比为 24%，几乎占了四分之一的篇幅。\n\n这本书是目前（2019 年 08 月 15 日）市面上能买到的最全的一本 Istio 相关的图书了，话说国外还一本 Istio 的书也出来，国内到现在都出了四本了，是不是有种墙外开花墙内香的感觉？\n\n建议大家结合 [Istio 官方文档](https:\/\/istio.io)一起来看这本书，Istio 版本更新虽然没有 Kubernetes 那么快，但是在本书发行一个多月后也要发布 1.2 版本了，欢迎大家加入 ServiceMesher 社区来学习 Istio！\n\n', '\/blog\/cloud-native-service-mesh-istio-book\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">云原生服务网格 Istio（华为云原生技术丛书）图书读后感，原理、实践、架构与源码解析（张超盟、章鑫、徐中虎、徐飞编著）。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/github-webhook-website-auto-deploy/">使用 GitHub Webhook 实现静态网站自动化部署</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2019/07/10</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e5%85%b6%e4%bb%96"> 
             其他
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('使用 GitHub Webhook 实现静态网站自动化部署', '通过本文你将了解到如何使用 GitHub Webhook 来自动化发布您的网站。', '\n本文介绍如何为 \u0060servicemesher.com\u0060 网站配置自动化部署的详细说明，通过本文你将了解到：\n\n- 如何使用 GitHub Webhook 来自动化发布您的网站\n- 如何配置 Nginx 代理根据 URI 请求转发到本地服务器的指定端口\n\n## 自动发布脚本\n\n使用名为 \u0060deploy.sh\u0060 的 Shell 脚本编译 Hugo 生成 HTML 文件，并放到 Nginx 配置的目录下。该脚本位于 [ServiceMesher 官网 GitHub 仓库](https:\/\/github.com\/servicemesher\/website)同级目录下，内容如下：\n\n\u0060\u0060\u0060bash\n#!\/bin\/bash\n# 网站的代码仓库目录\ninput=\u0022website\u0022\n# Nginx 中配置的网站的 HTML 根目录\noutput=\u0022\/home\/admin\/servicemesher.com\u0022\ncd $input\ngit pull\nhugo\ncd ..\ncp -r $input\/public\/* $output\n\u0060\u0060\u0060\n\n## 依赖安装\n\n该网站部署在阿里云上，操作系统为 CentOS 7.6.1810，并配置好了 [HTTPS](\/posts\/free-certificates-with-certbot)\t。\n\n安装后端服务配置所需的组件。\n\n\u0060\u0060\u0060bash\nyum install -y npm\n\u0060\u0060\u0060\n\n安装 NPM 包。\n\n\u0060\u0060\u0060bash\nnpm i -S github-webhook-handler\nnpm i -g pm2\n\u0060\u0060\u0060\n\n## 创建 webhook 服务后端\n\n我们使用 NodeJS 创建 webhook 服务后端，后端代码保存在 \u0060webhook.js\u0060文件中，调用 \u0060deploy.sh\u0060 来发布，因此需要与 \u0060deploy.sh\u0060 文件在同一级目录中，监听 \u0060http:\/\/127.0.0.1:6666\/webhook\u0060：\n\n当前的所有文件的结构如下：\n\n\u0060\u0060\u0060bash\n$ ls -1\ndeploy.sh\nnode_modules\npackage.json\nsofastack.tech\nwebhook.js\n\u0060\u0060\u0060\n\n\u0060webhook.js\u0060 文件内容如下：\n\n\u0060\u0060\u0060javascript\nvar http = require(\u0027http\u0027);\nvar spawn = require(\u0027child_process\u0027).spawn;\nvar createHandler = require(\u0027github-webhook-handler\u0027);\n\/\/ 注意将 secret 修改你自己的\nvar handler = createHandler({ path: \u0027\/webhook\u0027, secret: \u0027yourwebhooksecret\u0027 });\n\nhttp.createServer(function (req, res) {\n  handler(req, res, function (err) {\n    res.statusCode = 404;\n    res.end(\u0027no such location\u0027);\n  })\n}).listen(6666);\n\nhandler.on(\u0027error\u0027, function (err) {\n  console.error(\u0027Error:\u0027, err.message)\n});\n\nhandler.on(\u0027push\u0027, function (event) {\n  console.log(\u0027Received a push event for %s to %s\u0027,\n    event.payload.repository.name,\n    event.payload.ref);\n\n  runCommand(\u0027sh\u0027, [\u0027.\/deploy.sh\u0027], function( txt ){\n    console.log(txt);\n  });\n});\n\nfunction runCommand( cmd, args, callback ){\n    var child = spawn( cmd, args );\n    var resp = \u0027Deploy OK\u0027;\n    child.stdout.on(\u0027data\u0027, function( buffer ){ resp \u002b= buffer.toString(); });\n    child.stdout.on(\u0027end\u0027, function(){ callback( resp ) });\n}\n\u0060\u0060\u0060\n\n在 \u0060webhook.js\u0060 所在目录下启动后端服务：\n\n\u0060\u0060\u0060bash\npm2 start webhook.js\n\u0060\u0060\u0060\n\n查看服务状态：\n\n\u0060\u0060\u0060bash\n$ pm2 status\n┌──────────┬────┬─────────┬──────┬───────┬────────┬─────────┬────────┬─────┬───────────┬──────┬──────────┐\n│ App name │ id │ version │ mode │ pid   │ status │ restart │ uptime │ cpu │ mem       │ user │ watching │\n├──────────┼────┼─────────┼──────┼───────┼────────┼─────────┼────────┼─────┼───────────┼──────┼──────────┤\n│ webhook  │ 0  │ 1.0.0   │ fork │ 30366 │ online │ 0       │ 6h     │ 0%  │ 30.8 MB   │ root │ disabled │\n└──────────┴────┴─────────┴──────┴───────┴────────┴─────────┴────────┴─────┴───────────┴──────┴──────────┘\n Use \u0060pm2 show \u003cid|name\u003e\u0060 to get more details about an app\n\u0060\u0060\u0060\n\n使用 \u0060pm2 logs webhook\u0060 可以查看后端服务日志。\n\n## Nginx 配置\n\n在 nginx 配置中增加转发设置，将对网站 \u0060\/webhook\u0060 URI 的访问转发到服务器本地的 6666 端口，即 webhook 后端服务商。\n\n\u0060\u0060\u0060bash\n        # GitHub auto deploy webhook\n        location \/webhook {\n            proxy_pass http:\/\/127.0.0.1:6666;\n        }\n\u0060\u0060\u0060\n\n## GitHub Webhook 配置\n\n在 GitHub 仓库的 \u0060Settings\u0060 - \u0060webhooks\u0060 设置中创建一个新的 webhook。\n\n![GitHub Webhook 配置](006tNc79ly1g4uxl5ioq4j312q0u0ac3.jpg)\n\n注意选择 Content Type 为 \u0060application\/json\u0060，secret 设置成与 \u0060webhook.js\u0060 中的相同。\n\n配置完成后 GitHub 将自动调用 Webhook 以验证有效性。\n\n![GitHub 自动触发 Webhook](006tNc79ly1g4uxnir7ckj316a0ke3zd.jpg)\n\n如果看到 200 响应表示成功调用 Webhook 后端服务，这样每次我们的仓库合并后就会触发网站自动部署。\n\n## 更多\n\n为了加强 GitHub 自动化，还有更多 GitHub App 可以使用，推荐：\n\n- [auto-assigin](https:\/\/github.com\/apps\/auto-assign)\n- [mergify](https:\/\/github.com\/apps\/mergify)\n\n这些已经在 \u0060servicemesher.com\u0060 网站上集成了，感兴趣的读者可以访问 [ServiceMesher 官网的代码仓库](https:\/\/github.com\/servicemesher\/website)查看配置。\n\n## 参考\n\n- [使用 Github 的 webhooks 进行网站自动化部署](https:\/\/aotu.io\/notes\/2016\/01\/07\/auto-deploy-website-by-webhooks-of-github\/index.html)\n', '\/blog\/github-webhook-website-auto-deploy\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">通过本文你将了解到如何使用 GitHub Webhook 来自动化发布您的网站。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/free-certificates-with-certbot/">使用 Certbot 为网站设置永久免费的 HTTPS 证书</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2019/07/05</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e5%85%b6%e4%bb%96"> 
             其他
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('使用 Certbot 为网站设置永久免费的 HTTPS 证书', '实测推荐使用 Certbot 为网站设置永久免费的 HTTPS 证书，超简单，全程不用五分钟！', '\n我的博客从上线第一天起就使用了 HTTPS，用的是 [Cloudflare](https:\/\/www.cloudflare.com\/zh-cn\/)，直接在其后台配置即可。如果你是用 nginx、apache、haproxy 等服务器来运行自己的网站，给大家推荐 [Certbot](https:\/\/certbot.eff.org\/)，可以自动化来配置 SSL 证书和定时更新。\n\n下面记录我自己为 \u0060servicemesher.com\u0060 网站配置 HTTPS 证书的过程，全程不需要 5 分钟。\n\n## 环境\n\n网站的托管环境如下：\n\n- OS：CentOS 7.6 阿里云\n- 网站服务器：Nginx，使用 yum 安装，版本 1.12\n- 提前配置好 Nginx，确保使用 HTTP 先可以访问到网站\n\n注意：请使用 \u0060yum\u0060 命令安装 nginx，这样可以确保 nginx 安装在默认的位置，因为 certbot 会检测 \u0060\/etc\/nginx\/\u0060 目录下的配置文件。\n\n## 操作步骤\n\n执行下面的步骤可以直接为你的网站配置 HTTPS 证书。\n\n\u0060\u0060\u0060bash\nyum -y install yum-utils\nyum-config-manager --enable rhui-REGION-rhel-server-extras rhui-REGION-rhel-server-optional\nyum install certbot python2-certbot-nginx\n\u0060\u0060\u0060\n下图是在 Certbot 中选择服务器和操作系统的页面。\n\n![CertBot 页面](006tNc79ly1g4oqftr4fdj31e20u0gn8.jpg)\n\n执行下面的命令，根据提示会自动配置 nginx。\n\n\u0060\u0060\u0060bash\ncertbot --nginx\nSaving debug log to \/var\/log\/letsencrypt\/letsencrypt.log\nPlugins selected: Authenticator nginx, Installer nginx\nStarting new HTTPS connection (1): acme-v02.api.letsencrypt.org\n\nWhich names would you like to activate HTTPS for?\n1：servicemesher.com\n2: www.servicemsher.com\n# 这里直接回车选择所有的域名\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nSelect the appropriate numbers separated by commas and\/or spaces, or leave input\nblank to select all options shown (Enter \u0027c\u0027 to cancel):\n\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nYou have an existing certificate that contains a portion of the domains you\nrequested (ref: \/etc\/letsencrypt\/renewal\/servicemesher.com.conf)\n\nIt contains these names: servicemesher.com, www.servicemesher.com\n\nYou requested these names for the new certificate: servicemesher.com,\nprow.servicemesher.com, www.servicemesher.com.\n\nDo you want to expand and replace this existing certificate with the new\ncertificate?\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n(E)xpand\/(C)ancel: E\nRenewing an existing certificate\nPerforming the following challenges:\nhttp-01 challenge for prow.servicemesher.com\nWaiting for verification...\nCleaning up challenges\nDeploying Certificate to VirtualHost \/etc\/nginx\/nginx.conf\nDeploying Certificate to VirtualHost \/etc\/nginx\/nginx.conf\nDeploying Certificate to VirtualHost \/etc\/nginx\/nginx.conf\n\nPlease choose whether or not to redirect HTTP traffic to HTTPS, removing HTTP access.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n1: No redirect - Make no further changes to the webserver configuration.\n2: Redirect - Make all requests redirect to secure HTTPS access. Choose this for\nnew sites, or if you\u0027re confident your site works on HTTPS. You can undo this\nchange by editing your web server\u0027s configuration.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nSelect the appropriate number [1-2] then [enter] (press \u0027c\u0027 to cancel):\n# 这里是为了扩展证书支持更多的域名，所有输入 2 回车\nTraffic on port 80 already redirecting to ssl in \/etc\/nginx\/nginx.conf\nRedirecting all traffic on port 80 to ssl in \/etc\/nginx\/nginx.conf\nTraffic on port 80 already redirecting to ssl in \/etc\/nginx\/nginx.conf\n\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nYour existing certificate has been successfully renewed, and the new certificate\nhas been installed.\n\u0060\u0060\u0060\n\n然后重新加载配置。\n\n\u0060\u0060\u0060bash\nnginx -t;nginx -s reload\n\u0060\u0060\u0060\n\n设置证书自动更新。\n\n\u0060\u0060\u0060bash\necho \u00220 0,12 * * * root python -c \u0027import random; import time; time.sleep(random.random() * 3600)\u0027 \u0026\u0026 certbot renew\u0022 | sudo tee -a \/etc\/crontab \u003e \/dev\/null\n\u0060\u0060\u0060\n\n好了现在访问你的网站就可以看到 https 头部加了 HTTPS 锁了。\n\n## 参考\n\n- [让网站永久拥有 HTTPS - 申请免费 SSL 证书并自动续期](https:\/\/blog.csdn.net\/xs18952904\/article\/details\/79262646)\n- certbot - 免费的 https 证书\n', '\/blog\/free-certificates-with-certbot\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">实测推荐使用 Certbot 为网站设置永久免费的 HTTPS 证书，超简单，全程不用五分钟！</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/open-source-compliance-practices/">开源软件合规实践</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2019/06/08</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e5%bc%80%e6%ba%90"> 
             开源
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('开源软件合规实践', '本文是开源软件合规实践的，介绍开源软件合规的流程及建议。', '\n##  总体概述\n\n开源软件合规（Compliance）实践，从狭义上讲就是企业使用开源软件许可证（License）的合规。*Recommended Open Source Compliance Practices for the Enterprise* 电子书（共 32 页）由 *Ibrahim Haddad* 博士撰写，本书从以下几个角度为你的公司的进行开源合规实践以指导：\n\n- 创建开源审查委员会（Open Source Review Committee）\n- 代码扫描\n- 软件溯源（Software Sourcing）\n- 开源法务支持（Open Source Legal Support）\n- 流程中的合规检查（Compliance Checkpoints）\n- 开发和部署检查器\n- 合规事项看板\n\n### 开源合规审查组\n\n企业为了保证自己产品或软件的合规，通常会有一个许可证合规审查组，负责以下几项职责：\n\n1. 遵守开源许可条款\n1. 促进在产品和服务中使用开源\n1. 遵守第三方商业软件的许可条款\n1. 保护您的产品\/服务差异化（知识产权\/IP）\n\n![开源促进及合规计划](006tNc79ly1g3unqmzuawj30yy0fmgnv.jpg)\n\n### 开源合规流程\n\n图 2 是开源合规流程闭环。\n\n![图 2. 开源合规流程闭环](006tNc79ly1g3unru4rl8j31300qkmz8.jpg)\n\n该流程中分为以下三步：确认（Identify）、批准（Approve）和确知（Satisfy）。\n\n![图 3. 开源合规步骤产出](006tNc79ly1g3unvsqmmrj31zy0fu0w8.jpg)\n\n#### 确认（Identify）\n\n此初始步骤的目标是监控软件组合中开源来源，无论该组合是作为独立软件包还是嵌入在第三方或公司开发的软件中。此步骤的输出是详细的软件物料清单（Bill of Materials），用于标识所有开源软件包（Package）和代码片段（Snippet）的来源（Origin）、许可证（License）以及由软件组合分析工具所识别的许可冲突。\n\n#### 批准（Approve）\n\n这一步的目标是：\n\n1. 查看上一步的输出，了解管理相关源代码的使用、修改和分发的许可证；\n1. 根据其独特的背景（context），确定是否批准使用已识别的开源软件；\n\n#### 确知（Satisfy）\n\n在最后一步中，准备好所有已批准的开源软件（整个组件和片段）的许可证、版权（copyright）和归属声明，并将其交给相关的部门，以包含在产品文档中。同样，已经确知和标记了许可义务的开源软件包，就可以在产品\/服务上线时发布了。\n\n### 对企业开源合规实践的建议\n\n作者提出了企业可以实施的实践建议，以改进和加强其开源合规性计划：\n\n- 成立开源审查委员会（Open Source Review Board，简称 OSRB）\n- 建立自动化系统来识别开源软件\n- 让软件供应商遵守开源许可证\n- 扩展开源法律支持\n- 在业务和开发过程中集成开源合规性检查点\n- 提供各种开源合规性任务的清单（checklist）\n- 开发和部署支持清单\n- 建立开源合规活动基准（benchmark）\n- 参与关键合规性开源合规性计划\n\n## 成立开源审查委员会\n\n除开源合规官或开源计划办公室的代表外，开源审查委员会（OSRB）由法律和产品\/工程团队的代表组成。OSRB 的主要职责是审查和批准计划在产品和服务中使用开源软件。\n\n下面是 OSRB 中每个参与者职责的宏观概述。\n\n**开源法律顾问（Open Source Legal Counsel）**\n\n- 审查和批准开源软件的使用、修改和分发。\n- 提供与开源许可相关的法律指导。\n- 为创建合规培训做出贡献。\n- 有助于改进合规计划。\n- 审查和批准与许可证合规性相关的 Web 门户的内容。\n- 审核并批准使用的开源软件的义务列表。\n- 从开源合规性角度签署产品发布。\n\n**产品\/工程代表（Product \/ Engineering Representative）**\n\n- 在其组织内实施合规性政策（policy）和流程（process）。\n- 在软件开发过程中集成合规性实践。\n- 从工程角度为改进合规计划做出贡献。\n- 遵循技术开源合规指南。\n- 与 OSRB 成员协作以响应合规性查询。\n- 进行设计、架构和代码审查。\n- 准备用于出版物的开源软件包和通知。\n- 从开源合规性角度签署产品发布。\n\n**开源计划办公室和合规官的代表（Representative of the Open Source Program Office or Compliance Officer）**\n\n- 推动开源合规活动。\n- 协调源代码扫描和审核。\n- 参与工程审查和分发准备评估。\n- 协调开源软件包和通知的发布。\n- 为培训工作和改进合规计划做出贡献。\n- 有助于促进开源软件的自动化和发现。\n- 从开源合规性角度签署产品发布。\n\n除了 OSRB 的成员之外，实现开源合规是一项跨学科活动，涉及到组织内的各个部门和个人，如图 4 所示。\n\n![图 4. 开源项目办公室组成](006tNc79ly1g3unxxety2j31ik0li0v5.jpg)\n\n下面是对支持团队帮助 OSRB 确保开源合规性的核心职责的描述。\n\n**IT**\n\n- 创建\/获取确保合规性所需的新工具\n- 为合规计划使用的工具和自动化基础设施提供支持和维护\n\n**企业发展（Cooperate Development）**\n\n- 请求\/监督开源合规性尽职调查在合并或收购之前完成\n- 从外包开发中心接收源代码时确保合规性记录\n\n**文档（Documentation）**\n\n- 在产品文档中包含开源许可证信息和通知（notice）\n\n**开源执行委员会（Open Source Executive Committee）**\n\n- 审查并批准在开源许可下发布专有源代码的提议\n\n**软件采购（Software Procurement）**\n\n- 授权第三方软件提供商在许可或购买的软件组件中披露开源\n- 协助引入包含（或不包含）开源软件的第三方软件\n\n## 开源代码审查\n\n开源合规性工作的核心是识别开源代码及其各自的许可证，以便组织可以满足适用的许可证义务。开源策略和流程指导此核心活动。合规性政策和流程管理开源软件的使用、贡献、审核和发布的各个方面。如果我们采用下图 5 所示的基本流程并对其进行扩展，我们将考虑端到端的合规流程。下图显示了这样一个流程，它具有源自多个源的源代码输入。源代码经过一系列步骤，流程的最终输出包括书面报价、通知列表（版权、归属、许可证），以及为履行许可义务而发布的源代码包。\n\n图 5 提供了端到端合规流程的详细示例，其中包括软件组件被 OSRB 批准在构建系统中与软件产品集成之前经历的各个步骤。\n\n![图 5. 端到端开源合规流程示例](006tNc79ly1g3unjbh5amj31900fuac7.jpg)\n\n图 6 简要描述了每个步骤中发生的情况。\n\n![图 6. 开源合规代码确认步骤详解](006tNc79ly1g3uzfnj1lzj327i0kuq71.jpg)\n\n## 开源代码溯源\n\n让您的软件提供商参与开源合规中至关重要。软件提供商必须披露其可交付成果中包含的开源代码，并提供包括适用源代码在内的所有通知（notice）。\n\n![图 7. 多源开发模型](006tNc79ly1g3upmcjnl5j31di0ncdjd.jpg)\n\n图 7 描绘了多源开发模型和传入源代码的各种源组合。在此模型下，产品或软件堆栈可以包含专有软件、第三方商业和第三方开源软件的任意组合。例如，除了第三方专有源代码之外，软件组件 A 可以包括专有源代码，而软件组件 B 除了可以包含来自开源项目的源代码之外还可以包括专有源代码。\n\n当今的公司处于必须更新其供应链（软件采购）程序以解决获取和使用开源软件的状态。通常会有供应链人员参与将软件从供应商转移到贵公司。他们可以通过两种主要方式支持开源合规性活动：\n\n- 要求第三方软件提供商披露他们在其可交付成果中使用的任何开源，以及\n- 协助许可与开源软件包捆绑在一起或与之集成的第三方软件。\n\n此领域的推荐做法是强制第三方软件提供商披露其产品中使用的所有开源组件，并声明他们计划如何满足适用的开源许可证义务。如果第三方软件包含开源，供应链必须确保在初始入口后满足开源许可证义务——您作为提供开源产品或服务的分销商将承担这些义务和责任。\n\n## 提供便捷的法务支持\n\n大多数组织都会创建开源合规性计划并建立核心团队以确保合规性。大多数公司往往会会遇到开源法律支持的瓶颈，因为您公司里可能有成百上千的使用和集成开源代码的开发人员，而很少有法务人员提供所需的法律支持。扩展开源法律支持需要一些\u0060开箱即用\u0060的思考，但可以借助以下实用方法实现。\n\n### 许可证手册（License Playbooks）\n\n提供面向软件开发人员的易于阅读和摘要的开源许可证摘要。提供有关这些许可证的易于理解的信息，例如许可证授予、限制、义务、专利影响等。使用开源软件许可证手册可以大量减少发送给法律顾问的基本问题的数量，并为开发人员提供了对常见查询的即时指导、信息和答案。\n\n### 许可证兼容性矩阵（License Compatibility Matrix）\n\n许可证兼容性是指确定某个许可证是否与另一个许可证兼容。GPL 兼容性是指确定某个许可证是否与 GPL 条款兼容。当合并源自不兼容许可下软件组件的源代码时，开发团队经常会遇到许可兼容性问题。当开发团队将不同许可证下的代码组合在一起时，可以参考许可证兼容性矩阵来验证在单个软件组件中是否存在加入源代码的许可冲突。如果开发团队使用的许可证源不在矩阵中，则可以后续获得法律顾问的建议。\n\n### 许可证分类\n\n为了减少开源法律顾问收到的问题数量并增加许可和合规流程教育，一些公司选择在几个类别下对其产品中最常用的许可进行分类。图 11 显示了许可证分类系统的一个简单示例，其中大多数使用的开源许可证分为四类。\n\n![图 8. 开源许可证分类（仅供参考）](006tNc79ly1g3ur9rfeqaj310c0gkdip.jpg)\n\n上述许可证类别是对许可证进行分类的简单方法，使开发人员在根据这些许可证集成代码时更容易了解操作过程。下面这个例子是开发人员想要使用在以下许可下的开源软件包的：\n\n- License A - Action：尽管用，没有什么问题\n- License E - Action：获得工程经理的批准\n- License I - Action：获得法律顾问的批准\n- License M - Action：根据政策禁止适用该 License\n- 其他 - Action：向经理询问行动方案\n\n有关此话题的进一步阅读，我们建议阅读**[扩展开源法律支持的实用建议](https:\/\/www2.thelinuxfoundation.org\/pub-practical-advice-to-scale-legal)**。本文探讨了法律顾问在确保开源合规方面的作用，并为法律顾问提供了可以为软件开发团队提供的实用建议。这些实用建议将使软件开发人员能够做出与开源许可相关的日常决策，而无需再去找负责每个问题的法律顾问。\n\n## 开源合规流程中的检查点及发布清单\n\n有必要将合规性实践纳入开发流程，以确保开源合规工作的成功。您可以通过多种方式实现这一目标。\n\n1. **每个内部版本的合规性**：更新流程管理，以确保在产品开发周期中尽早包含开源合规性活动，以使组织能够满足其发布时间表。遵循此模型，未来版本的增量合规性也变得简单明了。\n1. **更新供应链程序**：定制供应链的供应商选择程序，以确保在对供应商及其可交付成果进行尽职调查（Due Diligence）时考虑开源合规性要求。\n1. **执行验证**：使用验证步骤确保在发生发行外部版本之前满足所有合规性要求。\n1. **培训员工**：为所有员工提供开源合规培训。\n1. **采用 SPDX 报告许可证信息**：以 SDPX 格式提供许可证信息，以尽量减少任何可能的错误，并标准化报告信息的方式。\n\n\u003e **SPDX**\n\u003e\n\u003e [SPDX®](https:\/\/spdx.org\/)（Software Package Data Exchange®）是用于传达软件物料清单信息（包括组件、许可证、版权和安全参考）的开放标准。\n\u003e\n\u003e SPDX 通过为公司和社区提供共享格式来共享软件许可、版权和安全参考的重要数据，从而简化和改进合规性，从而减少冗余工作。\n\u003e\n\u003e SPDX 规范由 SPDX 工作组开发，该工作组由 Linux 基金会托管。基层工作包括来自 20 多个组织的代表——软件、系统和工具供应商、基金会和系统集成商——都致力于为软件包数据交换格式创建标准。\n\n### 开发和部署清单\n\n清单很有用，可确保执行合规性任务的一致性和完整性。强烈建议根据员工职责建立合规里程碑清单和目标清单。\n\n清单的示例包括：\n\n- 批准将传入代码集成到产品的源代码存储库之前的核对表\n- 确保履行义务的清单\n- 开发人员的清单\n- 工程经理的清单\n- 合规人员清单\n- 开源法律人员的清单\n- 软件采购人员清单\n\n为了说明这一点，我们提供了一个示例清单，展示了在组织发布源代码包之前必须检查的各种任务，以履行在交付产品中包含的开源代码的许可义务：\n\n预发行清单（Pre-Distribution Checklist）\n\n- 验证引入开源软件包的修改是否已记录，并作为更改日志的一部分包含在开源发行说明中。\n- 确保每个修改后的源代码文件都包含版权声明，免责声明和通用“更改日志”（Changelog）条目的附加条目。\n- 确认源代码包的所有内容均已由工程团队审核并由 OSRB 确认。\n- 确保在非公司标准 Linux 计算机上编译开源软件包。此步骤的目标是确保您要发布的开源软件包在通用最终用户系统上进行编译。\n- 将产品手册更新为：\n  - 提及该产品包含开源软件。\n  - 包括与产品中包含的不同开源软件相对应的所有许可证的列表。\n  - 提供适当的版权和归属通知。\n  - 通过网页下载或通过产品手册中提供的指定地址通过电子邮件或邮寄方式与贵公司联系，说明如何访问开源软件包的代码（书面提供）。\n - 执行语言检查（linguistic review）以确保源代码中没有任何不适当的注释。\n   - 注意：有些公司忘记进行语言检查，当代码发布时，他们会因源代码中留下的不当注释而尴尬。执行语言检查的另一个重要原因是确保源代码和注释不涉及未来的产品代码名称或功能。\n- 确保现有许可、版权和归属通知不受干扰。\n  - 验证要分发的源代码是否与产品一起使用的二进制文件对应，源代码构建到与产品一起分发的同一个库中，并且源代码分发中包含适当的指令（除时间\/日期戳外派生的二进制文件通常是相同的）。\n  - 验证包是否遵循开源策略中定义的链接关系和交互。\n  - 确保在开源软件包的根文件夹中的 LICENSE 文件中包含许可证文本的副本（如果尚未存在）。\n  - 如果源代码包需要特殊的构建工具或环境设置，则将详细信息包含在 README 文件或类似文件中。\n    这些清单，特别是在实现自动化并与业务和开发流程集成时，可以提醒您必须完成的所有事项，以确保合规性并减少发生错误的几率。\n\n## 最后\n\n本书中的最后还推广了波 OpenChain 项目，该项目提供了一组自我认证的选项，由该领域的利益相关者创建，用于合规性规范，该规范允许给定的组织进行自我测试并声明其遵守特定的合规级别。您可以访问 **https:\/\/www.openchainproject.org\/conformance** 了解更多信息。\n', '\/blog\/open-source-compliance-practices\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文是开源软件合规实践的，介绍开源软件合规的流程及建议。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
          <div class="col-12">
 
 
 
 
 
 
 
 
 
 
 
 <nav aria-label="Page navigation">
   <ul class="pagination justify-content-center">
     
     
     <li class="page-item">
       <a class="page-link" href="/blog/">
         ««
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a href="/blog/page/22/" class="page-link">
         «
       </a>
     </li>
     
     
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item">
           <a href="/blog/page/21/" class="page-link">
             21
           </a>
         </li>
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item">
           <a href="/blog/page/22/" class="page-link">
             22
           </a>
         </li>
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item page-item active ">
           <a href="/blog/page/23/" class="page-link">
             23
           </a>
         </li>
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item">
           <a href="/blog/page/24/" class="page-link">
             24
           </a>
         </li>
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item">
           <a href="/blog/page/25/" class="page-link">
             25
           </a>
         </li>
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
     
     
     <li class="page-item">
       <a href="/blog/page/24/" class="page-link">
         »
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a class="page-link" href="/blog/page/27/">
         »»
       </a>
     </li>
     
   </ul>
 </nav>
 
</div>

        </div>
      </div>
      <!-- sidebar -->
      <aside class="col-lg-4 order-1 order-lg-2 d-none d-sm-block">
          <div class="sidebar">
          <!-- categories -->
<div class="blog-categories mb-4">
  <p class="sidebar-title">
      专栏
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/istio" class="sidebar-item">
            <span>Istio</span>
            <span>(74)</span>
        </a>
      
        <a href="/categories/service-mesh" class="sidebar-item">
            <span>Service Mesh</span>
            <span>(42)</span>
        </a>
      
        <a href="/categories/kubernetes" class="sidebar-item">
            <span>Kubernetes</span>
            <span>(24)</span>
        </a>
      
        <a href="/categories/%e9%9a%8f%e7%ac%94" class="sidebar-item">
            <span>随笔</span>
            <span>(22)</span>
        </a>
      
        <a href="/categories/%e5%85%b6%e4%bb%96" class="sidebar-item">
            <span>其他</span>
            <span>(18)</span>
        </a>
      
        <a href="/categories/envoy" class="sidebar-item">
            <span>Envoy</span>
            <span>(17)</span>
        </a>
      
        <a href="/categories/%e4%b8%9a%e6%80%81" class="sidebar-item">
            <span>业态</span>
            <span>(17)</span>
        </a>
      
        <a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f" class="sidebar-item">
            <span>云原生</span>
            <span>(14)</span>
        </a>
      
        <a href="/categories/ai" class="sidebar-item">
            <span>AI</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%ae%89%e5%85%a8" class="sidebar-item">
            <span>安全</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%bc%80%e6%ba%90" class="sidebar-item">
            <span>开源</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e6%97%85%e8%a1%8c" class="sidebar-item">
            <span>旅行</span>
            <span>(6)</span>
        </a>
      
        <a href="/categories/%e5%8f%af%e8%a7%82%e6%b5%8b%e6%80%a7" class="sidebar-item">
            <span>可观测性</span>
            <span>(5)</span>
        </a>
  </div>
</div>

<div class="blog-categories mb-4">
  <p class="sidebar-title">
      资料
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/%e5%87%ba%e7%89%88%e7%89%a9" class="sidebar-item">
            <span>出版物</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e7%94%b5%e5%ad%90%e4%b9%a6" class="sidebar-item">
            <span>翻译电子书</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e6%96%87%e6%a1%a3" class="sidebar-item">
            <span>翻译文档</span>
            <span>(7)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>翻译图书</span>
            <span>(6)</span>
        </a>
      
        <a href="/categories/%e5%8e%9f%e5%88%9b%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>原创图书</span>
            <span>(2)</span>
        </a>
      
        <a href="/categories/%e6%95%99%e7%a8%8b%e6%89%8b%e5%86%8c" class="sidebar-item">
            <span>教程手册</span>
            <span>(2)</span>
        </a>
  </div>
</div>





          </div>
      </aside>
      <!-- /sidebar -->
    </div>
  </div>
</section>




<footer>
  
  <div class="footer bg-footer section-sm border-bottom overlay ">
    <div class="container-xl">
      <div class="row">
        <div class="col col-xl-4 d-sm-none mb-2 mb-lg-0 d-xl-block d-none">
          
          <p class="h3 text-white mb-4 text-uppercase">联系</p>
          
          <ul class="list-unstyled">
            
            
            <li class="mb-4 text-color">微信公众号</li>
            
            
            <li class="mb-4"><img src="/images/servicemesher-wechat.webp" width="118px" height="118px" alt="footer image"></li>
            
            
            
          
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">博客</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/blog/multi-cluster-pki-istio-recipe/">多集群 PKI 与 Istio 实践：为服务网格构建可信且可扩展的 PKI</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/envoy-tracing/">Envoy 代理如何处理用户请求以实现追踪</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/black-myth-wukong-review/">《黑神话：悟空》一周目评测：瑕不掩瑜，期待更丰富内容</a></li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">链接</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://istio.io/latest/zh/" target="_blank" rel="noopener noreferrer">
                  Istio 服务网格
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://tetrate.io/?jimmysong" target="_blank" rel="noopener noreferrer">
                  Tetrate 公司
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener noreferrer">
                  云原生学院|Bilibili
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/awesome-cloud-native/" target="_blank" rel="noopener noreferrer">
                  云原生开源项目大全
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://cloudnative.to" target="_blank" rel="noopener noreferrer">
                  云原生社区（中国）
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">教程</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/envoy-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Envoy 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/istio-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Istio 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/kubernetes-handbook/" >
                  Kubernetes 基础教程
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/envoy-made-simple/" >
                  简明 Envoy 教程
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">通知</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/notice/nist-sp-800-233-service-mesh-proxy-models/">资料分享：云原生应用服务网格代理模型的威胁分析指南</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/kubecon-china-2024-panel/">KubeCon China 2024（香港）</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/website-revamp-notice/">网站改版通知</a></li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>

  
  <div class="copyright py-4 bg-footer overlay">
    <div class="container-xl">
      <div class="row">
        <div class="col-sm-6 text-sm-left text-center">
          <p class="mb-0 text-color">© 2017-2024 Jimmy Song 保留所有权利</p>
        </div>
        <div class="col-sm-6 text-sm-right text-center">
          <ul class="list-inline">
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://twitter.com/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-x-twitter text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/contact/" >
                    <i class="fa-brands fa-weixin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://github.com/rootsongjc" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-github text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://linkedin.com/in/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-linkedin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="mailto:rootsongjc@gmail.com" >
                    <i class="fa-solid fa-envelope text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/blog/index.xml" >
                    <i class="fa-solid fa-rss text-white"></i>
              </a>
            </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>


<!-- JS Plugins -->

<script src="/plugins/popper/popper.min.js"></script>

<script src="/plugins/bootstrap/bootstrap.min.js"></script>

<script src="/plugins/slick/slick.min.js"></script>

<script src="/plugins/filterizr/jquery.filterizr.min.js"></script>

<script src="/plugins/search/fuse.min.js"></script>

<script src="/plugins/search/mark.js"></script>

<script src="/plugins/hex_md5/hex_md5.js"></script>

<script src="/plugins/anchor/anchor.min.js"></script>

<script src="/plugins/tocbot/tocbot.min.js"></script>

<script src="/plugins/bigger-picture/bigger-picture.min.js"></script>


<!-- Main Script -->

<script src="/js/script.min.f94c22b1d478bfc9e2e0a7d954429e47b7e6d36edd423758482e04154ae1842e.js"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-ESY906ZWZ0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ESY906ZWZ0');
</script>


<!-- Baidu analysis -->
<meta name="baidu-site-verification" content="g8IYR9SNLF" />





<script>
    anchors.add();
</script>






<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>










<script src="/js/wowchemy-search.min.7a37268e7bbe4a9160c2e4c33b749816.js" type="module"></script>
<script id="search-hit-fuse-template" type="text/x-template">
  <div class="search-hit" id="summary-{{key}}">
    <div class="search-hit-content border-bottom">
      <div class="search-hit-name">
        <div class='search-hit-link'><a href="{{relpermalink}}">{{title}}</a></div>
        <div class="search-hit-metadata d-flex">
            <span class="mr-1"><i class="fa-regular fa-calendar mr-1"></i>{{date}}</span>
            <span class="mr-1"><i class="fa-regular fa-folder-open mr-1"></i>{{section}}</span>
            <span class="d-sm-block d-none"><i class="fa-solid fa-link mr-1"></i>{{relpermalink}}</span>
        </div>
        <div class="search-hit-description">{{snippet}}</div>
      </div>
    </div>
  </div>
</script>



    </body>
</html>
