<!DOCTYPE html>
<html lang="zh"><head>
  <meta charset="utf-8">
  
  <title>博客 · Jimmy Song</title>
  

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta name="description" content="Jimmy Song 的原创博客及译文。">
  <meta name="author" content="Jimmy Song">
  <meta name="generator" content="Hugo 0.129.0">

  <!-- CSS plugins -->
  
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
  
  <link rel="preload" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" as="style">
  <link rel="stylesheet" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" media="screen">
  

  <!-- Main Stylesheet -->
  
  <link rel="preload" href="/scss/style.min.595949bd12db88434115e2a1e70965cf2928cc646e73acc6437c4cbbc323f585.css" as="style">
  <link rel="stylesheet" href="/scss/style.min.595949bd12db88434115e2a1e70965cf2928cc646e73acc6437c4cbbc323f585.css" media="screen">

  <!-- Bigger picture css -->
  
  <link rel="stylesheet" href="/plugins/bigger-picture/bigger-picture.min.css" media="print" onload="this.media='all'">
  <!--Favicon generate by https://realfavicongenerator.net-->
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="200x200" href="/images/favicon.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">

  <link href='/opensearchdescription.xml' rel='search' title='Content search' type='application/opensearchdescription+xml'/>

  <!--Twitter card-->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="jimmysong.io" />
  <meta name="twitter:creator" content="@jimmysongio" />
  <meta property="og:url" content="https://jimmysong.io/blog/" />
  <meta property="og:title" content="博客 | Jimmy Song" />
  <meta property="twitter:title" content="博客 | Jimmy Song" />

  
  <meta property="og:description" content="Jimmy Song 的原创博客及译文。" />
  <meta property="twitter:description" content="Jimmy Song 的原创博客及译文。" />

  
  <meta property="og:image" content="https://jimmysong.io/images/banner/default.jpg" />
  <meta property="twitter:image" content="https://jimmysong.io/images/banner/default.jpg" />

  
  
</head>
<body>
<header class="fixed-top header">
  
  
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa fa-arrow-circle-up" aria-hidden="true"></i></button>
  
  <div class="navigation w-100 ">
    <div class="container-xl">
      <nav class="navbar navbar-expand-lg navbar-light p-0">
        <a class="navbar-brand" href="/">
            
            <b>JIMMY SONG</b>
            
        </a>
        <button class="navbar-toggler rounded-0" type="button" data-toggle="collapse" data-target="#navigation"
          aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse text-center" id="navigation">
          <ul class="navbar-nav ml-auto">
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/blog">博客</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/book">资料</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/tags">标签</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/notice">公告</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/contact">联系</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/about">关于</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/community/">社区</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener">视频 <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i></a>
              
            </li>
            
            

          
          
          <li class="nav-item">
            
            
            
              
              
                
                
                
                  
                    
                    <a class="nav-link" href="/en/blog/">English</a>
                    
                  
                
              
              
              
                
                  
                    
                    
                  
                
                
                
              
          </li>
          
          
          <!-- search -->
           <button type="button" class="search-btn js-search" id="searchOpen" aria-label="Search">
              <div class="search-container d-flex justify-content-center">
              <span class="search-content">
                  <i class="fa fa-search"></i>
                  <span>搜索</span>
              </span>
              <span class="search-shortcuts d-none d-sm-block">
                  <kbd class="cmd-key">⌘</kbd>
                  <kbd class="k-key">K</kbd>
              </span>
              </div>
          </button>
          
          </ul>
        </div>
      </nav>
    </div>
  </div>
</header>


            <aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between">
        <div class="col-6 search-title">
          <p>站内搜索</p> 
        </div>
        <div class="col-6 col-search-close">
          <div class="js-search" aria-label="关闭"><i class="fa-solid fa-circle-xmark text-muted" aria-hidden="true"></i></div>
        </div>
      </div>

      <div id="search-box">
        <i class="fa-solid fa-magnifying-glass" id="search-icon" aria-hidden="true"></i>
        <input name="q" id="search-query" placeholder="请输入搜索词" autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control" aria-label="请输入搜索词">
        
        <div class="mt-4">
          <span>搜索类型: </span>
          <span>
            <input type="radio" id="all" name="search_type" value="all" checked>
            <label for="all">所有</label>
            
              <input type="radio" id="blog" name="search_type" value="blog">
              <label for="blog">原创</label>
              <input type="radio" id="trans" name="search_type" value="trans">
              <label for="trans">译文</label>
            
            <input type="radio" id="book" name="search_type" value="book">
            <label for="book">资料</label>
            <input type="radio" id="notice" name="search_type" value="notice">
            <label for="notice">公告</label>
          </span>
        </div>
      </div>
      
    </section>
    <section class="section-search-results">
      <div id="search-results-count" class="search-results-count"></div>
      <div id="search-hits">
        
      </div>
    </section>
  </div>
</aside>

        
        
            

<section class="bg-cover page-title-section overlay" style="background-image: url('/images/backgrounds/circle.svg'),url('/images/backgrounds/page-title.webp');background-size: cover;">
    <div class="container-xl">
        <div class="row">
            <div class="col-12">
                <p class="h1">
                    博客
                </p>
                <p class="page-description">
                    Jimmy Song 的原创博客及译文。
                </p>
                
            </div>
        </div>
    </div>
</section>

        


<section class="section-sm book-list-section bg-gray">
  <div class="container-xl">
    <div class="row">
      <div class="col-lg-8 order-2 order-lg-1">
        <div class="row">
          
          
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/envoy-proxy-config-deep-dive/">Istio 的数据平面 Envoy Proxy 配置详解</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2019/01/07</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/envoy"> 
             Envoy
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio 的数据平面 Envoy Proxy 配置详解', '本文介绍了 Envoy proxy 的概念，对应的 xDS 的版本以及配置的详细解析。', '\nEnvoy 是 Istio Service Mesh 中默认的 Sidecar，Istio 在 Envoy 的基础上按照 Envoy 的 xDS 协议扩展了其控制平面，在讲到 Envoy xDS 协议之前还需要我们先熟悉下 Envoy 的基本术语。下面列举了 Envoy 里的基本术语及其数据结构解析，关于 Envoy 的详细介绍请参考 [Envoy 官方文档](https:\/\/cloudnative.to\/envoy\/)，至于 Envoy 在 Service Mesh（不仅限于 Istio）中是如何作为转发代理工作的请参考网易云刘超的这篇[深入解读 Service Mesh 背后的技术细节 ](https:\/\/www.cnblogs.com\/163yun\/p\/8962278.html)以及[理解 Istio Service Mesh 中 Envoy 代理 Sidecar 注入及流量劫持](\/blog\/envoy-sidecar-injection-in-istio-service-mesh-deep-dive\/)，本文引用其中的一些观点，详细内容不再赘述。\n\n![Envoy proxy 架构图](xds.svg)\n\n## 基本术语\n\n下面是您应该了解的 Envoy 里的基本术语：\n\n- **Downstream（下游）**：下游主机连接到 Envoy，发送请求并接收响应，即发送请求的主机。\n- **Upstream（上游）**：上游主机接收来自 Envoy 的连接和请求，并返回响应，即接受请求的主机。\n- **Listener（监听器）**：监听器是命名网地址（例如，端口、unix domain socket 等)，下游客户端可以连接这些监听器。Envoy 暴露一个或者多个监听器给下游主机连接。\n- **Cluster（集群）**：集群是指 Envoy 连接的一组逻辑相同的上游主机。Envoy 通过服务发现来发现集群的成员。可以选择通过主动健康检查来确定集群成员的健康状态。Envoy 通过负载均衡策略决定将请求路由到集群的哪个成员。\n\n我将在本文的后半部分解释以上术语与 Kubernetes、Istio 中概念之间的联系。\n\n## 关于 xDS 的版本\n\n有一点需要大家注意，就是 Envoy 的 API 有 v1 和 v2 两个版本，从 Envoy 1.5.0 起 v2 API 就已经生产就绪了，为了能够让用户顺利的向 v2 版本的额 API 过度，Envoy 启动的时候设置了一个 \u0060--v2-config-only\u0060 的标志，Envoy 不同版本对 v1\/v2 API 的支持详情请参考 [Envoy v1 配置废弃时间表](https:\/\/groups.google.com\/forum\/#!topic\/envoy-announce\/Lb1QZcSclGQ)。\n\nEnvoy 的作者 Matt Klein 在 [Service Mesh 中的通用数据平面 API 设计](https:\/\/cloudnative.to\/blog\/the-universal-data-plane-api\/)这篇文章中说明了 Envoy API v1 的历史及其缺点，还有 v2 的引入。v2 API 是 v1 的演进，而不是革命，它是 v1 功能的超集。\n\n在 Istio 1.0 及以上版本中使用的是 **Envoy 1.8.0-dev** 版本，其支持 v2 的 API，同时在 Envoy 作为 Sidecar proxy 启动的使用使用了例如下面的命令：\n\n\u0060\u0060\u0060bash\n$ \/usr\/local\/bin\/envoy -c \/etc\/istio\/proxy\/envoy-rev0.json --restart-epoch 0 --drain-time-s 45 --parent-shutdown-time-s 60 --service-cluster ratings --service-node sidecar~172.33.14.2~ratings-v1-8558d4458d-ld8x9.default~default.svc.cluster.local --max-obj-name-len 189 --allow-unknown-fields -l warn --v2-config-only\n\u0060\u0060\u0060\n\n上面是都 Bookinfo 示例中的 rating pod 中的 sidecar 启动的分析，可以看到其中指定了 \u0060--v2-config-only\u0060，表明 Istio 1.0\u002b 只支持 xDS v2 的 API。\n\n## Istio sidecar proxy 配置\n\n假如您使用 [kubernetes-vagrant-centos-cluster](https:\/\/github.com\/rootsongjc\/kubernetes-vagrant-centos-cluster) 部署了 Kubernetes 集群并开启了 [Istio Service Mesh](https:\/\/istio.io\/zh)，再部署 [bookinfo 示例](https:\/\/istio.io\/latest\/zh\/docs\/examples\/bookinfo\/)，那么在 \u0060default\u0060 命名空间下有一个名字类似于 \u0060ratings-v1-7c9949d479-dwkr4\u0060 的 Pod，使用下面的命令查看该 Pod 的 Envoy sidecar 的全量配置：\n\n\u0060\u0060\u0060bash\nkubectl -n default exec ratings-v1-7c9949d479-dwkr4 -c istio-proxy curl http:\/\/localhost:15000\/config_dump \u003e dump-rating.json\n\u0060\u0060\u0060\n\n将 Envoy 的运行时配置 dump 出来之后你将看到一个长 6000 余行的配置文件。\n\nIstio 会在为 Service Mesh 中的每个 Pod 注入 Sidecar 的时候同时为 Envoy 注入 Bootstrap 配置，其余的配置是通过 Pilot 下发的，注意整个数据平面即 Service Mesh 中的 Envoy 的动态配置应该是相同的。您也可以使用上面的命令检查其他 sidecar 的 Envoy 配置是否跟最上面的那个相同。\n\n使用下面的命令检查 Service Mesh 中的所有有 Sidecar 注入的 Pod 中的 proxy 配置是否同步。\n\n\u0060\u0060\u0060bash\n$ istioctl proxy-status\nPROXY                                                 CDS        LDS        EDS               RDS          PILOT                            VERSION\ndetails-v1-876bf485f-sx7df.default                    SYNCED     SYNCED     SYNCED (100%)     SYNCED       istio-pilot-5bf6d97f79-6lz4x     1.0.0\n...\n\u0060\u0060\u0060\n\n[istioctl](https:\/\/istio.io\/zh\/docs\/reference\/commands\/istioctl\/) 这个命令行工具就像 [kubectl](https:\/\/jimmysong.io\/kubernetes-handbook\/guide\/kubectl-cheatsheet.html) 一样有很多神器的魔法，通过它可以高效的管理 Istio 和 debug。\n\n## Envoy proxy 配置解析\n\nIstio envoy sidecar proxy 配置中包含以下四个部分。\n\n- **bootstrap**：Envoy proxy 启动时候加载的静态配置。\n- **listeners**：监听器配置，使用 LDS 下发。\n- **clusters**：集群配置，静态配置中包括 xds-grpc 和 zipkin 地址，动态配置使用  CDS 下发。\n- **routes**：路由配置，静态配置中包括了本地监听的服务的集群信息，其中引用了 cluster，动态配置使用 RDS 下发。\n\n每个部分中都包含静态配置与动态配置，其中 bootstrap 配置又是在集群启动的时候通过 sidecar 启动参数注入的，配置文件在 \u0060\/etc\/istio\/proxy\/envoy-rev0.json\u0060。\n\n由于 bootstrap 中的配置是来自 Envoy 启动时加载的静态文件，主要配置了节点信息、tracing、admin 和统计信息收集等信息，这不是本文的重点，大家可以自行研究。\n\nBootstrap 是 Envoy 中配置的根本来源，Bootstrap 消息中有一个关键的概念，就是静态和动态资源的之间的区别。例如 Listener 或 Cluster 这些资源既可以从 static_resources 静态的获得也可以从 dynamic_resources 中配置的 LDS 或 CDS 之类的 xDS 服务获取。\n\n### Listener\n\nListener 顾名思义，就是监听器，监听 IP 地址和端口，然后根据策略转发。\n\n**Listener 的特点**\n\n- 每个 Envoy 进程中可以有多个 Listener，Envoy 与 Listener 之间是一对多的关系。\n- 每个 Listener 中可以配置一条 filter 链表（filter_chains），Envoy 会根据 filter 顺序执行过滤。\n- Listener 可以监听下游的端口，也可以接收来自其他 listener 的数据，形成链式处理。\n- filter 是可扩展的。\n- 可以静态配置，也可以使用 LDS 动态配置。\n- 目前只能监听 TCP，UDP 还未支持。\n\n**Listener 的数据结构**\n\nListener 的数据结构如下，除了 \u0060name\u0060、\u0060address\u0060 和 \u0060filter_chains\u0060 为必须配置之外，其他都为可选的。\n\n\u0060\u0060\u0060json\n{\n  \u0022name\u0022: \u0022...\u0022,\n  \u0022address\u0022: \u0022{...}\u0022,\n  \u0022filter_chains\u0022: [],\n  \u0022use_original_dst\u0022: \u0022{...}\u0022,\n  \u0022per_connection_buffer_limit_bytes\u0022: \u0022{...}\u0022,\n  \u0022metadata\u0022: \u0022{...}\u0022,\n  \u0022drain_type\u0022: \u0022...\u0022,\n  \u0022listener_filters\u0022: [],\n  \u0022transparent\u0022: \u0022{...}\u0022,\n  \u0022freebind\u0022: \u0022{...}\u0022,\n  \u0022socket_options\u0022: [],\n  \u0022tcp_fast_open_queue_length\u0022: \u0022{...}\u0022,\n  \u0022bugfix_reverse_write_filter_order\u0022: \u0022{...}\u0022\n}\n\u0060\u0060\u0060\n\n下面是关于上述数据结构中的常用配置解析。\n\n- **name**：该 listener 的 UUID，唯一限定名，默认 60 个字符，例如 \u006010.254.74.159_15011\u0060，可以使用命令参数指定长度限制。\n\n- **address**：监听的逻辑\/物理地址和端口号，例如\n\n  \u0060\u0060\u0060json\n  \u0022address\u0022: {\n         \u0022socket_address\u0022: {\n          \u0022address\u0022: \u002210.254.74.159\u0022,\n          \u0022port_value\u0022: 15011\n         }\n  }\n  \u0060\u0060\u0060\n\n- **filter_chains**：这是一个列表，Envoy 中内置了一些通用的 filter，每种 filter 都有特定的数据结构，Envoy 会根据该配置顺序执行 filter。Envoy 中内置的 filter 有：[envoy.client_ssl_auth](https:\/\/www.envoyproxy.io\/docs\/envoy\/v1.8.0\/configuration\/network_filters\/client_ssl_auth_filter#config-network-filters-client-ssl-auth)、[envoy.echo](https:\/\/www.envoyproxy.io\/docs\/envoy\/v1.8.0\/configuration\/network_filters\/echo_filter#config-network-filters-echo)、[Envoy.http_connection_manager](https:\/\/www.envoyproxy.io\/docs\/envoy\/v1.8.0\/configuration\/http_conn_man\/http_conn_man#config-http-conn-man)、[envoy.mongo_proxy](https:\/\/www.envoyproxy.io\/docs\/envoy\/v1.8.0\/configuration\/network_filters\/mongo_proxy_filter#config-network-filters-mongo-proxy)、[envoy.rate_limit](https:\/\/www.envoyproxy.io\/docs\/envoy\/v1.8.0\/configuration\/network_filters\/rate_limit_filter#config-network-filters-rate-limit)、[Envoy.redis_proxy](https:\/\/www.envoyproxy.io\/docs\/envoy\/v1.8.0\/configuration\/network_filters\/redis_proxy_filter#config-network-filters-redis-proxy)、[envoy.tcp_proxy](https:\/\/www.envoyproxy.io\/docs\/envoy\/v1.8.0\/configuration\/network_filters\/tcp_proxy_filter#config-network-filters-tcp-proxy)、[http_filters](https:\/\/www.envoyproxy.io\/docs\/envoy\/v1.8.0\/intro\/arch_overview\/http_filters)、[thrift_filters](https:\/\/www.envoyproxy.io\/docs\/envoy\/v1.8.0\/configuration\/thrift_filters\/thrift_filters)等。这些 filter 可以单独使用也可以组合使用，还可以自定义扩展，例如使用 Istio 中的 EnvoyFilter 配置。\n\n- **use_original_dst**：这是一个布尔值，如果使用 iptables 重定向连接，则代理接收的端口可能与原始目的地址的端口不一样。当此标志设置为 true 时，Listener 将重定向的连接切换到与原始目的地址关联的 Listener。如果没有与原始目的地址关联的 Listener，则连接由接收它的 Listener 处理。默认为 false。注意：该参数将被废弃，请使用原始目的地址的 Listener filter 替代。该参数的主要用途是：Envoy 通过监听 15001 端口将应用的流量截取后再由其他 Listener 处理而不是直接转发出去，详情见 [Virtual Listener](https:\/\/zhaohuabing.com\/post\/2018-09-25-istio-traffic-management-impl-intro\/#virtual-listener)。\n\n关于 Listener 的详细介绍请参考 Envoy v2 API reference - listener。\n\n### Route\n\n我们在这里所说的路由指的是 HTTP 路由，这也使得 Envoy 可以用来处理网格边缘的流量。HTTP 路由转发是通过路由过滤器实现的。该过滤器的主要职能就是执行路由表中的指令。除了可以做重定向和转发，路由过滤器还需要处理重试、统计之类的任务。\n\n**HTTP 路由的特点**\n\n- 前缀和精确路径匹配规则。\n- 可跨越多个上游集群进行基于权重\/百分比的路由。\n- 基于优先级的路由。\n- 基于哈希策略的路由。\n\n**Route 的数据结构**\n\n\u0060\u0060\u0060json\n{\n  \u0022name\u0022: \u0022...\u0022,\n  \u0022virtual_hosts\u0022: [],\n  \u0022internal_only_headers\u0022: [],\n  \u0022response_headers_to_add\u0022: [],\n  \u0022response_headers_to_remove\u0022: [],\n  \u0022request_headers_to_add\u0022: [],\n  \u0022request_headers_to_remove\u0022: [],\n  \u0022validate_clusters\u0022: \u0022{...}\u0022\n}\n\u0060\u0060\u0060\n\n下面是关于上述数据结构中的常用配置解析。\n\n- **name**：该名字跟 \u0060envoy.http_connection_manager\u0060 filter 中的 \u0060http_filters.rds.route_config_name\u0060 一致，在 Istio Service Mesh 中为 Envoy 下发的配置中的 Route 是以监听的端口号作为名字，而同一个名字下面的 \u0060virtual_hosts\u0060 可以有多个值（数组形式）。\n- **virtual_hosts**：因为 **VirtualHosts** 是 Envoy 中引入的一个重要概念，我们在下文将详细说明 \u0060virtual_hosts\u0060 的数据结构。\n- **validate_clusters**：这是一个布尔值，用来设置开启使用 cluster manager 来检测路由表引用的 cluster 是否有效。如果是路由表是通过 route_config 静态配置的则该值默认设置为 true，如果是使用 rds 动态配置的话，则该值默认设置为 false。\n\n#### route.VirtualHost\n\nVirtualHost 即上文中 Route 配置中的 \u0060virtual_hosts\u0060，VirtualHost 是路由配置中的顶级元素。每个虚拟主机都有一个逻辑名称以及一组根据传入请求的 host header 路由到它的域。这允许单个 Listener 为多个顶级域路径树提供服务。基于域选择了虚拟主机后 Envoy  就会处理路由以查看要路由到哪个上游集群或是否执行重定向。\n\n**VirtualHost 的数据结构**\n\n下面是 VirtualHost 的数据结构，除了 \u0060name\u0060 和 \u0060domains\u0060 是必须配置项外，其他皆为可选项。\n\n\u0060\u0060\u0060json\n{\n  \u0022name\u0022: \u0022...\u0022,\n  \u0022domains\u0022: [],\n  \u0022routes\u0022: [],\n  \u0022require_tls\u0022: \u0022...\u0022,\n  \u0022virtual_clusters\u0022: [],\n  \u0022rate_limits\u0022: [],\n  \u0022request_headers_to_add\u0022: [],\n  \u0022request_headers_to_remove\u0022: [],\n  \u0022response_headers_to_add\u0022: [],\n  \u0022response_headers_to_remove\u0022: [],\n  \u0022cors\u0022: \u0022{...}\u0022,\n  \u0022per_filter_config\u0022: \u0022{...}\u0022,\n  \u0022include_request_attempt_count\u0022: \u0022...\u0022\n}\n\u0060\u0060\u0060\n\n下面是关于上述数据结构中的常用配置解析。\n\n- **name**：该 VirtualHost 的名字，一般是 FQDN 加端口，如 \u0060details.default.svc.cluster.local:9080\u0060。\n- **domains**：这是个用来匹配 VirtualHost 的域名（host\/authority header）列表，也可以使用通配符，但是通配符不能匹配空字符，除了仅使用 \u0060*\u0060 作为 domains，注意列表中的值不能重复和存在交集，只要有一条 domain 被匹配上了，就会执行路由。Istio 会为该值配置所有地址解析形式，包括 IP 地址、FQDN 和短域名等。\n- **routes**：针对入口流量的有序路由列表，第一个匹配上的路由将被执行。我们在下文将详细说明 route 的数据结构。\n\n下面是一个实际的 VirtualHost 的例子，该配置来自 [Bookinfo 应用](https:\/\/istio.io\/latest\/zh\/docs\/examples\/bookinfo\/)的 details 应用的 Sidecar 服务。\n\n\u0060\u0060\u0060json\n{\n            \u0022name\u0022: \u0022details.default.svc.cluster.local:9080\u0022,\n            \u0022domains\u0022: [\n                \u0022details.default.svc.cluster.local\u0022,\n                \u0022details.default.svc.cluster.local:9080\u0022,\n                \u0022details\u0022,\n                \u0022details:9080\u0022,\n                \u0022details.default.svc.cluster\u0022,\n                \u0022details.default.svc.cluster:9080\u0022,\n                \u0022details.default.svc\u0022,\n                \u0022details.default.svc:9080\u0022,\n                \u0022details.default\u0022,\n                \u0022details.default:9080\u0022,\n                \u002210.254.4.113\u0022,\n                \u002210.254.4.113:9080\u0022\n            ],\n            \u0022routes\u0022: [\n                {\n                    \u0022match\u0022: {\n                        \u0022prefix\u0022: \u0022\/\u0022\n                    },\n                    \u0022route\u0022: {\n                        \u0022cluster\u0022: \u0022outbound|9080||details.default.svc.cluster.local\u0022,\n                        \u0022timeout\u0022: \u00220s\u0022,\n                        \u0022max_grpc_timeout\u0022: \u00220s\u0022\n                    },\n                    \u0022decorator\u0022: {\n                        \u0022operation\u0022: \u0022details.default.svc.cluster.local:9080\/*\u0022\n                    },\n                    \u0022per_filter_config\u0022: {\n                        \u0022mixer\u0022: {\n                            \u0022forward_attributes\u0022: {\n                                \u0022attributes\u0022: {\n                                    \u0022destination.service.uid\u0022: {\n                                        \u0022string_value\u0022: \u0022istio:\/\/default\/services\/details\u0022\n                                    },\n                                    \u0022destination.service.host\u0022: {\n                                        \u0022string_value\u0022: \u0022details.default.svc.cluster.local\u0022\n                                    },\n                                    \u0022destination.service.namespace\u0022: {\n                                        \u0022string_value\u0022: \u0022default\u0022\n                                    },\n                                    \u0022destination.service.name\u0022: {\n                                        \u0022string_value\u0022: \u0022details\u0022\n                                    },\n                                    \u0022destination.service\u0022: {\n                                        \u0022string_value\u0022: \u0022details.default.svc.cluster.local\u0022\n                                    }\n                                }\n                            },\n                            \u0022mixer_attributes\u0022: {\n                                \u0022attributes\u0022: {\n                                    \u0022destination.service.host\u0022: {\n                                        \u0022string_value\u0022: \u0022details.default.svc.cluster.local\u0022\n                                    },\n                                    \u0022destination.service.uid\u0022: {\n                                        \u0022string_value\u0022: \u0022istio:\/\/default\/services\/details\u0022\n                                    },\n                                    \u0022destination.service.name\u0022: {\n                                        \u0022string_value\u0022: \u0022details\u0022\n                                    },\n                                    \u0022destination.service.namespace\u0022: {\n                                        \u0022string_value\u0022: \u0022default\u0022\n                                    },\n                                    \u0022destination.service\u0022: {\n                                        \u0022string_value\u0022: \u0022details.default.svc.cluster.local\u0022\n                                    }\n                                }\n                            },\n                            \u0022disable_check_calls\u0022: true\n                        }\n                    }\n                }\n            ]\n        }\n\u0060\u0060\u0060\n\n#### route.Route\n\n路由既是如何匹配请求的规范，也是对下一步做什么的指示（例如，redirect、forward、rewrite 等）。\n\n**route.Route 的数据结构**\n\n下面是是 route.Route 的数据结构，除了 \u0060match\u0060 之外其余都是可选的。\n\n\u0060\u0060\u0060json\n{\n  \u0022match\u0022: \u0022{...}\u0022,\n  \u0022route\u0022: \u0022{...}\u0022,\n  \u0022redirect\u0022: \u0022{...}\u0022,\n  \u0022direct_response\u0022: \u0022{...}\u0022,\n  \u0022metadata\u0022: \u0022{...}\u0022,\n  \u0022decorator\u0022: \u0022{...}\u0022,\n  \u0022per_filter_config\u0022: \u0022{...}\u0022,\n  \u0022request_headers_to_add\u0022: [],\n  \u0022request_headers_to_remove\u0022: [],\n  \u0022response_headers_to_add\u0022: [],\n  \u0022response_headers_to_remove\u0022: []\n}\n\u0060\u0060\u0060\n\n下面是关于上述数据结构中的常用配置解析。\n\n- **match**：路由匹配参数。例如 URL prefix（前缀）、path（URL 的完整路径）、regex（规则表达式）等。\n- **route**：这里面配置路由的行为，可以是 route、redirect 和 direct_response，不过这里面没有专门的一个配置项用来配置以上三种行为，而是根据实际填充的配置项来确定的。例如在此处添加 \u0060cluster\u0060 配置则暗示路由动作为”route“，表示将流量路由到该 cluster。详情请参考 route.RouteAction。\n- **decorator**：被匹配的路由的修饰符，表示被匹配的虚拟主机和 URL。该配置里有且只有一个必须配置的项 \u0060operation\u0060，例如 \u0060details.default.svc.cluster.local:9080\/*\u0060。\n- **per_filter_config**：这是一个 map 类型，\u0060per_filter_config\u0060 字段可用于为 filter 提供特定路由的配置。Map 的 key 应与 filleter 名称匹配，例如用于 HTTP buffer filter 的 \u0060envoy.buffer\u0060。该字段是特定于 filter 的，详情请参考 HTTP filter。\n\n### Cluster\n\nCluster 是指 Envoy 连接的一组逻辑相同的上游主机。Envoy 通过服务发现来发现 cluster 的成员。可以选择通过主动健康检查来确定集群成员的健康状态。Envoy 通过负载均衡策略决定将请求路由到 cluster 的哪个成员。\n\n**Cluster 的特点**\n\n- 一组逻辑上相同的主机构成一个 cluster。\n- 可以在 cluster 中定义各种负载均衡策略。\n- 新加入的 cluster 需要一个热身的过程才可以给路由引用，该过程是原子的，即在 cluster 热身之前对于 Envoy 及 Service Mesh 的其余部分来说是不可见的。\n- 可以通过多种方式来配置 cluster，例如静态类型、严格限定 DNS、逻辑 DNS、EDS 等。\n\n**Cluster 的数据结构**\n\nCluster 的数据结构如下，除了 \u0060name\u0060 字段，其他都是可选的。\n\n\u0060\u0060\u0060json\n{\n  \u0022name\u0022: \u0022...\u0022,\n  \u0022alt_stat_name\u0022: \u0022...\u0022,\n  \u0022type\u0022: \u0022...\u0022,\n  \u0022eds_cluster_config\u0022: \u0022{...}\u0022,\n  \u0022connect_timeout\u0022: \u0022{...}\u0022,\n  \u0022per_connection_buffer_limit_bytes\u0022: \u0022{...}\u0022,\n  \u0022lb_policy\u0022: \u0022...\u0022,\n  \u0022hosts\u0022: [],\n  \u0022load_assignment\u0022: \u0022{...}\u0022,\n  \u0022health_checks\u0022: [],\n  \u0022max_requests_per_connection\u0022: \u0022{...}\u0022,\n  \u0022circuit_breakers\u0022: \u0022{...}\u0022,\n  \u0022tls_context\u0022: \u0022{...}\u0022,\n  \u0022common_http_protocol_options\u0022: \u0022{...}\u0022,\n  \u0022http_protocol_options\u0022: \u0022{...}\u0022,\n  \u0022http2_protocol_options\u0022: \u0022{...}\u0022,\n  \u0022extension_protocol_options\u0022: \u0022{...}\u0022,\n  \u0022dns_refresh_rate\u0022: \u0022{...}\u0022,\n  \u0022dns_lookup_family\u0022: \u0022...\u0022,\n  \u0022dns_resolvers\u0022: [],\n  \u0022outlier_detection\u0022: \u0022{...}\u0022,\n  \u0022cleanup_interval\u0022: \u0022{...}\u0022,\n  \u0022upstream_bind_config\u0022: \u0022{...}\u0022,\n  \u0022lb_subset_config\u0022: \u0022{...}\u0022,\n  \u0022ring_hash_lb_config\u0022: \u0022{...}\u0022,\n  \u0022original_dst_lb_config\u0022: \u0022{...}\u0022,\n  \u0022least_request_lb_config\u0022: \u0022{...}\u0022,\n  \u0022common_lb_config\u0022: \u0022{...}\u0022,\n  \u0022transport_socket\u0022: \u0022{...}\u0022,\n  \u0022metadata\u0022: \u0022{...}\u0022,\n  \u0022protocol_selection\u0022: \u0022...\u0022,\n  \u0022upstream_connection_options\u0022: \u0022{...}\u0022,\n  \u0022close_connections_on_host_health_failure\u0022: \u0022...\u0022,\n  \u0022drain_connections_on_host_removal\u0022: \u0022...\u0022\n}\n\u0060\u0060\u0060\n\n下面是关于上述数据结构中的常用配置解析。\n\n- **name**：如果你留意到作为 Sidecar 启动的 Envoy 的参数的会注意到 \u0060--max-obj-name-len 189\u0060，该选项用来用来指定 cluster 的名字，例如 \u0060inbound|9080||ratings.default.svc.cluster.local\u0060。该名字字符串由 \u0060|\u0060 分隔成四个部分，分别是 \u0060inbound\u0060 或 \u0060outbound\u0060 代表入向流量或出向流量、端口号、subcluster 名称、FQDN，其中 subcluster 名称将对应于 Istio \u0060DestinationRule\u0060 中配置的 \u0060subnet\u0060，如果是按照多版本按比例路由的话，该值可以是版本号。\n- **type**：即服务发现类型，支持的参数有 \u0060STATIC\u0060（缺省值）、\u0060STRICT_DNS\u0060、\u0060LOGICAL_DNS\u0060、\u0060EDS\u0060、\u0060ORIGINAL_DST\u0060。\n- **hosts**：这是个列表，配置负载均衡的 IP 地址和端口，只有使用了  \u0060STATIC\u0060、\u0060STRICT_DNS\u0060、\u0060LOGICAL_DNS\u0060 服务发现类型时才需要配置。\n- **eds_cluster_config**：如果使用 \u0060EDS\u0060 做服务发现，则需要配置该项目，其中包括的配置有 \u0060service_name\u0060 和 \u0060ads\u0060。\n\n## 参考\n\n- [深入解读 Service Mesh 背后的技术细节 - cnblogs.com](https:\/\/www.cnblogs.com\/163yun\/p\/8962278.html)\n- [理解 Istio Service Mesh 中 Envoy 代理 Sidecar 注入及流量劫持 - jimmysong.io](https:\/\/jimmysong.io\/blog\/envoy-sidecar-injection-in-istio-service-mesh-deep-dive\/)\n', '\/blog\/envoy-proxy-config-deep-dive\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文介绍了 Envoy proxy 的概念，对应的 xDS 的版本以及配置的详细解析。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/envoy-sidecar-routing-of-istio-service-mesh-deep-dive/">理解 Istio Service Mesh 中 Envoy Sidecar 代理的路由转发</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2018/12/26</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('理解 Istio Service Mesh 中 Envoy Sidecar 代理的路由转发', 'Sidecar proxy 中 Indbound\/Outbound 流量处理过程详解。', '\n本文以 Istio 官方的 [bookinfo 示例](https:\/\/preliminary.istio.io\/zh\/docs\/examples\/bookinfo)来讲解在进入 Pod 的流量被 iptables 转交给 Envoy sidecar 后，Envoy 是如何做路由转发的，详述了 Inbound 和 Outbound 处理过程。关于流量拦截的详细分析请参考[理解 Istio Service Mesh 中 Envoy 代理 Sidecar 注入及流量劫持](https:\/\/jimmysong.io\/posts\/envoy-sidecar-injection-in-istio-service-mesh-deep-dive\/)。\n\n下面是 Istio 官方提供的 bookinfo 的请求流程图，假设 bookinfo 应用的所有服务中没有配置 DestinationRule。\n\n![Bookinfo 示例](006tNbRwgy1fvlwjd3302j31bo0ro0x5.jpg)\n\n下面是 Istio 自身组件与 Bookinfo 示例的连接关系图，我们可以看到所有的 HTTP 连接都在 9080 端口监听。\n\n![Bookinfo 示例与 Istio 组件连接关系图](006tNbRwly1fyitp0jsghj31o70u0x6p.jpg)\n\n\n可以在 [Google Drive](https:\/\/drive.google.com\/open?id=19ed3_tkjf6RgGboxllMdt_Ytd5_cocib) 上下载原图。\n\n## Sidecar 注入及流量劫持步骤概述\n\n下面是从 Sidecar 注入、Pod 启动到 Sidecar proxy 拦截流量及 Envoy 处理路由的步骤概览。\n\n**1.** Kubernetes 通过 Admission Controller 自动注入，或者用户使用 \u0060istioctl\u0060 命令手动注入 sidecar 容器。\n\n**2.** 应用 YAML 配置部署应用，此时 Kubernetes API server 接收到的服务创建配置文件中已经包含了 Init 容器及 sidecar proxy。\n\n**3.** 在 sidecar proxy 容器和应用容器启动之前，首先运行 Init 容器，Init 容器用于设置 iptables（Istio 中默认的流量拦截方式，还可以使用 BPF、IPVS 等方式）将进入 pod 的流量劫持到 Envoy sidecar proxy。所有 TCP 流量（Envoy 目前只支持 TCP 流量）将被 sidecar 劫持，其他协议的流量将按原来的目的地请求。\n\n**4.** 启动 Pod 中的 Envoy sidecar proxy 和应用程序容器。这一步的过程请参考[通过管理接口获取完整配置](https:\/\/zhaohuabing.com\/post\/2018-09-25-istio-traffic-management-impl-intro\/#%E9%80%9A%E8%BF%87%E7%AE%A1%E7%90%86%E6%8E%A5%E5%8F%A3%E8%8E%B7%E5%8F%96%E5%AE%8C%E6%95%B4%E9%85%8D%E7%BD%AE)。\n\n\u003e **Sidecar proxy 与应用容器的启动顺序问题**\n\u003e\n\u003e 启动 sidecar proxy 和应用容器，究竟哪个容器先启动呢？正常情况是 Envoy Sidecar 和应用程序容器全部启动完成后再开始接收流量请求。但是我们无法预料哪个容器会先启动，那么容器启动顺序是否会对 Envoy 劫持流量有影响呢？答案是肯定的，不过分为以下两种情况。\n\u003e\n\u003e **情况 1：应用容器先启动，而 sidecar proxy 仍未就绪**\n\u003e\n\u003e 这种情况下，流量被 iptables 转移到 15001 端口，而 Pod 中没有监听该端口，TCP 链接就无法建立，请求失败。\n\u003e\n\u003e **情况 2：Sidecar 先启动，请求到达而应用程序仍未就绪**\n\u003e\n\u003e 这种情况下请求也肯定会失败，至于是在哪一步开始失败的，留给读者来思考。\n\n**问题**：如果为 sidecar proxy 和应用程序容器添加[就绪和存活探针](https:\/\/jimmysong.io\/kubernetes-handbook\/guide\/configure-liveness-readiness-probes.html)是否可以解决该问题呢？\n\n**5.** 不论是进入还是从 Pod 发出的 TCP 请求都会被 iptables 劫持，inbound 流量被劫持后经 Inbound Handler 处理后转交给应用程序容器处理，outbound 流量被 iptables 劫持后转交给 Outbound Handler 处理，并确定转发的 upstream 和 Endpoint。\n\n**6.** Sidecar proxy 请求 Pilot 使用 xDS 协议同步 Envoy 配置，其中包括 LDS、EDS、CDS 等，不过为了保证更新的顺序，Envoy 会直接使用 ADS 向 Pilot 请求配置更新。\n\n## Envoy 如何处理路由转发\n\n 下图展示的是 \u0060productpage\u0060 服务请求访问 \u0060http:\/\/reviews.default.svc.cluster.local:9080\/\u0060，当流量进入 \u0060reviews\u0060 服务内部时，\u0060reviews\u0060 服务内部的 Envoy Sidecar 是如何做流量拦截和路由转发的。可以在 [Google Drive](https:\/\/drive.google.com\/file\/d\/1n-h235tm8DnL_RqxTTA95rgGtrLkBsyr\/view?usp=sharing) 上下载原图。\n\n![Envoy sidecar 流量劫持与路由转发示意图](envoy-sidecar-traffic-interception-zh-20210818.png)\n\n\n第一步开始时，\u0060productpage\u0060 Pod 中的 Envoy sidecar 已经通过 EDS 选择出了要请求的 \u0060reviews\u0060 服务的一个 Pod，知晓了其 IP 地址，发送 TCP 连接请求。\n\nIstio 官网中的 Envoy 配置深度解析中是以发起 HTTP 请求的一方来详述 Envoy 做流量转发的过程，而本文中考虑的是接受 downstream 的流量的一方，它既要接收 downstream 发来的请求，自己还需要请求其他服务，例如 \u0060reviews\u0060 服务中的 Pod 还需要请求 \u0060ratings\u0060 服务。\n\n\u0060reviews\u0060 服务有三个版本，每个版本有一个实例，三个版本中的 sidecar 工作步骤类似，下文只以 \u0060reviews-v1-cb8655c75-b97zc\u0060 这一个 Pod 中的 Sidecar 流量转发步骤来说明。\n\n## 理解 Inbound Handler\n\nInbound handler 的作用是将 iptables 拦截到的 downstream 的流量转交给 localhost，与 Pod 内的应用程序容器建立连接。\n\n查看下 \u0060reviews-v1-cb8655c75-b97zc\u0060 pod 中的 Listener。\n\n运行 \u0060istioctl pc listener reviews-v1-cb8655c75-b97zc\u0060 查看该 Pod 中的具有哪些 Listener。\n\n\u0060\u0060\u0060ini\nADDRESS            PORT      TYPE \n172.33.3.3         9080      HTTP \u003c--- 接收所有 Inbound HTTP 流量，该地址即为当前 Pod 的 IP 地址\n10.254.0.1         443       TCP  \u003c--\u002b\n10.254.4.253       80        TCP     |\n10.254.4.253       8080      TCP     |\n10.254.109.182     443       TCP     |\n10.254.22.50       15011     TCP     |\n10.254.22.50       853       TCP     |\n10.254.79.114      443       TCP     | \n10.254.143.179     15011     TCP     |\n10.254.0.2         53        TCP     | 接收与 0.0.0.0_15001 监听器配对的 Outbound 非 HTTP 流量\n10.254.22.50       443       TCP     |\n10.254.16.64       42422     TCP     |\n10.254.127.202     16686     TCP     |\n10.254.22.50       31400     TCP     |\n10.254.22.50       8060      TCP     |\n10.254.169.13      14267     TCP     |\n10.254.169.13      14268     TCP     |\n10.254.32.134      8443      TCP     |\n10.254.118.196     443       TCP  \u003c--\u002b\n0.0.0.0            15004     HTTP \u003c--\u002b\n0.0.0.0            8080      HTTP    |\n0.0.0.0            15010     HTTP    | \n0.0.0.0            8088      HTTP    |\n0.0.0.0            15031     HTTP    |\n0.0.0.0            9090      HTTP    | \n0.0.0.0            9411      HTTP    | 接收与 0.0.0.0_15001 配对的 Outbound HTTP 流量\n0.0.0.0            80        HTTP    |\n0.0.0.0            15030     HTTP    |\n0.0.0.0            9080      HTTP    |\n0.0.0.0            9093      HTTP    |\n0.0.0.0            3000      HTTP    |\n0.0.0.0            8060      HTTP    |\n0.0.0.0            9091      HTTP \u003c--\u002b    \n0.0.0.0            15001     TCP  \u003c--- 接收所有经 iptables 拦截的 Inbound 和 Outbound 流量并转交给虚拟监听器处理\n\u0060\u0060\u0060\n\n当来自 \u0060productpage\u0060 的流量抵达 \u0060reviews\u0060 Pod 的时候已经，downstream 必须明确知道 Pod 的 IP 地址为 \u0060172.33.3.3\u0060 所以才会访问该 Pod，所以该请求是 \u0060172.33.3.3:9080\u0060。\n\n**\u0060virtual\u0060 Listener**\n\n从该 Pod 的 Listener 列表中可以看到，0.0.0.0:15001\/TCP 的 Listener（其实际名字是 \u0060virtual\u0060）监听所有的 Inbound 流量，下面是该 Listener 的详细配置。\n\n\u0060\u0060\u0060json\n{\n    \u0022name\u0022: \u0022virtual\u0022,\n    \u0022address\u0022: {\n        \u0022socketAddress\u0022: {\n            \u0022address\u0022: \u00220.0.0.0\u0022,\n            \u0022portValue\u0022: 15001\n        }\n    },\n    \u0022filterChains\u0022: [\n        {\n            \u0022filters\u0022: [\n                {\n                    \u0022name\u0022: \u0022envoy.tcp_proxy\u0022,\n                    \u0022config\u0022: {\n                        \u0022cluster\u0022: \u0022BlackHoleCluster\u0022,\n                        \u0022stat_prefix\u0022: \u0022BlackHoleCluster\u0022\n                    }\n                }\n            ]\n        }\n    ],\n    \u0022useOriginalDst\u0022: true\n}\n\u0060\u0060\u0060\n\n**UseOriginalDst**：从配置中可以看出 \u0060useOriginalDst\u0060 配置指定为 \u0060true\u0060，这是一个布尔值，缺省为 false，使用 iptables 重定向连接时，proxy 接收的端口可能与原始目的地址的端口不一样，如此处 proxy 接收的端口为 15001，而原始目的地端口为 9080。当此标志设置为 true 时，Listener 将连接重定向到与原始目的地址关联的 Listener，此处为 \u0060172.33.3.3:9080\u0060。如果没有与原始目的地址关联的 Listener，则连接由接收它的 Listener 处理，即该 \u0060virtual\u0060 Listener，经过 \u0060envoy.tcp_proxy\u0060 过滤器处理转发给 \u0060BlackHoleCluster\u0060，这个 Cluster 的作用正如它的名字，当 Envoy 找不到匹配的虚拟监听器时，就会将请求发送给它，并返回 404。这个将于下文提到的 Listener 中设置 \u0060bindToPort\u0060 相呼应。\n\n**注意**：该参数将被废弃，请使用原始目的地址的 Listener filter 替代。该参数的主要用途是：Envoy 通过监听 15001 端口将 iptables 拦截的流量经由其他 Listener 处理而不是直接转发出去，详情见 [Virtual Listener](https:\/\/zhaohuabing.com\/post\/2018-09-25-istio-traffic-management-impl-intro\/#virtual-listener)。\n\n**Listener 172.33.3.3_9080**\n\n上文说到进入 Inbound handler 的流量被 \u0060virtual\u0060 Listener 转移到 \u0060172.33.3.3_9080\u0060 Listener，我们在查看下该 Listener 配置。\n\n运行 \u0060istioctl pc listener reviews-v1-cb8655c75-b97zc --address 172.33.3.3 --port 9080 -o json\u0060 查看。\n\n\u0060\u0060\u0060json\n[{\n    \u0022name\u0022: \u0022172.33.3.3_9080\u0022,\n    \u0022address\u0022: {\n        \u0022socketAddress\u0022: {\n            \u0022address\u0022: \u0022172.33.3.3\u0022,\n            \u0022portValue\u0022: 9080\n        }\n    },\n    \u0022filterChains\u0022: [\n        {\n            \u0022filterChainMatch\u0022: {\n                \u0022transportProtocol\u0022: \u0022raw_buffer\u0022\n            },\n            \u0022filters\u0022: [\n                {\n                    \u0022name\u0022: \u0022envoy.http_connection_manager\u0022,\n                    \u0022config\u0022: {\n                        ... \n                        \u0022route_config\u0022: {\n                            \u0022name\u0022: \u0022inbound|9080||reviews.default.svc.cluster.local\u0022,\n                            \u0022validate_clusters\u0022: false,\n                            \u0022virtual_hosts\u0022: [\n                                {\n                                    \u0022domains\u0022: [\n                                        \u0022*\u0022\n                                    ],\n                                    \u0022name\u0022: \u0022inbound|http|9080\u0022,\n                                    \u0022routes\u0022: [\n                                        {\n                                            ...\n                                            \u0022route\u0022: {\n                                                \u0022cluster\u0022: \u0022inbound|9080||reviews.default.svc.cluster.local\u0022,\n                                                \u0022max_grpc_timeout\u0022: \u00220.000s\u0022,\n                                                \u0022timeout\u0022: \u00220.000s\u0022\n                                            }\n                                        }\n                                    ]\n                                }\n                            ]\n                        },\n                        \u0022use_remote_address\u0022: false,\n                        ...\n                    }\n                }\n            ]，\n            \u0022deprecatedV1\u0022: {\n                \u0022bindToPort\u0022: false\n            }\n        ...\n        },\n        {\n            \u0022filterChainMatch\u0022: {\n                \u0022transportProtocol\u0022: \u0022tls\u0022\n            },\n            \u0022tlsContext\u0022: {...\n            },\n            \u0022filters\u0022: [...\n            ]\n        }\n    ],\n...\n}]\n\u0060\u0060\u0060\n\n**bindToPort**：注意其中有一个 [\u0060bindToPort\u0060](https:\/\/www.envoyproxy.io\/docs\/envoy\/v1.6.0\/api-v1\/listeners\/listeners) 的配置，其值为 \u0060false\u0060，该配置的缺省值为 \u0060true\u0060，表示将 Listener 绑定到端口上，此处设置为 \u0060false\u0060 则该 Listener 只能处理其他 Listener 转移过来的流量，即上文所说的 \u0060virtual\u0060 Listener，我们看其中的 filterChains.filters 中的 \u0060envoy.http_connection_manager\u0060 配置部分：\n\n\u0060\u0060\u0060json\n\u0022route_config\u0022: {\n                            \u0022name\u0022: \u0022inbound|9080||reviews.default.svc.cluster.local\u0022,\n                            \u0022validate_clusters\u0022: false,\n                            \u0022virtual_hosts\u0022: [\n                                {\n                                    \u0022domains\u0022: [\n                                        \u0022*\u0022\n                                    ],\n                                    \u0022name\u0022: \u0022inbound|http|9080\u0022,\n                                    \u0022routes\u0022: [\n                                        {\n                                            ...\n                                            \u0022route\u0022: {\n                                                \u0022cluster\u0022: \u0022inbound|9080||reviews.default.svc.cluster.local\u0022,\n                                                \u0022max_grpc_timeout\u0022: \u00220.000s\u0022,\n                                                \u0022timeout\u0022: \u00220.000s\u0022\n                                            }\n                                        }\n                                    ]\n                                }\n                            ]\n                        }\n\u0060\u0060\u0060\n\n该配置表示流量将转交给 Cluster \u0060inbound|9080||reviews.default.svc.cluster.local\u0060 处理。\n\n**Cluster \u0060inbound|9080||reviews.default.svc.cluster.local\u0060**\n\n运行 \u0060istioctl pc cluster reviews-v1-cb8655c75-b97zc --fqdn reviews.default.svc.cluster.local --direction inbound -o json\u0060 查看该 Cluster 的配置如下。\n\n\u0060\u0060\u0060json\n[\n    {\n        \u0022name\u0022: \u0022inbound|9080||reviews.default.svc.cluster.local\u0022,\n        \u0022connectTimeout\u0022: \u00221.000s\u0022,\n        \u0022hosts\u0022: [\n            {\n                \u0022socketAddress\u0022: {\n                    \u0022address\u0022: \u0022127.0.0.1\u0022,\n                    \u0022portValue\u0022: 9080\n                }\n            }\n        ],\n        \u0022circuitBreakers\u0022: {\n            \u0022thresholds\u0022: [\n                {}\n            ]\n        }\n    }\n]\n\u0060\u0060\u0060\n\n可以看到该 Cluster 的 Endpoint 直接对应的就是 localhost，再经过 iptables 转发流量就被应用程序容器消费了。\n\n## 理解 Outbound Handler\n\n因为 \u0060reviews\u0060 会向 \u0060ratings\u0060 服务发送 HTTP 请求，请求的地址是：\u0060http:\/\/ratings.default.svc.cluster.local:9080\/\u0060，Outbound handler 的作用是将 iptables 拦截到的本地应用程序发出的流量，经由 Envoy 判断如何路由到 upstream。\n\n应用程序容器发出的请求为 Outbound 流量，被 iptables 劫持后转移给 Envoy  Outbound handler 处理，然后经过 \u0060virtual\u0060 Listener、\u00600.0.0.0_9080\u0060 Listener，然后通过 Route 9080 找到 upstream 的 cluster，进而通过 EDS 找到 Endpoint 执行路由动作。这一部分可以参考 Istio 官网中的 Envoy 深度配置解析。\n\n**Route 9080**\n\n\u0060reviews\u0060 会请求 \u0060ratings\u0060 服务，运行 \u0060istioctl proxy-config routes reviews-v1-cb8655c75-b97zc --name 9080 -o json\u0060 查看 route 配置，因为 Envoy 会根据 HTTP header 中的 domains 来匹配 VirtualHost，所以下面只列举了 \u0060ratings.default.svc.cluster.local:9080\u0060 这一个 VirtualHost。\n\n\u0060\u0060\u0060json\n[{\n    \u0022name\u0022: \u0022ratings.default.svc.cluster.local:9080\u0022,\n    \u0022domains\u0022: [\n        \u0022ratings.default.svc.cluster.local\u0022,\n        \u0022ratings.default.svc.cluster.local:9080\u0022,\n        \u0022ratings\u0022,\n        \u0022ratings:9080\u0022,\n        \u0022ratings.default.svc.cluster\u0022,\n        \u0022ratings.default.svc.cluster:9080\u0022,\n        \u0022ratings.default.svc\u0022,\n        \u0022ratings.default.svc:9080\u0022,\n        \u0022ratings.default\u0022,\n        \u0022ratings.default:9080\u0022,\n        \u002210.254.234.130\u0022,\n        \u002210.254.234.130:9080\u0022\n    ],\n    \u0022routes\u0022: [\n        {\n            \u0022match\u0022: {\n                \u0022prefix\u0022: \u0022\/\u0022\n            },\n            \u0022route\u0022: {\n                \u0022cluster\u0022: \u0022outbound|9080||ratings.default.svc.cluster.local\u0022,\n                \u0022timeout\u0022: \u00220.000s\u0022,\n                \u0022maxGrpcTimeout\u0022: \u00220.000s\u0022\n            },\n            \u0022decorator\u0022: {\n                \u0022operation\u0022: \u0022ratings.default.svc.cluster.local:9080\/*\u0022\n            },\n            \u0022perFilterConfig\u0022: {...\n            }\n        }\n    ]\n},\n..]\n\u0060\u0060\u0060\n\n从该 Virtual Host 配置中可以看到将流量路由到 Cluster \u0060outbound|9080||ratings.default.svc.cluster.local\u0060。\n\n**Endpoint \u0060outbound|9080||ratings.default.svc.cluster.local\u0060**\n\nIstio 1.1 以前版本不支持使用 \u0060istioctl\u0060 命令直接查询 Cluster 的 Endpoint，可以使用查询 Pilot 的 debug 端点的方式折中。\n\n\u0060\u0060\u0060bash\nkubectl exec reviews-v1-cb8655c75-b97zc -c istio-proxy curl http:\/\/istio-pilot.istio-system.svc.cluster.local:9093\/debug\/edsz \u003e endpoints.json\n\u0060\u0060\u0060\n\n\u0060endpoints.json\u0060 文件中包含了所有 Cluster 的 Endpoint 信息，我们只选取其中的 \u0060outbound|9080||ratings.default.svc.cluster.local\u0060 Cluster 的结果如下。\n\n\u0060\u0060\u0060json\n{\n  \u0022clusterName\u0022: \u0022outbound|9080||ratings.default.svc.cluster.local\u0022,\n  \u0022endpoints\u0022: [\n    {\n      \u0022locality\u0022: {\n\n      },\n      \u0022lbEndpoints\u0022: [\n        {\n          \u0022endpoint\u0022: {\n            \u0022address\u0022: {\n              \u0022socketAddress\u0022: {\n                \u0022address\u0022: \u0022172.33.100.2\u0022,\n                \u0022portValue\u0022: 9080\n              }\n            }\n          },\n          \u0022metadata\u0022: {\n            \u0022filterMetadata\u0022: {\n              \u0022istio\u0022: {\n                  \u0022uid\u0022: \u0022kubernetes:\/\/ratings-v1-8558d4458d-ns6lk.default\u0022\n                }\n            }\n          }\n        }\n      ]\n    }\n  ]\n}\n\u0060\u0060\u0060\n\nEndpoint 可以是一个或多个，Envoy 将根据一定规则选择适当的 Endpoint 来路由。\n\n**注**：Istio 1.1 将支持 \u0060istioctl pc endpoint\u0060 命令来查询 Endpoint。\n\n## 参考\n\n- 调试 Envoy 和 Pilot - istio.io\n- [理解 Istio Service Mesh 中 Envoy 代理 Sidecar 注入及流量劫持 - jimmysong.io](https:\/\/jimmysong.io\/posts\/envoy-sidecar-injection-in-istio-service-mesh-deep-dive\/)\n- [Istio 流量管理实现机制深度解析 - zhaohuabing.com](https:\/\/zhaohuabing.com\/post\/2018-09-25-istio-traffic-management-impl-intro\/)\n\n', '\/blog\/envoy-sidecar-routing-of-istio-service-mesh-deep-dive\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">Sidecar proxy 中 Indbound/Outbound 流量处理过程详解。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-service-and-traffic-model/">Istio 中的服务和流量的抽象模型</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2018/12/17</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio 中的服务和流量的抽象模型', '本文介绍了 Istio 和 Kubernetes 中的一些服务和流量的抽象模型。', '\n本文介绍了 Istio 和 Kubernetes 中的一些服务和流量的抽象模型。虽然 Istio 一开始确定的抽象模型与对接的底层平台无关，但目前来看基本绑定 Kubernetes，本文仅以 Kubernetes 说明。另外在 ServiceMesher 社区中最近有很多关于 Istio、Envoy、Kubernetes 之中的服务模型关系的讨论，本文作为一个开篇说明，Kubernetes 和 Isito 之间有哪些共有的服务模型，Istio 在 Kubernetes 的服务模型之上又增加了什么。\n\n**服务具有多个版本。** 在 CI\/CD 过程中，同一个服务可能同时部署在多个环境中，如开发、生产和测试环境等，这些服务版本不一定具有不同的 API，可能只是一些小的更改导致的迭代版本。在 A\/B 测试和灰度发布中经常遇到这种情况。\n\n## Kubernetes 与 Istio 中共有的模型\n\n因为 Istio 基本就是绑定在 Kubernetes 上，下面是我们熟知的 Kubernetes 及 Istio 中共有的服务模型。\n\nKubernetes 中 iptables 代理模式（另外还有 IPVS 模式）下的 service，管理员可以在 kube-proxy 中配置简单的负载均衡，对整个 node 生效，无法配置到单个服务的负载均衡和其他微服务的高级功能，例如熔断、限流、追踪等，这些功能只能在应用中实现了，而在 Istio 的概念模型中完全去掉了 \u0060kube-proxy\u0060  这个组件，将其分散到每个应用 Pod 中同时部署的 Envoy 中实现。\n\n下面列举的是 Kubernetes 和 Istio 中共有的模型。\n\n### Service\n\n这实际上跟 Kubernetes 中的 service 概念是一致的，请参考 [Kubernetes 中的 service](https:\/\/jimmysong.io\/kubernetes-handbook\/concepts\/service.html)。Istio 推出了比 service 更复杂的模型 \u0060VirtualService\u0060，这不单纯是定义一个服务了，而是在服务之上定义了路由规则。\n\n每个服务都有一个完全限定的域名（FQDN），监听一个或多个端口。服务还可以有与其相关联的单个负载均衡器或虚拟 IP 地址。针对 FQDN 的 DNS 查询将解析为该负载均衡器或者虚拟 IP 的地址。\n\n例如 Kubernetes 中一个服务为 \u0060foo.default.svc.cluster.local\u0060 ，虚拟 IP \/ClusterIP 是 10.0.1.1，监听的端口是 80 和 8080。\n\n### Endpoint\n\n这里指的是 Kubernetes 中的 endpoint，一个 endpoint 是实现了某服务的具体实例，一个服务可能有一个或者多个 Endpoint，表示为 IP 地址加端口，也可以为 DNS 名称加端口。\n\n其实到底哪些实例属于同一个 service，还是需要 通过 label 匹配来选择。\n\n### Label\n\n服务的版本、对应的引用名称等是通过 label 来标记的，例如下面 Kubernetes 中一个应用的 YAML 配置。\n\n\u0060\u0060\u0060yaml\napiVersion: extensions\/v1beta1\nkind: Deployment\nmetadata:\n  name: ratings-v1\nspec:\n  replicas: 1\n  template:\n    metadata:\n      labels:\n        app: ratings\n        version: v1\n    spec:\n      containers:\n      - name: ratings\n        image: istio\/examples-bookinfo-ratings-v1:1.8.0\n        imagePullPolicy: IfNotPresent\n        ports:\n        - containerPort: 9080\n\u0060\u0060\u0060\n\n \u0060version: v1\u0060 标记该服务是 v1 版本，\u0060version\u0060 是一个约定俗称的标签，建议大家的服务上都带上该标签。\n\n当然服务的 label 可以设置任意多个，这样的好处是在做路由的时候可以根据标签匹配来做细粒度的流量划分。\n\n## 数据平面 Envoy\n\nEnvoy 是 Istio 中默认的 sidecar proxy，负责服务间的流量管控、认证与安全加密、可观测性等。\n\n下面是 Envoy 的架构图。\n\n![Envoy 架构图](envoy-arch-20190114.png)\n\n我再给大家介绍 Envoy 中的如下几个重要概念。\n\n### Cluster\n\n集群（cluster）是 Envoy 连接到的一组逻辑上相似的上游主机。Envoy 通过服务发现发现集群中的成员。Envoy 可以通过主动运行状况检查来确定集群成员的健康状况。Envoy 如何将请求路由到集群成员由负载均衡策略确定。\n\n这个与 Kubernetes 中的 Service 概念类似，只不过 Kubernetes 中的服务发现中并不包含健康状况检查，而是通过[配置 Pod 的 liveness 和 readiness 探针](https:\/\/jimmysong.io\/kubernetes-handbook\/guide\/configure-liveness-readiness-probes.html)来实现，服务发现默认也是通过 DNS 来实现。\n\n### Listener\n\n监听器（listener）是可以由下游客户端连接的命名网络位置（例如，端口、unix 域套接字等）。Envoy 公开一个或多个下游主机连接的侦听器。一般是每台主机运行一个 Envoy，使用单进程运行，但是每个进程中可以启动任意数量的 Listener（监听器），目前只监听 TCP，每个监听器都独立配置一定数量的（L3\/L4）网络过滤器。Listenter 也可以通过 Listener Discovery Service（**LDS**）动态获取。\n\n### Listener filter\n\nListener 使用 listener filter（监听器过滤器）来操作链接的元数据。它的作用是在不更改 Envoy 的核心功能的情况下添加更多的集成功能。Listener filter 的 API 相对简单，因为这些过滤器最终是在新接受的套接字上运行。在链中可以互相衔接以支持更复杂的场景，例如调用速率限制。Envoy 已经包含了多个监听器过滤器。\n\n## Istio 中增加的流量模型\n\n\u0060VirtualService\u0060、\u0060DestinationRule\u0060、\u0060Gateway\u0060、\u0060ServiceEntry\u0060 和 \u0060EnvoyFilter\u0060 都是 Istio 中为流量管理所创建的 CRD，这些概念其实是做路由配置和流量管理的，而 Kubernetes 中的 service 只是用来做服务发现。Service Mesh 中真正的服务模型应该是 Envoy 的 [xDS 协议](https:\/\/cloudnative.to\/blog\/envoy-xds-protocol\/)，其中包括了服务的流量治理，服务的端点是通过 EDS 来配置的。\n\n![Istio pilot 架构图](istio-pilot.png)\n\n上图是 Pilot 设计图，来自[Istio Pilot design overview](https:\/\/github.com\/istio\/old_pilot_repo\/blob\/master\/doc\/design.md)。\n\n### Routing\n\nKubernetes 中的 service 是没有任何路由属性可以配置的，Istio 在设计之初就通过在同一个 Pod 中，在应用容器旁运行一个 sidecar proxy 来透明得实现细粒度的路由控制。\n\n### VirtualService\n\n\u0060VirtualService\u0060 定义针对指定服务流量的路由规则。每个路由规则都针对特定协议的匹配规则。如果流量符合这些特征，就会根据规则发送到服务注册表中的目标服务（或者目标服务的子集或版本）。对于 A\/B 测试和灰度发布等场景，通常需要使用划分 \u0060subset\u0060，VirtualService 中根据 destination 中的 subset 配置来选择路由，但是这些 subset 究竟对应哪些服务示例，这就需要 \u0060DestionationRule\u0060。\n\n### DestinationRule\n\n\u0060DestinationRule\u0060 所定义的策略，决定了经过路由处理之后的流量的访问策略。这些策略中可以定义负载均衡配置、连接池尺寸以及外部检测（用于在负载均衡池中对不健康主机进行识别和驱逐）配置。\n\n### Gateway\n\n\u0060Gateway\u0060 描述了一个负载均衡器，用于承载网格边缘的进入和发出连接。这一规范中描述了一系列开放端口，以及这些端口所使用的协议、负载均衡的 SNI 配置等内容。\n\n这个实际上就是定义服务网格的边缘路由。\n\n### ServiceEntry\n\n\u0060ServiceEntry\u0060 能够在 Istio 内部的服务注册表中加入额外的条目，从而让网格中自动发现的服务能够访问和路由到这些手工加入的服务。\u0060ServiceEntry\u0060 描述了服务的属性（DNS 名称、VIP、端口、协议以及端点）。这类服务可能是网格外的 API，或者是处于网格内部但却不存在于平台的服务注册表中的条目（例如需要和 Kubernetes 服务沟通的一组虚拟机服务）。\n\n如果没有配置 ServiceEntry 的话，Istio 实际上是无法发现服务网格外部的服务的。\n\n### EnvoyFilter\n\n\u0060EnvoyFilter\u0060 对象描述了针对代理服务的过滤器，这些过滤器可以定制由 Istio Pilot 生成的代理配置。这一功能一定要谨慎使用。错误的配置内容一旦完成传播，可能会令整个服务网格进入瘫痪状态。\n\nEnvoy 中的 listener 可以配置多个 filter，这也是一种通过 Istio 来扩展 Envoy 的机制。\n\n## 参考\n\n- [Kubernetes 中的 service - jimmysong.io](https:\/\/jimmysong.io\/kubernetes-handbook\/concepts\/service.html)\n- [Istio services model - github.com](https:\/\/github.com\/istio\/old_pilot_repo\/blob\/master\/doc\/service-registry.md)\n- [Istio 文档 - istio.io](https:\/\/istio.io)\n', '\/blog\/istio-service-and-traffic-model\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文介绍了 Istio 和 Kubernetes 中的一些服务和流量的抽象模型。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/software-defined-delivery-manifesto/">软件定义交付（SDD）宣言</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2018/11/30</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e4%b8%9a%e6%80%81"> 
             业态
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('软件定义交付（SDD）宣言', '今天给大家分享的是《软件定义交付宣言》，该宣言发出已经有一周多时间了，还在联署签名中。', '\n今天给大家分享的是《软件定义交付宣言》，该宣言发出已经有一周多时间了，目前该宣言的官方网站（\u0060https:\/\/sdd-manifesto.org\/\u0060 已停止维护）还在联署签名中。\n\n云原生通过不可变基础设施与声明式配置，作为了软件定义交付的基础，再假以持续交付工具可以极大的提高软件交付效率，本宣言的起草者中包含众多云原生理念的鉴定拥护者如 Kenny Bastani、Matt Stine 等。\n\n该宣言通过 GitHub 协作草拟（\u003chttps:\/\/github.com\/sdd-manifesto\/manifesto\u003e），仍未达到 1.0 版本。下面是《软件定义交付宣言》的中文版。\n\n## 软件定义交付宣言\n\n我们从日常生产和实践中认识到软件塑造了我们的世界。我们认识到代码才是指定精确操作的最佳方式。我们认识到代码仅在被交付时才有用。\n\n开发的软件被能够被交付出去就软件本身存在的目的。现在是时候将我们的核心技能应用到实际的工作中去了。是时候对交付去做出 *设计* 了。我们将区别人类和计算机在交付工作中承担的作用：人类做决策，计算机来完成自动化任务。\n\n每一次交付工作本质上都是独一无二的。应用程序、组织、部署环境和团队组合千差万别。我们认识到每个团队都需要能够理解这种交付的独特性和对交付做自动化。我们认识到，虽然持续交付对满足业务需求至关重要，但自动执行所有重复任务也非常重要。\n\n我们使用与加速应用程序开发类似的方式来加速软件交付：使用现代架构和编程语言，通用功能的框架、库和服务。\n\n交付基础设施现在是可编程的，我们将对其进行编程。\n\n## 软件定义交付是指\n\n**核心**：交付是每个软件团队和组织的基础和战略能力。\n\n- **优先**：交付的代码是生产代码。\n- **战略**：决定团队和组织层面的策略；在代码中实现精确控制。\n- **不断发展**：不断改进交付。\n\n**工程设计**：强大，可测试的代码。70 年代的脚本语言是不够的。\n\n- **现代软件架构**：事件驱动和可扩展。\n- **现代编程语言**：逻辑最好用代码指定，而不是图片或 GUI。脚本不好扩展。\n- **基于模型**：由软件领域的模型支持，具有对代码的理解。\n- **可测试**：在生产之前启用小规模应用以发现错误。\n\n**协作**：\n\n- **从群众中来**：所有人都可以在代码中表述自己的专业知识，这对大家都有利。\n- **到软件中去**：使用最好的工具，但将它们结合起来之后就是独一无二的。\n- **在人与软件之间**：协同自动化可以增强我们的感知和帮助我们做决策。将信息落实到行动，使我们能够体察软件的自动化行为。通过代码来区分团队的共享交付目标集及其实现。\n\n**加速**：\n\n- **通过自动化**：自动执行重复任务，加快了工作速度还可以避免错误发生。\n- **通过重用**：在开发人员、团队和组织之间共享通用功能。\n\n**可观测性**：通常用于观察和排除作为生产系统的交付过程中发生的情况。\n\n- **跟踪**：观察系统中的活动并跟踪操作之间的关系。\n- **调试**：检查和与交付流程交互。\n- **指标**：在整个交付流程的活动中获取指标。\n\n**作者**：(姓氏按字母顺序排列）：本宣言由 Kenny Bastani、Marc Holmes、Rod Johnson、Jessica Kerr、Mik Kersten、Russ Miles、Erin Schnabel、Matt Stine 及其他社区成员草拟。\n\n©2018，上述作者和本声明可以任何形式自由复制，但需全文复制本声明。\n', '\/blog\/software-defined-delivery-manifesto\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">今天给大家分享的是《软件定义交付宣言》，该宣言发出已经有一周多时间了，还在联署签名中。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/kubecon-cloudnativecon-china-2018/">KubeCon&amp;CloudNativeCon China 2018</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2018/11/16</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e9%9a%8f%e7%ac%94"> 
             随笔
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('KubeCon\u0026CloudNativeCon China 2018', 'KubeCon\u0026CloudNativeCon China 2018 参会回顾。', '\n本次大会是一个难得的机会，让我见到了很多朋友，很多都是第一次在线下见面。\n\n![KubeCon\u0026CloudNativeCon China 上海 2018](kubecon-shanghai-2018-group.webp)\n\n*图中由上自下的大合影是：ServiceMesher 社区上海聚首合影；中美日的 Kubernetes、Envoy、Istio、Apache Skywalking、ServiceMesher 社区在 KubeCon 上海；Yahoo Japan 与蚂蚁集团团队在上海中心办公室合影。*\n\n## 活动\n\n**Meet the Ambassadors**\n\n参加了一场 **Meet the Ambassadors** 采访，第一次参加英文的采访，本来准备的英文回答没用上，现场反而还紧张了。。。工作人员的摄像机又没就位，我还充当了摄影师（本色出演）。一共采访了四位中国的 Ambassador。\n\n- Jiayao (Julia) Han, Caicloud\n- Jia Xuan, China Mobile Research Institute\n- Jimmy Song, Ant Group\n- Jessie Qian, Alauda\n\n我们的名字不约而同的都是 J 字头。\n\n**Service Mesh Roundtable**\n\n然后参加了一场 Service Mesh Roundtable，参加人员有：\n\n- Jimmy Song, Developer Advocate on Cloud Native at Ant Group \n- Yulin Son, Principal Architect at Huawei \n- George Miranda, PagerDuty \n- Nic Jackson, Developer Advocate at HashiCorp \n\n我们就 Service Mesh 的现状，存在的问题后未来进行了广泛的探讨。\n\n## PPT\n\nKubeCon China 会议的很多 PPT 在[大会的官网](https:\/\/www.lfasiallc.com\/events\/kubecon-cloudnativecon-china-2018\/schedule-chinese\/)上都可以下载，或者通过[百度网盘](https:\/\/pan.baidu.com\/s\/1oihwETA063WSFyigWsn8Mw)下载 zip 包，提取码：**5vn0**。或者通过[GitHub](https:\/\/github.com\/bbotte\/cncf-presentations\/tree\/master\/KubeCon%2BCloudNativeCon-2018)下载单个 PPT。\n\n## 飞行\n\n在会场随便一坐，就能遇到熟人。还有很多我都叫不上名字的人来打招呼，不能一一道谢了，感谢晚餐以及收到的 Prometheus 飞行袜。\n\n11 月 12 日晚在上海静安寺上空飞行，航拍的南京西路夜景。\n\n\u003cdiv style=\u0022position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;\u0022\u003e\n  \u003ciframe src=\u0022\/\/player.bilibili.com\/player.html?aid=36041724\u0026cid=63259487\u0026page=1\u0022 style=\u0022position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;\u0022 allowfullscreen title=\u0022Jimmy Song 的航拍视频\u0022\u003e\u003c\/iframe\u003e\n\u003c\/div\u003e\n', '\/blog\/kubecon-cloudnativecon-china-2018\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">KubeCon&amp;CloudNativeCon China 2018 参会回顾。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/envoy-sidecar-injection-in-istio-service-mesh-deep-dive/">理解 Istio Service Mesh 中 Envoy 代理 Sidecar 注入及流量劫持</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2018/09/11</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('理解 Istio Service Mesh 中 Envoy 代理 Sidecar 注入及流量劫持', '以往有很多文章讲解 Istio 是如何做 Sidecar 注入的，但是没有讲解注入之后 Sidecar 工作的细节。本文将带大家详细了解 Istio 是如何将 Envoy 作为 Sidecar 的方式注入到应用程序 Pod 中，及 Sidecar 是如何做劫持流量的。', '\n本文最新更新于 2022 年 3 月 7 日。\n\n\u003e 以往有很多文章讲解 Istio 是如何做 Sidecar 注入的，但是没有讲解注入之后 Sidecar 工作的细节。本文将带大家详细了解 Istio 是如何将 Envoy 作为 Sidecar 的方式注入到应用程序 Pod 中，及 Sidecar 是如何做劫持流量的。\n\n在讲解 Istio 如何将 Envoy 代理注入到应用程序 Pod 中之前，我们需要先了解以下几个概念：\n\n- Sidecar 模式：容器应用模式之一，Service Mesh 架构的一种实现方式。\n- Init 容器：Pod 中的一种专用的容器，在应用程序容器启动之前运行，用来包含一些应用镜像中不存在的实用工具或安装脚本。\n- iptables：流量劫持是通过 iptables 转发实现的。\n\n查看目前 \u0060reviews-v1-745ffc55b7-2l2lw\u0060 Pod 中运行的容器：\n\n\u0060\u0060\u0060bash\n$ kubectl -n default get pod reviews-v1-745ffc55b7-2l2lw -o=jsonpath=\u0027{..spec.containers[*].name}\u0027\nreviews istio-proxy\n\u0060\u0060\u0060\n\n\u0060reviews\u0060 即应用容器，\u0060istio-proxy\u0060 即 Envoy 代理的 sidecar 容器。另外该 Pod 中实际上还运行过一个 Init 容器，因为它执行结束就自动终止了，所以我们看不到该容器的存在。关注 \u0060jsonpath\u0060 的用法请参考 [JSONPath Support](https:\/\/kubernetes.io\/docs\/reference\/kubectl\/jsonpath\/)。\n\n## Sidecar 模式\n\n在了解 Istio 使用 Sidecar 注入之前，需要先说明下什么是 Sidecar 模式。Sidecar 是容器应用模式的一种，也是在 Service Mesh 中发扬光大的一种模式。\n\n使用 Sidecar 模式部署服务网格时，无需在节点上运行代理（因此您不需要基础结构的协作），但是集群中将运行多个相同的 Sidecar 副本。从另一个角度看：我可以为一组微服务部署到一个服务网格中，你也可以部署一个有特定实现的服务网格。在 Sidecar 部署方式中，你会为每个应用的容器部署一个伴生容器。Sidecar 接管进出应用容器的所有流量。在 Kubernetes 的 Pod 中，在原有的应用容器旁边运行一个 Sidecar 容器，可以理解为两个容器共享存储、网络等资源，可以广义的将这个注入了 Sidecar 容器的 Pod 理解为一台主机，两个容器共享主机资源。\n\n下图展示的是 Service Mesh 的架构图，其中的位于每个 Pod 中的 proxy  组成了数据平面，而这些 proxy 正是以 sidecar 模式运行的。\n\n![Istio 架构](istio-sidecar.jpg)\n\n**注意**：下文中所指的 Sidecar 都是指的 Envoy 代理容器。\n\n## Init 容器\n\nInit 容器是一种专用容器，它在应用程序容器启动之前运行，用来包含一些应用镜像中不存在的实用工具或安装脚本。\n\n一个 Pod 中可以指定多个 Init 容器，如果指定了多个，那么 Init 容器将会按顺序依次运行。只有当前面的 Init 容器必须运行成功后，才可以运行下一个 Init 容器。当所有的 Init 容器运行完成后，Kubernetes 才初始化 Pod 和运行应用容器。\n\nInit 容器使用 Linux Namespace，所以相对应用程序容器来说具有不同的文件系统视图。因此，它们能够具有访问 Secret 的权限，而应用程序容器则不能。\n\n在 Pod 启动过程中，Init 容器会按顺序在网络和数据卷初始化之后启动。每个容器必须在下一个容器启动之前成功退出。如果由于运行时或失败退出，将导致容器启动失败，它会根据 Pod 的 \u0060restartPolicy\u0060 指定的策略进行重试。然而，如果 Pod 的 \u0060restartPolicy\u0060 设置为 Always，Init 容器失败时会使用 \u0060RestartPolicy\u0060 策略。\n\n在所有的 Init 容器没有成功之前，Pod 将不会变成 \u0060Ready\u0060 状态。Init 容器的端口将不会在 Service 中进行聚集。正在初始化中的 Pod 处于 \u0060Pending\u0060 状态，但应该会将 \u0060Initializing\u0060 状态设置为 true。Init 容器运行完成以后就会自动终止。\n\n关于 Init 容器的详细信息请参考 [Init 容器 - Kubernetes 中文指南\/云原生应用架构实践手册](\/book\/kubernetes-handbook\/objects\/init-containers\/)。\n\n## Sidecar 注入示例分析\n\n本文我们将以 Istio 官方示例 \u0060bookinfo\u0060 中 \u0060reivews\u0060 服务为例，来接讲解 Sidecar 容器注入的额流程，每个注入了 Sidecar 的 Pod 中除了原先应用的应用本身的容器外，都会多出来这样两个容器：\n\n- \u0060istio-init\u0060：用于给 Sidecar 容器即 Envoy 代理做初始化，设置 iptables 端口转发\n- \u0060istio-proxy\u0060：Envoy 代理容器，运行 Envoy 代理\n\n接下来将分别解析下这两个容器。\n\n### Init 容器解析\n\nIstio 在 Pod 中注入的 Init 容器名为 \u0060istio-init\u0060，如果你查看 \u0060reviews\u0060 Deployment 配置，你将看到其中 \u0060initContaienrs\u0060 的启动参数：\n\n\u0060\u0060\u0060bash\n      initContainers:\n        - name: istio-init\n          image: docker.io\/istio\/proxyv2:1.13.1\n          args:\n            - istio-iptables\n            - \u0027-p\u0027\n            - \u002715001\u0027\n            - \u0027-z\u0027\n            - \u002715006\u0027\n            - \u0027-u\u0027\n            - \u00271337\u0027\n            - \u0027-m\u0027\n            - REDIRECT\n            - \u0027-i\u0027\n            - \u0027*\u0027\n            - \u0027-x\u0027\n            - \u0027\u0027\n            - \u0027-b\u0027\n            - \u0027*\u0027\n            - \u0027-d\u0027\n            - 15090,15021,15020\n\u0060\u0060\u0060\n\n我们看到 \u0060istio-init\u0060 容器的入口是 \u0060istio-iptables\u0060 命令，该命令是用于初始化路由表的。\n\n### Init 容器启动入口\n\nInit 容器的启动入口是 \u0060\/usr\/local\/bin\/istio-iptable\u0060 命令，该命令的用法如下：\n\n\u0060\u0060\u0060bash\n$ istio-iptables -p PORT -u UID -g GID [-m mode] [-b ports] [-d ports] [-i CIDR] [-x CIDR] [-h]\n  -p: 指定重定向所有 TCP 流量的 Envoy 端口（默认为 $ENVOY_PORT = 15001）\n  -u: 指定未应用重定向的用户的 UID。通常，这是代理容器的 UID（默认为 $ENVOY_USER 的 uid，istio_proxy 的 uid 或 1337）\n  -g: 指定未应用重定向的用户的 GID。（与 -u param 相同的默认值）\n  -m: 指定入站连接重定向到 Envoy 的模式，“REDIRECT” 或 “TPROXY”（默认为 $ISTIO_INBOUND_INTERCEPTION_MODE)\n  -b: 逗号分隔的入站端口列表，其流量将重定向到 Envoy（可选）。使用通配符 “*” 表示重定向所有端口。为空时表示禁用所有入站重定向（默认为 $ISTIO_INBOUND_PORTS）\n  -d: 指定要从重定向到 Envoy 中排除（可选）的入站端口列表，以逗号格式分隔。使用通配符“*” 表示重定向所有入站流量（默认为 $ISTIO_LOCAL_EXCLUDE_PORTS）\n  -i: 指定重定向到 Envoy（可选）的 IP 地址范围，以逗号分隔的 CIDR 格式列表。使用通配符 “*” 表示重定向所有出站流量。空列表将禁用所有出站重定向（默认为 $ISTIO_SERVICE_CIDR）\n  -x: 指定将从重定向中排除的 IP 地址范围，以逗号分隔的 CIDR 格式列表。使用通配符 “*” 表示重定向所有出站流量（默认为 $ISTIO_SERVICE_EXCLUDE_CIDR）。\n  -z: 所有入站 TCP 流量重定向端口（默认为 $INBOUND_CAPTURE_PORT 15006）\n\u0060\u0060\u0060\n\n关于该命令的详细代码请[查看 GitHub：\u0060tools\/istio-iptables\/pkg\/cmd\/root.go\u0060](https:\/\/github.com\/istio\/istio\/blob\/master\/tools\/istio-iptables\/pkg\/cmd\/root.go)。\n\n再参考 \u0060istio-init\u0060 容器的启动参数，完整的启动命令如下：\n\n\u0060\u0060\u0060bash\n$ \/usr\/local\/bin\/istio-iptables -p 15001 -z 15006 -u 1337 -m REDIRECT -i \u0027*\u0027 -x \u0022\u0022 -b * -d \u002215090,15201,15020\u0022\n\u0060\u0060\u0060\n\n该容器存在的意义就是让 Envoy 代理可以拦截所有的进出 Pod 的流量，即将入站流量重定向到 Sidecar，再拦截应用容器的出站流量经过 Sidecar 处理后再出站。\n\n**命令解析**\n\n这条启动命令的作用是：\n\n- 将应用容器的所有流量都转发到 Envoy 的 15006 端口。\n- 使用 \u0060istio-proxy\u0060 用户身份运行，UID 为 1337，即 Envoy 所处的用户空间，这也是 \u0060istio-proxy\u0060 容器默认使用的用户，见 YAML 配置中的 \u0060runAsUser\u0060 字段。\n- 使用默认的 \u0060REDIRECT\u0060 模式来重定向流量。\n- 将所有出站流量都重定向到 Envoy 代理。\n- 将除了 15090、15201、15020 端口以外的所有端口的流量重定向到 Envoy 代理。\n\n因为 Init 容器初始化完毕后就会自动终止，因为我们无法登陆到容器中查看 iptables 信息，但是 Init 容器初始化结果会保留到应用容器和 Sidecar 容器中。\n\n### istio-proxy 容器解析\n\n为了查看 iptables 配置，我们需要登陆到 Sidecar 容器中使用 root 用户来查看，因为 \u0060kubectl\u0060 无法使用特权模式来远程操作 docker 容器，所以我们需要登陆到 \u0060reviews\u0060 Pod 所在的主机上使用 \u0060docker\u0060 命令登陆容器中查看。\n\n查看 \u0060reviews\u0060 Pod 所在的主机。\n\n\u0060\u0060\u0060bash\n$ kubectl -n default get pod -l app=reviews -o wide\nNAME                              READY     STATUS    RESTARTS   AGE       IP             NODE\nreviews-v1-745ffc55b7-2l2lw   2\/2       Running   0          1d        172.33.78.10   node3\n\u0060\u0060\u0060\n\n从输出结果中可以看到该 Pod 运行在 \u0060node3\u0060 上，使用 \u0060vagrant\u0060 命令登陆到 \u0060node3\u0060 主机中并切换为 root 用户。\n\n\u0060\u0060\u0060bash\n$ vagrant ssh node3\n$ sudo -i\n\u0060\u0060\u0060\n\n查看 iptables 配置，列出 NAT（网络地址转换）表的所有规则，因为在 Init 容器启动的时候选择给  \u0060istio-iptables.sh\u0060 传递的参数中指定将入站流量重定向到 Envoy 的模式为“REDIRECT”，因此在 iptables 中将只有 NAT 表的规格配置，如果选择 \u0060TPROXY\u0060 还会有 \u0060mangle\u0060 表配置。\u0060iptables\u0060 命令的详细用法请参考 [iptables](https:\/\/wangchujiang.com\/linux-command\/c\/iptables.html)，规则配置请参考 [iptables 规则配置](http:\/\/www.zsythink.net\/archives\/1517)。\n\n## 理解 iptables\n\n\u0060iptables\u0060 是 Linux 内核中的防火墙软件 netfilter 的管理工具，位于用户空间，同时也是 netfilter 的一部分。Netfilter 位于内核空间，不仅有网络地址转换的功能，也具备数据包内容修改、以及数据包过滤等防火墙功能。\n\n在了解 Init 容器初始化的 iptables 之前，我们先来了解下 iptables 和规则配置。\n\n下图展示了 iptables 调用链。\n\n![iptables 调用链](iptables_packetflow.png)\n\n### iptables 中的表\n\nInit 容器中使用的的 iptables 版本是 \u0060v1.6.0\u0060，共包含 5 张表：\n\n1. \u0060raw\u0060 用于配置数据包，\u0060raw\u0060 中的数据包不会被系统跟踪。\n2. \u0060filter\u0060 是用于存放所有与防火墙相关操作的默认表。\n3. \u0060nat\u0060 用于 [网络地址转换](https:\/\/en.wikipedia.org\/wiki\/Network_address_translation)（例如：端口转发）。\n4. \u0060mangle\u0060 用于对特定数据包的修改（参考[损坏数据包](https:\/\/en.wikipedia.org\/wiki\/Mangled_packet)）。\n5. \u0060security\u0060 用于[强制访问控制](https:\/\/wiki.archlinux.org\/index.php\/Security#Mandatory_access_control) 网络规则。\n\n**注**：在本示例中只用到了 \u0060nat\u0060 表。\n\n不同的表中的具有的链类型如下表所示：\n\n| 规则名称    | raw  | filter | nat  | mangle | security |\n| ----------- | ---- | ------ | ---- | ------ | -------- |\n| PREROUTING  | ✓    |        | ✓    | ✓      |          |\n| INPUT       |      | ✓      | ✓    | ✓      | ✓        |\n| OUTPUT      |      | ✓      | ✓    | ✓      | ✓        |\n| POSTROUTING |      |        | ✓    | ✓      |          |\n| FORWARD     | ✓    | ✓      |      | ✓      | ✓        |\n\n下图是 iptables 的调用链顺序。\n\n![iptables 调用链顺序](iptables-chains.jpg)\n\n\n### iptables 命令\n\n\u0060iptables\u0060 命令的主要用途是修改这些表中的规则。\u0060iptables\u0060 命令格式如下：\n\n\u0060\u0060\u0060bash\n$ iptables [-t 表名] 命令选项［链名]［条件匹配］[-j 目标动作或跳转］\n\u0060\u0060\u0060\n\nInit 容器中的 \u0060\/istio-iptables.sh\u0060 启动入口脚本就是执行 iptables 初始化的。\n\n### 理解 iptables 规则\n\n查看 \u0060istio-proxy\u0060 容器中的默认的 iptables 规则，默认查看的是 filter 表中的规则。\n\n\u0060\u0060\u0060bash\n$ iptables -L -v\nChain INPUT (policy ACCEPT 350K packets, 63M bytes)\n pkts bytes target     prot opt in     out     source               destination\n\nChain FORWARD (policy ACCEPT 0 packets, 0 bytes)\n pkts bytes target     prot opt in     out     source               destination\n\nChain OUTPUT (policy ACCEPT 18M packets, 1916M bytes)\n pkts bytes target     prot opt in     out     source               destination\n\u0060\u0060\u0060\n\n我们看到三个默认的链，分别是 INPUT、FORWARD 和 OUTPUT，每个链中的第一行输出表示链名称（在本例中为 INPUT\/FORWARD\/OUTPUT），后跟默认策略（ACCEPT）。\n\n每条链中都可以添加多条规则，规则是按照顺序从前到后执行的。我们来看下规则的表头定义。\n\n- **pkts**：处理过的匹配的报文数量\n- **bytes**：累计处理的报文大小（字节数）\n- **target**：如果报文与规则匹配，指定目标就会被执行。\n- **prot**：协议，例如 \u0060tdp\u0060、\u0060udp\u0060、\u0060icmp\u0060 和 \u0060all\u0060。 \n- **opt**：很少使用，这一列用于显示 IP 选项。\n- **in**：入站网卡。\n- **out**：出站网卡。\n- **source**：流量的源 IP 地址或子网，后者是 \u0060anywhere\u0060。\n- **destination**：流量的目的地 IP 地址或子网，或者是 \u0060anywhere\u0060。\n\n还有一列没有表头，显示在最后，表示规则的选项，作为规则的扩展匹配条件，用来补充前面的几列中的配置。\u0060prot\u0060、\u0060opt\u0060、\u0060in\u0060、\u0060out\u0060、\u0060source\u0060 和 \u0060destination\u0060 和显示在 \u0060destination\u0060 后面的没有表头的一列扩展条件共同组成匹配规则。当流量匹配这些规则后就会执行 \u0060target\u0060。\n\n\n**target 支持的类型**\n\n\u0060target\u0060 类型包括 ACCEPT\u0060、REJECT\u0060、\u0060DROP\u0060、\u0060LOG\u0060 、\u0060SNAT\u0060、\u0060MASQUERADE\u0060、\u0060DNAT\u0060、\u0060REDIRECT\u0060、\u0060RETURN\u0060 或者跳转到其他规则等。只要执行到某一条链中只有按照顺序有一条规则匹配后就可以确定报文的去向了，除了 \u0060RETURN\u0060 类型，类似编程语言中的 \u0060return\u0060 语句，返回到它的调用点，继续执行下一条规则。\u0060target\u0060 支持的配置详解请参考 [iptables 详解（1）：iptables 概念](http:\/\/www.zsythink.net\/archives\/1199)。\n\n从输出结果中可以看到 Init 容器没有在 iptables 的默认链路中创建任何规则，而是创建了新的链路。\n\n## 查看 iptables nat 表中注入的规则\n\nInit 容器通过向 iptables nat 表中注入转发规则来劫持流量的，下图显示的是三个 reviews 服务示例中的某一个 Pod，其中有 init 容器、应用容器和 sidecar 容器，图中展示了 iptables 流量劫持的详细过程。\n\n![Envoy sidecar 流量劫持与路由转发示意图](istio-iptables.svg)\n\nInit 容器启动时命令行参数中指定了 \u0060REDIRECT\u0060 模式，因此只创建了 NAT 表规则，接下来我们查看下 NAT 表中创建的规则，这是全文中的**重点部分**，前面讲了那么多都是为它做铺垫的。\n\n### 进入到 reviews pod\n\nReviews 服务有三个版本，我们进入到其中任意一个版本，例如 reviews-1，首先你需要搞清楚这个 pod 运行在哪个节点上，知道那个容器的具体 ID，然后使用 SSH 登录那个节点，使用 \u0060ps\u0060 命令查看到那个容器的具体 IP，使用 \u0060nsenter\u0060 命令进入该容器。\n\n\u0060\u0060\u0060sh\nnsenter -t{PID} -n\n\u0060\u0060\u0060\n\n**为什么不直接使用 kubectl 进入容器？**\n\nIstio 向 pod 中自动注入的 sidecar 容器（名为 \u0060istio-proxy\u0060）其中默认的用户是 \u0060istio-proxy\u0060，该用户没有权限查看路由表规则，即当你在该容器中运行 \u0060iptabes\u0060 命令时会得到 \u0060iptables -t nat -L -v\u0060 这样的结果，而且你又没有 root 权限。对于 reviews 容器也是一样，默认用户的 UID 是 \u00601000\u0060，而且这个用户又没有名字，一样也无法切换为 root 用户，系统中默认没有安装 iptabels 命令。所以我们只能登录到 Pod 的宿主节点上，使用 \u0060nsenter\u0060 命令进入容器内部。\n\n### 查看路由表\n\n下面是查看 nat 表中的规则，其中链的名字中包含 \u0060ISTIO\u0060 前缀的是由 Init 容器注入的，规则匹配是根据下面显示的顺序来执行的，其中会有多次跳转。\n\n\u0060\u0060\u0060bash\n# 查看 NAT 表中规则配置的详细信息\n$ iptables -t nat -L -v\n# PREROUTING 链：用于目标地址转换（DNAT），将所有入站 TCP 流量跳转到 ISTIO_INBOUND 链上\nChain PREROUTING (policy ACCEPT 0 packets, 0 bytes)\n pkts bytes target     prot opt in     out     source               destination\n    2   120 ISTIO_INBOUND  tcp  --  any    any     anywhere             anywhere\n\n# INPUT 链：处理输入数据包，非 TCP 流量将继续 OUTPUT 链\nChain INPUT (policy ACCEPT 2 packets, 120 bytes)\n pkts bytes target     prot opt in     out     source               destination\n\n# OUTPUT 链：将所有出站数据包跳转到 ISTIO_OUTPUT 链上\nChain OUTPUT (policy ACCEPT 41146 packets, 3845K bytes)\n pkts bytes target     prot opt in     out     source               destination\n   93  5580 ISTIO_OUTPUT  tcp  --  any    any     anywhere             anywhere\n\n# POSTROUTING 链：所有数据包流出网卡时都要先进入POSTROUTING 链，内核根据数据包目的地判断是否需要转发出去，我们看到此处未做任何处理\nChain POSTROUTING (policy ACCEPT 41199 packets, 3848K bytes)\n pkts bytes target     prot opt in     out     source               destination\n\n# ISTIO_INBOUND 链：将所有目的地为 9080 端口的入站流量重定向到 ISTIO_IN_REDIRECT 链上\nChain ISTIO_INBOUND (1 references)\n pkts bytes target     prot opt in     out     source               destination\n    2   120 ISTIO_IN_REDIRECT  tcp  --  any    any     anywhere             anywhere             tcp dpt:9080\n\n# ISTIO_IN_REDIRECT 链：将所有的入站流量跳转到本地的 15006 端口，至此成功的拦截了流量到 Envoy \nChain ISTIO_IN_REDIRECT (1 references)\n pkts bytes target     prot opt in     out     source               destination\n    2   120 REDIRECT   tcp  --  any    any     anywhere             anywhere             redir ports 15006\n\n# ISTIO_OUTPUT 链：选择需要重定向到 Envoy（即本地） 的出站流量，所有非 localhost 的流量全部转发到 ISTIO_REDIRECT。为了避免流量在该 Pod 中无限循环，所有到 istio-proxy 用户空间的流量都返回到它的调用点中的下一条规则，本例中即 OUTPUT 链，因为跳出 ISTIO_OUTPUT 规则之后就进入下一条链 POSTROUTING。如果目的地非 localhost 就跳转到 ISTIO_REDIRECT；如果流量是来自 istio-proxy 用户空间的，那么就跳出该链，返回它的调用链继续执行下一条规则（OUPT 的下一条规则，无需对流量进行处理）；所有的非 istio-proxy 用户空间的目的地是 localhost 的流量就跳转到 ISTIO_REDIRECT\nChain ISTIO_OUTPUT (1 references)\n pkts bytes target     prot opt in     out     source               destination\n    0     0 ISTIO_REDIRECT  all  --  any    lo      anywhere            !localhost\n   40  2400 RETURN     all  --  any    any     anywhere             anywhere             owner UID match istio-proxy\n    0     0 RETURN     all  --  any    any     anywhere             anywhere             owner GID match istio-proxy\t\n    0     0 RETURN     all  --  any    any     anywhere             localhost\n   53  3180 ISTIO_REDIRECT  all  --  any    any     anywhere             anywhere\n\n# ISTIO_REDIRECT 链：将所有流量重定向到 Envoy（即本地） 的 15001 端口\nChain ISTIO_REDIRECT (2 references)\n pkts bytes target     prot opt in     out     source               destination\n   53  3180 REDIRECT   tcp  --  any    any     anywhere             anywhere             redir ports 15001\n\u0060\u0060\u0060\n\n\u0060iptables\u0060 显示的链的顺序，即流量规则匹配的顺序。其中要特别注意 \u0060ISTIO_OUTPUT\u0060 链中的规则配置。为了避免流量一直在 Pod 中无限循环，所有到 istio-proxy 用户空间的流量都返回到它的调用点中的下一条规则，本例中即 OUTPUT 链，因为跳出 \u0060ISTIO_OUTPUT\u0060 规则之后就进入下一条链 \u0060POSTROUTING\u0060。\n\n\u0060ISTIO_OUTPUT\u0060 链规则匹配的详细过程如下：\n\n- 如果目的地非 localhost 就跳转到 ISTIO_REDIRECT 链\n- 所有来自 istio-proxy 用户空间的非 localhost 流量跳转到它的调用点 \u0060OUTPUT\u0060 继续执行 \u0060OUTPUT\u0060 链的下一条规则，因为 \u0060OUTPUT\u0060 链中没有下一条规则了，所以会继续执行 \u0060POSTROUTING\u0060 链然后跳出 iptables，直接访问目的地\n- 如果流量不是来自 istio-proxy 用户空间，又是对 localhost 的访问，那么就跳出 iptables，直接访问目的地\n- 其它所有情况都跳转到 \u0060ISTIO_REDIRECT\u0060 链\n\n其实在最后这条规则前还可以增加 IP 地址过滤，让某些 IP 地址段不通过 Envoy 代理。\n\n以上 iptables 规则都是 Init 容器启动的时使用 [istio-iptables](https:\/\/github.com\/istio\/istio\/tree\/master\/tools\/istio-iptables) 命令生成的，详细过程可以查看该命令行程序。\n\n## 参考\n\n- [Init 容器 - Kubernetes 中文指南\/云原生应用架构实践手册 - jimmysong.io](\/book\/kubernetes-handbook\/objects\/init-containers\/)\n- [JSONPath Support - kubernetes.io](https:\/\/kubernetes.io\/docs\/reference\/kubectl\/jsonpath\/)\n- [iptables 命令使用说明 - wangchujiang.com](https:\/\/wangchujiang.com\/linux-command\/c\/iptables.html)\n- [How To List and Delete Iptables Firewall Rules - digitalocean.com](https:\/\/www.digitalocean.com\/community\/tutorials\/how-to-list-and-delete-iptables-firewall-rules)\n- [一句一句解说 iptables 的详细中文手册 - cnblog.com](https:\/\/www.cnblogs.com\/fhefh\/archive\/2011\/04\/04\/2005249.html)\n', '\/blog\/envoy-sidecar-injection-in-istio-service-mesh-deep-dive\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">以往有很多文章讲解 Istio 是如何做 Sidecar 注入的，但是没有讲解注入之后 Sidecar 工作的细节。本文将带大家详细了解 Istio 是如何将 Envoy 作为 Sidecar 的方式注入到应用程序 Pod 中，及 Sidecar 是如何做劫持流量的。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/sofamesh-and-mosn-proxy-sidecar-service-mesh-by-ant-financial/">蚂蚁集团开源 SOFAMesh</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2018/07/16</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('蚂蚁集团开源 SOFAMesh', '蚂蚁集团开源 SOFAMesh—一款基于 Istio 改进和扩展而来的 Service Mesh 大规模落地实践方案。', '\n{{\u003ccallout warning 注意\u003e}}\n\nSOFAMesh 已闭源，本文已过时。\n\n{{\u003c\/callout\u003e}}\n\n4 月，蚂蚁集团自主研发的分布式中间件（Scalable Open Financial Architecture，以下简称 SOFA）启动开源计划，并开放多个组件，（相关背景请点击链接阅读《[开源 | 蚂蚁集团启动分布式中间件开源计划，用于快速构建金融级云原生架构](http:\/\/mp.weixin.qq.com\/s?__biz=MzI0Nzc3MTQyMw==\u0026mid=2247484729\u0026idx=1\u0026sn=0d8dbee2739fb0eef3e4ad699661fd13\u0026chksm=e9abbd49dedc345fd5d6898fd1989710f249d6386bf3d52ae1603365a4a1c3696538bc8b9a8f\u0026scene=21#wechat_redirect) 》、《[开源 | 蚂蚁集团分布式中间件开源第二弹：丰富微服务架构体系](http:\/\/mp.weixin.qq.com\/s?__biz=MzI0Nzc3MTQyMw==\u0026mid=2247485026\u0026idx=1\u0026sn=0a367bc67d5fe3a268e3715b17e020ab\u0026chksm=e9abbe12dedc370489102d9307b832457891fdb0530eec5c35c0fb82bc2a3e6dbbc7db8436c4\u0026scene=21#wechat_redirect) 》），这一系列的动作受到大家的关注和支持，SOFA 社区也日益壮大。\n\n在两轮开源之后，蚂蚁集团自主研发的分布式中间件（Scalable Open Financial Architecture，以下简称 SOFA）在今天推出了**第三轮的开源产品：SOFAMesh**。和前两轮开源的历经多年沉淀和打磨的成熟产品不同，本轮的开源主角 SOFAMesh，将探索一条和以往产品有所不同的开源道路。下面我们就来看看到底有哪些不同吧！\n\n## SOFAMesh 的开源探索之路\n\nSOFAMesh 尝试在以下几个方面进行自我突破和勇敢探索：\n\n**全新的技术领域**\n\nService Mesh 是目前技术社区最为炙手可热的新技术方向，有下一代微服务的明显趋势。但是目前 Service Mesh 技术还处于发展早期，暂时还没有成熟的产品，尤其缺乏大规模的落地实践。\n\n**较早的开源时间**\n\n在上述背景下，我们选择了将启动不久的 Service Mesh 产品开源在开发早期，也就是还未成熟之时，就对社区开放，开放源码并寻求社区合作。\n\n**更加开放的态度**\n\n在 SOFAMesh 上，我们愿意以开源共建的方式来和社区一起推进 Service Mesh 技术的更好发展和实现落地实践，共同打造一个技术先进，功能丰富，具备良好的性能和稳定性，可以实实在在的生产落地的优秀产品。欢迎国内技术社区的朋友们和我们开展不同层面的交流与合作。\n\n**务实的产品路线**\n\nSOFAMesh 在产品路线上，选择了跟随社区主流，我们选择了目前 Service Mesh 中最有影响力和前景的 Istio。SOFAMesh 会在 Istio 的基础上，提升性能，增加扩展性，并在落地实践上做探索和补充，以弥补目前 Istio 的不足，同时保持与 Istio 社区的步骤一致和持续跟进。\n\n## SOFAMesh 介绍\n\nSOFAMesh 将在兼容 Istio 整体架构和协议的基础上，做出部分调整：\n\n1. 使用 Golang 语言开发全新的 Sidecar，替代 Envoy\n2. 为了避免 Mixer 带来的性能瓶颈，合并 Mixer 部分功能进入 Sidecar\n3. Pilot 和 Citadel 模块进行了大幅的扩展和增强\n\n我们的目标：打造一个更加务实的 Istio 落地版本！\n\n{{\u003ccallout note 备注\u003e}}\n\n以上架构调整的细节以及我们做调整的出发点和原因，请浏览 [蚂蚁集团大规模微服务架构下的 Service Mesh 探索之路](https:\/\/cloudnative.to\/blog\/the-way-to-service-mesh-in-ant-financial\/) 一文，有非常详尽的解释。\n\n{{\u003c\/callout\u003e}}\n\n## 开源内容\n\n在本轮开源中，我们将推出 SOFAMesh 目前正在开发的两大模块：MOSN 和 SOFAPilot。\n\n## MOSN\n\nSOFAMesh 中 Golang 版本的 Sidecar，是一个名为 MOSN (Modular Observable Smart Netstub) 的全新开发的模块，实现 Envoy 的功能，兼容 Envoy 的 API，可以和 Istio 集成。\n\n![MOSN 架构图](mosn-with-service-mesh.png)\n\n此外，我们会增加对 SOFARPC、Dubbo 等通讯协议的支持，以便更好的迎合国内用户包括我们自身的实际需求。\n\n由于 Sidecar 相对独立，而且我们也预期会有单独使用 MOSN 的场景，因此 MOSN 的代码仓库是独立于 SOFAMesh 的，地址为：https:\/\/github.com\/mosn\/mosn\n\n欢迎大家使用，提供需求、反馈问题、贡献代码或者合作开发。\n\n## SOFAPilot\n\n我们将大幅扩展和增强 Istio 中的 Pilot 模块：\n\n1. 增加 SOFARegistry 的 Adapter，提供超大规模服务注册和发现的解决方案\n2. 增加数据同步模块，以实现多个服务注册中心之间的数据交换。\n3. 增加 Open Service Registry API，提供标准化的服务注册功能\n\nMOSN 和 SOFAPilot 配合，将可以提供让传统侵入式框架（如 Spring Cloud，Dubbo，SOFA RPC 等）和 Service Mesh 产品可以相互通讯的功能，以便可以平滑的向 Service Mesh 产品演进和过渡。\n\n**Pilot 和后面会陆续开放的 Mixer，Citadel 等 Istio 模块**，会统一存放在同一个从 Istio Fork 出来的代码仓库中。未来会持续更新 Istio 最新代码，以保持和 Istio 的一致。\n\n## 附录\n\n本文中提到的链接地址集合：\n\n- [MOSN](https:\/\/github.com\/mosn\/mosn)\n- [蚂蚁集团大规模微服务架构下的 Service Mesh 探索之路](https:\/\/cloudnative.to\/blog\/the-way-to-service-mesh-in-ant-financial\/)\n', '\/blog\/sofamesh-and-mosn-proxy-sidecar-service-mesh-by-ant-financial\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">蚂蚁集团开源 SOFAMesh—一款基于 Istio 改进和扩展而来的 Service Mesh 大规模落地实践方案。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/hello-pulumi-from-jeo-duffy/">[译] 云原生编程语言 Pulumi 开源宣言</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2018/06/24</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e5%bc%80%e6%ba%90"> 
             开源
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="http://joeduffyblog.com/2018/06/18/hello-pulumi/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('云原生编程语言 Pulumi 开源宣言', '2018 年 6 月 18 日 Joe Duffy 在他的博客中宣布开源了云原生编程语言 Pulumi。', '\n\u003e 2018 年 6 月 18 日 Joe Duffy 在[他的博客](http:\/\/joeduffyblog.com\/2018\/06\/18\/hello-pulumi\/)中宣布开源了云原生编程语言[Pulumi](https:\/\/pulumi.io)。这是继[Ballerina](https:\/\/ballerina.io)之后我看到的另一款云原生编程语言，他们之间有一些共同的特点，例如都是为了支持多种云环境，基于不可变基础设施和基础设施即代码的理念构建，使云原生应用的集成更加方便，但也有一些不同，Ballerina 是直接创建了一个基于 JVM 的语言，而 Pulumi 是为不同编程语言构建了 SDK。\n\u003e\n\u003e 下文是对 [Hello, Pulumi!](http:\/\/joeduffyblog.com\/2018\/06\/18\/hello-pulumi\/)一文的翻译。\n\n今天我们发布了 Pulumi，这是一款开源的云开发平台。有了 Pulumi，您可以使用自己最喜欢的编程语言来开发云应用程序，可以直接跨过底层的基础设施即代码直接开发更高效更具生产力的现代容器和 serverless 应用。一年多前我们发起了 Pulumi，我们都为自己在这一年多取得的成绩感到惊讶。这是我们开源的第一步，也是我们做出的一步重大跨越，我们期望与您分享我们的成就。\n\nPulumi 支持多语言、混合云环境、完全可扩展。初期支持 JavaScript、TypeScript、Python 和 Go 语言，支持 AWS、Azure、GCP 云平台，另外还支持所有兼容 Kubernetes 的公有云、私有云和混合云。Pulumi 实现了一种单一、一致的编程模型，一组编程工具，可管理所有以上环境，丰富的生态系统支持大量可复用的包。使用真实的语言来改变一切。\n\n*TL;DR 有了 Pulumi，38 页的手动操作说明将变成了 38 行代码。25000 行 YAML 配置变成了使用真实编程语言的 500 行语句。*\n\nPulumi 的整个运行时、CLI、支持的库都可以在 GitHub 上免费下载。我们的团队正急切的等待您的反馈。与此同时，我需要告诉您一些关于 Pulumi 的事情，为什么我们会创造它。\n\n## 为什么创造 Pulumi？\n\n我的背景是 100% 在开发者工具上。我是.NET 的早期工程师，设计了其中的并发和异构部分，领导的分布式操作系统的变成平台，管理微软语言小组，包括开源和使.NET Core 跨平台。因为这些背景，进入云领域我有自己的见解。\n\n我发现的东西显然无法吸引我。\n\n2016 年年末的时候我就开始跟我的朋友也是共同创始人 Eric Rudder 开始构思 Pulumi，那时候容器和 serverless 已经甚嚣尘上，但是距离落地还为时尚早。云的能力十分惊人，但是至今将使用它还是十分困难。\n\n对于每一个 serverless 函数来说，我都要写几十行的 JSON 或者 YAML 配置。要链接到一个 API 端点，我还要学习晦涩的概念，执行一系列复制 - 粘贴的低级工作。如果我想在本机上运行一个小的集群的话，那么 Docker 还是很棒的，但是如果要在生产上使用的话，那么就要手动管理 etcd 集群，配置网络和 iptables 路由表，还有一系列与我的应用程序本身不相干的事情。不过 Kubernetes 的出现至少让我可以配置一次下次就可以跨云平台重用，但这还是会分散开发人员的精力。\n\n我认为我还算一个经验丰富的工程师，已经在软件行业从业 20 年了，但是当我想要将自己的代码部署到云中的时候，我感觉自己就像是个傻子。真是太令人悲哀了！如果我掌握了这些能力，那么是世界就会出触手可及。我总是在淌这浑水，处理云的复杂性，而我真正想做的是花时间来创造业务价值。\n\n关于编程的许多方面都经历了类似的转变过程：\n\n- 在 80 年代初，我们使用汇编语言对微处理器进行了编程。最终，编译器技术进步了，我们可以同时处理多种常见的架构。像 FORTRAN 和 C 这样的 Low-level 的编程语言开始兴起。\n- 在 90 年代初期，我们直接针对低级别操作系统原语进行编程，无论是 POSIX 系统调用还是 Win32 API，并进行手动内存和资源管理。最终，语言运行时技术和处理器速度提升到了可以使用更高级别语言的状态，如 Java。除了动态语言之外，这种趋势已经加速，如 JavaScript 统治了 Web。\n- 在 21 世纪初期，我们的编程模型中的共享内存并发性最好是原始的（[我花了很多时间在这个问题上](http:\/\/joeduffyblog.com\/2016\/11\/30\/15-years-of-concurrency\/)）。现在，我们简单地假设 OS 具有高级线程共享、调度和异步 IO 功能，以及编程到更高级别的 API，例如任务和承诺。\n\n我相信云软件也在进行类似的转变。从构建单一应用程序到构建真正的云优先分布式系统，我们正处在一场巨变中。然而，当海啸发生之前，人们几乎不知道它正在发生。\n\n从上面的角度来看，使用“配置”情况是有道理的。在虚拟机的早期，我们利用现有的应用程序并将它们扔在栅栏上，以便有人添加一点 INI 或 XML 粘合剂，让它们在虚拟机内部运行，以实现更灵活的管理。随着我们将这些相同的虚拟机“提升并转移到云中”，这种配置方法一直伴随着我们。这将我们带到了大致正确的边界。\n\n使用这种相同类型的配置表示基于容器的微服务、serverless 和细粒度托管服务之间的关系导致了异常的复杂性。将应用程序转变为分布式系统应该是事后的想法。事实证明，云覆盖了您的架构和设计。表达架构和设计的最好的方式是使用代码，使用真正的编程语言编写抽象，重用和优秀的工具。\n\n早些时候，Eric 和我采访了几十个客户。我们发现，开发人员和 DevOps 工程师都普遍感到幻灭。我们发现了极端的专业化，即使在同一个团队中，工程师也不会使用同一种语言。最近几周我已经听到了这个消息，我期待有一天会出现 NoYAML 运动。\n\n专业化是一件好事，我们希望我们最优秀和最聪明的云计算架构师晋升到 DevOps 和 SRE 的高级职位，但团队必须能够在合作时使用相同的语言。因为没有共同的通用语言导致了团队之间的物理隔离，而不是根据策略和环境分工。Pulumi 的目标是为人们提供解决这个问题所需的工具。\n\n## Pulumi 是什么？\n\nPulumi 是一个支持多语言和混合云开发平台。它可以让您使用真实语言和真实代码创建云计算的各个方面，从基础设施到应用程序本身。只需编写程序并运行它们，Pulumi 就能帮你完成出其余部分。\n\nPulumi 的中心是一个云对象模型，与运行时相结合以了解如何以任何语言编写程序，理解执行它们所需的云资源，然后以强大的方式规划和管理您的云资源。这种云运行时和对象模型本质上是与语言、云中立的，这就是为什么我们能够支持如此多的语言和云平台。更多支持正在路上。\n\nPulumi 采用了基础设施即代码以及不可变基础设施的概念，并可让您从您最喜欢的语言（而不是 YAML 或 DSL）中获得自动化和可重复性优势。在部署它们之前，您可以对变更进行区分，并且我们会对谁更改了什么以及何时更改进行完善的审计追踪。核心模型因此是陈述性的。\n\n使用真正的语言可以带来巨大的好处：\n\n- **熟悉**：不需要学习新的定制 DSL 或基于 YAML 的模板语言\n- **抽象**：正如我们喜爱的编程语言那样，我们可以用更小的东西来构建更大的东西\n- **共享和重用**：利用现有的语言包管理器共享和重用这些抽象，无论是与社区、团队内部共享\n- **表现力**：充分利用您的编程语言，包括异步、循环和条件\n- **工具**：通过使用真正的语言，我们可以即时访问 IDE、重构、测试、静态分析和编排等等\n- **生产力**：将以上所有好处加在一起，一起将变得更快，我们也会变得更快乐\n\n当提供原始云资源时，这些好处当然最重要，但是我们在团队中发现，您只能使用抽象。这包括在函数中包装事物以消除样板并创建引入更高级别概念的自定义类，通常将它们打包并重复使用。\n\n例如，此代码在 AWS 中创建一个 DynamoDB 数据库：\n\n\u0060\u0060\u0060python\nimport * as aws from \u0022@pulumi\/aws\u0022;\nlet music = new aws.dynamodb.Table(\u0022music\u0022, {\n    attributes: [\n        { name: \u0022Album\u0022, type: \u0022S\u0022 },\n        { name: \u0022Artist\u0022, type: \u0022S\u0022 },\n    ],\n    hashKey: \u0022Album\u0022,\n    rangeKey: \u0022Artist\u0022,\n});\n\u0060\u0060\u0060\n\n此代码创建一个基于容器的任务和无服务器功能，由一个存储桶触发：\n\n\u0060\u0060\u0060python\nimport * as cloud from \u0022@pulumi\/cloud\u0022;\nlet bucket = new cloud.Bucket(\u0022bucket\u0022);\nlet task = new cloud.Task(\u0022ffmpegThumbTask\u0022, {\n    build: \u0022.\/path_to_dockerfile\/\u0022,\n});\nbucket.onPut(\u0022onNewVideo\u0022, bucketArgs =\u003e {\n    let file = bucketArgs.key;\n    return task.run({\n        environment: {\n            \u0022S3_BUCKET\u0022:   bucket.id.get(),\n            \u0022INPUT_VIDEO\u0022: file,\n            \u0022TIME_OFFSET\u0022:  file.substring(file.indexOf(\u0027_\u0027)\u002b1, file.indexOf(\u0027.\u0027)).replace(\u0027-\u0027,\u0027:\u0027),\n            \u0022OUTPUT_FILE\u0022: file.substring(0, file.indexOf(\u0027_\u0027)) \u002b \u0027.jpg\u0027,\n        },\n    });\n});\n\u0060\u0060\u0060\n\n更好的是，这些代码可以根据您的需求部署到任何公共或私有云中。\n\n最后，这个例子创建了一个 Redis 缓存。我们怎么知道？我们不需要。缓存组件是一个抽象，它封装了我们可以安全忽略的不重要的细节：\n\n\u0060\u0060\u0060python\nimport {Cache} from \u0022.\/cache\u0022;\nlet cache = new Cache(\u0022url-cache\u0022);\n\u0060\u0060\u0060\n\n在使用 Pulumi 之后，你不会再以同样的方式考虑基础设施。你的大脑将不再是一个独立于应用程序的独特“事物”，而是开始将分布式云系统看作是你的程序架构的核心部分，而不是事后的想法。\n\n由于抽象，我们已经能够提供一些强大的库。该库是提炼和执行最佳实践的绝佳方式。当然，对于我们自己的库来说没有什么特别的，因为它们只是功能、类和代码，我们期待着看到你为自己、你的团队或者社区建立的那些库。\n\n我们最复杂的库——Pulumi 云框架——提供了一些令人兴奋的正在进行的工作的早期预览，展示如何创建跨越云提供商自己对诸如容器、无服务器功能和存储桶等核心概念的抽象。以同样的方式，您可以用 Node.js、Python、Java、.NET 等语言编写功能强大的应用程序，利用进程、线程和文件系统，无论是在 macOS、Linux 还是 Windows 上，这种方法都可以让您创建针对任何云提供商的现代混合云应用程序。像 Kubernetes 和其他 CNCF 产品组合这样的技术正在帮助推动这一不可避免的结果，因为它们在整个云基板上实现了对基本计算抽象的民主化和共识。\n\nPulumi 不是 PaaS，尽管它提供类似 PaaS 的生产力；您的程序总是直接针对您选择的云运行，并且始终可以访问该基础云的全部功能。即使您选择使用更高级别的组件，它也会向下兼容，并且您可以随时直接使用原始资源。它就像任何复杂的现代软件：有时，整个事情必须用 C\u002b\u002b 编写，以便访问底层平台的全部功能，但对于大多数常见情况，70% 到 100％可以是平台独立代码，而只有不到 30% 的专业化才能真正需要直接与操作系统交互。\n\n接下来我还将发布十几篇博客文章来介绍 Pulumi 所有方面的更多细节。然而，为了保持这篇文章尽量简短，我将首先介绍下 Pulumi 的一些我最喜欢的方面。\n\n## 我最喜欢的东西\n\n这很难选择，但这里有一些关于 Pulumi 我最喜欢的东西：\n\n**开源**。我坚信所有开发人员工具都应该是开源的。当然，Pulumi 也是一家公司，但是有充足的机会通过增加便利性以建立商业模式。（可以认为是​​Git 与 GitHub 的关系）我们从以前的工作中受益匪浅，其中包括 Docker、Terraform、Kubernetes、TypeScript 以及其他许多明确提及的工作。我们期待成为生态系统的一部分。因为我们在开放源代码方面下了很大功夫，所以我很高兴看到社区给我们带来什么，特别是在更高级别的软件包领域。\n\n**多语言**。就像使用 Java 和.NET 一样，Pulumi 运行时的架构可以支持多种语言，并以目标语言的所有方面（风格、语法、软件包等）的惯用方式来实现。因为我们是开源的，任何人都可以贡献自己的力量。\n\n**混合云**。我们的云对象模型是一个强大的基础，可以支持任何云提供商。这提供了一个统一的编程模型，工具和控制平面，用于在任何地方管理云软件。如果仅仅是为了让一个简单的基于容器的应用程序在生产中运行起来，没有必要学习三种不同的 YAML 方言和五种不同的 CLI。\n\n**云对象模型**。这个底层云对象模型为您的云计算构建方式提供了丰富的视图。所得到的对象使用程序中的依赖关系组成一个 DAG，系统可以分析和理解这些依赖关系以提供洞察力，这是我们打算随着时间的推移解锁复杂的静态分析和可视化的功能。\n\n**可重复使用的组件**。由于拥有真正的语言，我们可以构建更高层次的抽象。我最喜欢的例子之一是帮助我们的客户定期从部署中排除 1000 行 YAML，这是我们的 AWS 基础架构软件包。它采用 AWS 最佳实践来设置虚拟私有云，并提供专用子网和多可用区域支持，并将其转变为几行代码以配置整个网络：\n\n\u0060\u0060\u0060python\nimport * as awsinfra from \u0022@pulumi\/aws-infra\u0022;\nlet network = new awsinfra.Network(\u0060${prefix}-net\u0060, {\n    numberOfAvailabilityZones: 3, \/\/ Create subnets in many AZs\n    usePrivateSubnets: true,      \/\/ Run inside private per-AZ subnets\n});\n\u0060\u0060\u0060\n\n迄今为止，我最喜欢的成功案例是将客户的 25,000 行 AWS CloudFormation YAML 文件（其中使用无服务器、容器、基础设施和三个自定义部署管道）使用 500 行 TypeScript 和一个 Pulumi 的持续部署架构来替换。这不仅仅使得公司所有工程师都可以理解的代码变得少得多，这样他们可以将过去需要花费数周时间才能完成的事情现在用一个下午就可以搞定，而且现在可以在任何云或原生的 Kubernetes 上运行，而不仅是在 AWS。管理团队的 CloudFormation 堆栈，而不是一个工作量过饱和的工程师，整个团队可以更加高效。\n\n**统一的容器构建\/发布管道**。尝试将容器投入生产时有个问题让我早就感到很沮丧，就是同步我的应用程序、容器和基础架构管理，因为每个容器都倾向于使用不同的工具。我们的云框架演示了一个集成的工作流程，在这个工作流程中，只需简单地运行 Pulumi 构建、diff、推送和拉取新的容器镜像，所有这些都经过精心安排，以消除停机时间。\n\n**Lambda 无服务器功能 **。AWS 的取了个好名字：Lambda。在 Pulumi 中，我现在可以用我最喜欢的语言使用 lambda 表达式来编写我的无服务器函数，而不需要一行 YAML：\n\n\u0060\u0060\u0060python\nimport * as aws from \u0022@pulumi\/aws\u0022;\nimport * as serverless from \u0022@pulumi\/aws-serverless\u0022;\nlet topic = new aws.sns.Topic(\u0022topic\u0022);\nserverless.cloudwatch.onEvent(\u0022hourly\u0022, \u0022rate(60 minutes)\u0022, event =\u003e {\n    const sns = new (await import \u0022aws-sdk\u0022).SNS();\n    return sns.publish({\n        Message: JSON.stringify({ event: event }),\n        TopicArn: topic.id.get(),\n    }).promise();\n});\n\u0060\u0060\u0060\n\n此功能允许您捕获对变量的引用：常量、配置设置或加密，甚至可以引用其他资源，以便与它们进行通信。当你第一次这样做的时候，我保证你会有一个“哇塞”的时刻，将无服务器连接到你写过的每一个事件驱动的代码片段。\n\n**使用 API 的资源**。因为我可以捕获对其他云资源的引用，所以我可以在其上创建 API 以使它们更易于在我的运行时代码中使用。这使得“演员般的”编程模型无需处理配置和服务发现。\n\n**堆栈**。Pulumi 的核心是“堆栈”的概念。堆栈是您的云计算的独立实例，其资源和配置与所有其他堆栈不同。您可能有一堆用于生产、暂存和测试的堆栈，或者可能是每个单一租户的环境。Pulumi 的 CLI 使得启动和卸载大量堆栈变得轻而易举。这会打开以前可能没有尝试过的工作流，例如每个开发人员都拥有自己的堆栈，将新堆叠起来（并拆除）以测试每个 Pull 请求，甚至将服务的层拆分成多个链接在一起的堆栈。\n\n我将在未来的博客文章介绍如何做。现在 Pulumi 已经公开，期望在接下来的几天和几周内听到更多的消息。我希望这能让您更好地了解整体平台，其方法和独特优势。\n\n## 下一步是什么？\n\n我们希望通过 Pulumi，开发人员和 DevOps 团队都将体验到云的复兴。构建强大的云软件将更加愉快、更高效、更具协作性。现代云计算软件将从代码孤岛转变为等量的配置胶水，成为优雅的分布式系统。\n\n这是一个难题。我绝不会说我们已经解决了它。我确实相信 Pulumi 是我亲身见过并希望最接近我心目中的云开发平台。在这个激动人心的时刻，投注于语言将使我们所有人“站在巨人的肩膀上”，这让我感到乐观；语言总是一个安全的赌注。\n\n今天很可能是我职业生涯中最激动人心的一天。我想感谢我们的团队和所有帮助过我们的人，放纵我们的疯狂想法并相信我们。\n\n现在访问[https:\/\/pulumi.io](https:\/\/pulumi.io\/)，或者直接运行：\n\n\u0060\u0060\u0060bash\n$ curl -fsSL https:\/\/get.pulumi.com | sh\n\u0060\u0060\u0060\n\n我迫不及待想看看你将使用 Pulumi 构建的所有令人难以置信的东西。\n\n---\n\nP.S 我要感谢我已故的导师，最好的朋友 Chris Brumme。虽然 Chris 没办法和我们一起庆祝这一刻，但我清楚“Chris 每一步会做些什么”。Pulumi 是夏威夷语，是“扫帚”的意思，尽管这完全是他名字的错误发音，但为了纪念 Chirs 我还是用了它。\n', '\/trans\/hello-pulumi-from-jeo-duffy\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">2018 年 6 月 18 日 Joe Duffy 在他的博客中宣布开源了云原生编程语言 Pulumi。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/ci-cd-in-kubernetes/">Kubernetes 中的 CI/CD</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2018/06/14</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/kubernetes"> 
             Kubernetes
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Kubernetes 中的 CI\/CD', 'TheNewStack 的报告解读，介绍了 Kubernetes 中 CI\/CD 的现状。', '\n众所周知 Kubernetes 并不提供代码构建、发布和部署，所有的这些工作都是由 CI\/CD 工作流完成的，最近 TheNewStack 又出了本小册子（117 页）介绍了 Kubernetes 中 CI\/CD 的现状，[下载本书的 PDF](https:\/\/thenewstack.io\/ebooks\/kubernetes\/ci-cd-with-kubernetes\/)。\n\n## 关于本书\n\n本书的作者有：\n\n- Rob Scott：ReactiveOps 公司的 SRE\n- Janakiram MSV：Janakiram \u0026 Associates 的首席分析师\n- Craig Martin：Kenzan 的高级副总裁\n- Container Solutions\n\n这本小册子里主要主要介绍了以下几点：\n\n- DevOps 模式\n- 云原生应用模式\n- 使用 Spinnaker 做持续交付\n- 云原生时代的监控\n\n## DevOps 模式\n\n这一章从一些流行的自动化运维工具讲起，比如 Chef、Puppet 等，引申出 CI\/CD 流水线，进而引出 Docker 和 DevOps，将容器如何解除开发和运维之间的隔阂，但同时也带来了一些挑战，比如频繁的发布变更如何控制，如何控制容器集群的行为，如何拆分应用到容器之中等。这是一个专门用于容器编排调度的工具呼之欲出，Kubernetes 的出现彻底改变了局面，可以说它直接改变了应用的基础架构。\n\nKubernetes 细化的应用程序的分解粒度，同时将服务发现、配置管理、负载均衡和健康检查等作为基础设施的功能，简化了应用程序的开发。\n\n而 Kubernetes 这种声明式配置尤其适合 CI\/CD 流程，况且现在还有如 Helm、Draft、Spinnaker、Skaffold 等开源工具可以帮助我们发布 Kuberentes 应用。\n\n有了基于 Kubernetes 的 CI\/CD 流程后，又诞生了 GitOps（[WeaveWorks](http:\/\/weave.works) 的博客中有很多相关文章）和 SecOps（Security Operation）。\n\n## 云原生应用模式\n\n\u003e 云原生是通过构建团队、文化和技术，利用自动化和架构来管理系统的复杂性和解放生产力。——Joe Beda，Heptio CTO，联合创始人\n\n这一章的重点是给出了云原生应用的 10 条关键属性。\n\n1. 使用轻量级的容器打包\n2. 使用最合适的语言和框架开发\n3. 以松耦合的微服务方式设计\n4. 以 API 为中心的交互和协作\n5. 无状态和有状态服务在架构上界限清晰\n6. 不依赖于底层操作系统和服务器\n7. 部署在自服务、弹性的云基础设施上\n8. 通过敏捷的 DevOps 流程管理\n9. 自动化能力\n10. 通过定义和策略驱动的资源分配\n\n作者然后将应用程序架构中的不同组件映射到云原生的工作负载中。\n\n这也是 DevOps 需要关注的部分，如何将云原生的组件映射为 Kubernetes 的原语（即 Kubernetes 里的各种资源对象和概念组合）呢？\n\n总结概括为以下 10 条：\n\n1. 不要直接部署裸的 Pod。\n2. 为工作负载选择合适的 Controller。\n3. 使用 Init 容器确保应用程序被正确的初始化。\n4. 在应用程序工作负载启动之前先启动 service。\n5. 使用 Deployment history 来回滚到历史版本。\n6. 使用 ConfigMap 和 Secret 来存储配置。\n7. 在 Pod 里增加 Readiness 和 Liveness 探针。\n8. 给 Pod 这只 CPU 和内存资源限额。\n9. 定义多个 namespace 来限制默认 service 范围的可视性。\n10. 配置 HPA 来动态扩展无状态工作负载。\n\n## 使用 Spinnaker 进行持续交付\n\n作者首先讲到了 Spinnaker 的各种特性，比如面向微服务啦，云原生的交付工具啦，可视化的交付和基础设施啦，支持多个 region，支持容器和 Kubernetes 等等，不一而足，感兴趣大家可以自己看下报告或者登陆[Spinnaker 官网](https:\/\/www.spinnaker.io)查看。\n\n总之作者就是想说 Spinnaker 很好很强大啦，足以满足您对云原生应用 CI\/CD 的需求。\n\n## 云原生时代的监控\n\n监控是为了实现系统的可观测性，不要以为监控就是简单的出个监控页面，监控其实包括以下部分：\n\n- 日志收集\n- 监控和指标度量\n- 追踪\n- 告警和可视化\n\n要把其中任何一个方面做好都不容易。作者主要讲述的 Prometheus 和 Grafana 的开源监控方案。这一章我不详述，感兴趣大家可以查看报告原文。\n', '\/blog\/ci-cd-in-kubernetes\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">TheNewStack 的报告解读，介绍了 Kubernetes 中 CI/CD 的现状。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/tracing-grpc-with-istio/">[译] 在 Istio 中跟踪 gRPC</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2018/06/08</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('在 Istio 中跟踪 gRPC', '本文介绍的是如何在 Istio 中使用 grpc 并设置跟踪（tracing）与 header 传播，包括 gRPC 到 grpc 请求传播 header、gRPC 到 HTTP 请求传播 header、使用 grpc-gateway 时传播 header 等', '\nAspen Mesh 很喜欢用[gRPC](https:\/\/grpc.io\/docs\/)。Apen Mesh 面向公众的 API 和许多内部 API 大多都是使用 gRPC 构建的。如果您还没有听说过 gRPC（熟练掌握 gRPC 真的很难），那么我先为您简单的介绍下，它是一种新型、高效和优化的远程过程调用（RPC）框架。gRPC 基于[protocol buffer](https:\/\/developers.google.com\/protocol-buffers\/)序列化格式和[HTTP\/2](https:\/\/http2.github.io\/)网络协议。\n\n使用 HTTP\/2 协议，gRPC 应用程序可以利用多路复用请求显著提高连接利用率，而且比起如 HTTP\/1.1 等[其他协议](https:\/\/http2.github.io\/faq\/)具有更多增强功能。此外，protocal buffer 是以二进制方式对结构化数据进行序列化，这比起基于文本的序列化方式更简单且可扩展，还可以显着提高性能。将这两个结果组合在一个低延迟和高度可扩展的 RPC 框架中，这实质上就是 gRPC。此外，不断增长的 gRPC 生态支持使用多种语言编写应用程序，例如（C \u002b\u002b、Java、Go 等），还包括大量第三方[库](https:\/\/github.com\/grpc-ecosystem)。\n\n除了上面列出的好处之外，gRPC 让我最喜欢的一点是可以让我以简单直观的方式指定 RPC（使用 protobuf IDL）以及客户端调用服务器端的方法，就好像是调用本地函数一样。很多代码（服务描述和处理程序、客户端方法等）都可以自动生成，这使得 gRPC 非常好用。\n\n现在我已经介绍了 gRPC 的一些背景知识，我们再把注意力转回到博客的主题。在这里，我将介绍如何在基于 gRPC 的应用程序中添加跟踪，特别是如果您使用 Istio 或 Aspen Mesh。\n\n跟踪（Tracing）非常适合于调试和理解应用程序的行为。理解所有跟踪数据的关键是能够关联来自与单个客户端请求相关的多个不同微服务的跨度（span）。\n\n为了实现这一点，应用程序中的所有微服务应该传播跟踪 header。如果您使用的是像 Istio 或 Aspen Mesh 这样的服务网格，ingress 和 sidecar 代理会自动添加适当的跟踪 header，并将这些 span 报告给跟踪收集器后端，如 Jaeger 或 Zipkin。应用程序唯一要做的就是将传入请求（sidecar 或 ingress 代理添加的）的跟踪 header 传播到其对其他微服务的所有传出请求。\n\n## gRPC 到 grpc 请求传播 header\n\n使用 gRPC，跟踪 header 传播的最简单方法是使用[grpc opentracing middleware](https:\/\/github.com\/grpc-ecosystem\/go-grpc-middleware\/tree\/master\/tracing\/opentracing)库的客户端拦截器。如果您的 gRPC 应用程序在收到传入请求时发出新的出站 gRPC 请求，则可以使用此功能。以下是将传入的跟踪 header 正确传播到传出的 gRPC 请求的示例代码：\n\n\u0060\u0060\u0060go\n  import (\n    \u0022golang.org\/x\/net\/context\u0022\n    \u0022github.com\/grpc-ecosystem\/go-grpc-middleware\/tracing\/opentracing\u0022\n    \u0022ot \u0022github.com\/opentracing\/opentracing-go\u0022\n  )\n\n  \/\/ ctx is the incoming gRPC request\u0027s context\n  \/\/ addr is the address for the new outbound request\n  func createGRPCConn(ctx context.Context, addr string) (*grpc.ClientConn, error) {\n  \tvar opts []grpc.DialOption\n  \topts = append(opts, grpc.WithStreamInterceptor(\n  \t\tgrpc_opentracing.StreamClientInterceptor(\n  \t\t\tgrpc_opentracing.WithTracer(ot.GlobalTracer()))))\n  \topts = append(opts, grpc.WithUnaryInterceptor(\n  \t\tgrpc_opentracing.UnaryClientInterceptor(\n  \t\t\tgrpc_opentracing.WithTracer(ot.GlobalTracer()))))\n  \tconn, err := grpc.DialContext(ctx, addr, opts...)\n  \tif err != nil {\n  \t\tglog.Error(\u0022Failed to connect to application addr: \u0022, err)\n  \t\treturn nil, err\n  \t}\n  \treturn conn, nil\n  }\n\u0060\u0060\u0060\n\n很简单对吧？\n\n添加 opentracing 客户端拦截器可确保在客户端连接上创建任何新的一元（unary）或流式 gRPC 请求注入正确的跟踪 header。如果传递的上下文中存在跟踪 header（如使用 Aspen Mesh 或 Istio 传入入站 gRPC 请求上下文），则新创建的 span 将作为传递的上下文中已存在的 span 的子 span。另外，如果上下文中没有跟踪信息，则会为出站 gRPC 请求创建新的根 span。\n\n## gRPC 到 HTTP 请求传播 header\n\n我们再来看下这个场景，如果您的应用程序在收到一个新传入的 gRPC 请求时发出一个出站 HTTP\/1.1 请求。以下是在此情况下完成 header 传播的示例代码：\n\n\u0060\u0060\u0060go\n  import (\n    \u0022net\/http\u0022\n    \u0022golang.org\/x\/net\/context\u0022\n    \u0022golang.org\/x\/net\/context\/ctxhttp\u0022\n    \u0022ot \u0022github.com\/opentracing\/opentracing-go\u0022\n  )\n\n  \/\/ ctx is the incoming gRPC request\u0027s context\n  \/\/ addr is the address of the application being requested\n  func makeNewRequest(ctx context.Context, addr string) {\n    if span := ot.SpanFromContext(ctx); span != nil {\n      req, _ := http.NewRequest(\u0022GET\u0022, addr, nil)\n\n      ot.GlobalTracer().Inject(\n        span.Context(),\n        ot.HTTPHeaders,\n        ot.HTTPHeadersCarrier(req.Header))\n\n      resp, err := ctxhttp.Do(ctx, nil, req)\n      \/\/ Do something with resp\n    }\n  }\n\u0060\u0060\u0060\n\n这是序列化传入请求（HTTP 或 gRPC）上下文中跟踪 header 的标准方式。\n\n很好，至此我们已经能够使用库或标准实用程序代码来实现我们想要的功能。\n\n## 使用 grpc-gateway 时传播 header\n\ngRPC 应用程序中有一个常用的库[grpc-gateway](https:\/\/github.com\/grpc-ecosystem\/grpc-gateway)，可以将 gRPC 服务作为 RESTful JSON API 暴露出来。当您想要了解 gRPC 或维护 RESTful 架构，使用 curl、web 浏览器等客户端时，这非常有用。有关如何使用\u0060grpc-gateway\u0060从 gRPC 中暴露 RESTful API 的更多细节请参考[这个博客](https:\/\/coreos.com\/blog\/grpc-protobufs-swagger.html)。如果您对此架构不熟悉，我强烈建议您阅读。\n\n当您开始使用\u0060grpc-gateway\u0060并想传播跟踪 header 时，有一些值得一提的非常有趣的交互。 \u0060grpc-gateway\u0060 [文档](https:\/\/github.com\/grpc-ecosystem\/grpc-gateway#mapping-grpc-to-http)指出，作为 gRPC 请求 header，所有 IANA（互联网号码分配局）永久 HTTP header 都以\u0060grpcgateway-\u0060作为前缀并添加。这很好，但是像\u0060x-b3-traceid\u0060、\u0060x-b3-spanid\u0060等跟踪 header 不是 IANA 认可的永久 HTTP header，当\u0060grpc-gateway\u0060代理 HTTP 请求时，它们不会被复制到 gRPC 请求中。这意味着只要将\u0060grpc-gateway\u0060添加到您的应用程序中，header 传播逻辑就会停止工作。\n\n这是个特例吗？添加一个东西打断了当前的工作。不用担心，我为您解决问题！\n\n这是一种确保使用\u0060grpc-gateway\u0060在 HTTP 和 gRPC 之间进行代理时不会丢失跟踪信息的方法：\n\n\u0060\u0060\u0060go\n  import (\n    \u0022net\/http\u0022\n    \u0022golang.org\/x\/net\/context\u0022\n    \u0022google.golang.org\/grpc\/metadata\u0022\n    \u0022github.com\/grpc-ecosystem\/grpc-gateway\/runtime\u0022\n  )\n\n  const (\n  \tprefixTracerState  = \u0022x-b3-\u0022\n  \tzipkinTraceID      = prefixTracerState \u002b \u0022traceid\u0022\n  \tzipkinSpanID       = prefixTracerState \u002b \u0022spanid\u0022\n  \tzipkinParentSpanID = prefixTracerState \u002b \u0022parentspanid\u0022\n  \tzipkinSampled      = prefixTracerState \u002b \u0022sampled\u0022\n  \tzipkinFlags        = prefixTracerState \u002b \u0022flags\u0022\n  )\n\n  var otHeaders = []string{\n  \tzipkinTraceID,\n  \tzipkinSpanID,\n  \tzipkinParentSpanID,\n  \tzipkinSampled,\n  \tzipkinFlags}\n\n  func injectHeadersIntoMetadata(ctx context.Context, req *http.Request) metadata.MD {\n  \tpairs := []string{}\n  \tfor _, h := range otHeaders {\n  \t\tif v := req.Header.Get(h); len(v) \u003e 0 {\n  \t\t\tpairs = append(pairs, h, v)\n  \t\t}\n  \t}\n  \treturn metadata.Pairs(pairs...)\n  }\n\n  type annotator func(context.Context, *http.Request) metadata.MD\n\n  func chainGrpcAnnotators(annotators ...annotator) annotator {\n  \treturn func(c context.Context, r *http.Request) metadata.MD {\n  \t\tmds := []metadata.MD{}\n  \t\tfor _, a := range annotators {\n  \t\t\tmds = append(mds, a(c, r))\n  \t\t}\n  \t\treturn metadata.Join(mds...)\n  \t}\n  }\n\n  \/\/ Main function of your application. Insert tracing headers into gRPC\n  \/\/ metadata using annotators\n  func run() {\n    ...\n\t  annotators := []annotator{injectHeadersIntoMetadata}\n\n\t  gwmux := runtime.NewServeMux(\n\t\t  runtime.WithMetadata(chainGrpcAnnotators(annotators...)),\n\t  )\n    ...\n  }\n\u0060\u0060\u0060\n\n在上面的代码中，我使用了\u0060grpc-gateway\u0060库中的[\u0060runtime.WithMetadata\u0060](https:\/\/github.com\/grpc-ecosystem\/grpc-gateway\/blob\/master\/runtime\/mux.go#L88)。该 API 从 HTTP 请求中读取属性并将其添加到 gRPC 元数据中，这一点非常有用，这正是我们想要的！虽然多了一步，但仍然使用库提供的 API。\n\n\u0060injectHeadersIntoMetadata\u0060注解器在 HTTP 请求中查找跟踪 header 并将其附加到 gRPC 元数据中，从而确保跟踪 header 可以使用前面部分中提到的技术从 gRPC 进一步传播到出站请求。\n\n您可能观察到的另一个有趣的事情是\u0060chainGrpcAnnotators\u0060包装函数。\u0060runtime.WithMetadata\u0060 API 只允许添加一个注释器，这可能不足以满足所有场景。在我们的例子中，我们有一个跟踪注释器（如上面的一个示例）和一个认证注释器，它将来自 HTTP 请求的认证数据附加到 gRPC 元数据。使用\u0060chainGrpcAnnotators\u0060允许您添加多个注释器，并且包装函数将来自各种注释器的元数据加入到 gRPC 请求的单个元数据中。\n', '\/trans\/tracing-grpc-with-istio\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文介绍的是如何在 Istio 中使用 grpc 并设置跟踪（tracing）与 header 传播，包括 gRPC 到 grpc 请求传播 header、gRPC 到 HTTP 请求传播 header、使用 grpc-gateway 时传播 header 等</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
          <div class="col-12">
 
 
 
 
 
 
 
 
 
 
 
 <nav aria-label="Page navigation">
   <ul class="pagination justify-content-center">
     
     
     <li class="page-item">
       <a class="page-link" href="/blog/">
         ««
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a href="/blog/page/22/" class="page-link">
         «
       </a>
     </li>
     
     
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item">
           <a href="/blog/page/21/" class="page-link">
             21
           </a>
         </li>
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item">
           <a href="/blog/page/22/" class="page-link">
             22
           </a>
         </li>
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item page-item active ">
           <a href="/blog/page/23/" class="page-link">
             23
           </a>
         </li>
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item">
           <a href="/blog/page/24/" class="page-link">
             24
           </a>
         </li>
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item">
           <a href="/blog/page/25/" class="page-link">
             25
           </a>
         </li>
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
     
     
     <li class="page-item">
       <a href="/blog/page/24/" class="page-link">
         »
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a class="page-link" href="/blog/page/26/">
         »»
       </a>
     </li>
     
   </ul>
 </nav>
 
</div>

        </div>
      </div>
      <!-- sidebar -->
      <aside class="col-lg-4 order-1 order-lg-2 d-none d-sm-block">
          <div class="sidebar">
          <!-- categories -->
<div class="blog-categories mb-4">
  <p class="sidebar-title">
      专栏
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/istio" class="sidebar-item">
            <span>Istio</span>
            <span>(69)</span>
        </a>
      
        <a href="/categories/service-mesh" class="sidebar-item">
            <span>Service Mesh</span>
            <span>(38)</span>
        </a>
      
        <a href="/categories/kubernetes" class="sidebar-item">
            <span>Kubernetes</span>
            <span>(24)</span>
        </a>
      
        <a href="/categories/%e9%9a%8f%e7%ac%94" class="sidebar-item">
            <span>随笔</span>
            <span>(21)</span>
        </a>
      
        <a href="/categories/%e4%b8%9a%e6%80%81" class="sidebar-item">
            <span>业态</span>
            <span>(17)</span>
        </a>
      
        <a href="/categories/%e5%85%b6%e4%bb%96" class="sidebar-item">
            <span>其他</span>
            <span>(17)</span>
        </a>
      
        <a href="/categories/envoy" class="sidebar-item">
            <span>Envoy</span>
            <span>(16)</span>
        </a>
      
        <a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f" class="sidebar-item">
            <span>云原生</span>
            <span>(13)</span>
        </a>
      
        <a href="/categories/ai" class="sidebar-item">
            <span>AI</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%ae%89%e5%85%a8" class="sidebar-item">
            <span>安全</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%bc%80%e6%ba%90" class="sidebar-item">
            <span>开源</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%8f%af%e8%a7%82%e6%b5%8b%e6%80%a7" class="sidebar-item">
            <span>可观测性</span>
            <span>(5)</span>
        </a>
      
        <a href="/categories/%e6%97%85%e8%a1%8c" class="sidebar-item">
            <span>旅行</span>
            <span>(4)</span>
        </a>
  </div>
</div>

<div class="blog-categories mb-4">
  <p class="sidebar-title">
      资料
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/%e5%87%ba%e7%89%88%e7%89%a9" class="sidebar-item">
            <span>出版物</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e7%94%b5%e5%ad%90%e4%b9%a6" class="sidebar-item">
            <span>翻译电子书</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e6%96%87%e6%a1%a3" class="sidebar-item">
            <span>翻译文档</span>
            <span>(7)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>翻译图书</span>
            <span>(6)</span>
        </a>
      
        <a href="/categories/%e5%8e%9f%e5%88%9b%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>原创图书</span>
            <span>(2)</span>
        </a>
      
        <a href="/categories/%e6%95%99%e7%a8%8b%e6%89%8b%e5%86%8c" class="sidebar-item">
            <span>教程手册</span>
            <span>(1)</span>
        </a>
  </div>
</div>





          </div>
      </aside>
      <!-- /sidebar -->
    </div>
  </div>
</section>




<footer>
  
  <div class="footer bg-footer section-sm border-bottom overlay ">
    <div class="container-xl">
      <div class="row">
        <div class="col col-xl-4 d-sm-none mb-2 mb-lg-0 d-xl-block d-none">
          
          <p class="h3 text-white mb-4 text-uppercase">联系</p>
          
          <ul class="list-unstyled">
            
            
            <li class="mb-4 text-color">微信公众号</li>
            
            
            <li class="mb-4"><img src="/images/servicemesher-wechat.webp" width="118px" height="118px" alt="footer image"></li>
            
            
            
          
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">博客</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/blog/black-myth-wukong-game-life/">从黑神话悟空聊起：我心目中的 3A 大作</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/envoy-gateway-integration-istio-mesh/">集成 Envoy Gateway 作为 Istio 服务网格中的入口网关</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/istio-configuration-safety-common-misconfigurations/">Istio 配置安全：如何避免错误配置</a></li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">链接</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://istio.io/latest/zh/" target="_blank" rel="noopener noreferrer">
                  Istio 服务网格
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://tetrate.io/?jimmysong" target="_blank" rel="noopener noreferrer">
                  Tetrate 公司
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener noreferrer">
                  云原生学院|Bilibili
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/awesome-cloud-native/" target="_blank" rel="noopener noreferrer">
                  云原生开源项目大全
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://cloudnative.to" target="_blank" rel="noopener noreferrer">
                  云原生社区（中国）
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">教程</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/envoy-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Envoy 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/istio-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Istio 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/kubernetes-handbook/" >
                  Kubernetes 基础教程
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">通知</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/notice/kubecon-china-2024-panel/">KubeCon China 2024（香港）</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/website-revamp-notice/">网站改版通知</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/cloud-native-meetup-dalian-2024/">2024 大连云原生技术开放日</a></li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>

  
  <div class="copyright py-4 bg-footer overlay">
    <div class="container-xl">
      <div class="row">
        <div class="col-sm-6 text-sm-left text-center">
          <p class="mb-0 text-color">© 2017-2024 Jimmy Song 保留所有权利</p>
        </div>
        <div class="col-sm-6 text-sm-right text-center">
          <ul class="list-inline">
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://twitter.com/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-x-twitter text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/contact/" >
                    <i class="fa-brands fa-weixin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://github.com/rootsongjc" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-github text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://linkedin.com/in/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-linkedin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="mailto:rootsongjc@gmail.com" >
                    <i class="fa-solid fa-envelope text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/blog/index.xml" >
                    <i class="fa-solid fa-rss text-white"></i>
              </a>
            </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>


<!-- JS Plugins -->

<script src="/plugins/popper/popper.min.js"></script>

<script src="/plugins/bootstrap/bootstrap.min.js"></script>

<script src="/plugins/slick/slick.min.js"></script>

<script src="/plugins/filterizr/jquery.filterizr.min.js"></script>

<script src="/plugins/search/fuse.min.js"></script>

<script src="/plugins/search/mark.js"></script>

<script src="/plugins/hex_md5/hex_md5.js"></script>

<script src="/plugins/anchor/anchor.min.js"></script>

<script src="/plugins/tocbot/tocbot.min.js"></script>

<script src="/plugins/bigger-picture/bigger-picture.min.js"></script>


<!-- Main Script -->

<script src="/js/script.min.f94c22b1d478bfc9e2e0a7d954429e47b7e6d36edd423758482e04154ae1842e.js"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-ESY906ZWZ0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ESY906ZWZ0');
</script>


<!-- Baidu analysis -->
<meta name="baidu-site-verification" content="g8IYR9SNLF" />


<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?11f7d254cfa4e0ca44b175c66d379ecc";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>




<script>
    anchors.add();
</script>






<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>










<script src="/js/wowchemy-search.min.7a37268e7bbe4a9160c2e4c33b749816.js" type="module"></script>
<script id="search-hit-fuse-template" type="text/x-template">
  <div class="search-hit" id="summary-{{key}}">
    <div class="search-hit-content border-bottom">
      <div class="search-hit-name">
        <div class='search-hit-link'><a href="{{relpermalink}}">{{title}}</a></div>
        <div class="search-hit-metadata d-flex">
            <span class="mr-1"><i class="fa-regular fa-calendar mr-1"></i>{{date}}</span>
            <span class="mr-1"><i class="fa-regular fa-folder-open mr-1"></i>{{section}}</span>
            <span class="d-sm-block d-none"><i class="fa-solid fa-link mr-1"></i>{{relpermalink}}</span>
        </div>
        <div class="search-hit-description">{{snippet}}</div>
      </div>
    </div>
  </div>
</script>



    </body>
</html>
