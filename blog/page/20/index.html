<!DOCTYPE html>
<html lang="zh"><head>
  <meta charset="utf-8">
  
  <title>博客 - Jimmy Song</title>
  

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta name="description" content="专注开源技术、云原生与生活随笔的分享与思考。">
  <meta name="author" content="Jimmy Song">
  <meta name="generator" content="Hugo 0.129.0">

  <!-- CSS plugins -->
  
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
  
  <link rel="preload" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" as="style">
  <link rel="stylesheet" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" media="screen">
  

  <!-- Main Stylesheet -->
  
  <link rel="preload" href="/scss/style.min.595949bd12db88434115e2a1e70965cf2928cc646e73acc6437c4cbbc323f585.css" as="style">
  <link rel="stylesheet" href="/scss/style.min.595949bd12db88434115e2a1e70965cf2928cc646e73acc6437c4cbbc323f585.css" media="screen">

  <!-- Bigger picture css -->
  
  <link rel="stylesheet" href="/plugins/bigger-picture/bigger-picture.min.css" media="print" onload="this.media='all'">
  <!--Favicon generate by https://realfavicongenerator.net-->
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="200x200" href="/images/favicon.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">

  <link href='/opensearchdescription.xml' rel='search' title='Content search' type='application/opensearchdescription+xml'/>

  <!--Twitter card-->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="jimmysong.io" />
  <meta name="twitter:creator" content="@jimmysongio" />
  <meta property="og:url" content="https://jimmysong.io/blog/" />
  <meta property="og:title" content="博客 | Jimmy Song" />
  <meta property="twitter:title" content="博客 | Jimmy Song" />

  
  <meta property="og:description" content="专注开源技术、云原生与生活随笔的分享与思考。" />
  <meta property="twitter:description" content="专注开源技术、云原生与生活随笔的分享与思考。" />

  
  <meta property="og:image" content="https://jimmysong.io/images/banner/default.jpg" />
  <meta property="twitter:image" content="https://jimmysong.io/images/banner/default.jpg" />

  
  
</head>
<body>
<header class="fixed-top header">
  
  
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa fa-arrow-circle-up" aria-hidden="true"></i></button>
  
  <div class="navigation w-100 ">
    <div class="container-xl">
      <nav class="navbar navbar-expand-lg navbar-light p-0">
        <a class="navbar-brand" href="/">
            
            <b>JIMMY SONG</b>
            
        </a>
        <button class="navbar-toggler rounded-0" type="button" data-toggle="collapse" data-target="#navigation"
          aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse text-center" id="navigation">
          <ul class="navbar-nav ml-auto">
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/blog">博客</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/book">资料</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/tags">标签</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/notice">公告</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/contact">联系</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/about">关于</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/community/">社区</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener">视频 <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i></a>
              
            </li>
            
            

          
          
          <li class="nav-item">
            
            
            
              
              
                
                
                
                  
                    
                    <a class="nav-link" href="/en/blog/">English</a>
                    
                  
                
              
              
              
                
                  
                    
                    
                  
                
                
                
              
          </li>
          
          
          <!-- search -->
           <button type="button" class="search-btn js-search" id="searchOpen" aria-label="Search">
              <div class="search-container d-flex justify-content-center">
              <span class="search-content">
                  <i class="fa fa-search"></i>
                  <span>搜索</span>
              </span>
              <span class="search-shortcuts d-none d-sm-block">
                  <kbd class="cmd-key">⌘</kbd>
                  <kbd class="k-key">K</kbd>
              </span>
              </div>
          </button>
          
          </ul>
        </div>
      </nav>
    </div>
  </div>
</header>


            <aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between">
        <div class="col-6 search-title">
          <p>站内搜索</p> 
        </div>
        <div class="col-6 col-search-close">
          <div class="js-search" aria-label="关闭"><i class="fa-solid fa-circle-xmark text-muted" aria-hidden="true"></i></div>
        </div>
      </div>

      <div id="search-box">
        <i class="fa-solid fa-magnifying-glass" id="search-icon" aria-hidden="true"></i>
        <input name="q" id="search-query" placeholder="请输入搜索词" autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control" aria-label="请输入搜索词">
        
        <div class="mt-4">
          <span>搜索类型: </span>
          <span>
            <input type="radio" id="all" name="search_type" value="all" checked>
            <label for="all">所有</label>
            
              <input type="radio" id="blog" name="search_type" value="blog">
              <label for="blog">原创</label>
              <input type="radio" id="trans" name="search_type" value="trans">
              <label for="trans">译文</label>
            
            <input type="radio" id="book" name="search_type" value="book">
            <label for="book">资料</label>
            <input type="radio" id="notice" name="search_type" value="notice">
            <label for="notice">公告</label>
          </span>
        </div>
      </div>
      
    </section>
    <section class="section-search-results">
      <div id="search-results-count" class="search-results-count"></div>
      <div id="search-hits">
        
      </div>
    </section>
  </div>
</aside>

        
        
            

<section class="bg-cover page-title-section overlay" style="background-image: url('/images/backgrounds/circle.svg'),url('/images/backgrounds/page-title.webp');background-size: cover;">
    <div class="container-xl">
        <div class="row">
            <div class="col-12">
                <p class="h1">
                    博客
                </p>
                <p class="page-description">
                    专注开源技术、云原生与生活随笔的分享与思考。
                </p>
                
            </div>
        </div>
    </div>
</section>

        


<section class="section-sm book-list-section bg-gray">
  <div class="container-xl">
    <div class="row">
      <div class="col-lg-8 order-2 order-lg-1">
        <div class="row">
          
          
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/cloudera-to-go-private-as-kkr-cdr-grab-it-for-5-3b/">[译] Hadoop 时代或将落幕，Cloudera 将被私有化</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2021/06/01</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e4%b8%9a%e6%80%81"> 
             业态
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://techcrunch.com/2021/06/01/cloudera-to-go-private-as-kkr-cdr-grab-it-for-5-3b/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Hadoop 时代或将落幕，Cloudera 将被私有化', '北京时间 6 月 1 日晚，据 TechCrunch 报道，KKR 和 CD\u0026R 将以 53 亿美元收购 Cloudera，Cloudera 将被私有化。', '\n北京时间 6 月 1 日晚，据 [TechCrunch 报道](https:\/\/techcrunch.com\/2021\/06\/01\/cloudera-to-go-private-as-kkr-cdr-grab-it-for-5-3b\/)，KKR 和 CD\u0026R 将以 53 亿美元收购 Cloudera，Cloudera 将被私有化。截止到本文发稿，11 点 49 分，Cloudera 股票报价 15.94 美元，涨幅 23.95%。\n\n![Cloudera 股价](008i3skNly1gr379cnii9j30u01fh1ee.jpg)\n\n[Cloudera](http:\/\/cloudera.com\/)曾经是最热门的 Hadoop 初创公司之一，但是随着时间的推移，这个市场的光芒不再，今天它将被私有化，因为 KKR 和 Clayton Dubilier \u0026 Rice 这两家私募股权公司宣布他们打算以 53 亿美元收购 Cloudera。目前该公司的市值约为 37 亿美元。\n\nCloudera 和 Hortonworks 是 Hadoop 领域的两家重要初创公司，于[2018 年以 52 亿美元的价格合并](https:\/\/techcrunch.com\/2018\/10\/03\/cloudera-and-hortonworks-announce-5-2-billion-merger\/)。Cloudera 可能受到激进投资者 Carl Icahn 的压力，他在 2019 年持有该公司[18% 的股份](https:\/\/siliconangle.com\/2019\/08\/12\/activist-investor-carl-icahn-shakes-cloudera\/)，现在可以从这次出售中获益，该公司表示，每股 16 美元的价格对股东有 24% 的溢价。今早开市前，该公司的股价为 12.86 美元。\n\n早在十年前，当 Hadoop 成为处理大数据的方式时，风险资金就涌入了这个领域。随着时间的推移，它失去了一些光辉。因为它是高度劳动密集型的，公司开始转移到云端，并寻找能为他们做更多工作的软件服务。像数据湖这样的更现代的技术开始取代它，该公司认识到它必须改变其方法以在现代数据处理市场中生存。\n\nCloudera 首席执行官 Rob Bearden 认为这项交易正是实现这一目标的一种方式。\u0022Bearden 在一份声明中说：\u0022我们相信，作为一家拥有 CD\u0026R 和 KKR 等经验丰富的投资者的专业知识和支持的私营公司，Cloudera 将拥有资源和灵活性来推动以产品为主导的增长，并扩大我们的市场机会。\n\n虽然该声明中有很多行政术语，但它基本上意味着该公司希望这些私募股权公司能够给它一些额外的财政资源，以便向处理大量数据的更现代的方法前进。\n\n在此过程中，Cloudera 还宣布了自己的几项收购，以帮助其实现现代化的目标。首先，Cloudera 收购了[Datacoral](https:\/\/techcrunch.com\/2018\/11\/08\/datacoral-raises-10m-series-a-for-its-data-infrastructure-service\/)，这家初创公司将构建数据管道所需的基础设施抽象化，而无需使用代码。它还收购了[Cazena](https:\/\/techcrunch.com\/tag\/cazena\/)，一家帮助客户建立云数据湖的初创公司，为公司提供了处理大数据的更现代的方法。Bearden 认为这两项服务有助于 Cloudera 在大数据自助服务市场上重新定位。\n\n\u0022这两项业务将使我们合并后的客户享受到复杂性的降低和更快的数据计划价值实现时间，从而提高洞察力，加快创新，并与客户和合作伙伴进行更有力的合作，\u0022Bearden 在一份声明中说。\n\nCloudera 在[2018 年上市](https:\/\/techcrunch.com\/2017\/04\/28\/cloudera-finishes-up-20-in-stock-market-debut\/)，在筹集了 10 亿美元后以每股 18.09 美元的价格收盘。其中绝大部分是英特尔资本在 2014 年的[7.4 亿美元的投资](https:\/\/techcrunch.com\/2014\/03\/31\/intel-pours-740m-into-cloudera-in-exchange-for-an-18-stake\/)。值得注意的是，Cloudera 在去年年底以 3.14 亿美元收购了英特尔在该公司的股份。\n\nHortonworks 又筹集了 2.48 亿美元。第三家 Hadoop 创业公司，MapR 筹集了 2.8 亿美元。该公司的资产在 2019 年以低于 5000 万美元的价格相当惨淡地卖给了 HPE，这表明 Hadoop 市场[早已落幕](https:\/\/techcrunch.com\/2019\/08\/07\/with-mapr-fire-sale-hadoops-promise-has-fallen-on-hard-times\/)。\n\nCloudera 的交易包括一个简短的 \u0022go shop\u0022条款，允许它继续寻找一个更好的交易。它是否能找到这样的交易值得怀疑，如果找不到，与 KKR 和 CD\u0026R 的交易预计将在今年下半年完成，但需要经过监管审查。该公司将在今天晚些时候公布收益。\n', '\/trans\/cloudera-to-go-private-as-kkr-cdr-grab-it-for-5-3b\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">北京时间 6 月 1 日晚，据 TechCrunch 报道，KKR 和 CD&amp;R 将以 53 亿美元收购 Cloudera，Cloudera 将被私有化。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/zoom-obs-bilibili-broadcast/">Zoom &#43; OBS &#43; B 站直播配置手册</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2021/05/25</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e9%9a%8f%e7%ac%94"> 
             随笔
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Zoom \u002b OBS \u002b B 站直播配置手册', '本文将指导你如何配置和使用 OBS \u002b zoom 在 Bilibili 上直播。', '\n今晚我第一次使用 Zoom \u002b OBS 和马若飞在 B 站上进行了[《Istio 大咖说》](https:\/\/space.bilibili.com\/1698576814)栏目的第一期分享——「Istio 开源四周年回顾与展望」。考虑到很多社区、主播、调音台会有在 B 站或其他平台上直播的需求，特别将我的个人经验分享给大家，欢迎大家补充，我会不断优化直播体验。\n\n下图是我直播时桌面的情况，使用的设备有：\n\n- MacBook Pro，这个自不必说\n- USB 麦克风博雅 BY-500，作为音频输入麦克风\n- 海康威视外接摄像头，用作第二机位\n- iPad，作为直播监视器，同时回答观众的弹幕\n- 环形补光灯，直播通常是在晚上，光线太暗需要补光\n- AirPods Pro，用于监听声音的，不作为音频输入\n- 静音蓝牙键盘，防止键盘敲击声音影响直播的声音体验\n- iPhone，用于和直播讲师私下沟通，这样不会被直播出去\n\n以上这些不是全部都需要的，只要你有一台电脑和一个耳机就可以直播。\n\n![我的桌面](desktop.jpg)\n\n上面是直播时的桌面（请忽略我杂乱的被各种设备占满空间的桌面），下面是我的配置参考。\n\n## 硬件准备\n\n- 电脑：macOS、Windows 都可以，我是用的是 Macbook Pro 2016 年产，配置如下：\n\n![系统配置](008i3skNly1gqv0t9gubjj30wk0jiwl1.jpg) \n\n- 外接麦克风：切勿直接使用电脑机身上自带的麦克风，那样会收录电脑风扇的声音，我使用的是博雅 BY-500（400 多块钱）麦克风，电容式麦克风，指向性比较好，基本没有噪音。\n- 摄像头：保证电脑上的摄像头可用，因为会议的时候需要开摄像头，或者用外接摄像头也可以。\n- 网络：确保网速至少 100MB\/s 的宽带，因为推流还是比较占用带宽的，而且还需要同时查看直播效果，对下行带宽也有要求。\n- 另一台可联网设备：用来监控直播效果，可以是手机、iPad 等\n\n## 软件准备\n\n- Zoom：需要 Pro 版，这样才可以举行超过 45 分钟的线上会议，否则会在超时后打断再重新加入，需要准备好账号，中国大陆用户貌似不能再注册？如果没有 zoom，换成其他任何一个会议软件都可以，比如腾讯会议。\n- OBS：用来做推流，到[官网](https:\/\/obsproject.com\/)下载最新的版本。\n- 音频插件 Sunflower：[点击跳转到下载页面](https:\/\/github.com\/mattingalls\/Soundflower\/releases)，如果安装时遇到系统权限问题，请在命令行中执行 \u0060sudo spctl --master-disable\u0060 并在电脑的 \u0060系统首选项\u0060 的 \u0060安全与隐私\u0060 中批准来自任意途径的软件安装，如果看到有详情页面，点击进去批准软件发行商。\n- Bilibili：需要一个 B 站账号，并开通直播间，经过实名认证。\n\n## OBS 配置\n\n下面是在 Macbook 中安装的 OBS 配置截图。\n\n需要注意的是输出、音频和视频的配置。请参考图中的配置，尤其注意编码控制、比特率的配置。\n\n![OBS 输出配置](008i3skNly1gqv0t9tppnj312t0u0gpv.jpg)\n\n![OBS 音频配置](008i3skNly1gqv0tbb4g8j313m0u0jv1.jpg)\n\n请注意分辨率的配置，同时调整电脑屏幕的分辨率为 1440x900，**不要使用太大的分辨率，否则可能导致直播画面黑屏**。\n\n![OBS 视频配置](008i3skNly1gqv0tarnvoj31is0p276g.jpg)\n\n![Macbook 显示配置](008i3skNly1gqv0tbrclhj31140pkjxy.jpg)\n\n## 会议直播\n\n以上场景是仅限于本机画面的直播，还有中场景就是现场会议直播，你还需要录制现场画面，这时候你最好制作一个直播底板，例如下图。\n\n![OBS 直播底板](diban.jpg)\n\n该底板用于布局 PPT 和摄像头画面，同时底板上也包括了活动 logo 和主办方、赞助商信息。该图最好是 PNG 透明的格式，把图片放在布局最上层，这样就能很好地展示布局。\n\n## 音频配置\n\n安装 sunflower 后，在 Midi 设备中创建一个多输出设备，如图。\n\n![MacBook 音频配置](008i3skNly1gqv0ta93jfj31060q0n28.jpg) \n\n选择 Sunflower（2ch）和你想要用来监听系统声音的设备，我是用的是 AirPods，你也可以选择其他耳机，总之不要让麦克风录到这个系统输出的即可。\n\n还要在 OBS 的麦克风配置里增加下新创建的这个输出设备，这样直播的时候就可以收录你的系统，也就是你的耳机听到的声音了，比如在视频会议中，所有人讲话的声音都会被直播出去。\n\n### 使用独立音频硬件\n\n如果安装 sunflower 有问题的话，你也可以购买一款独立的音频设备，要知道一台电脑是可以安装多块声卡的，这些声卡可以通过 USB 接口转接，而且价格都很便宜（只要几十块钱），一旦有了多个声卡，你就可以为不同的音频源选择不同的输出，而且可以对它们的音量进行单独单独控制。例如下面这款 USB 外置声卡（非利益相关），即插即用，不需要安装任何软件。\n\n![USB 外置声卡](ugreen.jpg)\n\n你也可以用 USB 外置声卡来转接其他的无线麦克风，比如我就转接了 Rode Wireless Go（你还需要买一根转接的音频线，红色的那根，用于连接声卡）。\n\n## 多路推流（多渠道同步直播）\n\n因为我们在直播时往往有多个渠道，比如多个 B 站直播间、微信视频号等，如何使用 OBS 同步推流到多个渠道呢？可以使用 [sorayuki\/obs-multi-rtmp](https:\/\/github.com\/sorayuki\/obs-multi-rtmp) 插件（支持 Windows 和 macOS），注意需要将 OBS 升级到最新版本（至少 27.0.1 版本）。安装完插件，重启 OBS 后就可以看到一个窗口新建多路推流，如下图所示。\n\n![OBS 新建多路推流](008i3skNly1gu39v42dlkj60ia0hl0tj02.jpg)\n\n如果没有看到该窗口，请点击【视图】-【停靠部件】-【多路推流】即可显示。\n\n![OBS 多路推流选项](008i3skNly1gu39u3zpknj60f3096gmh02.jpg)\n\n## 直播效果\n\n下面是当晚直播的 zoom 录制的视频直出，已上传到 [B 站](https:\/\/www.bilibili.com\/video\/BV1jK4y1R7Tk)，大家可以感受下画面的清晰度还有声音效果，我还是比较满意的。\n\n![Bilibili](bilibili.jpg)\n\n其中只有几个小插曲：\n\n- 因为我是用的是 AirPods 蓝牙耳机，戴上耳机的时候我无法确定它要连那个设备（我有两个 iPhone、1 个 iPad、1 个 MacBook 都有可能被脸上）活动开始的时候总是连不上 MacBook，一气之下把其他的苹果设备的蓝牙全关掉，只留下 MacBook 的蓝牙开启，这样可以保证连上 MacBook\n- 说话的时候忘记了把麦克风静音了\n- 直播大概进行了 1 个小时的时候，zoom 突然断开了 10 几秒钟后又自动重连，总体来说 zoom 会议还是比较稳定的，1 个小时左右的会议应该不会断连\n\n## 直播开始前的检查\n\n- 电脑屏幕分辨率调整为 1440 x 900\n- 关闭与直播无关的 APP，减少系统资源占用\n- 电脑设置为勿扰模式\n- 使用外接麦克风，切勿直接使用电脑内置的麦克风，会收录风扇及键盘杂音，影响音质\n- 使用外接耳机，如 AirPods\n- 音频输出调整为多设备输出，其中包括 Sunflower（2ch）和耳机\n- Zoom 会议开始前记得点击录像\n- 会议开始后检查 B 站直播间，确保声音和画质没有问题\n- OBS 推流的时候不用录像，因为 zoom 已经在录了\n- 直播完成后检查 zoom 生成的视频文件并备份\n\n## 优化项\n\n直接直播屏幕内容也会造成多重布局的问题，以上方案还是有可优化的地方。比如将视频会议中的共享桌面与摄像头画面分开布局到 OBS 上。\n\n## 最后\n\n直播是除了在线下面对面交流以外，可以跟社区及开源爱好者交流最直接最友好的方式，我会时常发起，感谢大家的关注我主持的直播间：\n\n- [云原生社区](https:\/\/live.bilibili.com\/22230973)\n- [Istio Service Mesh](https:\/\/live.bilibili.com\/23095515)\n\n关注上面的 B 站账号，获取直播推送提醒。关于 B 站直播，如果你有任何问题或者建议请在下面留言。\n', '\/blog\/zoom-obs-bilibili-broadcast\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文将指导你如何配置和使用 OBS &#43; zoom 在 Bilibili 上直播。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-4-year-birthday/">Istio 开源四周年回顾与展望</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2021/05/24</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio 开源四周年回顾与展望', '今天是 Istio 开源四周年，让我们一起来回顾一下 Istio 四年来的发展并展望一下它的未来。', '\nIstio 是由 [Tetrate](https:\/\/tetrate.io\/) 创始人 Varun Talwar 和谷歌首席工程师 Louis Ryan 命名并在 2017 年 5 月 24 日开源。今天是 Istio 开源四周年，让我们一起来回顾一下 Istio 四年来的发展并展望一下它的未来。\n\n## Istio 的开源历史\n\n2017 年是 Kubernetes 结束容器编排之战的一年，Google 为了巩固在云原生领域的优势，并弥补 Kubernetes 在服务间流量管理方面的劣势，趁势开源了 Istio。下面是截止目前 Istio 历史上最重要的几次版本发布。\n\n| **日期**   | 版本 | 说明                                                         |\n| ---------- | ---- | ------------------------------------------------------------ |\n| 2017-05-24 | 0.1  | 正式开源，该版本发布时仅一个命令行工具。确立了功能范围和 sidecar 部署模式，确立的 Envoy 作为默认 sidecar proxy 的地位。 |\n| 2017-10-10 | 0.2  | 支持多运行时环境，如虚拟机。                                 |\n| 2018-06-01 | 0.8  | API 重构。                                                   |\n| 2018-07-31 | 1.0  | 生产就绪，此后 Istio 团队被大规模重组。                      |\n| 2019-03-19 | 1.1  | 企业就绪，支持多 Kubernetes 集群，性能优化。                 |\n| 2020-03-03 | 1.5  | 回归单体架构，支持 WebAssembly 扩展，使得 Istio 的生态更加强大。 |\n| 2020-11-18 | 1.8  | 正式放弃 Mixer，进一步完善对虚拟机的支持。                   |\n\nIstio 开源后经过了一年时间的发展，在 1.0 发布的前两个月发布了 0.8 版本，这是对 API 的一次大规模重构。而在 2018 年 7 月底发布 1.0 时，Istio 达到了生产可用的临界点，此后 Google 对 Istio 团队进行了大规模重组，多家以 Istio 为基础的 Service Mesh [创业公司](https:\/\/istio.io\/latest\/about\/ecosystem\/#providers)诞生，可以说 2018 年是服务网格行业诞生的元年。\n\n2019 年 3 月 Istio 1.1 发布，而这距离 1.0 发布已经过去了近 9 个月，这已经远远超出一个开源项目的平均发布周期。我们知道迭代和进化速度是基础软件的核心竞争力，此后 Istio 开始以每个季度一个版本的固定[发布节奏](https:\/\/istio.io\/v1.7\/about\/release-cadence\/)，并在 2019 年成为了 [GitHub 增长最快的十大项目中排名第 4 名](https:\/\/octoverse.github.com\/#fastest-growing-oss-projects-by-contributors)！\n\n## Istio 社区\n\nIstio 开源四年来，已经在 GitHub 上收获了 2.7 万颗星，获得了大量的[社区用户](https:\/\/istio.io\/latest\/about\/case-studies\/)。下图是 [Istio](https:\/\/github.com\/istio\/istio) 的 GitHub star 数增长情况。\n\n![](008i3skNly1gqtm7n2hm1j31me0n2tag.jpg)\n\n2020 年 Istio 的项目管理开始走向成熟，治理方式也到了进化的阶段。2020 年，Istio 社区进行了第一次[管委会选举](https:\/\/istio.io\/latest\/blog\/2020\/steering-election-results\/)，还把商标转让给了 [Open Usage Commons](https:\/\/istio.io\/latest\/blog\/2020\/open-usage\/)。首届 [IstioCon](https:\/\/events.istio.io\/istiocon-2021\/) 在 2021 年 2 月份成功举办，几千人参加了线上会议。在中国也有大量的 Istio 社区用户，2021 年也会有线下面对面的 Istio 社区 meetup 在中国举办。\n\n![](008i3skNly1gquicfqg14j31lw0smwl2.jpg)\n\n根据 CNCF 2020 年调查，46% 的组织在生产中使用服务网格或计划在未来 12 个月内使用。Istio 是在生产中使用的最多的网格。\n\n## 未来\n\n经过 4 年的发展，围绕 Istio 不仅形成了庞大的用户群，还诞生了多家 Istio 供应商，你可以在最近改版的 [Istio 的官网首页](https:\/\/istio.io)中看到。在最近几个版本中，Istio 已经将发展中心转移到了提升 Day 2 Operation 体验上来了。我们还希望看到更多的 Istio 的采纳路径建议、案例研究、学习资料、培训及认证（例如来自 Tetrate 的业界的第一个 [Istio 管理员认证](https:\/\/academy.tetrate.io\/courses\/certified-istio-administrator)），这些都将有利于 Istio 的推广和采用。\n', '\/blog\/istio-4-year-birthday\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">今天是 Istio 开源四周年，让我们一起来回顾一下 Istio 四年来的发展并展望一下它的未来。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/what-is-istio-and-why-does-kubernetes-need-it/">什么是 Istio？为什么 Kubernetes 需要 Istio？</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2021/04/28</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('什么是 Istio？为什么 Kubernetes 需要 Istio？', '本文将解释 Istio 是如何产生的，以及它与 Kubernetes 的关系。', '\nIstio 是当前[最流行的服务网格实现](https:\/\/www.cncf.io\/blog\/2020\/03\/04\/2019-cncf-survey-results-are-here-deployments-are-growing-in-size-and-speed-as-cloud-native-adoption-becomes-mainstream\/)，它是在 Kubernetes 的基础上开发的，它跟 Kubernetes 在云原生应用的生态中拥有着不同的定位。本文不是直接为你介绍 Istio 具有哪些功能，而是先向你介绍 Istio 诞生的历史条件，然后带你从 Kubernetes 与 Istio 的分工开始，了解什么是 Istio。\n\n要想解释什么是 Istio，还得先了解 Istio 是在什么样的情况下出现的——即为什么会有 Istio？\n\n容器作为云原生应用的交付物，既解决了环境一致性的问题，又可以更细粒度的限制应用资源，但是随着微服务和 DevOps 的流行，容器作为微服务的载体得以广泛应用。2014 年，Google 开源了 Kubernetes，随后几年得到迅猛发展，在 2017 年奠定了容器编排调度标准的地位。Kubernetes 作为一种容器编排调度工具，解决了分布式应用程序的部署和调度问题。因为一台单机的资源有限，而互联网应用可能因为用户规模的急速扩张，或用户属性的不同在不同时间段会出现流量洪峰，因此对计算资源的弹性要求比较高。而一台单机显然无法满足一个如何规模庞大的应用，反之，对于一个规模很小的应用也没必要占用整台主机，那将导致巨大的浪费。\n\n简而言之，Kubernetes 定义服务的最终状态，并使系统自动地达到和维持在该状态。那么在应用部署完成后，如何管理服务上的流量呢？下面我们将看下 Kubernetes 中如何做服务管理，及在 Istio 中的变化。\n\n## Kubernetes 中如何做服务管理？\n\n下图展示的是 Kubernetes 中的服务模型。\n\n![Kubernetes 服务模型](service-model.jpg)\n\n从上图中我们可以看出：\n\n- 同一个服务的的不同示例可能被调度到不同的节点上；\n- Kubernetes 通过 Service 对象将一个服务的多个实例组合在了一起，统一对外服务；\n- Kubernetes 在每个 node 中安装了 \u0060kube-proxy\u0060  组件来转发流量，它拥有的简单的负载均衡功能；\n- Kubernetes 集群外部流量可以通过 Ingress 进入集群中（Kubernetes 还有其他几种暴露服务的方式，如 NodePort、LoadBalancer 等）；\n\nKubernetes 是用于资源集约管理的工具。但在为应用分配好资源后，如何保证应用的健壮性、冗余性，如何实现更细粒度的流量划分（不是根据服务中实例个数来实现），如何保障服务的安全性，如何进行多集群管理等，这些问题 Kubernetes 都不能很好地解决。\n\n服务具有多个版本，需要迭代和上线，在新版发布的时候需要切分流量，实现金丝雀发布；同时我们应该假定服务是不可靠的，可能因为各种原因导致请求失败，需要面向失败来编程，如何监控应用程序的指标，了解每个请求的耗时和状态？Istio 的发起这们就想到了在每个 pod 中注入一个代理，将代理的配置通过一个控制平面集中分发，然后将从 pod 中应用容器发起的每个请求都劫持到 sidecar 代理中，然后转发，这样不就可以完美的解决以上问题了吗？Kubernetes 优秀的架构和可扩展性，例如 CRD，pod 内的部署模式，可以完美的解决大量 sidecar 的注入和管理问题，使得 Istio 的实现成为可能。\n\n## Istio 的基本原理\n\n下图是 Istio 中的服务模型，它既可以支持 Kubernetes 中的工作负载，又可以支持虚拟机。\n\n![Istio](istio.jpg)\n\n从图中我们可以看出：\n\n- Istiod 作为控制平面，将配置下发给所有的 sidecar proxy 和 gateway（为了美观，图中没有画 Istiod 及 sidecar 之间的连接）\n- Istio 不再使用 \u0060kube-proxy\u0060 组件做流量转发，而是依托在每个 pod 中注入的 sidecar proxy，所有的 proxy 组成了 Istio 的数据平面；\n- 应用程序管理员可以和管理 Kubernetes 中的工作负载一样，通过声明式 API 操作 Istio mesh 中流量的行为；\n- Ingress 被 Gateway 资源所替代，Gateway 是一种特殊的 proxy，实际上也是复用的 Sidecar proxy；\n- 可以在虚拟机中安装 sidecar proxy，将虚拟机引入的 Istio mesh 中；\n\n实际上在 Istio 之前，人们可以使用 SpringCloud、Netflix OSS 等，通过在应用程序中集成 SDK，编程的方式来管理应用程序中的流量。但是这通常会有编程语言限制，而且在 SDK 升级的时候，需要修改代码并重新上线应用，会增大人力负担。Istio 使得流量管理变得对应用程序透明，使这部分功能从应用程序中转移到了平台层，成为了云原生基础设施。\n\n正是因为 Istio 补足了 Kubernetes 对于云原生应用的流量管理、可观测性和安全方面的短板，在 2017 年由 Google、IBM 和 Lyft 共同发起的这个服务网格开源项目，并在三年来取得了长足的发展。关于 Istio 核心功能的介绍可以参考 [Istio 文档](https:\/\/istio.io\/latest\/docs\/concepts\/what-is-istio\/)。\n\n## 总结\n\n- Service Mesh 相当于云原生时代的 TCP\/IP，解决应用程序网络通信、安全及可见性问题；\n- Istio 是目前最流行的 service mesh 实现，依托于 Kubernetes，但也可以扩展到虚拟机负载；\n- Istio 的核心由控制平面和数据平面组成，Envoy 是默认的数据平面代理；\n- Istio 作为云原生基础设施的网络层，对应用透明。\n\n  ', '\/blog\/what-is-istio-and-why-does-kubernetes-need-it\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文将解释 Istio 是如何产生的，以及它与 Kubernetes 的关系。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/zero-trust-architecture/">[译] 零信任架构白皮书</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2021/04/22</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e5%ae%89%e5%85%a8"> 
             安全
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://www.tetrate.io/white-paper-zero-trust-architecture/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('零信任架构白皮书', '本文译自 Tetrate 发布的《零信任架构白皮书》。', '\n## 背景介绍\n\n传统的数据中心网络安全架构试图在一个优美的内部花园周围建立强大的围墙。这种堡垒模型长久以来存在一个固有的弱点，即当（而不是如果）入侵者渗透到周边时，他们就可以控制整个花园。虽然这个弱点早就存在，但随着进入数据中心的入口的增加及工作负载的扩展的趋势增加，这个弱点越发严重。\n\n零信任网络架构提供了一条前进的道路，它解决了基于周界安全的弱点，采取的立场是网络本身就是敌对的；周界背后的安全是一种幻觉，野蛮人已经撞开了大门。\n\n虽然零信任需要对现状进行重大反思，但它远不是一个崇高的、不可实现的目标。现在就有一些工具可以开始实施零信任网络架构。这些工具和实践可以逐步实施，以满足你的需要，而不是要求你全盘重新构建你的整个网络安全基础设施。\n\n## 传统安全模式的弱点\n\n周边安全薄弱的原因与现代军队放弃大规模固定防御的原因类似：一旦被渗透，战斗就会失败；而周边安全最终也会被渗透。\n\n**单纯的周边安全提供了糟糕的控制粒度。**如果周界内的所有流量都是可信的，那么一个漏洞就会使周界内的一切都变得脆弱。当网络服务只有几十种时，这可能是可控的，而且可以通过物理位置严格限制访问，但服务激增到几十万种，而且都是以相同的访问水平相互通信，这使得目前的技术状态无法维持，特别是由于一个被破坏的服务可以转移到许多其他服务。\n\n多年来，业务需求已经削弱了外围的完整性。出于需要，防火墙上被打了很多洞，导致了多个暴露的入口点和难以管理的防火墙规则的扩散，使外围更像是一条马奇诺防线，而不是围墙和城堡。\n\n面对周界几乎消失的情况，为改善周界安全模式所做的新努力，如微分割和软件定义网络，有助于减少服务周围的攻击面。但是，它们也只是部分解决方案，其代价是复杂性的增加和配置规则的爆炸。分割仍然提供了糟糕的粒度。例如，隔离网络服务器和数据库服务器可以减少这些服务周围的攻击面，但网络服务器可能支持许多应用程序，它们各自可能引入的漏洞仍然是不透明的。\n\n## 零信任的信条\n\n\u0022*信任不是理想的状态，信任是你想避免的失败点*\u0022——约翰·金德瓦格\n\n零信任是一种方法，一种对网络安全的思考方式，而不是任何特定的架构或实现。它从一个假设开始，即网络上没有安全的地方。你应该把你的数据中心，不管它是否喜欢，当作它所有的数据和服务都暴露在公共互联网上。\n\n在零信任模式中，与传统的周边安全不同，可及性并不意味着授权。零信任旨在缩小资源周围的隐性信任区域，最好是缩小到零。在一个零信任的网络中，所有对资源的访问都应该是这样的。\n\n- **经过认证和动态授权**：不仅在网络层和服务间层，而且在应用层。网络位置并不意味着信任。在允许任何访问之前，服务身份和终端用户凭证是经过认证和动态授权的。\n- **有时间限制**：认证和授权被约束在一个短暂的会话中，之后必须重新建立。\n- **在空间上有界限**：一个服务周围的信任周界应该尽可能小。加密，既是为了防止窃听，也是为了确保信息的真实性和未被篡改。\n- **可观察**：所以所有资产的完整性和安全态势可以被持续监控，策略的执行可以持续得到保证。另外，从观察中获得的洞察力应该被反馈到改进策略上。\n\n### 为什么它更好？\n\n- 可访问性不是授权——与周边安全不同，对一个服务的访问并不仅仅是因为该服务是可以到达的，它还必须经过明确的认证和授权。\n\n- 经过认证和授权的工作负载受到保护，不受周边漏洞的影响。\n- 在时间上的约束限制了凭证受损的风险。\n- 在空间上的约束允许策略执行的高颗粒度。\n- 动态策略执行确保授权策略是最新的。\n- 加密限制了侦查，并提供了通信的真实性。\n- 细粒度的可观测性允许实时保证策略的执行，以及对历史上如何执行策略的事后审计，还有用于故障排除和分析的必要数据。\n\n零信任系统的试金石是，部署在该系统中的应用程序在公开曝光时不会有任何变化。如果实施得当，一个零信任的安全架构在公开的互联网上运行时与在防火墙后面运行时一样安全。\n\n### 我什么时候需要它？\n\n虽然每个组织都可能从采用零信任原则中受益，但期望几十年的基础设施和业务流程全盘转变为新模式是不现实的。\n\n特定的压力可能会促使你尽早这样做。当你的基础设施跨越不同的供应商时，例如，分裂的企业内部和云部署或混合云部署，在这些扩展的网络上大规模应用 VPN 和 NAT 的复杂性和脆弱性可能使得在短期内对这些部署应用零信任网络原则具有成本效益和风险效率。\n\n## ZTA 组件\n\nNIST 提出了三个逻辑组件来实现动态授权和认证。\n\n1.    一个策略引擎（Policy Engine，简称 PE），负责确定授权。\n2.    一个策略管理员（Policy Aadminstrator，简称 PA），用于根据策略引擎的结果建立和\/或关闭通往资源的通信路径。\n3.    策略执行点（Policy Enforcement Point，简称 PEP），位于提出请求的主体和目标资源之间，启用、监测和终止它们之间的连接。\n\n![图一](008i3skNly1gpsrzpm3cvj31n40u0whm.jpg)\n\n在这种模式下，主体要求的所有工作负载必须有一个身份，可以在 PEP 进行认证和授权。策略决策点对这些身份执行策略，并在允许访问之前执行认证和授权。在这里，授权是基于细粒度的策略；可及性不算作授权。数据平面的 PEP 允许在运行时对系统进行观察，并确保持续的合规性和治理控制。\n\n## 实施\n\n由于零信任不是一个蓝图，而更像是一种设计理念，因此有许多潜在的方法来实现零信任架构。作为服务网格和下一代访问控制（NGAC）技术的创始人和实施者，我们认为服务网格与 NGAC 相结合，为建立零信任架构网络提供了最佳基础。\n\n服务网格提供了你所需要的重要基元：\n\n- 集中管理的策略授权\n- 分布式策略执行点——PEP 与资源访问点（RAP 共同部署）\n- 内置支持基于运行时身份而非网络位置的工作负载身份\n- 内置支持终端用户的应用级认证和授权，允许对网状结构中的每个应用进行全局和一致的策略执行\n- 对线上数据进行加密\n- 内置可观测性\n\n网格提供了操作上的保证，你可以在部署认证和授权系统时使用网格，使它们更安全，更容易管理。我们可以很容易地用服务网格中的组件来重新绘制图一中所代表的 NIST 的逻辑架构。\n\n![图二](008i3skNly1gpsrzq4xikj31da0u0acq.jpg)\n\n\n服务网格的透明性允许我们逐步采用，而不需要对你的安全基础设施和业务流程全面推倒重建。网格对应用程序、部署和安全问题的解耦意味着你可以开始在现有的基础设施上建立一个零信任的架构，而不扰乱你的业务流程和应用程序交付生命周期。\n\n\n## 案例研究——美国国防部 Platform One\n\n\u0022老实说，我任务在没有服务网格的情况下无法获得任何有意义的成功；也许在 2018 年可以，但在 2020 年和这以后不可能。\u0022 ——美国空军首席软件官尼古拉斯·M·查兰（Nicolas M. Chaillan）。\n\n美国国防部在空军首席软件官 Nicolas M. Chaillan 的主持下，对其开发和运营软件的方式进行了革新。由 Chaillan 领导的在整个国防部发展 DevSecOps 实践的团队 Platform One，提供了多种企业服务，将 \u0022自动化的软件工具、服务和标准带到国防部的项目中，使作战人员能够在安全、灵活的情况下创建、部署和操作软件应用。\n\n这些服务包括他们的 DevSecOps 平台（DSOP），这是一个经批准的、符合 CNCF 标准的 Kubernetes 发行版的集合，还有 Istio、基础设施即代码的手册和加固的容器。\n\n根据 Chaillan 的说法，\u0022拥有一个集中的、由政府提供的、团队可以来使用的 DevSecOps 堆栈，这改变了游戏规则。\u0022过去，软件更新周期长达数年，而现在国防部 \u0022每天都在推送代码，一天推送多次......每个项目的初始计划时间每 5 年平均节省 12 至 18 个月。\u0022\n\nIstio 是他们架构的一个主要支柱，它提供了服务网格的能力，特别是它实现零信任模型的方式。当被问及为什么他们使用服务网格而不是仅使用入口控制器时，他不仅提到每个应用程序默认都有 mTLS 传输加密，而且 \u0022一旦你转向微服务和容器，你必须管理东西向流量，这与南北向完全不同……你需要确保横向移动受到限制。你不希望一个坏人获得一个容器的访问权，并能够......横向移动到其他容器。除了 SSO 和 mTLS，Platform One 的架构使用 Istio 来执行东西向白名单，并在容器之间提供策略执行点。\n\n该网格将策略执行从应用堆栈中剥离出来，并将其透明地转移到 sidecar 代理上。Platform One 能够将不同应用团队独立构建的多个 \u0022雪花 \u0022应用级 SSO 和加密实现整合为一个加固的单点登录和授权库，可供企业范围内所有应用使用。这就减轻了开发团队在每个应用中构建安全的负担。它还通过对单一的、经过严格审查的实施方案进行标准化，大大降低了漏洞风险。\n\nChaillan 说，\u0022如果你不使用服务网格，你最终不得不按语言、按微服务来做。而现在你是紧密耦合的。而且，比方说，在过去如果你想要更新加密位数，你就必须更新所有容器，而现在只需要更新服务网格中的 sidecar，现在你已经解耦了。仅此一点，就值得使用服务网格。”\n\n## 总结\n\n周边安全模式及其渐进式的后继者过于脆弱和复杂，无法满足现代应用开发和部署的需要。现在应用程序的构建方式需要一个动态的、灵活的安全解决方案，一个既能集中管理又能普遍适用于所有应用程序开发团队的解决方案。零信任架构在网络和应用层面提供了急需的安全改进，而服务网格为实现零信任提供了最强大、动态和灵活的方式。\n\n在所有服务和所有应用之间部署全局管理的策略执行点，服务网格提供了插入零信任功能的模拟点，如 SSO、mTLS 和动态授权。通过在全局范围内将安全责任从单个应用程序抽离到服务网格，企业有可能逐步采用零信任原则，而无需重写应用程序或改变现有流程。\n', '\/trans\/zero-trust-architecture\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文译自 Tetrate 发布的《零信任架构白皮书》。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/evolving-kubernetes-networking-with-the-gateway-api/">[译] 利用 Gateway API 发展 Kubernetes 网络</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2021/04/22</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/kubernetes"> 
             Kubernetes
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://kubernetes.io/blog/2021/04/22/evolving-kubernetes-networking-with-the-gateway-api/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('利用 Gateway API 发展 Kubernetes 网络', 'Gateway API 的出现解决了 Ingress 的可移植性问题，且有利于基于角色的访问设计。', '\nIngress 资源是 Kubernetes 众多成功案例中的一个。它创造了一个[多样化的 Ingress 控制器的生态系统](https:\/\/kubernetes.io\/docs\/concepts\/services-networking\/ingress-controllers\/)，这些控制器以标准化和一致的方式在数十万个集群中使用。这种标准化有助于用户采用 Kubernetes。然而，在 Ingress 创建五年后，有迹象表明它被分割成不同但[惊人相似的 CRD](https:\/\/dave.cheney.net\/paste\/ingress-is-dead-long-live-ingressroute.pdf) 和 [过载的注释](https:\/\/kubernetes.github.io\/ingress-nginx\/user-guide\/nginx-configuration\/annotations\/)。Ingress 普遍存在的可移植性问题也限制了它的未来。\n\n那是在 2019 年圣地亚哥的 Kubecon 上，一群充满激情的贡献者聚集在一起，讨论 [Ingress 的发展](https:\/\/static.sched.com\/hosted_files\/kccncna19\/a5\/Kubecon%20San%20Diego%202019%20-%20Evolving%20the%20Kubernetes%20Ingress%20APIs%20to%20GA%20and%20Beyond%20%5BPUBLIC%5D.pdf)。拥挤的人群溢出到了街对面的酒店大堂，而讨论出来的东西后来被称为 [Gateway API](https:\/\/gateway-api.sigs.k8s.io\/)。这次讨论是基于几个关键的假设：\n\n1. 路由匹配、流量管理和服务暴露所依据的 API 标准已经商业化，对其实施者和用户提供的定制 API 的价值很小。\n2. 可以通过共同的核心 API 资源来表示 L4\/L7 的路由和流量管理。\n3. 可以在不牺牲核心 API 的用户体验的前提下，为更复杂的功能提供扩展性。\n\n## Gateway API 介绍\n\n这产出了一些设计原则，使 Gateway API 能够在 Ingress 的基础上进行改进。\n\n- **表达性**：除了 HTTP 主机 \/ 路径匹配和 TLS 之外，Gateway API 还可以表达 HTTP 头操作、流量加权和镜像、TCP\/UDP 路由等能力，以及其他只有在 Ingress 中通过自定义注释才能实现的能力。\n- **面向角色的设计**：API 资源模型反映了路由和 Kubernetes 服务网络中常见的责任分离。\n- **可扩展性**：这些资源允许在 API 的各个层面上进行任意的配置附加。这使得在最适当的地方进行细化的定制成为可能。\n- **灵活的一致性**：Gateway API 定义了不同的一致性级别 —— 核心（强制支持）、扩展（支持时可移植）和自定义（不保证可移植性），一起被称为[灵活的一致性](https:\/\/gateway-api.sigs.k8s.io\/concepts\/guidelines\/#conformance)。这促进了高度可移植的核心 API（如 Ingress），仍然为 Gateway 控制器实施者提供了灵活性。\n\n### Gateway API 是什么样子的？\n\nGateway API 引入了一些新的资源类型：\n\n- [**GatewayClasses**](https:\/\/gateway-api.sigs.k8s.io\/references\/spec\/#networking.x-k8s.io\/v1alpha1.GatewayClass) 是集群范围内的资源，作为模板，明确地定义由其衍生的网关的行为。这与 StorageClasses 的概念类似，但用于网络数据平面。\n- [**Gateway**](https:\/\/gateway-api.sigs.k8s.io\/references\/spec\/#networking.x-k8s.io\/v1alpha1.Gateway) 是 GatewayClasses 的部署实例。它们是执行路由的数据平面的逻辑表示，它可能是集群内的代理、硬件 LB 或云 LB。\n- **路由** 不是一个单一的资源，而是代表许多不同的特定协议的路由资源。[HTTPRoute](https:\/\/gateway-api.sigs.k8s.io\/references\/spec\/#networking.x-k8s.io\/v1alpha1.HTTPRoute) 有匹配、过滤和路由规则，这些规则被应用到可以处理 HTTP 和 HTTPS 流量的网关。同样，还有 [TCPRoutes](https:\/\/gateway-api.sigs.k8s.io\/references\/spec\/#networking.x-k8s.io\/v1alpha1.TCPRoute)、[UDPRoutes](https:\/\/gateway-api.sigs.k8s.io\/references\/spec\/#networking.x-k8s.io\/v1alpha1.UDPRoute) 和 [TLSRoutes](https:\/\/gateway-api.sigs.k8s.io\/references\/spec\/#networking.x-k8s.io\/v1alpha1.TLSRoute)，它们也有协议特定的语义。这种模式也允许网关 API 在未来逐步扩展其协议支持。\n\n![Gateway API 资源](008i3skNly1gpsl6ut5jlj31ed0u0jyp.jpg)\n\n### Gateway 控制器的实现\n\n好消息是，虽然 Gateway 还在 [Alpha](https:\/\/github.com\/kubernetes-sigs\/gateway-api\/releases) 阶段，但已经有几个 Gateway 控制器实现，你可以运行。由于它是一个标准化的规格，下面的例子都可以运行，而且功能应该完全相同。我们来看看如何安装和使用这些 Gateway 控制器。\n\n## 实践 Gateway API\n\n在下面的例子中，我们将展示不同的 API 资源之间的关系，并引导你完成一个常见的使用案例。\n\n- foo 团队在 foo 命名空间中部署了他们的应用程序。他们需要控制其应用程序的不同页面的路由逻辑。\n- Team bar 正在 bar 命名空间中运行。他们希望能够对他们的应用程序进行蓝绿部署以减少风险。\n- 平台团队负责管理 Kubernetes 集群中所有应用程序的负载均衡器和网络安全。\n\n下面的 foo-route 对 foo 命名空间中的各种服务进行路径匹配，并且有一个到 404 服务器的默认路由。这通过 \u0060foo.example.com\/login\u0060 和 \u0060foo.example.com\/home\u0060 分别暴露了 foo-auth 和 foo-home 服务。\n\n\u0060\u0060\u0060yaml\nkind: HTTPRoute\napiVersion: networking.x-k8s.io\/v1alpha1\nmetadata:\n  name: foo-route\n  namespace: foo\n  labels:\n    gateway: external-https-prod\nspec:\n  hostnames:\n  - \u0022foo.example.com\u0022\n  rules:\n  - matches:\n    - path:\n        type: Prefix\n        value: \/login\n    forwardTo:\n    - serviceName: foo-auth\n      port: 8080\n  - matches:\n    - path:\n        type: Prefix\n        value: \/home\n    forwardTo:\n    - serviceName: foo-home\n      port: 8080\n  - matches:\n    - path:\n        type: Prefix\n        value: \/\n    forwardTo:\n    - serviceName: foo-404\n      port: 8080\n\u0060\u0060\u0060\n\n在同一个 Kubernetes 集群的 bar 命名空间中运行的 bar 团队也希望将他们的应用程序暴露在互联网上，但他们也希望控制自己的金丝雀发布和蓝绿部署。下面的 HTTPRoute 被配置为以下行为。\n\n- 对于访问 \u0060bar.example.com\u0060的流量：\n  - 将 90% 的流量发送到 bar-v1\n  - 将 10% 的流量发送到 bar-v2\n- 对于访问 \u0060bar.example.com\u0060 的流量，HTTP header 为 \u0060env: canary\u0060：\n  - 将所有的流量发送到 bar-v2\n\n\n![The routing rules configured for the bar-v1 and bar-v2 Services](008i3skNly1gpsl6via0rj31np0fxq5x.jpg)\n\n\u0060\u0060\u0060yaml\nkind: HTTPRoute\napiVersion: networking.x-k8s.io\/v1alpha1\nmetadata:\n  name: bar-route\n  namespace: bar\n  labels:\n    gateway: external-https-prod\nspec:\n  hostnames:\n  - \u0022bar.example.com\u0022\n  rules:\n  - forwardTo:\n    - serviceName: bar-v1\n      port: 8080\n      weight: 90\n    - serviceName: bar-v2\n      port: 8080\n      weight: 10\n  - matches:\n    - headers:\n        values:\n          env: canary\n    forwardTo:\n    - serviceName: bar-v2\n      port: 8080\n\u0060\u0060\u0060\n\n### 路由和网关绑定\n\n因此，我们有两个 HTTPRoute 匹配并将流量路由到不同的服务。你可能想知道，这些服务在哪里可以访问？它们是通过哪些网络或 IP 暴露的？\n\n路由如何暴露给客户是由[路由绑定](https:\/\/gateway-api.sigs.k8s.io\/concepts\/api-overview\/#route-binding)管理的，它描述了路由和网关如何在彼此之间建立双向关系。当路由与网关绑定时，意味着它们的集体路由规则被配置在底层负载均衡器或代理上，并且路由可以通过网关访问。因此，网关是一个网络数据平面的逻辑表示，可以通过路由配置。\n\n![路由如何绑定到网关](008i3skNly1gpsl6w3e9aj31fo0gotay.jpg)\n\n### 行政授权\n\n网关和路由资源之间的分割允许集群管理员将一些路由配置委托给各个团队，同时仍然保留集中控制。下面的网关资源在 443 端口暴露 HTTPS，并用集群管理员控制的证书终止该端口的所有流量。\n\n\u0060\u0060\u0060yaml\nkind: Gateway\napiVersion: networking.x-k8s.io\/v1alpha1\nmetadata:\n  name: prod-web\nspec:\n  gatewayClassName: acme-lb\n  listeners:  \n  - protocol: HTTPS\n    port: 443\n    routes:\n      kind: HTTPRoute\n      selector:\n        matchLabels:\n          gateway: external-https-prod\n      namespaces:\n        from: All\n    tls:\n      certificateRef:\n        name: admin-controlled-cert\n\u0060\u0060\u0060\n\n下面的 HTTPRoute 显示了 Route 如何通过它的 \u0060kind\u0060（HTTPRoute）和资源标签（\u0060gateway=external-https-prod\u0060）确保它与 Gateway 的选择器相匹配。\n\n\u0060\u0060\u0060yaml\n# 匹配网关上所需的 kind 选择器\nkind: HTTPRoute\napiVersion: networking.x-k8s.io\/v1alpha1\nmetadata:\n  name: foo-route\n  namespace: foo-ns\n  labels:\n    # 匹配网关上所需的标签选择器\n    gateway: external-https-prod\n...\n\u0060\u0060\u0060\n\n### 以角色为导向的设计\n\n当你把它放在一起时，你有一个单一的负载均衡基础设施，可以被多个团队安全地共享。Gateway API 不仅是一个用于高级路由的更具表现力的 API，而且是一个面向角色的 API，为多用户基础设施而设计。它的可扩展性确保了它在保持可移植性的同时，还能为未来的使用场景而发展。最终，这些特性将使 Gateway API 在未来适应不同的组织模式和实施方式。\n\n### 尝试和参与\n有许多资源可供查阅，以了解更多。\n\n- 查阅[用户指南](https:\/\/gateway-api.sigs.k8s.io\/guides\/getting-started\/)，看看可以解决哪些用例。\n- 试用现有的网关控制器。\n- 或者[参与进来](https:\/\/gateway-api.sigs.k8s.io\/contributing\/community\/)，帮助设计并影响 Kubernetes 服务网络的未来！\n', '\/trans\/evolving-kubernetes-networking-with-the-gateway-api\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">Gateway API 的出现解决了 Ingress 的可移植性问题，且有利于基于角色的访问设计。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/introducing-getenvoy-extension-toolkit-for-webassembly-based-envoy-extensions/">[译] 使用基于 WebAssembly 的 GetEnvoy 工具包扩展 Envoy</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2021/04/21</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/envoy"> 
             Envoy
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('使用基于 WebAssembly 的 GetEnvoy 工具包扩展 Envoy', '本文为大家介绍了如何使用开源项目 GetEnvoy 来扩展 Envoy。', '\n说一说来龙去脉，Envoy 是一个非常注重规模化业务的底层网络组件，令人激动且功能强大。然而它在用户体验方面一直很欠缺。\n\n当用户开始使用一个新工具时，必然会从“如何在自己的环境中安装”这一问题开始。而 Envoy 之前并没有给出答案。\n\n为了填补这一空白，Tetrate [启动了](https:\/\/www.getenvoy.io\/blog\/announcing-the-getenvoy-project\/) GetEnvoy 项目并且 [推出了](https:\/\/www.getenvoy.io\/blog\/introducing-the-getenvoy-cli\/) getenvoy CLI，作为提供给用户的组件。\n\n### 新挑战\n\n下一个关于 Envoy 的常见需求是“如何扩展”。\n\n截止目前，如果想扩展或定制 Envoy，你将不得不“越界”成为实质上的 Envoy 开发者。 \n\n幸运的是，这种情况即将改变。一种名为 [WebAssembly（Wasm）](https:\/\/webassembly.org\/) 的新技术即将纳入 Envoy。Wasm 让使用不同编程语言开发 Envoy 扩展成为可能。更重要的是，能以完全动态的方式部署这些扩展。\n\n### GetEnvoy 扩展工具包\n\n[GetEnvoy 扩展工具包](https:\/\/www.getenvoy.io\/reference\/getenvoy_extension_toolkit_reference\/) 的目的在于帮助有扩展 Envoy 需求的开发者，在短时间内完成扩展开发并启动运行。\n\n作为开发者，你很可能想：\n\n- 从工作中的典型示例入手\n- 从开始就建立有效的开发工作流\n- 利用最佳实践，自动避免常见陷阱\n\nGetEnvoy 扩展工具包将帮助您解决以上所有问题！\n\n### 使用 Rust 创建 Envoy HTTP Filter\n\n让我们使用 Rust 开发一个 Envoy HTTP Filter 来试试 GetEnvoy 扩展工具包吧！\n\n#### 1. 前置要求\n\n[安装](https:\/\/www.getenvoy.io\/install\/) getenvoy CLI，例如：\n\n\u0060\u0060\u0060shell\n$ curl -L https:\/\/getenvoy.io\/cli | bash -s -- -b \/usr\/local\/bin\n\u0060\u0060\u0060\n\n[安装](https:\/\/docs.docker.com\/engine\/install\/) Docker。 \n\n检查\n\n运行命令：\n\n\u0060\u0060\u0060shell\n$ getenvoy --version\n\u0060\u0060\u0060\n应该看到类似于以下的输出：\n\u0060\u0060\u0060shell\ngetenvoy version 0.2.0\n\u0060\u0060\u0060\n运行\n\u0060\u0060\u0060shell\n$ docker --version\n\u0060\u0060\u0060\n应该看到类似于以下的输出：\n\u0060\u0060\u0060shell\nDocker version 19.03.8, build afacb8b\n\u0060\u0060\u0060\n\n#### 2. 安装新的 HTTP Filter 扩展包的脚手架\n\n如果想在交互模式下构建一个新扩展，运行命令：\n\n\u0060\u0060\u0060shell\n$ getenvoy extension init\n\u0060\u0060\u0060\n此外，如果想跳过向导，需要在命令行提供参数，比如：\n\u0060\u0060\u0060shell\n$ getenvoy extension init \\\n    --category envoy.filters.http \\\n    --language rust \\\n    --name me.filters.http.my_http_filter \\\n    my_http_filter \n\u0060\u0060\u0060\n\n检查\n\n运行命令：\n\n\u0060\u0060\u0060shell\n$ tree -a my_http_filter\n\u0060\u0060\u0060\n应该看到类似于以下的输出：\n\u0060\u0060\u0060shell\nmy_http_filter\n├── .cargo\n│   └── config\n├── .getenvoy\n│   └── extension\n│       └── extension.yaml\n├── .gitignore\n├── Cargo.toml\n├── README.md\n├── src\n│   ├── config.rs\n│   ├── factory.rs\n│   ├── filter.rs\n│   ├── lib.rs\n│   └── stats.rs\n└── wasm\n    └── module\n        ├── Cargo.toml\n        └── src\n            └── lib.rs\n\u0060\u0060\u0060\n\n#### 3. 构建扩展\n\n运行命令：\n\n\u0060\u0060\u0060shell\n$ getenvoy extension build\n\u0060\u0060\u0060\n应该看到类似于以下的输出：\n\u0060\u0060\u0060shell\nUpdating crates.io index\nDownloaded envoy-sdk v0.1.0\n...\nCompiling envoy-sdk v0.1.0\n...\nFinished dev [unoptimized \u002b debuginfo] target (s) in 23.57s\nCopying *.wasm file to \u0027target\/getenvoy\/extension.wasm\u0027\n\u0060\u0060\u0060\n\n检查\n\n运行命令：\n\n\u0060\u0060\u0060shell\n$ tree target\/getenvoy\/\n\u0060\u0060\u0060\n应该看到类似于以下的输出：\n\u0060\u0060\u0060shell\ntarget\/getenvoy\n└── extension.wasm\n\u0060\u0060\u0060\n\n#### 4. 运行单元测试\n\n运行命令：\n\n\u0060\u0060\u0060shell\n$ getenvoy extension test\n\u0060\u0060\u0060\n\n检查\n\n应该看到类似于以下的输出：\n\n\u0060\u0060\u0060shell\nrunning 1 test\ntest tests::should_initialize ... ok\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n\u0060\u0060\u0060\n\n#### 5. 在 Envoy 中运行扩展\n\n让我们用较困难的方式完成这部分工作。与其使用一条简单的自动化命令，不如手动完成每一步。\n\n##### 1. 下载 Envoy 二进制文件\n\n需要去下载和扩展开发版本相同的 Envoy\n\n运行命令：\n\n\u0060\u0060\u0060shell\n$ cat .getenvoy\/extension\/extension.yaml\n\u0060\u0060\u0060\n应该看到类似于以下的输出：\n\u0060\u0060\u0060shell\n…\n\n# Runtime the extension is being developed against.\n\nruntime:\n  envoy:\n    version: wasm:1.15\n\u0060\u0060\u0060\n为了下载该版本的 Envoy，运行命令：\n\u0060\u0060\u0060shell\n$ getenvoy fetch wasm:1.15\n\u0060\u0060\u0060\n应该看到类似于以下的输出：\n\u0060\u0060\u0060shell\nfetching wasm:1.15\/darwin\n[Fetching Envoy] 100%\n\u0060\u0060\u0060\n\n##### 2. 创建一个示例 Envoy 配置\n\n运行命令：\n\n\u0060\u0060\u0060shell\n$ getenvoy extension examples add\n\u0060\u0060\u0060\n检查一下，运行命令：\n\u0060\u0060\u0060shell\n$ tree .getenvoy\/extension\/examples\n\u0060\u0060\u0060\n应该看到类似于以下的输出：\n\u0060\u0060\u0060shell\n.getenvoy\/extension\/examples\n└── default\n  ├── README.md\n  ├── envoy.tmpl.yaml\n  ├── example.yaml\n  └── extension.json\n\u0060\u0060\u0060\n\n##### 3. 通过查看 README.md 文件了解更多关于示例配置的信息\n\n##### 4. 快速浏览示例 Envoy 配置\n\n运行命令：\n\n\u0060\u0060\u0060shell\n$  cat .getenvoy\/extension\/examples\/default\/envoy.tmpl.yaml\n\u0060\u0060\u0060\n应该看到类似于以下的输出：\n\u0060\u0060\u0060yaml\n...\nhttp_filters:\n- name: envoy.filters.http.wasm\n  typed_config:\n    \u0022@type\u0022: type.googleapis.com\/envoy.extensions.filters.http.wasm.v3.Wasm\n    config:\n      configuration: {{.GetEnvoy.Extension.Config}}\n      name: {{.GetEnvoy.Extension.Name}}\n      root_id: {{.GetEnvoy.Extension.Name}}\n      vm_config:\n        vm_id: {{.GetEnvoy.Extension.Name}}\n        runtime: envoy.wasm.runtime.v8\n        code: {{.GetEnvoy.Extension.Code}}\n- name: envoy.filters.http.router\n...\n\u0060\u0060\u0060\n\n注意，示例 Envoy 配置中包含了占位符 {{…}}，这些占位符会由 getenvoy CLI 解决。\n\n##### 5. 使用该示例配置启动 Envoy\n\n运行命令：\n\n\u0060\u0060\u0060shell\n$ getenvoy extension run\n\u0060\u0060\u0060\n应该看到类似于以下的输出：\n\u0060\u0060\u0060shell\ninfo Envoy command: [$HOME\/.getenvoy\/builds\/wasm\/1.15\/darwin\/bin\/envoy -c \/tmp\/getenvoy_extension_run732371719\/envoy.tmpl.yaml]\n...\n[info][main] [external\/envoy\/source\/server\/server.cc:339] admin address: 127.0.0.1:9901\n...\n[info][config] [external\/envoy\/source\/server\/listener_manager_impl.cc:700] all dependencies initialized. starting workers\n[info][main] [external\/envoy\/source\/server\/server.cc:575] starting main dispatch loop\n\u0060\u0060\u0060\n\n此时 Envoy 已启动，扩展也可以使用了。\n\n检查\n\n为了测试 HTTP Filter 扩展，运行命令：\n\n\u0060\u0060\u0060shell\n$ curl -i http:\/\/0.0.0.0:10000\n\u0060\u0060\u0060\n在 Envoy 的输出中，应该看到类似于以下的输出：\n\u0060\u0060\u0060shell\nmy_http_filter: #2 new http exchange starts at 2020-07-01T18:22:51.623813\u002b00:00 with config:\nmy_http_filter: #2 observing request headers\nmy_http_filter: #2 -\u003e :authority: 0.0.0.0:10000\nmy_http_filter: #2 -\u003e :path: \/\nmy_http_filter: #2 -\u003e :method: GET\nmy_http_filter: #2 -\u003e user-agent: curl\/7.64.1\nmy_http_filter: #2 -\u003e accept: *\/*\nmy_http_filter: #2 -\u003e x-forwarded-proto: http\nmy_http_filter: #2 -\u003e x-request-id: 8902ca62-75a7-40e7-9b2e-cd7dc983b091\nmy_http_filter: #2 http exchange complete\n\u0060\u0060\u0060\n由于现在你知道了运行扩展的背后都发生了什么，下次就可以用以下命令简单启动扩展：\n\u0060\u0060\u0060shell\n$ getenvoy extension run\n\u0060\u0060\u0060\n\n#### 增加一个新特性\n\n让我们为扩展添加一个新特性：在代理的 HTTP 响应中注入一个额外的标头。\n\n首先，更新扩展配置以保存注入的标头的名称（添加的行后添加了注释）：\n\n在 src\/config.rs 文件中\n\n\u0060\u0060\u0060rust\n\/\/\/ Configuration for a Sample HTTP Filter.\n#[derive (Debug, Default, Deserialize)]\npub struct SampleHttpFilterConfig {#[serde (default)]{\n#[serde(default)]\npub response_header_name: String, \/\/ 添加的代码\n}\n\u0060\u0060\u0060\n\n接着，添加 on_response_headers 方法到 SampleHttpFilter 中：\n\n在 src\/filter.rs 文件中\n\n\u0060\u0060\u0060rust\n\/\/\/ Called when HTTP response headers have been received. 当 HTTP 响应头被接收时调用\n\/\/\/\n\/\/\/ Use \u0060filter_ops\u0060 to access and mutate response headers. 使用 filter_ops 访问和变异响应头\nfn on_response_headers (\n    \u0026mut self,\n    _num_headers: usize,\n    _end_of_stream: bool,\n    filter_ops: \u0026dyn http::ResponseHeadersOps,\n) -\u003e Result\u003chttp::FilterHeadersStatus\u003e {if !self.config.response_header_name.is_empty () {\n        filter_ops.set_response_header (\n            \u0026self.config.response_header_name,\n            \u0022injected by WebAssembly extension\u0022\n        )?;\n    }\n    Ok (http::FilterHeadersStatus::Continue)\n}\n\u0060\u0060\u0060\n\n最后，在默认的示例设置中更新扩展配置。\n\n在 \u0060.getenvoy\/extension\/examples\/default\/extension.json\u0060 文件中\n\n\u0060\u0060\u0060{\u0022response_header_name\u0022:\u0022my-header\u0022}\u0060\u0060\u0060\n\n检查\n\n为了确认变更，重启示例设置：\n\n\u0060\u0060\u0060shell\n$ getenvoy extension run\n\u0060\u0060\u0060\n发出以下示例请求：\n\u0060\u0060\u0060sh\n$ curl -i localhost:10000\n\u0060\u0060\u0060\n应该看到类似于下面的输出：\n\u0060\u0060\u0060sh\nHTTP\/1.1 200 OK\ncontent-length: 22\ncontent-type: text\/plain\ndate: Tue, 07 Jul 2020 18:36:23 GMT\nserver: envoy\nx-envoy-upstream-service-time: 0\nmy-header: injected by WebAssembly extension\n \nHi from mock service!\n\u0060\u0060\u0060\n\n注意到一条额外的标头被注入到响应中。\n\n#### 增加一个新指标\n\nEnvoy 大力支持对新行为的可观测性。\n\n让我们更新扩展以暴露关于其新行为的度量。具体来说，提供一个计数器，显示被额外的标头注入了的 HTTP 响应的数量。 \n\n编辑源码如下（添加的行后加入了注释）：\n\n在 src\/stats.rs 文件中\n\n\u0060\u0060\u0060rust\nuse envoy::host::stats::Counter;\n\n\/\/\/ Sample stats.\npub struct SampleHttpFilterStats {requests_total: Box\u003cdyn Counter\u003e,\n   responses_injected_total: Box\u003cdyn Counter\u003e,              \/\/added code 新增行\n} \n\nimpl SampleHttpFilterStats {\n   pub fn new (requests_total: Box\u003cdyn Counter\u003e,\n       responses_injected_total: Box\u003cdyn Counter\u003e,          \/\/added code 新增行\n   ) -\u003e Self {\n       SampleHttpFilterStats {\n           requests_total,\n           responses_injected_total,                        \/\/added code 新增行\n       }\n   }\n\n   pub fn requests_total (\u0026self) -\u003e \u0026dyn Counter {\u0026*self.requests_total}\n\n   pub fn responses_injected_total (\u0026self) -\u003e \u0026dyn Counter { \/\/added code 新增行\n       \u0026*self.responses_injected_total\n   }\n}\n\u0060\u0060\u0060\n在 src\/factory.rs 中\n\u0060\u0060\u0060rust\n\/\/\/ Creates a new factory.\npub fn new (clock: \u0026\u0027a dyn Clock, stats: \u0026dyn Stats) -\u003e Result\u003cSelf\u003e {\n    let stats = SampleHttpFilterStats::new (stats.counter (\u0022examples.http_filter.requests_total\u0022)?,\n        stats.counter (\u0022examples.http_filter.responses_injected_total\u0022)?, \/\/added code 新增行\n    );\n    \/\/ Inject dependencies on Envoy host APIs\n    Ok (SampleHttpFilterFactory {config: Rc::new (SampleHttpFilterConfig::default ()),\n        stats: Rc::new (stats),\n        clock,\n    })\n}\n\u0060\u0060\u0060\n在 src\/filter.rs 中\n\u0060\u0060\u0060rust\n\/\/\/ Called when HTTP response headers have been received.\n\/\/\/\n\/\/\/ Use \u0060filter_ops\u0060 to access and mutate response headers.\nfn on_response_headers (\n    \u0026mut self,\n    _num_headers: usize,\n    _end_of_stream: bool,\n    filter_ops: \u0026dyn http::ResponseHeadersOps,\n) -\u003e Result\u003chttp::FilterHeadersStatus\u003e {if !self.config.response_header_name.is_empty () {\n        filter_ops.set_response_header (\n            \u0026self.config.response_header_name,\n           \u0022injected by WebAssembly extension\u0022,\n        )?;\n        self.stats.responses_injected_total ().inc ()?; \/\/added code\n    }\n    Ok (http::FilterHeadersStatus::Continue)\n}\n\u0060\u0060\u0060\n\n检查\n\n重启示例设置，发出示例请求并检查 Envoy 的指标：\n\n\u0060\u0060\u0060$ getenvoy extension run\u0060\u0060\u0060\n\n\u0060\u0060\u0060sh\n$ curl -i localhost:10000\n$ curl -i localhost:10000\n\n$ curl -s localhost:9901\/stats | grep responses_injected_total\n\u0060\u0060\u0060\n应该看到类似于以下的输出：\n\u0060\u0060\u0060\nexamples.http_filter.responses_injected_total: 2\n\u0060\u0060\u0060\n\n我们对使用 [GetEnvoy 扩展工具包](https:\/\/www.getenvoy.io\/reference\/getenvoy_extension_toolkit_reference\/) 的开发流程的简单介绍到此结束。\n\n### 结束语\n\n目前为止，我们展示了使用 GetEnvoy 开发 Envoy 扩展是多么容易。\n\n结合 [getenvoy CLI](https:\/\/www.getenvoy.io\/) 的便利和 [Envoy Rust SDK](https:\/\/docs.rs\/envoy-sdk\/) 的指引，你可以轻松胜任这些工作。\n\n除了上面演示的 [HTTP Filter](https:\/\/docs.rs\/envoy-sdk\/0.1.0\/envoy_sdk\/extension\/filter\/http\/index.html) 扩展外，你还可以使用该工具包开发其他类型的 Envoy 扩展，比如 [Network Filter](https:\/\/docs.rs\/envoy-sdk\/0.1.0\/envoy_sdk\/extension\/filter\/network\/index.html) 和 [Access Logger](https:\/\/docs.rs\/envoy-sdk\/0.1.0\/envoy_sdk\/extension\/access_logger\/index.html)。\n\n### 未来计划\n\n在未来的几个月里，我们将为 GetEnvoy 添加一些新特性。\n\n一方面，我们将把重点转移到扩展用户体验上，为用户提供能够轻松发现和使用扩展的方法。 \n\n另一方面，我们将继续改善开发者流程的用户体验。对更多编程语言和更多扩展类型的支持将会到来。 \n\n敬请关注 GetEnvoy 的进一步更新！请与我们分享你在 Rust 中的 Envoy 扩展！\n\n', '\/trans\/introducing-getenvoy-extension-toolkit-for-webassembly-based-envoy-extensions\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文为大家介绍了如何使用开源项目 GetEnvoy 来扩展 Envoy。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/why-do-you-need-istio-when-you-already-have-kubernetes/">为什么在使用了 Kubernetes 后你可能还需要 Istio？</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2021/04/07</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('为什么在使用了 Kubernetes 后你可能还需要 Istio？', '本文将带大家了解 Kubernetes 和 Istio 的内部工作原理。此外，我会介绍 Kubernetes 中的负载均衡方法，并解释为什么有了 Kubernetes 后可能还需要 Istio。', '\n如果你听说过服务网格，并尝试过 [Istio](https:\/\/istio.io\/)，你可能有以下问题。\n\n1. 为什么 Istio 要在 Kubernetes 上运行？\n2. Kubernetes 和服务网格在云原生应用架构中分别扮演什么角色？\n3. Istio 扩展了 Kubernetes 的哪些方面？它解决了哪些问题？\n4. Kubernetes、Envoy 和 Istio 之间是什么关系？\n\n本文将带大家了解 Kubernetes 和 Istio 的内部工作原理。此外，我会介绍 Kubernetes 中的负载均衡方法，并解释为什么有了 Kubernetes 后还需要 Istio。\n\nKubernetes 本质上是通过声明式配置来实现应用生命周期管理，而服务网格本质上是提供应用间的流量、安全管理和可观测性。如果你已经使用 Kubernetes 搭建了一个稳定的应用平台，那么如何设置服务间调用的负载均衡和流量控制？是否有这样一个通用的工具或者说平台（非 SDK），可以实现？这就需要用到服务网格了。\n\nEnvoy 引入了 xDS 协议，这个协议得到了各种开源软件的支持，比如 Istio、[MOSN](https:\/\/mosn.io\/) 等。Envoy 将 xDS 贡献给服务网格或云原生基础设施。Envoy 本质上是一个现代版的代理，可以通过 API 进行配置，在此基础上衍生出许多不同的使用场景–比如 API Gateway、服务网格中的 sidecar 代理和边缘代理。\n\n本文包含以下内容。\n\n- kube-proxy 的作用描述。\n- Kubernetes 在微服务管理方面的局限性。\n- Istio 服务网格的功能介绍。\n- Kubernetes、Envoy 和 Istio 服务网格中一些概念的比较。\n\n## Kubernetes vs Service Mesh\n\n下图显示了 Kubernetes 中的服务访问关系和服务网格（每个 pod 模型一个 sidecar）。\n\n![Kubernetes vs Service Mesh](008eGmZEly1gpb7knfo4dj31hk0redrz.jpg)\n\n### 流量转发\n\nKubernetes 集群中的每个节点都部署了一个 kube-proxy 组件，该组件与 Kubernetes API Server 进行通信，获取集群中的服务信息，然后设置 iptables 规则，将服务请求直接发送到对应的 Endpoint（属于同一组服务的 pod）。\n\n### 服务发现\n\n![Service Discovery](008eGmZEly1gpb7knwb79j30kq0fcjs9.jpg)\n\nIstio 可以跟踪 Kubernetes 中的服务注册，也可以在控制平面中通过平台适配器与其他服务发现系统对接；然后生成数据平面的配置（使用 CRD，这些配置存储在 etcd 中），数据平面的透明代理。数据平面的透明代理以 sidecar 容器的形式部署在每个应用服务的 pod 中，这些代理都需要请求控制平面同步代理配置。代理之所以“透明”，是因为应用容器完全不知道代理的存在。过程中的 kube-proxy 组件也需要拦截流量，只不过 kube-proxy 拦截的是进出 Kubernetes 节点的流量–而 sidecar 代理拦截的是进出 pod 的流量。\n\n### 服务网格的劣势\n\n由于 Kubernetes 的每个节点上都运行着很多 pod，所以在每个 pod 中放入原有的 kube-proxy 路由转发功能，会增加响应延迟–由于 sidecar 拦截流量时跳数更多，消耗更多的资源。为了对流量进行精细化管理，将增加一系列新的抽象功能。这将进一步增加用户的学习成本，但随着技术的普及，这种情况会慢慢得到缓解。\n\n### 服务网格的优势\n\nkube-proxy 的设置是全局的，无法对每个服务进行细粒度的控制，而 service mesh 通过 sidecar proxy 的方式将 Kubernetes 中的流量控制从服务层中抽离出来–可以实现更大的弹性。\n\n### Kube-proxy 的不足之处\n\n首先，如果转发的 pod 不能正常服务，它不会自动尝试其他 pod。每个 pod 都有一个健康检查机制，当一个 pod 出现健康问题时，kubelet 会重启 pod，kube-proxy 会删除相应的转发规则。另外，节点 Port 类型的服务不能添加 TLS 或更复杂的消息路由机制。\n\nKube-proxy 实现了一个 Kubernetes 服务的多个 pod 实例之间的流量负载均衡，但如何对这些服务之间的流量进行精细化控制–比如将流量按百分比划分给不同的应用版本（这些应用版本都是同一个服务的一部分，但在不同的部署上），或者做金丝雀发布（灰度发布）和蓝绿发布？\n\nKubernetes 社区给出了一个使用 Deployment 做[金丝雀发布](https:\/\/kubernetes.io\/docs\/concepts\/cluster-administration\/manage-deployment\/#canary-deployments)的方法，本质上是通过修改 pod 的标签来给部署的服务分配不同的 pod。\n\n### Kubernetes Ingress vs Istio Gateway\n\n如上所述，kube-proxy 只能在 Kubernetes 集群内路由流量。Kubernetes 集群的 pod 位于 CNI 创建的网络中。Ingress 是在 Kubernetes 中创建的资源对象，用于集群外部的通信。它由位于 Kubernetes 边缘节点上的入口控制器驱动，负责管理南北向流量。Ingress 必须与各种 Ingress 控制器对接，比如 [nginx ingress 控制器](https:\/\/github.com\/kubernetes\/ingress-nginx)和 [traefik](https:\/\/traefik.io\/)。Ingress 只适用于 HTTP 流量，使用简单。它只能通过匹配有限的字段来路由流量——如服务、端口、HTTP 路径等。这使得它无法对 TCP 流量进行路由，如 MySQL、Redis 和各种 RPC。这就是为什么你会看到人们在 ingress 资源注释中写 Nginx 配置语言的原因（注：使用 Nginx Ingress Controller 可以通过 [配置 ConfigMap 和 Service 的方式](https:\/\/kubernetes.github.io\/ingress-nginx\/user-guide\/exposing-tcp-udp-services\/)来变通支持 TCP 和 UDP  流量转发）。直接路由南北流量的唯一通行方法是使用服务的 LoadBalancer 或 NodePort，前者需要云厂商支持，后者需要额外的端口管理。\n\nIstio Gateway 的功能与 Kubernetes Ingress 类似，它负责进出集群的南北流量。Istio Gateway 描述了一个负载均衡器，用于承载进出服务网格边缘的连接。该规范描述了一组开放端口和这些端口所使用的协议，以及用于负载均衡的 SNI 配置等。Gateway 是一个 CRD 扩展，它也重用了 sidecar 代理的功能；详细配置请参见 [Istio 网站](https:\/\/istio.io\/latest\/docs\/reference\/config\/networking\/gateway\/)。\n\n## Envoy\n\nEnvoy 是 Istio 中默认的 sidecar 代理。Istio 基于 Envoy 的 xDS 协议扩展了其控制平面。在讨论 Envoy 的 xDS 协议之前，我们需要先熟悉 Envoy 的基本术语。下面是 Envoy 的架构图。\n\n![Envoy 架构图](envoy-arch.jpg)\n\n### 基础概念\n\n以下是 Envoy 中你应该知道的基本术语。\n\n- 下游。下游主机连接到 Envoy，发送请求，并接收响应，即发送请求的主机。\n- 上游：上游主机。上游主机接收来自 Envoy 的连接和请求，并返回响应；即接收请求的主机。\n- Listener：监听器。监听器是一个命名的网络地址（如端口、UNIX 域套接字等）；下游客户端可以连接到这些监听器。Envoy 将一个或多个监听器暴露给下游主机进行连接。\n- 集群。集群是一组逻辑上相同的上游主机，Envoy 连接到它们。Envoy 通过服务发现来发现集群的成员。可以选择通过主动的健康检查来确定集群成员的健康状态。Envoy 通过负载均衡策略来决定集群中哪个成员的请求路由。\n\n在 Envoy 中可以设置多个监听器，每个监听器可以设置一个过滤链（过滤链表），而且过滤链是可扩展的，这样我们可以更方便地操纵流量的行为–比如设置加密、私有 RPC 等。\n\nxDS 协议是由 Envoy 提出的，是 Istio 中默认的 sidecar 代理，但只要实现了 xDS 协议，理论上也可以作为 Istio 中的 sidecar 代理 —— 比如蚂蚁集团开源的 [MOSN](https:\/\/mosn.io)。\n\n![Istio 的架构](arch.png)\n\nIstio 是一个功能非常丰富的服务网格，包括以下功能。\n\n- 流量管理。这是 Istio 最基本的功能。\n- 策略控制。实现访问控制系统、遥测采集、配额管理、计费等功能。\n- 可观测性。在 sidecar 代理中实现。\n- 安全认证。由 Citadel 组件进行密钥和证书管理。\n\n## Istio 中的流量管理\n\nIstio 中定义了以下 CRD 来帮助用户进行流量管理。\n\n- 网关。网关描述了一个运行在网络边缘的负载均衡器，用于接收传入或传出的 HTTP\/TCP 连接。\n- 虚拟服务（VirtualService）。VirtualService 实际上是将 Kubernetes 服务连接到 Istio 网关。它还可以执行额外的操作，例如定义一组流量路由规则，以便在主机寻址时应用。\n- DestinationRule。DestinationRule 定义的策略决定了流量被路由后的访问策略。简单来说，它定义了流量的路由方式。其中，这些策略可以定义为负载均衡配置、连接池大小和外部检测（用于识别和驱逐负载均衡池中不健康的主机）配置。\n- EnvoyFilter。EnvoyFilter 对象描述了代理服务的过滤器，可以自定义 Istio Pilot 生成的代理配置。这种配置一般很少被主用户使用。\n- ServiceEntry。默认情况下，Istio 服务 Mesh 中的服务无法发现 Mesh 之外的服务。ServiceEntry 可以在 Istio 内部的服务注册表中添加额外的条目，从而允许 Mesh 中自动发现的服务访问并路由到这些手动添加的服务。\n\n## Kubernetes vs xDS vs Istio\n\n在回顾了 Kubernetes 的 kube-proxy 组件、xDS 和 Istio 对流量管理的抽象后，现在我们仅从流量管理的角度来看看这三个组件 \/ 协议的比较（注意，三者并不完全等同）。\n\n| **Kubernetes** | **xDS**  | **Istio service mesh** |\n| -------------- | -------- | ---------------------- |\n| Endpoint       | Endpoint | WorkloadEntry          |\n| Service        | Route    | VirtualService         |\n| kube-proxy     | Route    | DestinationRule        |\n| kube-proxy     | Listener | EnvoyFilter            |\n| Ingress        | Listener | Gateway                |\n| Service        | Cluster  | ServiceEntry           |\n\n## 核心观点\n\n- Kubernetes 的本质是应用生命周期管理，具体来说就是部署和管理（伸缩、自动恢复、发布）。\n- Kubernetes 为微服务提供了一个可扩展、高弹性的部署和管理平台。\n- 服务网格是基于透明代理，通过 sidecar 代理拦截服务之间的流量，然后通过控制平面配置管理它们的行为。\n- 服务网格将流量管理与 Kubernetes 解耦，不需要 kube-proxy 组件来支持服务网格内的流量；通过提供更接近微服务应用层的抽象来管理服务间的流量、安全性和可观测性。\n- xDS 是服务网格的协议标准之一。\n- 服务网格是 Kubernetes 中服务的一个更高层次的抽象。\n\n## 总结\n\n如果说 Kubernetes 管理的对象是一个 pod，那么服务网格管理的对象就是一个服务，所以用 Kubernetes 管理微服务，然后应用服务网格就可以了。如果你连服务都不想管理，那就用 [Knative](https:\/\/knative.dev\/) 这样的无服务器平台，不过这是后话。\n', '\/blog\/why-do-you-need-istio-when-you-already-have-kubernetes\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文将带大家了解 Kubernetes 和 Istio 的内部工作原理。此外，我会介绍 Kubernetes 中的负载均衡方法，并解释为什么有了 Kubernetes 后可能还需要 Istio。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/using-traefik-ingress-controller-with-istio-service-mesh/">[译] 在 Istio 服务网格中使用 Traefik Ingress Controller</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2021/04/01</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://thenewstack.io/using-traefik-ingress-controller-with-istio-service-mesh/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('在 Istio 服务网格中使用 Traefik Ingress Controller', '本文演示了如何将 Traefik Ingress 作为 Istio 服务网格的入口点。', '\nIstio 服务网格自带 ingress，但我们经常看到有要求使用非 Istio ingress 的客户。此前，我们已经介绍过[将 NGINX 与 Istio 集成](https:\/\/www.tetrate.io\/blog\/using-istio-with-other-ingress-proxies\/)的情况。最近，我们一直在与使用 [Traefik](https:\/\/traefik.io\/) ingress 的客户合作。通过对我们之前建议的方法进行一些轻微调整，我将向你介绍如何实现 Traefik 作为 Istio 服务网格的入口网关。\n\n流量的流向如下图所示。一旦请求从 Traefik Ingress 到达服务网格，Istio 就能够对请求应用安全性、可观测性和流量引导规则。\n\n![](008eGmZEly1gp4j5v18z8j31hc0u07ad.jpg)\n\n传入的流量绕过 Istio sidecar，直接到达 Traefik，所以请求终止在 Traefik ingress。\n\nTraefik 使用 \u0060IngressRoute\u0060 配置重写 Host 头以匹配目的地，并将请求转发到目标服务，这是一个多步骤的过程。\n\n- 从 Traefik Ingress 出来的请求被重定向到 Istio sidecar（由 iptables）。\n- Sidecar 接收请求，对其进行加密（因为我们的 Istio \u0060PeerAuthentication\u0060 策略要求使用 STRICT mTLS），然后将请求转发到目标服务的 pod。\n\n下面是一个端到端的部署示例，使用 Istio 的 bookinfo 演示应用，但用 Traefik ingress 来支撑整个部署。简而言之，要想在自己的环境中实现这个功能。\n\n- 用 Istio sidecar 部署 Traefik 控制器，注释部署，使入站流量绕过 Istio Sidecar:\n\n\u0060\u0060\u0060\n# Exclude the ports that Traefik receives traffic on\ntraffic.sidecar.istio.io\/excludeInboundPorts: “80” \n\n# Make sure Traefik controller can talk to the Kubernetes API server \n\ntraffic.sidecar.istio.io\/excludeOutboundIPRanges: X.X.X.X\/32 \n\u0060\u0060\u0060\n\n- 在应用程序命名空间中启用 Istio sidecar 注入，并部署任何你需要的 Istio 特定配置。\n- 用 Traefik \u0060Middleware\u0060 对象创建 \u0060IngressRoute\u0060，将主机名改写为网格识别的主机名（即集群中的服务；下文将通过一个例子详细讨论）。\n\n## 使用 Traefik Ingress 的 Bookinfo\n\n这篇文章的其余部分涵盖了部署 Istio 的 Bookinfo 示例应用程序，使用 Traefik 作为部署的 Ingress 代理。\n\n### 设置环境\n\n参考以下步骤。\n\n1. 部署一个至少 1.17 版本的 Kuberentes 集群（最小支持 Istio 1.8 版本）。我们使用 Google Kubernetes Engine 创建的集群。\n\n\u0060\u0060\u0060sh\ngcloud container clusters create istio-traefik \\\n  --cluster-version=1.17 \\\n  --region \u003cGCP region\u003e \\\n  --machine-type=e2-standard-4 \\\n  --project \u003cGCP Project\u003e \\\n  --num-nodes 1 \\\n  --node-locations \u003cGCP Zone\u003e # i.e us-west2-b (otherwise 1 node per zone)\n\u0060\u0060\u0060\n\n1. 下载 Istio 1.8\n\n\u0060\u0060\u0060sh\ncurl -sL https:\/\/git.io\/getLatestIstio |\\\nISTIO_VERSION=1.8.1 sh -\n\u0060\u0060\u0060\n\n1. 在启用 HTTP 访问日志的情况下进行安装。\n\n\u0060\u0060\u0060sh\n.\/istio-1.8.1\/bin\/istioctl install \\\n  --set meshConfig.accessLogFile=\/dev\/stdout \\\n  --skip-confirmation\n\u0060\u0060\u0060\n\n### 部署 Bookinfo 应用\n\n安装好 Istio 后，我们就可以开始部署我们的应用程序了。我们将使用 Istio 的 Bookinfo 应用程序进行演示。这个示例应用程序是 Istio 发行版的一部分（在\u0060.\/istio-1.8.1\/samples\/\u0060 文件夹中）。\n\n1. 创建 bookinfo namespace。\n\n\u0060\u0060\u0060sh\nkubectl create ns bookinfo\n\u0060\u0060\u0060\n\n1. 设置 label，让 sidecar 自动注入。\n\n\u0060\u0060\u0060sh\nkubectl label namespace bookinfo istio-injection=enabled\n\u0060\u0060\u0060\n\n1. 在该 namespace 中部署 bookinfo 应用程序。\n\n\u0060\u0060\u0060sh\nkubectl apply -f istio-1.8.1\/samples\/bookinfo\/platform\/kube\/bookinfo.yaml -n bookinfo\n\u0060\u0060\u0060\n\n确认所有的吊舱都已启动，并部署了侧车。\n\n启用 Istio mTLS 为应用程序命名空间的服务到服务通信。\n\n\u0060\u0060\u0060sh\ncat \u003c\u003cEOF | kubectl apply -f - \napiVersion: security.istio.io\/v1beta1\nkind: PeerAuthentication\nmetadata:\n  name: default\n  namespace: bookinfo\nspec:\n  mtls:\n    mode: STRICT\nEOF\n\u0060\u0060\u0060\n\n### 部署 Traefik 入口\n\n现在是时候按照 v2.3 文档来部署 Traefik 了（本篇文章中 Traefik 的最新版本是 2.3，但如果你根据你的版本调整了 \u0060IngressRoute\u0060 和 \u0060Middleware\u0060 资源，它将适用于任何版本的 Traefik）。\n\n1. 部署 Traefik。请注意，Traefik 网站上的文档部署有一些修改（代替 Traefik 文档中的默认命名空间，将指定 bookinfo 命名空间）。该文件可以在这里访问并应用如下。\n\n\u0060\u0060\u0060sh\n$ kubectl apply -f http:\/\/bit.ly\/Traefik-CRDs-and-Roles\ncustomresourcedefinition.apiextensions.k8s.io\/ingressroutes.traefik.containo.us created\ncustomresourcedefinition.apiextensions.k8s.io\/middlewares.traefik.containo.us created\ncustomresourcedefinition.apiextensions.k8s.io\/ingressroutetcps.traefik.containo.us created\ncustomresourcedefinition.apiextensions.k8s.io\/ingressrouteudps.traefik.containo.us created\ncustomresourcedefinition.apiextensions.k8s.io\/tlsoptions.traefik.containo.us created\ncustomresourcedefinition.apiextensions.k8s.io\/tlsstores.traefik.containo.us created\ncustomresourcedefinition.apiextensions.k8s.io\/traefikservices.traefik.containo.us created\nclusterrole.rbac.authorization.k8s.io\/traefik-ingress-lb created\nclusterrolebinding.rbac.authorization.k8s.io\/traefik-ingress-lb created\n\u0060\u0060\u0060\n\n1. 为传入的请求创建一个服务。该服务将接收外部 IP 地址。(Traefik 网站上的例子有一些变化)。\n\n- 需要指定 Namespace。\n- 只发布两个端口：80 用于 Bookinfo 应用，8080 用于 Traefik 管理。\n- 服务需要使用的标签（traefik-ingress-lb）指向 Traefik。\n- \u0060Type: Loadbalancer\u0060 是为了告诉 GCP 给服务分配一个外部 IP。\n\n\u0060\u0060\u0060sh\ncat \u003c\u003cEOF | kubectl apply -f - \napiVersion: v1\nkind: Service\nmetadata:\n  name: traefik\n  namespace: bookinfo\nspec:\n  ports:\n    - protocol: TCP\n      name: web\n      port: 80\n    - protocol: TCP\n      name: admin\n      port: 8080\n  selector:\n    app: traefik-ingress-lb\n  type: LoadBalancer\nEOF\n\u0060\u0060\u0060\n\n1. 确认服务的创建符合预期。\n\n\u0060\u0060\u0060sh\n$ kubectl get svc traefik -n bookinfo\nNAME      TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)                       AGE\ntraefik   LoadBalancer   10.35.244.227   35.236.XXX.XXX   80:31718\/TCP,8080:31334\/TCP   2m6s\n\u0060\u0060\u0060\n\n1. 正如 [Traefik 网站](https:\/\/doc.traefik.io\/traefik\/user-guides\/crd-acme\/)中介绍的，需要应用 \u0060ServiceAccount\u0060 的 Kubernetes 部署。除了名称和命名空间，网站示例还引入了以下变化。\n\n- 为了简单起见，删除了安全端点。\n  - \u0060Accesslog\u0060：增加了 \u0060=true\u0060，因为没有这个值就不行。\n  - \u0060Log.level\u0060 设置为 DEBUG 将帮助我们看到发生了什么。\n  - 增加了 \u0060traffic.sidecar.istio.io\u0060 注释（更多细节请参考之前提到的 Tetrate [NGINX 文章](https:\/\/www.tetrate.io\/blog\/using-istio-with-other-ingress-proxies\/)）。\n\n\u0060\u0060\u0060sh\nKUBERNETES_SVC_IP=$( kubectl get svc kubernetes -n default -o jsonpath=\u0027{.spec.clusterIP}\u0027 )\n \ncat \u003c\u003cEOF | kubectl apply -f - \napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  namespace: bookinfo\n  name: traefik-ingress-lb\n \n---\nkind: Deployment\napiVersion: apps\/v1\nmetadata:\n  namespace: bookinfo\n  name: traefik-ingress-lb\n  labels:\n    app: traefik-ingress-lb\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: traefik-ingress-lb\n  template:\n    metadata:\n      labels:\n        app: traefik-ingress-lb\n      annotations:\n        traffic.sidecar.istio.io\/excludeInboundPorts: \u002280\u0022\n        traffic.sidecar.istio.io\/excludeOutboundIPRanges: ${KUBERNETES_SVC_IP}\/32\n    spec:\n      serviceAccountName: traefik-ingress-lb\n      containers:\n        - name: traefik-ingress-lb\n          image: traefik:v2.3\n          args:\n            - --api.insecure\n            - --accesslog=true\n            - --providers.kubernetescrd\n            - --entrypoints.web.address=:80\n            - --log.level=DEBUG\n          ports:\n            - name: web\n              containerPort: 80\n            - name: admin\n              containerPort: 8080\nEOF\n\u0060\u0060\u0060\n\n1. 确认 Traefik 在 Bookinfo 命名空间的部署。\n\n\u0060\u0060\u0060\n$  kubectl get pods -n bookinfo -l app=traefik-ingress-lb\nNAME                                  READY   STATUS    RESTARTS   AGE\ntraefik-ingress-lb-669fc4b77d-74mpx   2\/2     Running   0          2m35s\n\u0060\u0060\u0060\n\n1. 获取服务 IP 并记录 BOOKINFO_IP 变量值。\n\n\u0060\u0060\u0060\nBOOKINFO_IP=$(kubectl -n bookinfo get service traefik -o jsonpath=\u0027{.status.loadBalancer.ingress[0].ip}\u0027)\n\u0060\u0060\u0060\n\n1. 测试来自 Ingress 80 端口的响应，看看它是否有通往应用的路由。\n\n\u0060\u0060\u0060sh\ncurl -I $BOOKINFO_IP\n\u0060\u0060\u0060\n\n确保它返回“404 Not Found”—— 由于尚未实施 Ingress 规则，所以预计会有 not-200 响应。\n\n### 配置 Traefik Ingress 规则\n\n1. Traefik 的 \u0060Middleware\u0060 头重写功能将使 Istio 服务网格正常运行。本例中，需要将主机定义为 \u0060productpage.bookinfo.svc\u0060。头可以根据 Traefik 文档来定义。\n\n\u0060\u0060\u0060sh\ncat \u003c\u003cEOF | kubectl apply -f - \napiVersion: traefik.containo.us\/v1alpha1\nkind: Middleware\nmetadata:\n  name: productpage-header\n  namespace: bookinfo\nspec:\n  headers:\n    customRequestHeaders:\n      Host: productpage.bookinfo.svc\nEOF\n\u0060\u0060\u0060\n\n1. 最后一步是指定 ingress 请求的路由逻辑，因为本文的重点是服务网格集成。这个定义非常简单，将所有到达 80 端口的入站请求转发到名为 ProductPage 的前沿 bookinfo 应用服务（服务于 9080 端口的流量）。它还使用了上一步创建的中间件对象。\n\n\u0060\u0060\u0060sh\ncat \u003c\u003cEOF | kubectl apply -f - \napiVersion: traefik.containo.us\/v1alpha1\nkind: IngressRoute\nmetadata:\n  name: productpage\n  namespace: bookinfo\nspec:\n  entryPoints:\n    - web\n  routes:\n  - match: PathPrefix(\u0060\/\u0060)\n    kind: Rule\n    middlewares:\n    - name: productpage-header\n    services:\n    - name: productpage\n      port: 9080\nEOF\n\u0060\u0060\u0060\n\n### 验证部署功能\n\n1. 重新测试应用程序的响应。\n\n\u0060\u0060\u0060sh\ncurl -I $BOOKINFO_IP\n\u0060\u0060\u0060\n\n我们会收到“200 OK“的回复。也可以通过浏览器测试，使用 \u0060http:\/\/\u003cBOOKINFO_IP\u003e\/productpage\u0060。\n\n1. 如果在 \u0060http:\/\/\u003cBOOKINFO_IP\u003e\/productpage\u0060，就会返回应用响应。\n\n![](008eGmZEly1gp4jrzhuugj30iq0aqaam.jpg)\n\n1. 通过查询 istio-proxy 容器的 bookinfo 命名空间中的 Traefik pod 日志，可以在 istio-proxy 日志中看到向应用程序发出的请求。没有传入请求，因为它们直接到达 Traefik Ingress。\n\n\u0060\u0060\u0060sh\nTRAEFIK_POD=$( kubectl -n bookinfo get pods -l app=traefik-ingress-lb -o jsonpath=\u0027{.items[0].metadata.name}\u0027 )\nkubectl -n bookinfo logs ${TRAEFIK_POD} -c istio-proxy\n\u0060\u0060\u0060\n\n请注意，请求处理后，日志需要几秒钟才能显示。只有在 Istio 安装时使用 \u0060meshConfig.accessLogFile=\/dev\/stdout\u0060 标志的情况下，才会显示日志。\n\n\u0060\u0060\u0060ini\n[2021-01-05T20:13:55.015Z] \u0022GET \/productpage HTTP\/1.1\u0022 200 - \u0022-\u0022 0 5179 1069 1069 \u002210.32.0.1\u0022 \u0022Mozilla\/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit\/537.36 (KHTML, like Gecko) Chrome\/87.0.4280.88 Safari\/537.36\u0022 \u00224bd443e9-1a2e-4d30-b1e3-398a5005f240\u0022 \u0022productpage.bookinfo.svc\u0022 \u002210.32.0.18:9080\u0022 outbound|9080||productpage.bookinfo.svc.cluster.local 10.32.0.19:51810 10.32.0.18:9080 10.32.0.1:0 - default\n[2021-01-05T20:13:56.301Z] \u0022GET \/static\/bootstrap\/fonts\/glyphicons-halflings-regular.woff2 HTTP\/1.1\u0022 200 - \u0022-\u0022 0 18028 3 3 \u002210.32.0.1\u0022 \u0022Mozilla\/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit\/537.36 (KHTML, like Gecko) Chrome\/87.0.4280.88 Safari\/537.36\u0022 \u00228cb44552-c3c8-45dd-8674-4af207ce1648\u0022 \u0022productpage.bookinfo.svc\u0022 \u002210.32.0.18:9080\u0022 outbound|9080||productpage.bookinfo.svc.cluster.local 10.32.0.19:51810 10.32.0.18:9080 10.32.0.1:0 - default\n\u0060\u0060\u0060\n\n## 总结\n\n本文演示了如何将 Traefik Ingress 作为 Istio 服务网格的入口点。这里应用的基本方法应该是适用的，即使你的环境与我们例子中使用的环境不同。当引入服务网格时，Traefik \/ 服务网格集成可以在不同的云中成功实施，并使用全新或现有（也就是棕地）部署 Traefik。最终，您将获得两者最好的东西：Istio 服务网格与您所选择的 Ingress 控制器相集成！\n', '\/trans\/using-traefik-ingress-controller-with-istio-service-mesh\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文演示了如何将 Traefik Ingress 作为 Istio 服务网格的入口点。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/multi-cluster-service-mesh/">[译] 是否选择多集群——使用服务网格的集群间通信</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2021/03/31</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://www.infoq.com/articles/kubernetes-multicluster-comms/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('是否选择多集群——使用服务网格的集群间通信', '是否该使用服务网格构建多集群？本文会给你答案。', '\n本文翻译自 [To Multicluster, or Not to Multicluster: Inter-Cluster Communication Using a Service Mesh](https:\/\/www.infoq.com\/articles\/kubernetes-multicluster-comms\/)。Istio 服务网格是解决 Kubernetes 集群间通信的一个关键，虽然翻译这篇文章距离原文发表也有快 2 年时间了，但是其中的很多观点仍不过时。\n\n## 主要观点\n\n- Kubernetes 已经成为容器编排的事实标准，许多组织都运行着多个集群。集群内的通信是一个解决了的问题，但是跨集群的通信需要更多的设计和操作开销。\n- 在决定是否实施多集群支持之前，你应该了解你的通信用例。\n- 你还应该确定你想要从解决方案中获得什么（单一界面的观察性、统一信任域等），然后制定一个关于如何实现这些的计划。\n- 有几种多集群服务网格方法，如共同管理、集群感知服务通过网关路由、扁平网络和 split-horizon 端点发现服务（EDS）。\n- Istio 有现有的多集群支持，在 1.1 中还有额外的新功能，甚至未来还会有更多的功能出现。\n\nKubernetes 已经成为企业中容器编排的事实标准。这是有充分理由的 —— 它提供了一系列功能，使管理容器化应用变得更加容易。Kubernetes 也带来了一些新的挑战，一个主要的挑战就是需要部署和管理多个 Kubernetes 集群，以便有效地管理大规模分布式系统。\n\n想象一下，你已经设计和编码了一个应用，并且你已经构建了容器 —— 你只需要运行它们。从代码到运行应用是令人振奋的，但正如任何构建了容器化应用的人所知道的那样，它并不像乍看起来那样简单。在部署到生产之前，有各种开发 \/ 测试 \/ 阶段周期。此外，还有一个扩展方面的问题 —— 你的生产应用可能需要在许多不同的地方运行，原因包括水平扩展性、弹性或接近最终用户。\n\n## 环境越多，（集群）问题越多\n\n即使是一个简单的绿地应用概念，最终也需要多个部署环境。如果你正在迁移一个现有的应用，你一定会遇到更多的挑战，比如不同的安全域，不同的组织 \/ 计费，以及对一个云供应商的机器学习工具包的亲和力。\n\n解决这个问题最常见的方法是创建多个 Kubernetes 集群，每个集群都致力于在其特定环境中运行你的应用组件。在高安全领域，你将广泛使用基于角色的访问控制（RBAC），并具有审计功能。测试环境应该重现很多生产行为，但要为便于调试和检查而定制。对于你的开发环境…… 好吧，也许你像我一样，你就打开 Docker 偏好设置，然后勾选 Kubernetes 框。易用性和短暂性是常态。\n\n你很可能最终会有多个 Kubernetes 集群，每个集群都会托管微服务。集群中这些微服务之间的通信可以通过服务网格来加强。在集群内部，Istio 提供了通用的通信模式来提高弹性、安全性和可观测性。那么集群之间和跨集群呢？\n\n运行多个 Kubernetes 集群并不一定可怕，但运行多个集群确实需要你考虑它们如何通信和交互，以便轻松交付运行在上面的优秀应用。像 Istio 这样的服务网格可以让多集群通信变得毫无痛苦。Istio 拥有多集群支持，在 1.1 中增加了新功能，并计划在未来增加更多的功能。团队也应该考虑采用服务网格来简化跨多个集群的通信。\n\n## 常见的使用案例\n\n运行多集群服务网格最常见的是这些用户需求。\n\n- 由于我的组织规模，我有多个集群，我想在一个地方查看和管理它们。我的集群一般不做集群间的流量，或者当它们做的时候，是通过定义好的 API。\n- 我有多个集群以实现高可用性，它们是彼此的克隆，如果一个集群发生故障，另一个集群可以接管，这一点非常重要。\n- 我有多个集群，它们组合成一个更高级别的应用。其中一个集群中的微服务需要与另一个集群中的微服务进行通信，以提供适当的端到端应用体验。\n\n第三类多集群需要集群间的流量。如果你想要集群间流量支持，你的实现将取决于集群之间的网络，以及你对容错的要求。\n\n### 你能从多集群中得到什么？\n\n当你考虑多集群和服务网格时，你应该从确定你想要什么开始，然后转移到如何获得它。\n\n### 单一界面\n\n你的多个服务网格从一个地方操作。你可以在一个单一的接口中查看所有集群的配置、指标和跟踪。\n\n### 统一信任域\n\n你使用服务网格来提供工作负载识别，并由强大的 mTLS 加密保护。这种零信任模型比基于源 IP 等拓扑信息来信任工作负载更好：你依靠的是它们是什么的加密证明，而不是脆弱的外围堆栈来控制它们的来源。\n\n统一的信任域意味着所有的工作负载都可以通过绑定到一个共同的信任根来相互认证（它们是什么）。服务网格控制平面都是为这个共同的信任根配置的，无论这些平面有一个还是几个。\n\n### 独立的故障域\n\n一个不依赖其他集群和相关基础设施，本身就可以正常运行的集群是一个独立的故障域。我是把服务网格列为相关基础设施 —— 如果你要安装服务网格，你是为了把通信弹性转移到应用下面的基础设施层。如果一个集群中的服务网格的故障可以破坏另一个集群中的服务网格，那么它就不能算是一个独立的故障域。\n\n### 集群间的流量\n\n如果你想让一个集群中的服务与另一个集群中的服务直接通信，并且你想让这种通信具有服务网格的好处，如高级路由、可观测性或透明加密，那么你需要集群之间的流量保持为服务网格的一部分。换句话说，你希望你的东\/西流量离开一个集群，中转一些中间网络，比如互联网，然后进入另一个集群。\n\n这可能是大多数人在考虑多集群服务网格时的第一想法，但我在这里单独把它列出来，因为它对容错有影响。\n\n### 异构\/非扁平化的网络\n\n非平面网络支持跨多个集群的服务，没有平面网络的要求。这意味着你可以做一些事情，比如在一个网格中分配 IP，而不考虑另一个网格，你不需要 VPN 或网络隧道来进行跨网格的通信。\n\n如果你的组织已经创建了一堆不同的集群，而没有冲突的 pod IP 地址范围，或者你只是永远不想再进入这种泥潭，这将是一个对你有吸引力的属性。\n\n## 多集群服务网格方法\n\n在阐述了你可能需要从多集群中寻找的不同属性之后，我可以介绍一下各种方法所带来的好处。\n\n### 独立集群\n\n这就是解多集群。仅仅因为你有多个集群，而且每个集群都使用一个服务网格，并不意味着你必须采用统一的多集群服务网格。扪心自问，你当初为什么会有多个集群。如果你希望每个集群都是自己独立的故障域，那么隔离和消除跨集群的依赖关系是有意义的。如果这能满足你的需求，那么把服务网格当作另一个单集群的服务，比如 pod 调度或持久性磁盘管理，也没有什么坏处。\n\n### 共同管理\n\n在独立集群方法之上的下一步是多个集群的共同管理系统。在这种模式下，每个集群都是独立运行的，但你通过一个共同的管理界面来管理这套网格。让你用来监控和调试系统（或者，在这种情况下，系统）的东西驻留在系统本身之外是一个很好的设计，这样当系统坏了的时候，你仍然可以检查和修复它。\n\n如果你选择在这些集群中使用一个共同的信任根（证书授权或签名证书），那么你也可以拥有一个统一的信任域。\n\n如果独立的故障域是首要任务，那么这是一个不错的选择。这种选择很适合将软件作为服务来消费，因为你可以得到一个外部的接口来统一一切，并得到服务级别协议的支持。\n\n### 通过网关进行集群感知的服务路由选择\n\nIstio 中的这种方法涉及多个独立的服务网格，每个集群中一个，以及一些配置技巧，以允许一个集群中的服务与另一个集群中的服务通信。首先，你要为所有网格创建一个统一的信任域。接下来，你配置一个入口网关，以接受来自另一个对等集群中的服务的可信流量。最后，配置服务条目，以允许某些服务的流量从一个集群路由出来并发送到另一个集群。\n\n这是第一种允许不同集群中的服务直接相互通信的方法。同时，每个集群仍然是一个独立的网格控制平面和故障域。这意味着，如果集群 B 中的服务网格发生故障，集群 A 仍然可以工作，只是看起来集群 B 中的服务不可用。配置这种跨集群流量的负担就落在了用户身上。\n\n### 扁平网络\n\n这种模式决定了你所有集群的服务网格。你安排它，使每个集群中的 pod 具有非重叠的 IP 地址，因此任何 pod 可以将流量路由到任何集群中的其他 pod。你可能在一个共同的防火墙后面有一堆集群，或者你可能在集群间建立 VPN 隧道。你配置服务网格，以将发现的 pod、服务和来自每个集群的配置结合到一个整体视图中。\n\n扁平化的网络使它看起来就像你有一个超级服务网格，横跨你的所有集群。也有一些缺点。这个超级服务网格由一个控制平面管理，所以如果它出现问题，所有集群的服务网格都会出现问题。如果你原来为了容错而划分成多个 Kubernetes 集群，这种方式就否定了这一点。另外一个考虑是控制平面必须要扩展来管理所有集群。而且你必须让这个扁平网络的性能足够好，以处理控制平面和跨集群的流量。\n\n### 分割区域端点发现服务（EDS）\n\n这种方法也可以在集群间创建一个服务网格，但不需要扁平网络。你仍然有一个控制平面，可以从每个集群中发现 pod、服务和配置，但 Istio 的 EDS，其功能类似于分裂水平 DNS，取代了对扁平网络的要求。\n\n一个集群中的 pod 的 sidecar 被配置了它想要通信的每个服务的端点列表。如果 pod 在同一个集群中，它就会直接显示在 EDS 列表中。如果 pod 在另一个集群中，则会出现另一个集群的入口网关。pod 选择一个端点进行对话并发送流量 —— 如果端点是本地的，则通信是直接的 pod 到 pod。如果 pod 选择了一个远程端点，它就会将流量发送到相关入口网关的地址，并标记为 pod 想要访问的服务。入口网关接收流量，并将其发送到其集群中实现服务的 pod 之一。入口网关使用服务器名称指示（SNI）来了解流量的目的地。\n\n与扁平网络方式一样，这种方式创建了一个统一的服务网格控制平面，并增加了一个单一故障域和单一信任域。它不需要扁平网络，只需要一个集群可以将流量发送到其他集群的入口网关的公共地址。\n\n## 要不要多集群？\n\n如果你出于开发和组织的原因要运行多个集群，那么了解你的需求并决定是否要在多集群环境中连接这些需求是很重要的，如果是这样，了解各种方法和每个选项的相关权衡。\n\n如果你已经读到这里，你可能已经决定了多集群。真正的问题是什么是最好的实现方法。希望下面的表格能帮助你决定适合你的方法。\n\n| 方法                               | 统一管理 | 统一信任 | 异构网络 | 独立故障域 | 跨集群通信 |\n| ---------------------------------- | -------- | -------- | -------- | ---------- | ---------- |\n| 独立集群                           |          |          | √        |            |            |\n| 共同管理                           | √        |          | √        | √          |            |\n| 扁平网络                           | √        | √        |          |            | √          |\n| 分割区域端点发现服务（EDS）        | √        | √        | √        |            | √          |\n| 通过网关进行集群感知的服务路由选择 |          | √        | √        | √          | √          |\n\n像 Istio 这样的服务网格可以提供帮助，如果使用得当，可以让多集群通信变得不痛苦。如果你想了解更多关于我对为什么以及团队应该如何考虑采用服务网格来简化跨多个集群的通信的看法。\n\n## 关于作者\n\nAndrew Jenkins 是 Aspen Mesh 的首席技术官，他正在构建一个企业服务网格，以帮助企业减轻管理微服务的负担。作为容器环境（如 Kubernetes）的软件和网络架构师，Jenkins 曾担任技术领导，推动快速发展的团队取得切实成果。他的专长包括 C\u002b\u002b、JavaScript（Node.js）、Python、C、Go 和 Java 的软件开发。Jenkins 还在软件和硬件测试、FPGA 和空间科学仪器的电路板设计方面拥有丰富的经验。\n', '\/trans\/multi-cluster-service-mesh\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">是否该使用服务网格构建多集群？本文会给你答案。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
          <div class="col-12">
 
 
 
 
 
 
 
 
 
 
 
 <nav aria-label="Page navigation">
   <ul class="pagination justify-content-center">
     
     
     <li class="page-item">
       <a class="page-link" href="/blog/">
         ««
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a href="/blog/page/19/" class="page-link">
         «
       </a>
     </li>
     
     
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item">
           <a href="/blog/page/18/" class="page-link">
             18
           </a>
         </li>
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item">
           <a href="/blog/page/19/" class="page-link">
             19
           </a>
         </li>
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item page-item active ">
           <a href="/blog/page/20/" class="page-link">
             20
           </a>
         </li>
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item">
           <a href="/blog/page/21/" class="page-link">
             21
           </a>
         </li>
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item">
           <a href="/blog/page/22/" class="page-link">
             22
           </a>
         </li>
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
     
     
     <li class="page-item">
       <a href="/blog/page/21/" class="page-link">
         »
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a class="page-link" href="/blog/page/26/">
         »»
       </a>
     </li>
     
   </ul>
 </nav>
 
</div>

        </div>
      </div>
      <!-- sidebar -->
      <aside class="col-lg-4 order-1 order-lg-2 d-none d-sm-block">
          <div class="sidebar">
          <!-- categories -->
<div class="blog-categories mb-4">
  <p class="sidebar-title">
      专栏
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/istio" class="sidebar-item">
            <span>Istio</span>
            <span>(71)</span>
        </a>
      
        <a href="/categories/service-mesh" class="sidebar-item">
            <span>Service Mesh</span>
            <span>(41)</span>
        </a>
      
        <a href="/categories/kubernetes" class="sidebar-item">
            <span>Kubernetes</span>
            <span>(24)</span>
        </a>
      
        <a href="/categories/%e9%9a%8f%e7%ac%94" class="sidebar-item">
            <span>随笔</span>
            <span>(21)</span>
        </a>
      
        <a href="/categories/%e4%b8%9a%e6%80%81" class="sidebar-item">
            <span>业态</span>
            <span>(17)</span>
        </a>
      
        <a href="/categories/%e5%85%b6%e4%bb%96" class="sidebar-item">
            <span>其他</span>
            <span>(17)</span>
        </a>
      
        <a href="/categories/envoy" class="sidebar-item">
            <span>Envoy</span>
            <span>(16)</span>
        </a>
      
        <a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f" class="sidebar-item">
            <span>云原生</span>
            <span>(14)</span>
        </a>
      
        <a href="/categories/ai" class="sidebar-item">
            <span>AI</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%ae%89%e5%85%a8" class="sidebar-item">
            <span>安全</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%bc%80%e6%ba%90" class="sidebar-item">
            <span>开源</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%8f%af%e8%a7%82%e6%b5%8b%e6%80%a7" class="sidebar-item">
            <span>可观测性</span>
            <span>(5)</span>
        </a>
      
        <a href="/categories/%e6%97%85%e8%a1%8c" class="sidebar-item">
            <span>旅行</span>
            <span>(5)</span>
        </a>
  </div>
</div>

<div class="blog-categories mb-4">
  <p class="sidebar-title">
      资料
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/%e5%87%ba%e7%89%88%e7%89%a9" class="sidebar-item">
            <span>出版物</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e7%94%b5%e5%ad%90%e4%b9%a6" class="sidebar-item">
            <span>翻译电子书</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e6%96%87%e6%a1%a3" class="sidebar-item">
            <span>翻译文档</span>
            <span>(7)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>翻译图书</span>
            <span>(6)</span>
        </a>
      
        <a href="/categories/%e5%8e%9f%e5%88%9b%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>原创图书</span>
            <span>(2)</span>
        </a>
      
        <a href="/categories/%e6%95%99%e7%a8%8b%e6%89%8b%e5%86%8c" class="sidebar-item">
            <span>教程手册</span>
            <span>(1)</span>
        </a>
  </div>
</div>





          </div>
      </aside>
      <!-- /sidebar -->
    </div>
  </div>
</section>




<footer>
  
  <div class="footer bg-footer section-sm border-bottom overlay ">
    <div class="container-xl">
      <div class="row">
        <div class="col col-xl-4 d-sm-none mb-2 mb-lg-0 d-xl-block d-none">
          
          <p class="h3 text-white mb-4 text-uppercase">联系</p>
          
          <ul class="list-unstyled">
            
            
            <li class="mb-4 text-color">微信公众号</li>
            
            
            <li class="mb-4"><img src="/images/servicemesher-wechat.webp" width="118px" height="118px" alt="footer image"></li>
            
            
            
          
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">博客</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/blog/service-mesh-data-plane-deployment-modes/">深入解析服务网格的四种数据平面部署模式：性能、安全性与成本分析</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/service-mesh-sidecar-vs-sidecarless-debate/">服务网格架构：Sidecar vs. Sidecarless，谁才是未来？</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/hong-kong-trip/">香港——内地的一面的镜子</a></li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">链接</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://istio.io/latest/zh/" target="_blank" rel="noopener noreferrer">
                  Istio 服务网格
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://tetrate.io/?jimmysong" target="_blank" rel="noopener noreferrer">
                  Tetrate 公司
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener noreferrer">
                  云原生学院|Bilibili
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/awesome-cloud-native/" target="_blank" rel="noopener noreferrer">
                  云原生开源项目大全
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://cloudnative.to" target="_blank" rel="noopener noreferrer">
                  云原生社区（中国）
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">教程</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/envoy-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Envoy 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/istio-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Istio 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/kubernetes-handbook/" >
                  Kubernetes 基础教程
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">通知</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/notice/nist-sp-800-233-service-mesh-proxy-models/">资料分享：云原生应用服务网格代理模型的威胁分析指南</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/kubecon-china-2024-panel/">KubeCon China 2024（香港）</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/website-revamp-notice/">网站改版通知</a></li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>

  
  <div class="copyright py-4 bg-footer overlay">
    <div class="container-xl">
      <div class="row">
        <div class="col-sm-6 text-sm-left text-center">
          <p class="mb-0 text-color">© 2017-2024 Jimmy Song 保留所有权利</p>
        </div>
        <div class="col-sm-6 text-sm-right text-center">
          <ul class="list-inline">
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://twitter.com/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-x-twitter text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/contact/" >
                    <i class="fa-brands fa-weixin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://github.com/rootsongjc" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-github text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://linkedin.com/in/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-linkedin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="mailto:rootsongjc@gmail.com" >
                    <i class="fa-solid fa-envelope text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/blog/index.xml" >
                    <i class="fa-solid fa-rss text-white"></i>
              </a>
            </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>


<!-- JS Plugins -->

<script src="/plugins/popper/popper.min.js"></script>

<script src="/plugins/bootstrap/bootstrap.min.js"></script>

<script src="/plugins/slick/slick.min.js"></script>

<script src="/plugins/filterizr/jquery.filterizr.min.js"></script>

<script src="/plugins/search/fuse.min.js"></script>

<script src="/plugins/search/mark.js"></script>

<script src="/plugins/hex_md5/hex_md5.js"></script>

<script src="/plugins/anchor/anchor.min.js"></script>

<script src="/plugins/tocbot/tocbot.min.js"></script>

<script src="/plugins/bigger-picture/bigger-picture.min.js"></script>


<!-- Main Script -->

<script src="/js/script.min.f94c22b1d478bfc9e2e0a7d954429e47b7e6d36edd423758482e04154ae1842e.js"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-ESY906ZWZ0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ESY906ZWZ0');
</script>


<!-- Baidu analysis -->
<meta name="baidu-site-verification" content="g8IYR9SNLF" />


<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?11f7d254cfa4e0ca44b175c66d379ecc";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>




<script>
    anchors.add();
</script>






<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>










<script src="/js/wowchemy-search.min.7a37268e7bbe4a9160c2e4c33b749816.js" type="module"></script>
<script id="search-hit-fuse-template" type="text/x-template">
  <div class="search-hit" id="summary-{{key}}">
    <div class="search-hit-content border-bottom">
      <div class="search-hit-name">
        <div class='search-hit-link'><a href="{{relpermalink}}">{{title}}</a></div>
        <div class="search-hit-metadata d-flex">
            <span class="mr-1"><i class="fa-regular fa-calendar mr-1"></i>{{date}}</span>
            <span class="mr-1"><i class="fa-regular fa-folder-open mr-1"></i>{{section}}</span>
            <span class="d-sm-block d-none"><i class="fa-solid fa-link mr-1"></i>{{relpermalink}}</span>
        </div>
        <div class="search-hit-description">{{snippet}}</div>
      </div>
    </div>
  </div>
</script>



    </body>
</html>
