<!DOCTYPE html>
<html lang="zh"><head>
  <meta charset="utf-8">
  
  <title>博客 - Jimmy Song</title>
  

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta name="description" content="专注开源技术、云原生与生活随笔的分享与思考。">
  <meta name="author" content="Jimmy Song">
  <meta name="generator" content="Hugo 0.136.0">

  <!-- CSS plugins -->
  
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
  
  <link rel="preload" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" as="style">
  <link rel="stylesheet" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" media="screen">
  

  <!-- Main Stylesheet -->
  
  <link rel="preload" href="/scss/style.min.784204edcd29c092198e88494fa2ae755eba9ae231d6fa7faf8e7da3207b4623.css" as="style">
  <link rel="stylesheet" href="/scss/style.min.784204edcd29c092198e88494fa2ae755eba9ae231d6fa7faf8e7da3207b4623.css" media="screen">

  <!-- Bigger picture css -->
  
  <link rel="stylesheet" href="/plugins/bigger-picture/bigger-picture.min.css" media="print" onload="this.media='all'">
  <!--Favicon generate by https://realfavicongenerator.net-->
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="200x200" href="/images/favicon.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">

  <link href='/opensearchdescription.xml' rel='search' title='Content search' type='application/opensearchdescription+xml'/>

  <!--Twitter card-->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="jimmysong.io" />
  <meta name="twitter:creator" content="@jimmysongio" />
  <meta property="og:url" content="https://jimmysong.io/blog/" />
  <meta property="og:title" content="博客 | Jimmy Song" />
  <meta property="twitter:title" content="博客 | Jimmy Song" />

  
  <meta property="og:description" content="专注开源技术、云原生与生活随笔的分享与思考。" />
  <meta property="twitter:description" content="专注开源技术、云原生与生活随笔的分享与思考。" />

  
  <meta property="og:image" content="https://jimmysong.io/images/banner/default.jpg" />
  <meta property="twitter:image" content="https://jimmysong.io/images/banner/default.jpg" />

  
  
</head>
<body>
<header class="fixed-top header">
  
  
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa fa-arrow-circle-up" aria-hidden="true"></i></button>
  
  <div class="navigation w-100 ">
    <div class="container-xl">
      <nav class="navbar navbar-expand-lg navbar-light p-0">
        <a class="navbar-brand" href="/">
            
            <b>JIMMY SONG</b>
            
        </a>
        <button class="navbar-toggler rounded-0" type="button" data-toggle="collapse" data-target="#navigation"
          aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse text-center" id="navigation">
          <ul class="navbar-nav ml-auto">
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/blog">博客</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/book">资料</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/tags">标签</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/notice">公告</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/contact">联系</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/about">关于</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/community/">社区</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener">视频 <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i></a>
              
            </li>
            
            

          
          
          <li class="nav-item">
            
            
            
              
              
                
                
                
                  
                    
                    <a class="nav-link" href="/en/blog/">English</a>
                    
                  
                
              
              
              
                
                  
                    
                    
                  
                
                
                
              
          </li>
          
          
          <!-- search -->
           <button type="button" class="search-btn js-search" id="searchOpen" aria-label="Search">
              <div class="search-container d-flex justify-content-center">
              <span class="search-content">
                  <i class="fa fa-search"></i>
                  <span>搜索</span>
              </span>
              <span class="search-shortcuts d-none d-sm-block">
                  <kbd class="cmd-key">⌘</kbd>
                  <kbd class="k-key">K</kbd>
              </span>
              </div>
          </button>
          
          </ul>
        </div>
      </nav>
    </div>
  </div>
</header>


            <aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between">
        <div class="col-6 search-title">
          <p>站内搜索</p> 
        </div>
        <div class="col-6 col-search-close">
          <div class="js-search" aria-label="关闭"><i class="fa-solid fa-circle-xmark text-muted" aria-hidden="true"></i></div>
        </div>
      </div>

      <div id="search-box">
        <i class="fa-solid fa-magnifying-glass" id="search-icon" aria-hidden="true"></i>
        <input name="q" id="search-query" placeholder="请输入搜索词" autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control" aria-label="请输入搜索词">
        
        <div class="mt-4">
          <span>搜索类型: </span>
          <span>
            <input type="radio" id="all" name="search_type" value="all" checked>
            <label for="all">所有</label>
            
              <input type="radio" id="blog" name="search_type" value="blog">
              <label for="blog">原创</label>
              <input type="radio" id="trans" name="search_type" value="trans">
              <label for="trans">译文</label>
            
            <input type="radio" id="book" name="search_type" value="book">
            <label for="book">资料</label>
            <input type="radio" id="notice" name="search_type" value="notice">
            <label for="notice">公告</label>
          </span>
        </div>
      </div>
      
    </section>
    <section class="section-search-results">
      <div id="search-results-count" class="search-results-count"></div>
      <div id="search-hits">
        
      </div>
    </section>
  </div>
</aside>

        
        
            

<section class="bg-cover page-title-section overlay" style="background-image: url('/images/backgrounds/circle.svg'),url('/images/backgrounds/page-title.webp');background-size: cover;">
    <div class="container-xl">
        <div class="row">
            <div class="col-12">
                <p class="h1">
                    博客
                </p>
                <p class="page-description">
                    专注开源技术、云原生与生活随笔的分享与思考。
                </p>
                
            </div>
        </div>
    </div>
</section>

        


<section class="section-sm book-list-section bg-gray">
  <div class="container-xl">
    <div class="row">
      <div class="col-lg-8 order-2 order-lg-1">
        <div class="row">
          
          
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/grpc-proxyless-service-mesh/">[译] 基于 gRPC 和 Istio 的无 sidecar 代理的服务网格</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2021/11/23</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://istio.io/latest/blog/2021/proxyless-grpc/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('基于 gRPC 和 Istio 的无 sidecar 代理的服务网格', '本文介绍了 Istio 对 gRPC 的无代理服务网格功能的支持。', '\n译者注：本文译自 Istio 官方博客，博客原标题 [gRPC Proxyless Service Mesh](https:\/\/istio.io\/latest\/blog\/2021\/proxyless-grpc\/)，其实是 Istio 1.11 版本中支持的实验特性，可以直接将 gRPC 服务添加到 Istio 中，而不需要再向 Pod 中注入 Envoy 代理。本文中还给出了一个 Demo 性能测试数据，这种做法可以极大的提升应用性能，降低网络延迟。\n\n------\n\nIstio 使用一组发现 API（统称为 [xDS API](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/intro\/arch_overview\/operations\/dynamic_configuration) 来动态配置其 Envoy sidecar 代理。这些 API 的目标是成为一个 [通用的数据平面 API](https:\/\/blog.envoyproxy.io\/the-universal-data-plane-api-d15cec7a?gi=64aa2eea0283)。gRPC 项目对 xDS API 有很好的支持，也就是说你可以管理 gRPC 工作负载，而不需要同时部署 Envoy sidecar。你可以在 [Megan Yahya 的 KubeCon EU 2021 演讲](https:\/\/www.youtube.com\/watch?v=cGJXkZ7jiDk)中了解更多关于该集成的信息。关于 gRPC 支持的最新情况，可以在他们的[提案](https:\/\/github.com\/grpc\/proposal\/search?q=xds)中找到，还有实现状态。\n\nIstio 1.11 增加了实验性支持，可以直接将 gRPC 服务添加到网格中。我们支持基本的服务发现，一些基于 VirtualService 的流量策略，以及双向 TLS。\n\n## 支持的功能\n\n与 Envoy 相比，目前 gRPC 内的 xDS API 的实现在某些方面是有限的。以下功能应该可以使用，尽管这不是一个详尽的列表，其他功能可能部分可用。\n\n- 基本的服务发现。你的 gRPC 服务可以接触到在网格中注册的其他 pod 和虚拟机。\n- \u0060DestinationRule\u0060\n  - \u0060Subset\u0060：你的 gRPC 服务可以根据标签选择器将流量分割到不同的实例组。\n  - 目前唯一支持的 Istio \u0060loadBalancer\u0060 是 \u0060ROUND_ROBIN\u0060，\u0060consistentHash\u0060 将在未来的 Istio 版本中加入（支持 gRPC）。\n  - \u0060tls\u0060 设置被限制为 \u0060DISABLE\u0060 或 \u0060ISTIO_MUTUAL\u0060。其他模式将被视为 \u0060DISABLE\u0060。\n- \u0060VirtualService\u0060\n  - Header 匹配和 URI 匹配的格式为 \u0060\/ServiceName\/RPCName\u0060。\n  - 覆盖目标主机和子集。\n  - 加权的流量转移。\n- \u0060PeerAuthentication\u0060\n  - 只支持 \u0060DISABLE\u0060 和 \u0060STRICT\u0060。其他模式将被视为 \u0060DISABLE\u0060。\n  - 在未来的版本中可能会有对 auto-mTLS 的支持。\n\n其他功能包括故障、重试、超时、镜像和重写规则，可能会在未来的版本中支持。其中一些功能正等待在 gRPC 中实现，而其他功能则需要在 Istio 中支持。gRPC 中 xDS 功能的状态可以[在这里](https:\/\/github.com\/grpc\/grpc\/blob\/master\/doc\/grpc_xds_features.md)找到。Istio 的支持状况将存在于未来的官方文档中。\n\n这个功能是[实验性的](https:\/\/istio.io\/latest\/docs\/releases\/feature-stages\/)。标准的 Istio 功能将随着时间的推移和整体设计的改进而得到支持。\n\n## 架构概述\n\n![gRPC 服务如何与 istiod 通信的示意图](008i3skNly1gwp3lh9za5j311q0hm75n.jpg)\n\n虽然不使用 proxy 进行数据面通信，但它仍然需要一个 agent 来进行初始化和与控制面的通信。首先，agent 在启动时生成一个[引导文件](https:\/\/github.com\/grpc\/proposal\/blob\/master\/A27-xds-global-load-balancing.md#xdsclient-and-bootstrap-file)，与为 Envoy 生成引导文件的方式相同。这告诉 gRPC 库如何连接到 istiod，在哪里可以找到数据面通信的证书，以及向控制面发送什么元数据。接下来，agent 作为一个 xDS proxy，代表应用程序与 istiod 进行连接和认证。最后，agent 获取并轮换数据平面通信中使用的证书。\n\n## 对应用程序代码的修改\n\n本节介绍了 gRPC 在 Go 中的 xDS 支持。其他语言也有类似的 API。\n\n为了启用 gRPC 中的 xDS 功能，你的应用程序必须做一些必要的修改。你的 gRPC 版本应该至少是 1.39.0。\n\n### 客户端\n\n下面的导入将在 gRPC 中注册 xDS 解析器和均衡器。它应该被添加到你的主包或调用 \u0060grpc.Dial\u0060 的同一个包中。\n\n\u0060\u0060\u0060go\nimport _ \u0022google.golang.org\/grpc\/xds\u0022\n\u0060\u0060\u0060\n\n当创建一个 gRPC 连接时，URL 必须使用 \u0060xds:\/\/\/\u0060 scheme。\n\n\u0060\u0060\u0060go\nconn, err := grpc.DialContext(ctx, \u0022xds:\/\/\/foo.ns.svc.cluster.local:7070\u0022)\n\u0060\u0060\u0060\n\n此外，为了支持（m）TLS，必须向 \u0060DialContext\u0060 传递一个特殊的 \u0060TransportCredentials\u0060 选项。\u0060FallbackCreds\u0060 允许我们在 istiod 不发送安全配置时成功。\n\n\u0060\u0060\u0060go\nimport \u0022google.golang.org\/grpc\/credentials\/xds\u0022\n\n...\n\ncreds, err := xds.NewClientCredentials(xds.ClientOptions{\nFallbackCreds: insecure.NewCredentials()\n})\n\/\/ handle err\nconn, err := grpc.DialContext(\nctx,\n\u0022xds:\/\/\/foo.ns.svc.cluster.local:7070\u0022,\ngrpc.WithTransportCredentials(creds),\n)\n\u0060\u0060\u0060\n\n### 服务端\n\n为了支持服务器端的配置，如 mTLS，必须做一些修改。\n\n首先，我们使用一个特殊的构造函数来创建 \u0060GRPCServer\u0060。\n\n\u0060\u0060\u0060go\nimport \u0022google.golang.org\/grpc\/xds\u0022\n\n...\n\nserver = xds.NewGRPCServer()\nRegisterFooServer(server, \u0026fooServerImpl)\n\u0060\u0060\u0060\n\n如果你的 \u0060protoc\u0060 生成的 Go 代码已经过期，你可能需要重新生成，以便与 xDS 服务器兼容。你生成的 \u0060RegisterFooServer\u0060 函数应该像下面这样。\n\n\u0060\u0060\u0060go\nfunc RegisterFooServer(s grpc.ServiceRegistrar, srv FooServer) {\ns.RegisterService(\u0026FooServer_ServiceDesc, srv)\n}\n\u0060\u0060\u0060\n\n最后，与客户端的变化一样，我们必须启用安全支持。\n\n\u0060\u0060\u0060go\ncreds, err := xds.NewServerCredentials(xdscreds.ServerOptions{FallbackCreds: insecure.NewCredentials()})\n\/\/ handle err\nserver = xds.NewGRPCServer(grpc.Creds(creds))\n\u0060\u0060\u0060\n\n### 在你的 Kubernetes 部署中\n\n假设你的应用代码是兼容的，Pod 只需要注释 \u0060inject.istio.io\/templates：grpc-agent\u0060。这增加了一个运行上述代理的 sidecar 容器，以及一些环境变量，gRPC 使用这些变量来寻找引导文件并启用某些功能。\n\n对于 gRPC 服务端，你的 Pod 也应该用 \u0060proxy.istio.io\/config: \u0027{\u0022holdApplicationUntilProxyStarts\u0022: true}\u0027\u0060 来注释，以确保在你的 gRPC 服务端初始化之前，代理中的 xDS 代理和引导文件已经准备就绪。\n\n## 例子\n\n在本指南中，你将部署 echo，一个已经支持服务器端和客户端无代理的 gRPC 的应用。通过这个应用程序，你可以尝试一些支持的流量策略，启用 mTLS。\n\n### 先决条件\n\n本指南要求在进行之前[安装](https:\/\/istio.io\/latest\/docs\/setup\/install\/) Istio（1.11\u002b）控制平面。\n\n### 部署应用程序\n\n创建一个支持注入的命名空间 \u0060echo-grpc\u0060。接下来部署两个 \u0060echo\u0060 应用程序的实例以及服务。\n\n\u0060\u0060\u0060sh\n$ kubectl create namespace echo-grpc\n$ kubectl label namespace echo-grpc istio-injection=enabled\n$ kubectl -n echo-grpc apply -f samples\/grpc-echo\/grpc-echo.yaml\n\u0060\u0060\u0060\n\n确保两个 Pod 正在运行。\n\n\u0060\u0060\u0060sh\n$ kubectl -n echo-grpc get pods\n\nNAME                       READY   STATUS    RESTARTS   AGE\necho-v1-69d6d96cb7-gpcpd   2\/2     Running   0          58s\necho-v2-5c6cbf6dc7-dfhcb   2\/2     Running   0          58s\n\u0060\u0060\u0060\n\n### 测试 gRPC 解析器\n\n首先，将 17171 端口转发到其中一个 Pod 上。这个端口是一个非 xDS 支持的 gRPC 服务端，允许从端口转发的 Pod 发出请求。\n\n\u0060\u0060\u0060sh\n$ kubectl -n echo-grpc port-forward $(kubectl -n echo-grpc get pods -l version=v1 -ojsonpath=\u0027{.items[0].metadata.name}\u0027) 17171 \u0026\n\u0060\u0060\u0060\n\n接下来，我们可以发送一批 5 个请求。\n\n\u0060\u0060\u0060sh\n$ grpcurl -plaintext -d \u0027{\u0022url\u0022: \u0022xds:\/\/\/echo.echo-grpc.svc.cluster.local:7070\u0022, \u0022count\u0022: 5}\u0027 :17171 proto.EchoTestService\/ForwardEcho | jq -r \u0027.output | join(\u0022\u0022)\u0027  | grep Hostname\n\nHandling connection for 17171\n[0 body] Hostname=echo-v1-7cf5b76586-bgn6t\n[1 body] Hostname=echo-v2-cf97bd94d-qf628\n[2 body] Hostname=echo-v1-7cf5b76586-bgn6t\n[3 body] Hostname=echo-v2-cf97bd94d-qf628\n[4 body] Hostname=echo-v1-7cf5b76586-bgn6t\n\u0060\u0060\u0060\n\n你也可以使用类似 Kubernetes 名称解析的短名称。\n\n\u0060\u0060\u0060sh\n$ grpcurl -plaintext -d \u0027{\u0022url\u0022: \u0022xds:\/\/\/echo:7070\u0022}\u0027 :17171 proto.EchoTestService\/ForwardEcho | jq -r \u0027.output | join\n(\u0022\u0022)\u0027  | grep Hostname\n[0 body] Hostname=echo-v1-7cf5b76586-ltr8q\n$ grpcurl -plaintext -d \u0027{\u0022url\u0022: \u0022xds:\/\/\/echo.echo-grpc:7070\u0022}\u0027 :17171 proto.EchoTestService\/ForwardEcho | jq -r\n\u0027.output | join(\u0022\u0022)\u0027  | grep Hostname\n[0 body] Hostname=echo-v1-7cf5b76586-ltr8q\n$ grpcurl -plaintext -d \u0027{\u0022url\u0022: \u0022xds:\/\/\/echo.echo-grpc.svc:7070\u0022}\u0027 :17171 proto.EchoTestService\/ForwardEcho | jq -r\n\u0027.output | join(\u0022\u0022)\u0027  | grep Hostname\n[0 body] Hostname=echo-v2-cf97bd94d-jt5mf\n\u0060\u0060\u0060\n\n### 用目的地规则创建子集\n\n首先，为每个版本的工作负载创建一个子集。\n\n\u0060\u0060\u0060sh\n$ cat \u003c\u003cEOF | kubectl apply -f -\napiVersion: networking.istio.io\/v1alpha3\nkind: DestinationRule\nmetadata:\n  name: echo-versions\n  namespace: echo-grpc\nspec:\n  host: echo.echo-grpc.svc.cluster.local\n  subsets:\n  - name: v1\n    labels:\n      version: v1\n  - name: v2\n    labels:\n      version: v2\nEOF\n\u0060\u0060\u0060\n\n### 流量转移\n\n使用上面定义的子集，你可以把 80% 的流量发送到一个特定的版本。\n\n\u0060\u0060\u0060sh\n$ cat \u003c\u003cEOF | kubectl apply -f -\napiVersion: networking.istio.io\/v1beta1\nkind: VirtualService\nmetadata:\n  name: echo-weights\n  namespace: echo-grpc\nspec:\n  hosts:\n  - echo.echo-grpc.svc.cluster.local\n  http:\n  - route:\n    - destination:\n        host: echo.echo-grpc.svc.cluster.local\n        subset: v1\n      weight: 20\n    - destination:\n        host: echo.echo-grpc.svc.cluster.local\n        subset: v2\n      weight: 80\nEOF\n\u0060\u0060\u0060\n\n现在，发送一组 10 个请求。\n\n\u0060\u0060\u0060sh\ngrpcurl -plaintext -d \u0027{\u0022url\u0022: \u0022xds:\/\/\/echo.echo-grpc.svc.cluster.local:7070\u0022, \u0022count\u0022: 10}\u0027 :17171 proto.EchoTestService\/ForwardEcho | jq -r \u0027.output | join(\u0022\u0022)\u0027  | grep ServiceVersion\n\u0060\u0060\u0060\n\n响应应主要包含 v2 响应。\n\n\u0060\u0060\u0060plain\n[0 body] ServiceVersion=v2\n[1 body] ServiceVersion=v2\n[2 body] ServiceVersion=v1\n[3 body] ServiceVersion=v2\n[4 body] ServiceVersion=v1\n[5 body] ServiceVersion=v2\n[6 body] ServiceVersion=v2\n[7 body] ServiceVersion=v2\n[8 body] ServiceVersion=v2\n[9 body] ServiceVersion=v2\n\u0060\u0060\u0060\n\n### 启用 mTLS\n\n由于在 gRPC 中启用安全所需的应用程序本身的变化，Istio 的自动检测 mTLS 支持的传统方法是不可靠的。出于这个原因，初始版本需要在客户端和服务端上明确启用 mTLS。\n\n要启用客户端的 mTLS，请应用带有 \u0060tls\u0060 设置的 \u0060DestinationRule\u0060。\n\n\u0060\u0060\u0060sh\n$ cat \u003c\u003cEOF | kubectl apply -f -\napiVersion: networking.istio.io\/v1alpha3\nkind: DestinationRule\nmetadata:\n  name: echo-mtls\n  namespace: echo-grpc\nspec:\n  host: echo.echo-grpc.svc.cluster.local\n  trafficPolicy:\n    tls:\n      mode: ISTIO_MUTUAL\nEOF\n\u0060\u0060\u0060\n\n现在，试图调用尚未配置 mTLS 的服务器将会失败。\n\n\u0060\u0060\u0060sh\n$ grpcurl -plaintext -d \u0027{\u0022url\u0022: \u0022xds:\/\/\/echo.echo-grpc.svc.cluster.local:7070\u0022}\u0027 :17171 proto.EchoTestService\/ForwardEcho | jq -r \u0027.output | join(\u0022\u0022)\u0027\n\nHandling connection for 17171\nERROR:\nCode: Unknown\nMessage: 1\/1 requests had errors; first error: rpc error: code = Unavailable desc = all SubConns are in TransientFailure\n\u0060\u0060\u0060\n\n为了启用服务器端的 mTLS，应用一个 \u0060PeerAuthentication\u0060。\n\n以下策略对整个命名空间强制采用 STRICT mTLS。\n\n\u0060\u0060\u0060sh\n$ cat \u003c\u003cEOF | kubectl apply -f -\napiVersion: security.istio.io\/v1beta1\nkind: PeerAuthentication\nmetadata:\n  name: echo-mtls\n  namespace: echo-grpc\nspec:\n  mtls:\n    mode: STRICT\nEOF\n\u0060\u0060\u0060\n\n应用该政策后，请求将开始成功。\n\n\u0060\u0060\u0060sh\n$ grpcurl -plaintext -d \u0027{\u0022url\u0022: \u0022xds:\/\/\/echo.echo-grpc.svc.cluster.local:7070\u0022}\u0027 :17171 proto.EchoTestService\/ForwardEcho | jq -r \u0027.output | join(\u0022\u0022)\u0027\n\nHandling connection for 17171\n[0] grpcecho.Echo(\u0026{xds:\/\/\/echo.echo-grpc.svc.cluster.local:7070 map[] 0  5s false })\n[0 body] x-request-id=0\n[0 body] Host=echo.echo-grpc.svc.cluster.local:7070\n[0 body] content-type=application\/grpc\n[0 body] user-agent=grpc-go\/1.39.1\n[0 body] StatusCode=200\n[0 body] ServiceVersion=v1\n[0 body] ServicePort=17070\n[0 body] Cluster=\n[0 body] IP=10.68.1.18\n[0 body] IstioVersion=\n[0 body] Echo=\n[0 body] Hostname=echo-v1-7cf5b76586-z5p8l\n\u0060\u0060\u0060\n\n## 限制条件\n\n最初的版本有几个限制，可能会在未来的版本中修复。\n\n- 不支持自动 mTLS，也不支持许可模式。相反，我们需要在服务器上使用 \u0060STRICT\u0060，在客户端使用 \u0060ISTIO_MUTUAL\u0060 的明确 mTLS 配置。在迁移到 \u0060STRICT\u0060 的过程中，可以使用 Envoy。\n- \u0060grpc.Serve(listener)\u0060 或 \u0060grpc.Dial(\u0022xds:\/\/...\u0022)\u0060 在 bootstrap 被写入或 xDS 代理准备好之前被调用会导致失败。 \u0060holdApplicationUntilProxyStarts\u0060 可以用来解决这个问题，或者应用程序可以对这些失败更加稳健。\n- 如果支持 xDS 的 gRPC 服务器使用 mTLS，那么你将需要确保你的健康检查可以绕过这个问题。要么使用一个单独的端口，要么你的健康检查客户端需要一种方法来获得适当的客户端证书。\n- gRPC 中 xDS 的实现与 Envoy 不一致。某些行为可能不同，某些功能可能缺失。[gRPC 的功能状态](https:\/\/github.com\/grpc\/grpc\/blob\/master\/doc\/grpc_xds_features.md)提供了更多细节。请确保测试任何 Istio 配置是否真正适用于你的无代理的 gRPC 应用程序。\n\n## 性能\n\n### 实验设置\n\n- 使用 Fortio，一个基于 Go 的负载测试应用程序\n  - 稍作修改，以支持 gRPC 的 XDS 功能 (PR)\n- 资源：\n  - GKE 1.20 集群有 3 个 \u0060e2-standard-16\u0060 节点（每个节点有 16 个 CPU\u002b64GB 内存）\n  - Fortio 客户端和服务器应用程序：1.5 vCPU，1000 MiB 内存\n  - Sidecar（istio-agent 和可能的 Envoy 代理）：1 vCPU，512 MiB 内存\n- 测试的工作负载类型：\n  - 基线：常规的 gRPC，没有使用 Envoy 代理或 Proxyless xDS\n  - Envoy：标准的 istio-agent \u002b Envoy proxy sidecar\n  - 无代理：使用 xDS gRPC 服务器实现的 gRPC 和客户端的 \u0060xds:\/\/\/\u0060 解析器。\n  - 通过 \u0060PeerAuthentication\u0060 和 \u0060DestinationRule\u0060 启用 \/ 停用 mTLS\n\n### 延迟\n\n![P50 延迟对比图](008i3skNly1gwp512szlvj31260rgq57.jpg)\n\n![P99 延迟对比图](008i3skNly1gwp51zjxqaj312q0r2jtl.jpg)\n\n在使用无代理的 gRPC 解析器时，延迟会有微小的增加。与 Envoy 相比，这是一个巨大的改进，仍然可以实现先进的流量管理功能和 mTLS。\n\n### istio-proxy 容器的资源使用情况\n\n| 类别        | 客户端 \u0060mCPU\u0060 | 客户端内存 (\u0060MiB\u0060) | 服务端 \u0060mCPU\u0060 | 服务端内存 (\u0060MiB\u0060) |\n| ----------- | ------------- | ------------------ | ------------- | ------------------ |\n| Envoy 明文  | 320.44        | 66.93              | 243.78        | 64.91              |\n| Envoy mTLS  | 340.87        | 66.76              | 309.82        | 64.82              |\n| 无代理明文  | 0.72          | 23.54              | 0.84          | 24.31              |\n| 无代理 mTLS | 0.73          | 25.05              | 0.78          | 25.43              |\n\n尽管我们仍然需要一个代理，但代理使用的内存不到完整 vCPU 的 0.1%，而且只有 25 MiB，这还不到运行 Envoy 所需内存的一半。\n\n这些指标不包括应用容器中 gRPC 的额外资源使用量，但有助于展示 istio-agent 在此模式下运行时的资源使用影响。\n', '\/trans\/grpc-proxyless-service-mesh\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文介绍了 Istio 对 gRPC 的无代理服务网格功能的支持。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/how-ebpf-streamlines-the-service-mesh/">[译] eBPF 如何简化服务网格</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2021/10/27</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://thenewstack.io/how-ebpf-streamlines-the-service-mesh/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('eBPF 如何简化服务网格', '本文探讨一下 eBPF 是如何让我们精简服务网格，使服务网格的数据平面更有效率，更容易部署。', '\n今天有几个服务网格的产品和项目，承诺简化应用微服务之间的连接，同时提供额外的功能，如安全连接、可观测性和流量管理。但正如我们在过去几年中反复看到的那样，对服务网格的兴奋已经被对额外的[复杂性](https:\/\/engineering.hellofresh.com\/everything-we-learned-running-istio-in-production-part-2-ff4c26844bfb)和[开销的](https:\/\/pklinker.medium.com\/performance-impacts-of-an-istio-service-mesh-63957a0000b)实际[担忧所抑制](https:\/\/medium.com\/geekculture\/watch-out-for-this-istio-proxy-sidecar-memory-pitfall-8dbd99ea7e9d)。让我们来探讨一下 [eBPF](https:\/\/ebpf.io\/) 是如何让我们精简[服务网格](https:\/\/thenewstack.io\/category\/service-mesh\/)，使服务网格的数据平面更有效率，更容易部署。\n\n## Sidecar 问题\n\n今天的 Kubernetes 服务网格解决方案要求你在每一个应用 pod 上添加一个代理 sidecar 容器，如 [Envoy](https:\/\/www.envoyproxy.io\/) 或 [Linkerd-proxy](https:\/\/linkerd.io\/)。这是正确的：即使在一个非常小的环境中，比如说有 20 个服务，每个服务运行五个 pod，分布在三个节点上，你也有 100 个代理容器。无论代理的实现多么小和有效，这种纯粹的重复都会耗费资源。\n\n每个代理使用的内存与它需要能够通信的服务数量有关。Pranay Singhal 写了他配置 Istio 的[经验](https:\/\/medium.com\/geekculture\/watch-out-for-this-istio-proxy-sidecar-memory-pitfall-8dbd99ea7e9d)，将每个代理的消耗从 1GB 左右减少到更合理的 60-70MB。但是，即使在我们的小环境中，在三个节点上有 100 个代理，这种优化配置仍然需要每个节点 2GB 左右。\n\n![来自 [redhat.com\/architect\/why-when-service-mesh](https:\/\/redhat.com\/architect\/why-when-service-mesh)——每个微服务都有自己的代理 sidecar](008i3skNly1gvtp69o74jj31w50u0jy8.jpg) \n\n为什么我们需要所有这些 sidecar？这种模式允许代理容器与 pod 中的应用容器共享一个网络命名空间。网络命名空间是 Linux 内核的结构，它允许容器和 pod 拥有自己独立的网络堆栈，将容器化的应用程序相互隔离。这使得应用之间互不相干，这就是为什么你可以让尽可能多的 pod 在 80 端口上运行一个 web 应用 —— 网络命名空间意味着它们各自拥有自己的 80 端口。代理必须共享相同的网络命名空间，这样它就可以拦截和处理进出应用容器的流量。\n\n## 引入 eBPF\n\n[eBPF](http:\/\/ebpf.io\/) 是一种内核技术，允许自定义程序在内核中运行。这些程序在响应事件时运行，有成千上万个可能的事件，eBPF 程序可以被附加到这些事件上。这些事件包括轨迹点、进入或退出任何功能（在内核或用户空间）或对服务网格来说很重要的 —— 抵达的网络数据包。\n\n重要的是，**每个节点只有一个内核**；在一个节点上运行的所有容器（也就是所有的 pod）共享同一个内核。如果你在内核中添加一个 eBPF 程序到一个事件中，它将被触发，无论哪个进程引起该事件，无论它是在应用容器中运行还是直接运行在主机上。\n\n![每台主机一个内核](008i3skNly1gvtp6c8mn9j31ea0u0n0t.jpg) \n\n这就是为什么 eBPF 对于 Kubernetes 中的任何一种 instrumentation 来说都是如此令人兴奋的技术 —— 你只需要在每个节点上添加一次 instrumentation，所有的应用程序 pod 都会被覆盖。无论你是在寻求可观测性、安全性还是网络，由 eBPF 驱动的解决方案都可以在不需要 sidecar 的情况下对应用进行检测。\n\n基于 eBPF 的 [Cilium](http:\/\/cilium.io\/) 项目（最近 [以孵化级别加入云计算基金会](https:\/\/www.cncf.io\/blog\/2021\/10\/13\/cilium-joins-cncf-as-an-incubating-project\/)）将这种“无 sidecar\u0022 模式带到了服务网格的世界。除了传统的 sidecar 模型，Cilium 还支持每个节点使用一个 Envoy 代理实例运行服务网格的数据平面。使用我们前面的例子，这就把代理实例的数量从 100 个减少到只有 3 个。\n\n![用无 sidecar 代理模式减少代理实例](008i3skNly1gvtp67ocjkj31xt0u0jvp.jpg) \n\n## 减少 YAML\n\n在 sidecar 模型中，指定每个应用 pod 的 YAML 需要被修改以添加 sidecar 容器。这通常是自动化的 —— 例如，使用一个 mutating webhook，在每个应用 pod 部署的时候注入 sidecar。\n\n以 Istio 为例，这需要[标记](https:\/\/istio.io\/latest\/docs\/setup\/additional-setup\/sidecar-injection\/#controlling-the-injection-policy) Kubernetes 命名空间和 \/ 或 pod，以定义是否应该注入 sidecar—— 当然也需要为集群启用 mutating webhook。\n\n但如果出了问题怎么办？如果命名空间或 pod 的标签不正确，那么 sidecar 将不会被注入，pod 将不会被连接到服务网格。更糟糕的是，如果攻击者破坏了集群，并能够运行一个恶意的工作负载 —— 例如，一个加密货币矿工，他们将不太可能标记它，以便它加入服务网格。它不会通过服务网格提供的流量观察能力而被发现。\n\n相比之下，在支持 eBPF 的无 sidecar 代理模型中，pod 不需要任何额外的 YAML 就可以被检测。相反，一个 CRD 被用来在集群范围内配置服务网格。即使是已经存在的 pod 也可以成为服务网格的一部分，而不需要重新启动。\n\n如果攻击者试图通过直接在主机上运行工作负载来绕过 Kubernetes 编排，eBPF 程序可以检测并控制这一活动，因为这一切都可以从内核看到。\n\n## eBPF 支持的网络效率\n\n支持 eBPF 的网络允许数据包走捷径，绕过内核的部分网络堆栈，这可以使 Kubernetes 网络的[性能得到显著改善](https:\/\/cilium.io\/blog\/2021\/05\/11\/cni-benchmark)。让我们看看这在服务网格数据平面中是如何应用的。\n\n![在 eBPF 加速、无 sidecar 的服务网格模型中，网络数据包通过的路径要短得多](008i3skNly1gvtp6ao3lqj31q90u0gqw.jpg) \n\n在服务网格的情况下，代理在传统网络中作为 sidecar 运行，数据包到达应用程序的路径相当曲折：入站数据包必须穿越主机 TCP\/IP 栈，通过虚拟以太网连接到达 pod 的网络命名空间。从那里，数据包必须穿过 pod 的网络堆栈到达代理，代理将数据包通过回环接口转发到应用程序。考虑到流量必须在连接的两端流经代理，与非服务网格流量相比，这将导致延迟的[显著增加](https:\/\/linkerd.io\/2021\/05\/27\/linkerd-vs-istio-benchmarks\/#latency-at-20-rps)。\n\n基于 eBPF 的 Kubernetes CNI 实现，如 Cilium，可以使用 eBPF 程序，明智地钩住内核中的特定点，沿着更直接的路线重定向数据包。这是可能的，因为 Cilium 知道所有的 Kubernetes 端点和服务的身份。当数据包到达主机时，Cilium 可以将其直接分配到它所要去的代理或 Pod 端点。\n\n## 网络中的加密\n\n如果一个网络解决方案能够意识到 Kubernetes 服务，并在这些服务的端点之间提供网络连接，那么它能够提供服务网格数据平面的能力就不足为奇。但这些能力可以超越基本的连接。一个例子是透明加密。\n\n通常使用服务网格来确保所有的应用流量都是经过认证和加密的。这是通过双向 TLS（mTLS）实现的；服务网格代理组件作为网络连接的端点，并与其远程对等物协商一个安全的 TLS 连接。这种连接对代理之间的通信进行加密，而不需要对应用程序做任何改变。\n\n但在应用层管理的 TLS 并不是实现组件间认证和加密流量的唯一方法。另一个选择是在网络层加密流量，使用 [IPSec 或 WireGuard](https:\/\/cilium.io\/blog\/2021\/05\/11\/cni-benchmark#the-cost-of-encryption---wireguard-vs-ipsec)。因为它在网络层操作，这种加密不仅对应用程序完全透明，而且对代理也是透明的 —— 它可以在有或没有服务网格时启用。如果你使用服务网格的唯一原因是提供加密，你可能想考虑网络级加密。它不仅更简单，而且还可以用来验证和加密节点上的任何流量 —— 它不只限于那些启用了 sidecar 的工作负载。\n\n## eBPF 是服务网格的数据平面\n\n现在，eBPF 在 Linux 生产发行版使用的内核版本中得到广泛支持，企业可以利用它来获得更有效的网络解决方案，并作为服务网格的更有效的数据平面。\n\n去年，我代表 [CNCF](https:\/\/cncf.io\/?utm_content=inline-mention) 的技术监督委员会，对服务网格领域的整合和清晰化做了一些 [预测](https:\/\/youtu.be\/bESogtuHwX0)。在同一主题演讲中，我谈到 eBPF 有可能成为更多项目和更广泛部署能力的基础。这两个想法现在正结合在一起，因为 eBPF 似乎是服务网格数据平面的自然路径。\n', '\/trans\/how-ebpf-streamlines-the-service-mesh\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文探讨一下 eBPF 是如何让我们精简服务网格，使服务网格的数据平面更有效率，更容易部署。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/can-ztna-replace-vpn/">[译] ZTNA 能取代 VPN 吗？——三种远程访问方法对比</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2021/10/13</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e5%ae%89%e5%85%a8"> 
             安全
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://assets.ctfassets.net/slt3lc6tev37/IcpGyTHplQhOeB60k1Egp/e49211fc4482b67f3bf264c22923ef5c/Can_ZTNA_replace_your_VPN" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('ZTNA 能取代 VPN 吗？——三种远程访问方法对比', '本文对比了 VPN 和 ZTNA 远程访问解决方案，阐明了它们的好处和局限性，同时阐明了迁移项目的最重要考虑因素。同时给出了 Cloudflare 的解决方案及迁移到 ZTNA 的步骤建议。', '\n## 编者按\n\n本文译自 Cloudflare 出品的白皮书 [*Can ZTNA replace your VPN? Compare 3 remote access approaches*](https:\/\/assets.ctfassets.net\/slt3lc6tev37\/IcpGyTHplQhOeB60k1Egp\/e49211fc4482b67f3bf264c22923ef5c\/Can_ZTNA_replace_your_VPN)，本文对比了 VPN 和 ZTNA 远程访问解决方案，阐明了它们的好处和局限性，同时阐明了迁移项目的最重要考虑因素。同时给出了 Cloudflare 的解决方案及迁移到 ZTNA 的步骤建议。\n\n## 简介\n\n安全、无缝的远程访问是一个业务促进因素——提高远程用户的生产力，减少 IT 团队花在入职和维护用户与应用连接的时间，并具有灵活性和弹性。然而，远程访问对许多企业来说仍然是一个挑战。\n\n很久以前，VPN 提供了一种简单的方法，将一些远程用户短暂地连接到企业网络。然而，随着劳动力的分布越来越广——企业需要在更长时间内保持远程用户的安全连接——这种方法的缺陷变得很明显，从性能低下、安全风险增加到扩展性问题。\n\n随着远程访问需求的增长，企业正越来越多地从传统的 VPN 实施方式转向更安全、性能更高的远程访问解决方案。零信任网络访问（Zero Trust Network Access），或称 ZTNA，围绕特定的应用程序、私有 IP 和主机名创建安全边界，用基于身份和背景授予访问权的默认拒绝策略取代默认允许的 VPN 连接。\n\n![](008i3skNly1gvco15q2jsj619a0nead202.jpg) \n\n2020 年，大约 5% 的远程访问使用主要由 ZTNA 提供服务。由于传统 VPN 访问的局限性以及提供更精确的访问和会话控制的需要，预计到 2024 年，这一数字将跃升至 40%。\n\n虽然 ZTNA 为企业提供了比 VPN 更明显的优势和更多的功能，但许多组织发现它并不能完全替代 VPN 基础设施。但是，随着 ZTNA 变得更加强大，VPN 问题变得更加严重，这种情况正在迅速改变。本文对比了 VPN 和 ZTNA 远程访问解决方案，阐明了它们的好处和局限性，同时阐明了迁移项目的最重要考虑因素。它解释了 Cloudflare 如何提供 ZTNA，并推荐了一套行动步骤，将传统的 VPN 基础设施过渡到更快、更安全的远程用户零信任连接。\n\n## 方法 1：传统的 VPN\n\n几十年来，VPN 使组织能够将其远程用户连接到公司网络，并具有一定的隐私和安全性。在公共互联网上访问敏感信息，任何攻击者都可能窥探或窃取数据，而 VPN 允许用户通过加密连接安全访问内部资源。\n\n两种最常见的 VPN 实施模式是基于客户端的 VPN 和无客户端的 SSL-VPN。每种模式都有各自的好处和挑战。\n\n基于客户端的 VPN 通过加密的隧道将远程用户连接到一个私人网络。这种连接是通过一个软件应用程序或客户端建立的，它要求用户用用户名和密码进行一次认证，以获得对该网络内任何资源的持续访问。\n\n**优点**\n\n一旦建立连接，就自由的横向移动使用户很容易通过访问应用程序和连接到内部主机来快速访问多种资源。\n\n**挑战**\n\n- 不是为漫游用户和移动设备设计的。当用户四处漫游时，他们的笔记本电脑和移动设备都会随着无线网络的变化而无缝地重新连接。然而，VPN 客户端不善于流畅地处理这些重新连接，要求用户反复强迫 VPN 客户端重新启动和重新认证——造成生产力的损失，并产生 IT 票据。\n\n- 可见性差。采用这种方法，VPN 基础设施在数据中心的内部防火墙背后终止了来自 VPN 客户端的加密隧道。虽然这些连接被记录下来，但没有特定的应用集中日志来显示用户访问了哪些应用或他们在应用中采取了哪些行动。\n\n无客户端的 SSL-VPN 门户允许少数远程用户连接到私人网络中的一些基于浏览器的应用程序。这种连接是通过运行 VPN 服务的网络设备中内置的 Web 服务器实现的。\n\n**挑战**\n\n- 安全问题。数据中心内的大多数 VPN 设置允许用户完全访问，这给那些不希望非雇员（如承包商）不受限制地访问敏感资源和应用程序的组织带来了问题。\n\n- 不是为支持大量的并发用户而建立的。与现代云服务不同，门户网站的网络服务器不能弹性扩展以满足更高需求。相反，必须安装更多的网络设备并进行负载均衡，以扩大门户的规模，这通常是昂贵、复杂和无效的，因为设备的其他功能可能没有被充分利用。\n\n- 无客户端的 SSL-VPN 门户使防火墙端口和网络服务器暴露在攻击之下。为了让托管门户的网络服务器能够到达内部应用，管理员必须开放入站防火墙端口，使其暴露在外部攻击之下。开放的端口和网络服务器本身都必须屏蔽 DDoS 和网络应用的攻击，这需要更复杂的配置和更高的成本，以确保这种连接方法的安全。\n\nwpsfkrjr5.png) \n\n 虽然 VPN 为远程用户提供了基本的隐私，但在设计时并没有考虑到安全性或可扩展性。传统上，企业使用 VPN 将少数远程用户短期连接到企业网络。然而，随着远程工作变得越来越普遍，VPN 问题开始成倍增加。\n\n- 用户体验到性能低下。如果 VPN 基础设施没有能力处理其员工创造的流量吞吐量和并发连接，用户的互联网连接就会变慢。此外，当 VPN 距离用户和他们试图访问的应用服务器都很远时，就会造成访问延迟。\n\n- 企业网络容易受到攻击。VPN 通常采用城堡和山丘模式，即用户一旦连接到网络，就可以不受限制地访问所有企业资源。由于没有内置的方法来限制对关键基础设施和数据的访问，企业被迫配置昂贵、复杂的安全服务，如下一代防火墙和网络访问控制——或者容易受到恶意的横向移动，导致更大的数据泄露。\n\n**托管 VPN 服务的挑战**\n\n一些供应商已经将运行 VPN 服务的网络设备转移到公有云中，作为虚拟机在一个或多个数据中心运行。VPN 可能与其他安全服务捆绑在一起，也可能不与之捆绑在一起（或与之串联）。\n\n将 VPN 置于云中，似乎可以解决硬件 VPN 设备固有的一些可扩展性问题。然而，这样做也带来了一些重大的安全和可扩展性挑战。\n\n例如有一个组织托管一个完整的 NGFW（下一代防火墙），将 VPN 与防火墙和其他安全功能结合起来。由于 NGFW 是作为一个捆绑服务提供的，因此不可能根据需求独立扩展任何特定功能。扩大一个功能需要扩大整个服务；要做到这一点，必须启动更多的虚拟机，以平衡每个虚拟机中执行的少量计算的负载。这不仅是一个不切实际且不便的解决方案，而且随着组织的远程访问需求不断扩大，很可能会产生高额费用。\n\n## 方法 2：零信任网络访问\n\n零信任安全规避了 VPN 所固有的许多挑战。它所依据的原则是，网络内部或外部的任何用户或设备都不能被默认信任。为了减少数据泄露、内部攻击和其他威胁的风险和影响，零信任方法——\n\n- 对每一次登录和请求进行认证和记录。\n\n- 要求对所有用户和设备进行严格的核查。\n\n- 根据身份和背景，限制每个用户和设备可以访问的信息。\n\n- 并增加了端对端加密，以隔离网络中的应用和数据。\n\n![](008i3skNly1gvcoksofzvj61o80u0q5q02.jpg) \n\n与 VPN 一样，ZTNA 有两种配置方式：\n\n1. 无客户端（或服务发起的）ZTNA 使用现有的浏览器，而不是客户端，来创建一个安全连接并验证用户设备。传统上，无客户端 ZTNA 仅限于具有 HTTP\/HTTPS 协议的应用，但兼容性正在快速发展。 \n\n- 优点：无客户端 ZTNA 使用反向代理连接，防止直接访问应用程序，阻止用户访问他们可能没有权限查看的应用程序和数据，并允许管理员在管理方面有更强的控制和灵活性。\n\n2. 基于客户端（终端启动）的 ZTNA 在控制代理和授权应用之间建立加密连接之前，在用户设备上安装软件。\n\n- 优点：基于客户端的 ZTNA 使管理员能够更深入地了解用户访问应用程序的设备状态、位置和风险背景，因此可以创建和执行更精细的策略。而且，由于这种方法不限于 HTTP\/HTTPS，它可以用来访问更广泛的非 HTTP 应用——例如那些依赖 SSH、RDP、VNC、SMB 和其他 TCP 连接的应用。\n\n**实施 ZTNA 的挑战**\n\n虽然 ZTNA 与传统的 VPN 相比具有明显的优势，但它并不是一个确保远程用户网络访问安全的完美方法。当企业权衡采用零信任的利弊时，他们可能会遇到以下一个或多个挑战。\n\n1. 解决方案并不是真正的云原生。\n\n如果供应商不提供基于云的 ZTNA——意味着他们的客户需要在自己的数据中心部署软件，那么用户就会失去即时可扩展性和无限吞吐量等关键优势。\n\n2. 供应商可能不提供基于客户端和无客户端的 ZTNA 选项。\n\n这限制了那些需要将用户连接到非 HTTP 应用（如远程桌面、SSH 应用或文件共享）的组织的价值。\n\n3. 配置可能是复杂和耗时的。\n\n不提供策略协调和自动化支持的供应商（通过 Terraform 等工具）可能会给管理员带来更多的手动工作——除了在身份提供者中已经发生的配置之外。\n\n## 方法 3：Cloudflare 的远程访问方法\n\n保护和扩展远程访问应该是一个无缝的过程，一个不分层的笨重的安全解决方案，创造性能的权衡，减少不必要的成本。Cloudflare 使团队能够处理所有的远程访问用例，具有以下好处。\n\n- 为用户和管理员提供简单、无风险的入职培训。Cloudflare 很容易与现有的身份供应商和终端保护平台集成，以执行限制访问企业应用程序和资源的零信任政策。\n\n- 基于客户端和无客户端的 ZTNA 部署的灵活性。Cloudflare 为网络、SSH、VNC（以及即将推出的 RDP）应用程序的连接提供无客户端支持，为非 HTTP 应用程序和内部 IP（以及即将推出的主机名）的私有路由提供基于客户端的支持。\n\n![](wpsxPzRG3.png)  \n\n表 1：Cloudflare 如何应对远程访问挑战\n\n| 问题             | 解决方案        | Cloudflare 的实施                                   |\n| -------------------------- | ------------------------- | ------------------------------------------------------------ |\n| 难以扩展                   | 全局边缘网络            | 可扩展性问题困扰着非云原生的 VPN 和 ZTNA 服务，使远程用户难以访问应用程序和数据。Cloudflare 的全球 Anycast 网络不仅使用户的连接速度比 VPN 快，而且还确保任何规模的远程工作者都能根据需要安全、迅速地连接到企业资源，而不需要管理员进行额外的耗时配置。 |\n| 与移动设备的兼容性差       | 轻量级客户端              | 利用 IPSec 和 SSL 协议的 VPN 和 ZTNA 解决方案在移动和漫游设备上的性能往往不佳。Cloudflare 的 WARP 客户端利用更现代的 Wireguard 协议，该协议在用户空间运行，支持更广泛的操作系统选项，与传统选项相比，用户体验更好。Cloudflare 的 WARP 客户端可以在 Windows、MacOS、iOS、Android 和即将到来的 Linux 设备上配置。 |\n| 没有集成的或薄弱的 DDoS 保护 | 内置行业领先的 DDoS 保护    | 如果没有集成的 DDoS 保护，企业往往被迫以 daisy-chain 方式提供额外的安全服务，这可能会造成配置上的麻烦、可扩展性问题和安全挑战。Cloudflare 的 67\u002bTbps 网络为任何 ZTNA 模式提供内置的 DDoS 保护，抵御最大规模的攻击。 |\n| 协议的限制             | 非网络应用程序支持        | 模式兼容性：用于 SSH\/VNC 应用的无客户端 ZTNA；用于所有其他非网络应用的基于客户端的 ZTNA。 |\n| 没有集成的网络防火墙       | 内置网络防火墙            | 随着企业网络的发展，企业必须平衡的安全硬件堆栈也在不断增加——导致成本、性能和安全方面的折衷。Cloudflare 使管理员能够在边缘执行网络防火墙策略，使他们能够精细地控制哪些数据允许进出网络，并提高流量流经网络的可见性。  ✓ 模式兼容性：基于客户端的 ZTNA |\n| 缺乏细粒度的控制           | 内置安全网关（SWG） | 未经批准使用应用程序会给企业带来严重的安全问题；如果没有严格的政策，用户可能会访问和篡改敏感数据和其他企业资源。结合 ZTNA 和 SWG，Cloudflare 允许管理员对应用程序内的用户和设备访问权限进行更精细的控制，因此用户和基于角色的组只能访问他们需要的资源。✓ 模式兼容性：基于客户端的 ZTNA |\n\n## 用零信任网络访问取代传统 VPN\n\n在向无 VPN 安全过渡的漫长而痛苦的过程中，IT 安全领导可能会觉得零信任的承诺很空洞。但是，用零信任网络访问取代 VPN 是可能的，而不需要在协议支持或功能上做出取舍。\n\n推荐的迁移路径根据驱动你的项目的业务专家而有所不同。\n\n- 如果更快连接到应用程序是你的首要任务，请部署基于客户端的 ZTNA，首先用于非网络应用。\n\n- 如果加强你的应用程序访问规则的安全性更为重要，那么就从网络应用开始。替换 VPN 只是整个网络转型的第一步。由于向 SASE 模式的过渡可能是压倒性的，我们根据客户采取的方法，分解了一条通往零信任安全的常见路径。\n\n\n![](008i3skNly1gvcoknm2onj61tx0u0thb02.jpg)  \n', '\/trans\/can-ztna-replace-vpn\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文对比了 VPN 和 ZTNA 远程访问解决方案，阐明了它们的好处和局限性，同时阐明了迁移项目的最重要考虑因素。同时给出了 Cloudflare 的解决方案及迁移到 ZTNA 的步骤建议。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/service-mesh-ultimate-guide-e2/">[译] 服务网格终极指南第二版——下一代微服务开发</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2021/10/11</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://www.infoq.com/articles/service-mesh-ultimate-guide-2e/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('服务网格终极指南第二版——下一代微服务开发', '本文是 InfoQ 自 2020 年 2 月发表的服务网格终极指南后的第二版，发布于 2021 年 9 月。', '\n### 主要收获\n\n- 了解采用服务网格技术的新兴架构趋势，特别是多云、多集群和多租户模式，如何在异构基础设施（裸机、虚拟机和 Kubernetes）中部署服务网格解决方案，以及从边缘计算层到网格的应用 \/ 服务连接。\n- 了解服务网格生态系统中的一些新模式，如多集群服务网格、媒体服务网格（Media Service Mesh）和混沌网格，以及经典的微服务反模式，如“死星（Death Star） “架构。\n- 获取最新的关于在部署领域使用服务网格的创新总结，在 Pod（K8s 集群）和 VM（非 K8s 集群）之间进行快速实验、混乱工程和金丝雀部署。\n- 探索服务网格扩展领域的创新，包括：增强身份管理，以确保微服务连接的安全性，包括自定义证书授权插件，自适应路由功能，以提高服务的可用性和可扩展性，以及增强 sidecar 代理。\n- 了解操作方面即将出现的情况，如配置多集群功能和将 Kubernetes 工作负载连接到托管在虚拟机基础设施上的服务器，以及管理多集群服务网格中所有功能和 API 的开发者门户。\n\n在过去的几年里，服务网格技术有了长足的发展。服务网格在各组织采用云原生技术方面发挥着重要作用。通过提供四种主要能力 —— 连接性、可靠性、可观测性和安全性，服务网格已经成为 IT 组织的技术和基础设施现代化工作的核心组成部分。服务网格使开发和运维团队能够在基础设施层面实现这些能力，因此，当涉及到跨领域的非功能需求时，应用团队不需要重新发明轮子。\n\n自本文[第一版](https:\/\/www.infoq.com\/articles\/service-mesh-ultimate-guide\/)于 2020 年 2 月发表以来，服务网格技术经历了重大创新，在不断发展的服务网格领域出现了一些新的架构趋势、技术能力和服务网格项目。\n\n在过去的一年里，服务网格产品的发展远远超过了原有的 Kubernetes 解决方案，没有托管在 Kubernetes 平台上的应用无法利用服务网格。并非所有的组织都将其所有的业务和 IT 应用程序过渡到 Kubernetes 云平台。因此，自服务网格诞生以来，一直需要这项技术在不同的 IT 基础设施环境中工作。\n\n随着微服务架构的不断采用，应用系统在云供应商、基础设施（Kubernetes、虚拟机、裸机服务器）、地域，甚至在服务网格集成环境中要管理的工作负载类型方面，都已实现解耦和分布式。\n\n让我们从服务网格的历史开始说起，了解服务网格是如何产生的。\n\n2016 年前后，“服务网格 \u0022 这个词出现在微服务、云计算和 DevOps 的领域。Buoyant 团队在 2016 年用[这个](https:\/\/twitter.com\/wm\/status\/1383061764938469377?s=20)词来解释他们的产品 Linkerd。和云计算领域的许多概念一样，相关的模式和技术其实有很长的历史。\n\n服务网格的到来主要是由于 IT 领域内的一场风暴。开发人员开始使用多语言（polyglot）方法构建分布式系统，并需要动态服务发现。运维部门开始使用短暂的基础设施，并希望优雅地处理不可避免的通信故障和执行网络策略。平台团队开始接受像 Kubernetes 这样的容器编排系统，并希望使用现代 API 驱动的网络代理（如 Envoy）在系统中和周围动态地路由流量。\n\n本文旨在回答软件架构师和技术负责人的相关问题，如：什么是服务网格？我是否需要服务网格？如何评估不同的服务网格产品？\n\n## 服务网格模式\n\n服务网格模式专注于管理分布式软件系统中所有服务之间的通信。\n\n### 背景介绍\n\n该模式的背景有两个方面。首先，工程师们已经采用了微服务架构模式，并通过将多个（理想情况下是单一用途且可独立部署的）服务组合在一起构建他们的应用。第二，组织已经接受了云原生平台技术，如容器（如 Docker）、编排器（如 Kubernetes）和网关。\n\n### 意图\n\n服务网格模式试图解决的问题包括：\n\n- 消除了将特定语言的通信库编译到单个服务中的需求，以处理服务发现、路由和应用层（第 7 层）非功能通信要求。\n- 外部化服务通信配置，包括外部服务的网络位置、安全凭证和服务质量目标。\n- 提供对其他服务的被动和主动监测。\n- 在整个分布式系统中分布式地执行策略。\n- 提供可观测性的默认值，并使相关数据的收集标准化。\n  - 启用请求记录\n  - 配置分布式追踪\n  - 收集指标\n\n### 结构\n\n服务网格模式主要侧重于处理传统上被称为“东西向“的基于远程过程调用（RPC）的流量：请求 \/ 响应类型的通信，源自数据中心内部，在服务之间传播。这与 API 网关或边缘代理相反，后者被设计为处理“南北“流量。来自外部的通信，进入数据中心内的一个终端或服务。\n\n## 服务网格的特点\n\n服务网格的实施通常会提供以下一个或多个功能：\n\n- 规范化命名并增加逻辑路由，（例如，将代码级名称“用户服务 \u0022 映射到平台特定位置“AWS-us-east-1a\/prod\/users\/v4”。\n- 提供流量整形和流量转移\n- 保持负载均衡，通常采用可配置的算法\n- 提供服务发布控制（例如，金丝雀释放和流量分割）\n- 提供按请求的路由（例如，影子流量、故障注入和调试重新路由）。\n- 增加基线可靠性，如健康检查、超时 \/ 截止日期、断路和重试（预算）。\n- 通过透明的双向传输级安全（TLS）和访问控制列表（ACL）等策略，提高安全性\n- 提供额外的可观测性和监测，如顶线指标（请求量、成功率和延迟），支持分布式追踪，以及 \u0022挖掘\u0022 和检查实时服务间通信的能力。\n- 使得平台团队能够配置 \u0022 理智的默认值”，以保护系统免受不良通信的影响。\n\n服务网格的能力可分为以下四个方面：\n\n- 连接性\n- 可靠性\n- 安全性\n- 可观测性\n\n让我们看看服务网格技术在这些领域都能提供哪些功能。\n\n**连接性**\n\n- 流量控制（路由，分流）\n- 网关（入口、出口）\n- 服务发现\n- A\/B 测试、金丝雀\n- 服务超时、重试\n\n**可靠性**\n\n- 断路器\n- 故障注入 \/ 混沌测试\n\n**安全性**\n\n- 服务间认证（mTLS）\n- 证书管理\n- 用户认证（JWT）\n- 用户授权（RBAC）\n- 加密\n\n**可观测性**\n\n- 监测\n- 遥测、仪表、计量\n- 分布式追踪\n- 服务图表\n\n## 服务网格架构：内部原理\n\n服务网格由两部分组成：数据平面和控制平面。Matt Klein，[Envoy Proxy](https:\/\/www.envoyproxy.io\/) 的作者，写了一篇关于“ [服务网格数据平面与控制平面 ](https:\/\/blog.envoyproxy.io\/service-mesh-data-plane-vs-control-plane-2774e720f7fc)“的深入探讨。\n\n广义上讲，数据平面“执行工作”，负责“有条件地翻译、转发和观察流向和来自 [网络终端] 的每个网络数据包”。在现代系统中，数据平面通常以代理的形式实现，（如 Envoy、[HAProxy](http:\/\/www.haproxy.org\/) 或 [MOSN](https:\/\/github.com\/mosn\/mosn)），它作为 \u0022sidecar\u0022 与每个服务一起在进程外运行。Linkerd 使用了一种 [微型代理](https:\/\/linkerd.io\/2020\/12\/03\/why-linkerd-doesnt-use-envoy\/)方法，该方法针对服务网格的使用情况进行了优化。\n\n控制平面“监督工作”，并将数据平面的所有单个实例 —— 一组孤立的无状态 sidecar 代理变成一个分布式系统。控制平面不接触系统中的任何数据包 \/ 请求，相反，它允许人类运维人员为网格中所有正在运行的数据平面提供策略和配置。控制平面还能够收集和集中数据平面的遥测数据，供运维人员使用。\n\n控制平面和数据平面的结合提供了两方面的优势，即策略可以集中定义和管理，同时，同样的政策可以以分散的方式，在 Kubernetes 集群的每个 pod 中本地执行。这些策略可以与安全、路由、断路器或监控有关。\n\n下图取自 Istio 架构文档，虽然标注的技术是 Istio 特有的，但这些组件对所有服务网格的实现都是通用的。\n\n![Istio 架构](arch.jpg) \n\nIstio 架构，展示了控制平面和代理数据平面的交互方式（由 [Istio 文档提供](https:\/\/istio.io\/docs\/)）。\n\n## 使用案例\n\n服务网格可以实现或支持多种用例。\n\n### 动态服务发现和路由\n\n服务网格提供动态服务发现和流量管理，包括用于测试的流量影子（复制），以及用于金丝雀发布和 A\/B 实验的流量分割。\n\n服务网格中使用的代理通常是“应用层 \u0022 感知的（在 OSI 网络堆栈的第 7 层运行）。这意味着流量路由决策和指标的标记可以利用 HTTP 头或其他应用层协议元数据。\n\n### 服务间通信可靠性\n\n服务网格支持跨领域的可靠性要求的实施和执行，如请求重试、超时、速率限制和断路。服务网格经常被用来补偿（或封装）处理[分布式计算的八个谬误](https:\/\/en.wikipedia.org\/wiki\/Fallacies_of_distributed_computing)。应该注意的是，服务网格只能提供 wire-level 的可靠性支持（如重试 HTTP 请求），最终服务应该对相关的业务影响负责，如避免多个（非幂等的）HTTP POST 请求。\n\n### 流量的可观测性\n\n由于服务网格处于系统内处理的每个请求的关键路径上，它还可以提供额外的“可观测性”，例如请求的分布式追踪、HTTP 错误代码的频率以及全局和服务间的延迟。虽然在企业领域是一个被过度使用的短语，但服务网格经常被提议作为一种方法来捕获所有必要的数据，以实现整个系统内流量的统一界面视图。\n\n### 通信安全\n\n服务网格还支持跨领域安全要求的实施和执行，如提供服务身份（通过 x509 证书），实现应用级服务 \/ 网络分割（例如，“服务 A\u0022 可以与“服务 B“通信，但不能与“服务 C“通信），确保所有通信都经过加密（通过 TLS），并确保存在有效的用户级身份令牌或“[护照](https:\/\/qconsf.com\/sf2019\/presentation\/user-device-identity-microservices-netflix-scale) \u0022。\n\n## 反模式\n\n当反模式的使用出现时，这往往是一个技术成熟的标志。服务网格也不例外。\n\n### 太多的流量管理层次\n\n当开发人员不与平台或运维团队协商，并在现在通过服务网格实现的代码中重复现有的通信处理逻辑时，就会出现这种反模式。例如，除了服务网格提供的 wire-level 重试策略外，应用程序还在代码中还实现了重试策略。这种反模式会导致重复的事务等问题。\n\n### 服务网格银弹\n\n在 IT 领域没有“银弹“这样的东西，但供应商有时会被诱惑给新技术贴上这个标签。服务网格不会解决微服务、Kubernetes 等容器编排器或云网络的所有通信问题。服务网格的目的只是促进服务件（东西向）的通信，而且部署和运行服务网格有明显的运营成本。\n\n### 企业服务总线（ESB）2.0\n\n在前微服务面向服务架构（SOA）时代，企业服务总线（ESB）实现了软件组件之间的通信系统。有些人担心 ESB 时代的许多错误会随着服务网格的使用而重演。\n\n通过 ESB 提供的集中的通信控制显然有价值。然而，这些技术的发展是由供应商推动的，这导致了多种问题，例如：ESB 之间缺乏互操作性，行业标准的定制扩展（例如，将供应商的特定配置添加到 WS-* 兼容模式中），以及高成本。ESB 供应商也没有做任何事情来阻止业务逻辑与通信总线的集成和紧耦合。\n\n### 大爆炸部署\n\n在整个 IT 界有一种诱惑，认为大爆炸式的部署方法是最容易管理的方法，但正如 [Accelerate](https:\/\/itrevolution.com\/book\/accelerate\/) 和 [DevOps 报告](https:\/\/puppet.com\/resources\/report\/state-of-devops-report\/)的研究，事实并非如此。由于服务网格的全面推广意味着这项技术处于处理所有终端用户请求的关键路径上，大爆炸式的部署是非常危险的。\n\n### 死星建筑\n\n当企业采用微服务架构，开发团队开始创建新的微服务或在应用中利用现有的服务时，服务间的通信成为架构的一个关键部分。如果没有一个良好的治理模式，这可能会导致不同服务之间的紧密耦合。当整个系统在生产中出现问题时，也将很难确定哪个服务出现了问题。\n\n如果缺乏服务沟通战略和治理模式，该架构就会变成所谓的“死星架构”。\n\n关于这种架构反模式的更多信息，请查看关于云原生架构采用的[第一部分](https:\/\/www.infoq.com\/articles\/cloud-native-architecture-adoption-part1\/)、[第二部分](https:\/\/www.infoq.com\/articles\/cloud-native-architecture-adoption-part2\/)和[第三部分的](https:\/\/www.infoq.com\/articles\/cloud-native-architecture-adoption-part3\/)文章。\n\n### 特定领域的服务网格\n\n服务网格的本地实现和过度优化有时会导致服务网格部署范围过窄。开发人员可能更喜欢针对自己的业务领域的服务网格，但这种方法弊大于利。我们不希望实现过于细化的服务网格范围，比如为组织中的每个业务或功能域（如财务、人力资源、会计等）提供专用的服务网格。这就违背了拥有像服务网格这样的通用服务协调解决方案的目的，即企业级服务发现或跨域服务路由等功能。\n\n## 服务网格的实现和产品\n\n以下是一份非详尽的当前服务网格实施清单。\n\n- [Linkerd ](https:\/\/linkerd.io\/)(CNCF 毕业项目)\n- [Istio](https:\/\/istio.io\/)\n- [Consul](https:\/\/www.consul.io\/)\n- [Kuma](https:\/\/kuma.io\/)（CNCF 沙盒项目）\n- [AWS App Mesh](https:\/\/aws.amazon.com\/app-mesh\/)\n- [NGINX Service Mesh](https:\/\/www.nginx.com\/products\/nginx-service-mesh\/)\n- [AspenMesh](https:\/\/aspenmesh.io\/)\n- [Kong](https:\/\/konghq.com\/kong-mesh\/)\n- [Solo Gloo Mesh](https:\/\/www.solo.io\/products\/gloo-mesh\/)\n- [Tetrate Service Bridge](https:\/\/www.tetrate.io\/tetrate-service-bridge\/)\n- [Traefik Mesh](http:\/\/traefik.io\/traefik-mesh)（原名 Maesh）。\n- [Meshery](http:\/\/layer5.io\/meshery)\n- [Open Service MEsh](http:\/\/openservicemesh.io\/)（CNCF 沙盒项目）。\n\n另外，像 [DataDog](https:\/\/www.datadoghq.com\/blog\/tag\/service-mesh\/) 这样的其他产品也开始提供与 [Linkerd](https:\/\/docs.datadoghq.com\/integrations\/linkerd\/?tab=host)、Istio、Consul Connect 和 AWS App Mesh 等服务网格技术的集成。\n\n## 服务网格对比\n\n服务网格领域的发展极为迅速，因此任何试图创建比较的努力都可能很快变得过时。然而，确实存在一些比较。应该注意了解来源的偏见（如果有的话）和进行比较的日期。\n\n- https:\/\/layer5.io\/landscape\n- https:\/\/kubedex.com\/istio-vs-linkerd-vs-linkerd2-vs-consul\/（截至 2021 年 8 月的正确数据）\n- https:\/\/platform9.com\/blog\/kubernetes-service-mesh-a-comparison-of-istio-linkerd-and-consul\/（截至 2019 年 10 月的最新情况）\n- [https:\/\/servicemesh.es\/ ](https:\/\/servicemesh.es\/)(最后发表于 2021 年 8 月)\n\nInfoQ 一直建议服务网格的采用者对每个产品进行自己的尽职调查和试验。\n\n## 服务网格教程\n\n对于希望试验多服务网格的工程师或建筑师来说，可以使用以下教程、游戏场和工具。\n\n- [Layer 5 Meshery](https:\/\/layer5.io\/meshery)—— 多网格管理平面\n- [Solo 的 Gloo Mesh](https:\/\/github.com\/solo-io\/supergloo)—— 服务网格编排平台\n- KataCoda Istio 教程\n- [Consul 服务网格教程](https:\/\/learn.hashicorp.com\/consul)\n- [Linkerd 教程](https:\/\/linkerd.io\/2\/getting-started\/)\n- [NGINX 服务网格教程](https:\/\/docs.nginx.com\/nginx-service-mesh\/tutorials\/)\n- [Istio 基础教程](https:\/\/tetrate-academy.thinkific.com\/courses\/istio-fundamentals-zh)\n\n## 服务网格的历史\n\n自 2013 年底 Airbnb 发布 [SmartStack](https:\/\/medium.com\/airbnb-engineering\/smartstack-service-discovery-in-the-cloud-4b8a080de619)，为新兴的“ [微服务 ](https:\/\/www.infoq.com\/microservices\/)“风格架构提供进程外服务发现机制（使用 [HAProxy](http:\/\/www.haproxy.org\/)）以来，InfoQ 一直在跟踪这个我们现在称之为 [服务网格](https:\/\/www.infoq.com\/servicemesh\/)的话题。许多之前被贴上“独角兽“标签的组织在此之前就在研究类似的技术。从 21 世纪初开始，谷歌就在开发其 [Stubby ](https:\/\/grpc.io\/blog\/principles\/)RPC 框架，该框架演变成了 [gRPC](https:\/\/cloud.google.com\/blog\/products\/gcp\/grpc-a-true-internet-scale-rpc-framework-is-now-1-and-ready-for-production-deployments)，以及 [谷歌前端（GFE）](https:\/\/landing.google.com\/sre\/sre-book\/chapters\/production-environment\/)和全局软件负载均衡器（GSLB），在 [Istio](https:\/\/istio.io\/) 中可以看到它们的特质。在 2010 年代早期，Twitter 开始了 Scala 驱动的 [Finagle](https:\/\/twitter.github.io\/finagle\/) 的工作，[Linkerd](https:\/\/linkerd.io\/) 服务网格由此产生。\n\n2014 年底，Netflix 发布了[一整套基于 JVM 的实用程序](https:\/\/netflix.github.io\/)，包括 [Prana](https:\/\/www.infoq.com\/news\/2014\/12\/netflix-prana\/)，一个“sidecar“程序，允许用任何语言编写的应用服务通过 HTTP 与库的独立实例进行通信。2016 年，NGINX 团队开始谈论“[Fabric 模型](https:\/\/www.nginx.com\/blog\/microservices-reference-architecture-nginx-fabric-model\/) \u0022，这与服务网格非常相似，但需要使用他们的商业 NGINX Plus 产品来实现。另外，Linkerd v0.2 在 2016 年 2 月[发布](https:\/\/linkerd.io\/2016\/02\/18\/linkerd-twitter-style-operability-for-microservices\/)，尽管该团队直到后来才开始称它为服务网格。\n\n服务网格历史上的其他亮点包括 2017 年 5 月的 [Istio](https:\/\/istio.io\/)、2018 年 7 月的 [Linkerd 2.0](https:\/\/linkerd.io\/2018\/09\/18\/announcing-linkerd-2-0\/)、2018 年 11 月的 [Consul Connect](https:\/\/www.hashicorp.com\/products\/consul\/service-mesh) 和 [Gloo Mesh](https:\/\/github.com\/solo-io\/supergloo)、2019 年 5 月的 [服务网格接口（SMI）](https:\/\/smi-spec.io\/)，以及 2019 年 9 月的 Maesh（现在叫 Traefik Mesh）和 Kuma。\n\n即使是在独角兽企业之外出现的服务网格，如 HashiCorp 的 [Consul](https:\/\/www.consul.io\/)，也从上述技术中获得了灵感，通常旨在实现 CoreOS 提出的“[GIFEE ](https:\/\/github.com\/linearregression\/GIFEE)“概念；所有人可用的 Google 基础设施（Google infrastructure for everyone else）。\n\n为了深入了解现代服务网格概念的演变历史，[Phil Calçado](https:\/\/philcalcado.com\/) 写了一篇全面的文章“ [模式：服务网格](https:\/\/philcalcado.com\/2017\/08\/03\/pattern_service_mesh.html) \u0022。\n\n## 服务网格标准\n\n尽管在过去的几年里，服务网格技术年复一年地发生着重大转变，但服务网格的标准还没有跟上创新的步伐。\n\n使用服务网格解决方案的主要标准是[服务网格接口](https:\/\/smi-spec.io\/)（SMI）。服务网格接口是在 [Kubernetes](https:\/\/kubernetes.io\/) 上运行的服务网格的一个规范。它本身并没有实现服务网格，而是定义了一个通用的标准，可以由各种服务网格供应商来实现。\n\nSMI API 的目标是提供一套通用的、可移植的服务网格 API，Kubernetes 用户可以以一种与提供者无关的方式使用。通过这种方式，人们可以定义使用服务网格技术的应用程序，而不需要与任何特定的实现紧密结合。\n\nSMI 基本上是一个 Kubernetes 自定义资源定义（[CRD](https:\/\/kubernetes.io\/docs\/tasks\/extend-kubernetes\/custom-resources\/custom-resource-definitions\/)）和扩展 API 服务器的集合。这些 API 可以安装到任何 Kubernetes 集群，并使用标准工具进行操作。为了激活这些 API，需要在 Kubernetes 集群中运行一个 SMI 提供者。\n\nSMI 规范既允许终端用户的标准化，也允许服务网格技术提供商的创新。SMI 实现了灵活性和互操作性，并涵盖了最常见的服务网格功能。目前的[规范组件](https:\/\/github.com\/servicemeshinterface\/smi-spec\/tree\/main\/apis)集中在服务网格能力的连接方面。API 规范包括以下内容。\n\n- 流量访问控制\n- 流量指标\n- 流量规格\n- 流量分割\n\n目前的 SMI [生态系统](https:\/\/github.com\/servicemeshinterface\/smi-spec)包括广泛的服务网格，包括 Istio、Linkerd、Consul Connect、Gloo Mesh 等。\n\nSMI 规范是在 [Apache License 2.0 版本下](http:\/\/www.apache.org\/licenses\/)[许可的](https:\/\/github.com\/servicemeshinterface\/smi-spec\/blob\/main\/LICENSE)。\n\n如果你想了解更多关于 SMI 规范及其 API 细节，请查看以下链接。\n\n- [核心规范](https:\/\/github.com\/servicemeshinterface\/smi-spec\/blob\/main\/SPEC_LATEST_STABLE.md)（当前版本：0.6.0）\n- [规范 Github 项目](https:\/\/github.com\/servicemeshinterface\/smi-spec)\n- [如何贡献](https:\/\/github.com\/servicemeshinterface\/smi-spec\/blob\/main\/CONTRIBUTING.md)\n\n## 服务网格基准测试\n\n[服务网格性能](https:\/\/smp-spec.io\/)是一个捕捉基础设施容量、服务网配置和工作负载元数据细节的标准。SMP 规范用于捕捉以下细节。\n\n- 环境和基础设施细节\n- 节点的数量和规模，编排器\n- 服务网格和它的配置\n- 工作量 \/ 应用细节\n- 进行统计分析以确定性能特征\n\n来自 Linkerd 团队的 William Morgan [写了](https:\/\/linkerd.io\/2021\/05\/27\/linkerd-vs-istio-benchmarks\/)关于 Linkerd 和 Istio 的性能基准测试。还有一篇来自 2019 年的[文章](https:\/\/istio.io\/latest\/blog\/2019\/performance-best-practices\/)，介绍了 Istio 关于服务网格性能基准测试的最佳实践。\n\n重要的是要记住，就像其他性能基准测试一样，你不应该对任何这些外部出版物投入过多的注意力，特别是产品供应商发表的文章。该在你的服务器环境中设计和执行你自己的性能测试，以验证哪个具体产品适合你的应用程序的业务和非功能要求。\n\n## 探索服务网格的未来\n\n[Kasun Indrasiri](https:\/\/www.infoq.com\/profile\/Kasun-Indrasiri\/) 探讨了“ [为事件驱动的消息传递使用服务网格的潜力](https:\/\/www.infoq.com\/articles\/service-mesh-event-driven-messaging\/) \u0022，他在其中讨论了在服务网格中实现消息传递支持的两种主要的新兴架构模式：协议代理 sidecar 和 HTTP 桥接 sidecar。这是服务网格社区中一个活跃的发展领域，在 [Envoy 中](https:\/\/github.com\/envoyproxy\/envoy\/issues\/2852)支持 [Apache Kafka 的](https:\/\/github.com\/envoyproxy\/envoy\/issues\/2852)工作引起了相当多的关注。\n\nChristian Posta 之前在“[Towards a Unified, Standard API for Consolidating Service Meshes ](https:\/\/www.infoq.com\/articles\/service-mesh-api-federating\/)中写过关于服务网格使用标准化的尝试。这篇文章还讨论了 2019 年微软和合作伙伴在 KubeCon EU 上宣布的[服务网格接口（SMI）](https:\/\/cloudblogs.microsoft.com\/opensource\/2019\/05\/21\/service-mesh-interface-smi-release\/)。SMI 定义了一套通用和可移植的 API，旨在为开发人员提供不同服务网格技术的互操作性，包括 Istio、Linkerd 和 Consul Connect。\n\n将服务网格与平台结构整合的主题可以进一步分为两个子主题。\n\n首先，正在进行的工作是减少由服务网格数据平面引入的网络开销。这包括[数据平面开发工具包（DPDK）](https:\/\/www.dpdk.org\/)，它是一个[用户空间应用程序](https:\/\/www.linuxjournal.com\/content\/userspace-networking-dpdk)，“绕过了 Linux 内核网络堆栈，直接与网络硬件对话”。还有 [Cilium 团队的](https:\/\/www.infoq.com\/news\/2018\/03\/cilium-linux-bpf\/)基于 Linux 的 BPF 解决方案，它利用 Linux 内核中的扩展[伯克利包过滤器（eBPF）功能](https:\/\/cilium.io\/blog\/istio\/)来实现“非常有效的网络、策略执行和负载均衡功能”。另一个团队正在用[网络服务网格（Network Service Mesh）](https:\/\/github.com\/networkservicemesh\/networkservicemesh\/)将服务网格的概念映射到 L2\/L3 有效载荷，试图“以云原生的方式重新想象网络功能虚拟化（NFV）\u0022。\n\n其次，有多项举措将服务网格与公共云平台更紧密地结合在一起，从 [AWS App Mesh](https:\/\/www.infoq.com\/news\/2019\/01\/aws-app-mesh\/)、[GCP Traffic Director](https:\/\/www.infoq.com\/news\/2019\/04\/google-traffic-director\/) 和 [Azure Service Fabric Mesh 的](https:\/\/www.infoq.com\/articles\/azure-service-fabric-mesh\/)发布可见端倪。\n\nBuoyant 团队致力于为服务网格技术开发有效的以人为本的控制平面。他们最近发布了 [Buoyant Cloud](https:\/\/buoyant.io\/cloud\/)，一个基于 SaaS 的“团队控制平面”，用于平台团队操作 Kubernetes。这个产品将在下面的章节中详细讨论。\n\n自去年以来，在服务网格领域也有一些创新。\n\n### 多云、多集群、多租户服务网格\n\n近年来，不同组织对云的采用已经从单一的云解决方案（私有云或公共云）转变为由多个不同供应商（AWS、谷歌、微软 Azure 等）支持的基于多云（私有、公共和混合）的新基础设施。同时，需要支持不同的工作负载（交易、批处理和流媒体），这对实现统一的云架构至关重要。\n\n这些业务和非功能需求反过来又导致需要在异构基础设施（裸机、虚拟机和 Kubernetes）中部署服务网格解决方案。服务网格需要相应转变，以支持这些不同的工作负载和基础设施。\n\n像 [Kuma](https:\/\/konghq.com\/blog\/multi-cluster-multi-cloud-service-meshes-with-cncfs-kuma-and-envoy\/) 和 [Tetrate Service Bridge](https:\/\/www.tetrate.io\/tetrate-service-bridge\/) 这样的技术支持多网格控制平面，以使业务应用在多集群和多云服务网格环境中工作。这些解决方案抽象出跨多个区域的服务网格策略的同步以及跨这些区域的服务连接（和服务发现）。\n\n多集群服务网格技术的另一个新趋势是需要从边缘计算层（物联网设备）到网格层的应用 \/ 服务连接。\n\n### 媒体服务网格\n\n思科系统公司开发的[媒体流网格（Media Streaming Mesh）](https:\/\/www.ciscotechblog.com\/blog\/introducing-media-streaming-mesh\/)或媒体服务网格，用于协调实时应用程序，如多人游戏、多方视频会议或在 Kubernetes 云平台上使用服务网格技术的 CCTV 流。这些应用正越来越多地从单体应用转向微服务架构。服务网格可以通过提供负载均衡、加密和可观测性等功能来帮助应用程序。\n\n### 混沌网格\n\n[Chaos Mesh](https:\/\/chaos-mesh.org\/) 是 [CNCF 托管的项目](https:\/\/community.cncf.io\/chaos-mesh-community\/)，是一个开源的、云原生的混沌工程平台，用于托管在 Kubernetes 上的应用程序。虽然不是直接的服务网格实现，但 Chaos Mesh 通过协调应用程序中的故障注入行为来实现混沌工程实验。故障注入是服务网格技术的一个关键能力。\n\nChaos Mesh 隐藏了底层的实现细节，因此应用开发者可以专注于实际的混沌实验。Chaos Mesh [可以和服务网格一起使用](https:\/\/chaos-mesh.org\/blog\/chaos-mesh-q\u0026a\/)。请看这个[用例](https:\/\/github.com\/sergioarmgpl\/operating-systems-usac-course\/blob\/master\/lang\/en\/projects\/project1v3\/project1.md)，该团队如何使用 Linkerd 和 Chaos Mesh 来为他们的项目进行混沌实验。\n\n### 服务网格作为一种服务\n\n一些服务网格供应商，如 Buoyant，正在提供管理服务网格或“服务网格作为一种服务“的解决方案。今年早些时候，Buoyant [宣布](https:\/\/buoyant.io\/newsroom\/buoyant-cloud-offers-managed-service-mesh\/)公开测试发布一个名为 [Buoyant Cloud 的](http:\/\/buoyant.io\/cloud) SaaS 应用程序，允许客户组织利用 Linkerd 服务网格的按需支持功能来管理服务网格。\n\nBuoyant Cloud 解决方案提供的一些功能包括如下：\n\n- 自动跟踪 Linkerd 数据平面和控制平面的健康状况\n- 在 Kubernetes 平台上管理跨 pod、代理和集群的服务网格生命周期和版本\n- 以 SRE 为重点的工具，包括服务水平目标（SLO）、工作负荷黄金指标跟踪和变更跟踪\n\n### 网络服务网格（NSM）\n\n网络服务网格（[NSM](https:\/\/networkservicemesh.io\/)）是云原生计算基金会的另一个沙盒项目，提供了一个混合的、多云的 IP 服务网格。NSM 实现了网络服务连接、安全和可观测性等功能，这些都是服务网格的核心特征。NSM 与现有的容器网络接口（[CNI](https:\/\/github.com\/containernetworking\/cni)）实现协同工作。\n\n### 服务网格扩展\n\n服务网格扩展是另一个已经看到很多创新的领域。服务网格扩展的一些发展包括：\n\n- 增强的身份管理，以确保微服务连接的安全，包括自定义证书授权插件\n- 自适应路由功能，以提高服务的可用性和可扩展性\n- 加强 sidecar 代理权\n\n### 服务网格业务\n\n采用服务网格的另一个重要领域是服务网格生命周期的运维方面。操作方面 —— 如配置多集群功能和将 Kubernetes 工作负载连接到虚拟机基础设施上托管的服务器，以及管理多集群服务网格中所有功能和 API 的开发者门户 —— 将在生产中服务网格解决方案的整体部署和支持方面发挥重要作用。\n\n## 常见问题\n\n### 什么是服务网格？\n\n服务网格是一种在分布式（可能是基于微服务的）软件系统内管理所有服务对服务（东西向）流量的技术。它既提供以业务为重点的功能操作，如路由，也提供非功能支持，如执行安全策略、服务质量和速率限制。它通常（尽管不是唯一的）使用 sidecar 代理来实现，所有服务都通过 sidecar 代理进行通信。\n\n### 服务网格与 API 网关有什么不同？\n\n关于服务网格的定义，见上文。\n\n另一方面，API 网关管理进入集群的所有入口（南北）流量，并为跨功能的通信要求提供额外支持。它作为进入系统的单一入口点，使多个 API 或服务凝聚在一起，为用户提供统一的体验。\n\n### 如果我正在部署微服务，我是否需要服务网格？\n\n不一定。服务网格增加了技术栈的操作复杂性，因此通常只有在组织在扩展服务与服务之间的通信方面遇到困难，或者有特定的用例需要解决时才会部署。\n\n### 我是否需要服务网格来实现微服务的服务发现？\n\n不，服务网格提供了实现服务发现的一种方式。其他解决方案包括特定语言的库（如 Ribbon 和 [Eureka](https:\/\/www.infoq.com\/news\/2012\/09\/Eureka\/) 或 [Finagle](https:\/\/www.infoq.com\/finagle\/)）。\n\n### 服务网格是否会给我的服务之间的通信增加开销 \/ 延迟？\n\n是的，当一个服务与另一个服务进行通信时，服务网格至少会增加两个额外的网络跳数（第一个是来自处理源的出站连接的代理，第二个是来自处理目的地的入站连接的代理）。然而，这个额外的网络跳转通常发生在 [localhost 或 loopback 网络接口](https:\/\/en.wikipedia.org\/wiki\/Localhost)上，并且只增加了少量的延迟（在毫秒级）。实验和了解这对目标用例是否是一个问题，应该是服务网格分析和评估的一部分。\n\n### 服务网格不应该是 Kubernetes 或应用程序被部署到的 \u0022云原生平台\u0022 的一部分吗？\n\n潜在的。有一种说法是在云原生平台组件内保持关注点的分离（例如，Kubernetes 负责提供容器编排，而服务网格负责服务间的通信）。然而，正在进行的工作是将类似服务网格的功能推向现代平台即服务（PaaS）产品。\n\n### 我如何实施、部署或推广服务网格？\n\n最好的方法是分析各种服务网格产品（见上文），并遵循所选网格特有的实施准则。一般来说，最好是与所有利益相关者合作，逐步将任何新技术部署到生产中。\n\n### 我可以建立自己的服务网格吗？\n\n是的，但更相关的问题是，你应该吗？建立一个服务网格是你组织的核心竞争力吗？你能否以更有效的方式为你的客户提供价值？你是否也致力于维护你自己的网络，为安全问题打补丁，并不断更新它以利用新技术？由于现在有一系列的开源和商业服务网格产品，使用现有的解决方案很可能更有效。\n\n### 在一个软件交付组织内，哪个团队拥有服务网格？\n\n通常，平台或运维团队拥有服务网格，以及 Kubernetes 和持续交付管道基础设施。然而，开发人员将配置服务网格的属性，因此这两个团队应该紧密合作。许多企业正在追随云计算先锋的脚步，如 Netflix、Spotify 和谷歌，并正在创建内部平台团队，为[以产品为重点的全周期开发团队](https:\/\/www.infoq.com\/news\/2018\/06\/netflix-full-cycle-developers\/)提供工具和服务。\n\n### Envoy 是一个服务网格吗？\n\nEnvoy 是一个云原生代理，最初是由 Lyft 团队设计和构建的。Envoy 经常被用作服务网格的数据平面。然而，为了被认为是一个服务网格，Envoy 必须与控制平面一起使用，这样才能使这些技术集合成为一个服务网格。控制平面可以是简单的集中式配置文件库和指标收集器，也可以是全面 \/ 复杂的 Istio。\n\n### Istio 和“服务网格 \u0022 这两个词可以互换使用吗？\n\n不，Istio 是服务网格的一种。由于 Istio 在服务网格类别出现时很受欢迎，一些人将 Istio 和服务网格混为一谈。这个混淆的问题并不是服务网格所独有的，同样的挑战发生在 Docker 和容器技术上。\n\n### 我应该使用哪个服务网格？\n\n这个问题没有唯一的答案。工程师必须了解他们当前的需求，以及他们的实施团队的技能、资源和时间。上面的服务网格比较链接将提供一个良好的探索起点，但我们强烈建议企业至少尝试两个网格，以了解哪些产品、技术和工作流程最适合他们。\n\n### 我可以在 Kubernetes 之外使用服务网吗？\n\n是的。许多服务网格允许在各种基础设施上安装和管理数据平面代理和相关控制平面。[HashiCorp 的 Consul](https:\/\/www.hashicorp.com\/resources\/consul-service-mesh-kubernetes-and-beyond) 是最知名的例子，Istio 也被实验性地用于 Cloud Foundry。\n\n## 其他资源\n\n- [InfoQ 服务网格主页](https:\/\/www.infoq.com\/servicemesh\/)\n- [InfoQ eMag：服务网格的过去、现在和未来](https:\/\/www.infoq.com\/minibooks\/service-mesh\/)\n- [服务网格：每位软件工程师都需要了解的世界上最容易被滥用的技术](https:\/\/servicemesh.io\/)\n- [服务网格的比较](https:\/\/servicemesh.es\/)\n- [服务网格](https:\/\/softwareengineeringdaily.com\/2020\/01\/07\/service-meshes\/)\n- [采用云原生架构，第三部分：服务协调和服务网格](https:\/\/www.infoq.com\/articles\/cloud-native-architecture-adoption-part3\/)\n', '\/trans\/service-mesh-ultimate-guide-e2\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文是 InfoQ 自 2020 年 2 月发表的服务网格终极指南后的第二版，发布于 2021 年 9 月。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/service-mesh-unnecessary-complexity/">[译] 远离复杂性——服务网格需要更加务实</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2021/09/28</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://www.infoq.com/articles/service-mesh-unnecessary-complexity/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('远离复杂性——服务网格需要更加务实', '服务网格是 Kubernetes 世界中的一个热门话题，但许多潜在的采用者已经失去了耐心。', '\n## 主要收获\n\n- 采用服务网格有巨大的价值，但必须以轻便的方式进行，以避免不必要的复杂性。\n- 在实施服务网格时，要采取务实的方法，与技术的核心功能保持一致，并注意分散注意力的问题。\n- 服务网格的一些核心特征包括标准化监控、自动加密和身份识别、智能路由、可靠的重试和网络可扩展性。\n- 服务网格可以提供强大的功能，但这些功能可能会分散对核心利益的注意力，并不被视为实施服务网格的主要原因。\n- 一些值得注意的分心，可能对你的初始实施没有必要，包括复杂的控制平面、多集群支持、Envoy、WASM 和 A\/B 测试。\n\n服务网格是 Kubernetes 世界中的一个热门话题，但许多潜在的采用者已经失去了耐心。服务网格的采用受到了巨大的复杂性和似乎无穷无尽的供应商解决方案的限制。在我自己浏览了这个领域后，我发现采用服务网格有巨大的价值，但必须以轻量级的方式进行，以避免不必要的复杂性。尽管普遍存在幻灭感，但服务网格的前景依然光明。\n\n## 在工作中学习\n\n我进入服务网格的世界，始于我在一家历史悠久的财富 500 强科技公司担任云计算架构师。在我们的服务网格旅程开始时，我身边有许多强大的工程师，但大多数人几乎没有云开发的经验。我们的组织诞生于云计算之前，要完全实现云计算的价值需要时间。我们的传统业务线主要集中在技术堆栈的硬件元素上，而云计算的决策最初是由为运送硬件或为这些硬件提供固件和驱动程序而开发的流程所驱动。 \n\n随着这个组织经历了 \u0022数字化转型\u0022，它越来越依赖于提供高质量的软件服务，并逐渐形成了更好的方法论。但是，作为云计算架构师，我仍然在为优先考虑硬件的业务流程和具有不同技能组合、流程和信念的工程团队而奔波。随着时间的推移，我和我的团队在将.NET 应用程序迁移到 Linux、采用 Docker、迁移到 AWS 以及与之相关的最佳实践（如持续集成、自动部署、不可变基础设施、基础设施即代码、监控等）方面变得熟练和成功，但挑战仍然存在。\n\n在这段时间里，我们开始将我们的应用程序分割成一系列的微服务。起初，这是一个缓慢的转变，但最终这种方法流行起来，开发人员开始喜欢建立新的服务而不是增加现有的服务。我们这些基础设施团队的人把这看作是一种成功。唯一的问题是，与网络有关的问题数量激增，开发人员正在向我们寻求答案，而我们还没有准备应用这种冲击。\n\n## 服务网格拯救了我们\n\n我第一次听说服务网格是在 2015 年，当时我正在研究服务发现工具，并寻找与 Consul 集成的简单方法。我很喜欢把应用责任下沉到 \u0022sidecar\u0022容器的想法，并找到了一些可以做到这一点的工具。大约在这个时候，Docker 有一个叫做 \u0022linking\u0022的功能，让你把两个应用程序放在一个共享的网络空间中，这样它们就可以通过本地主机进行通信。这个功能提供了一个类似于我们现在在 Kubernetes pod 内的体验。两个独立构建的服务可以在部署时进行组合，以实现一些额外的功能。\n\n我总是抓住机会用简单的解决方案来解决大问题，所以这些新功能的力量立即打动了我。虽然这个工具是为了与 Consul 集成，但在实践中，它可以做任何你想要的事情。它是我们拥有的基础设施的一个新的层级，可以用来为每个人解决问题。\n\n这方面的一个具体例子是在我们采用过程的早期。当时，我们正在努力使许多不同服务的日志输出标准化。通过采用服务网格和这种新的设计模式，我们能够把我们的人的问题——让开发人员标准化他们的日志，转变成技术问题——把所有的服务流量通过一个可以为他们做日志记录的代理。这对我们的团队来说是一个重大的进步。\n\n我们对服务网格的实施是非常务实的，并与该技术的核心功能保持一致。然而，许多营销炒作可能集中在不太需要的边缘案例上，在评估服务网格是否适合你时，能够识别这些干扰是很重要的。\n\n## 核心功能\n\n服务网格可以提供的核心功能分为四个关键责任领域：可观测性、安全性、连接性和可靠性。\n\n## 标准化的监控\n\n这是我们最成功的地方之一，也是最简单的采用，就是标准化的监测。它的运营成本很低，而且可以被制作成适合你使用的任何监控系统。它使企业能够捕获他们所有的 HTTP 或 gRPC 指标，并在整个系统中以标准方式存储它们。这就控制了复杂性，减轻了应用团队的负担，他们不再需要实施 Prometheus 指标端点或标准化日志格式。它还使用户能够对其应用程序的[黄金信号](https:\/\/sre.google\/sre-book\/monitoring-distributed-systems\/#xref_monitoring_golden-signals)有一个公正的看法。 \n\n**自动加密和身份识别**\n\n证书管理是很难做好的。如果一个组织还没有在这方面投资，他们应该找一个网格来为他们做这件事。证书管理需要维护复杂的基础设施代码，具有巨大的安全影响。相比之下，网格将能够与编排系统集成，了解工作负载的身份，在需要时可以用来执行策略。这允许一个真正强大的安全态势，相当于或优于那些由 Calico 或 Cilium 等功能丰富的 CNI 提供的安全态势。\n\n## 智能路由\n\n智能路由是另一项功能，使网格在发送请求时能 \u0022做正确的事\u0022。应用如下：\n\n1. 使用延迟加权算法优化流量\n2. 拓扑感知路由，提高性能并降低成本\n3. 根据请求成功的可能性来确定时间\n4. 与编排系统集成以实现 IP 解析，而不是依赖 DNS\n5. 传输升级，如 HTTP 到 HTTP\/2\n\n这些功能可能不会让普通人感到兴奋，但随着时间的推移，它们带来了更多的价值。\n\n## 可靠的重试\n\n在分布式系统中重试请求可能很麻烦，然而，这总是需要实施的。分布式系统通常会将一个客户端请求转换为下游的许多请求，这意味着 \u0022尾巴\u0022情况的可能性大大增加，例如发生异常的失败请求。对此，最简单的缓解措施是重试失败的请求。\n\n困难来自于避免 \u0022重试风暴\u0022或 \u0022重试 DDoS\u0022，即当一个处于退化状态的系统触发重试时，随着重试的增加，负载增加，性能进一步下降。一个天真的实现不会考虑到这种情况，因为它可能需要与缓存或其他通信系统集成，以知道重试是否值得执行。服务网格可以通过提供整个系统允许的重试总数的约束来做到这一点。服务网格还可以在这些重试发生时进行报告，有可能在你的用户注意到之前提醒你系统的退化。\n\n## 网络可扩展性\n\n也许服务网格的最佳属性是其可扩展性。它提供了一个额外的适配层，可以承担 IT 部门接下来的任何工作。Sidecar 代理的设计模式是另一个令人兴奋和强大的功能，即使它有时被过度宣传和过度设计来做用户和技术还没有准备好的事情。当社区在等待哪个服务网格\u0022胜出\u0022时，这反映了之前被过度炒作的编排战争，我们将不可避免地在未来看到更多专门的网格，而且很可能有更多的最终用户建立自己的控制平面和代理来满足他们的使用情况。\n\n## 服务网格分心\n\n平台或基础设施控制层的价值怎么强调都不过分。然而，在服务网格的世界中，我了解到一个主要的挑战是，服务网格所解决的核心问题往往甚至不是大多数服务网格项目的沟通重点。\n\n相反，许多来自服务网格项目的沟通都是围绕着那些听起来很强大或令人兴奋的功能，但最终却让人分心。包括以下内容。\n\n## 强大（复杂）的控制平面\n\n要很好地运行复杂的软件是非常困难的。这就是为什么如此多的组织使用云计算，使用完全托管的服务。那么，为什么服务网格项目会让我们负责运行如此复杂的系统？系统的复杂性不是一种资产，而是一种责任，然而大多数项目都在吹嘘他们的功能集和可配置性。\n\n## 多集群支持\n\n多集群是现在的一个热门话题。大多数团队最终都会运行多个 Kubernetes 集群。但多集群的主要痛点是你的 Kubernetes 管理网络被分割成两半。服务网格帮助解决这个 Kubernetes 的扩展问题，但它最终并没有实现任何新的东西。是的，多集群支持是必要的，但它对服务网格的承诺被过度宣传了。\n\n## Envoy\n\nEnvoy 是一个伟大的工具，但它被当作某种标准来介绍，这是有问题的。Envoy 是许多开箱即用的代理之一，你可以在此基础上建立一个服务网格平台。但是，Envoy 并没有什么内在的特别之处，使它成为正确的选择。采用 Envoy 会给你的组织带来一系列重要的问题，包括：\n\n- 运行时间成本和性能（所有这些过滤器加起来）\n- 计算资源要求以及如何随负载变化而变化\n- 如何调试错误或意外行为\n- 你的网格如何与 Envoy 进行交互，以及配置的生命周期是什么\n- 运作成熟的时间（这可能比你预期的要长）\n\n服务网格中代理的选择应该是一个实施细节，而不是一个产品要求。\n\n## WASM\n\n我是 Web Assembly（WASM）的忠实粉丝，曾成功地用它在[Blazor](https:\/\/dotnet.microsoft.com\/apps\/aspnet\/web-apps\/blazor)中构建前端应用程序。然而，WASM 作为定制服务网格代理行为的工具，使你完全陷入了获得全新的软件生命周期开销的境地，这与你现有的软件生命周期是完全分离的。如果你的组织还没有准备好构建、测试、部署、维护、监控、回滚和版本代码（影响通过其系统运行的每个请求），那么你还没有准备好使用 WASM。\n\n## A\/B 测试\n\n当我意识到 A\/B 测试实际上是一个应用程序级别的问题已经太晚了。在基础设施层提供基元来实现它是可以的，但没有简单的方法来完全自动化大多数组织需要的 A\/B 测试水平。通常情况下，应用程序需要定义独特的指标，以确定测试的积极信号。如果一个组织想在服务网格层实施 A\/B 测试，以下是解决方案需要支持的内容：\n\n1. 对部署和回滚的精细控制，因为很可能有多个不同的 \u0022测试\u0022在同一时间进行\n2. 能够捕获系统知道的自定义指标，并能根据这些指标做出决定\n3. 根据请求的特点暴露出对流量方向的控制，这可能包括解析整个请求主体\n\n这是很难实现的，而且没有一个服务网格能做到开箱即用。最终，我们的组织选择了一个网格之外的功能标记解决方案，它以最小的努力取得了巨大的成功。\n\n## 我们终将走向何方\n\n最终，我们所面临的挑战并不是服务网格所独有的。我们工作的组织有一系列的限制条件，要求我们对解决的问题和解决的方式采取务实的态度。我们面临的问题包括： \n\n- 拥有大量不同技能的开发人员的大型组织\n- 一般来说，云计算和 SaaS 能力不成熟\n- 为非云计算软件优化的流程\n- 分散的软件工程方法和信念\n- 资源有限\n- 咄咄逼人的最后期限 \n\n简而言之，我们人少，问题多，而且需要快速展示价值。我们必须支持那些主要不是网络或云计算的开发者，我们需要扩大规模以支持大型工程组织，这些组织有不同的方法和流程来做云计算的事情。我们需要把大部分精力放在解决成熟度曲线上低的基本问题上。\n\n最后，当我们面临自己的服务网格决定时，我们决定建立在[Linkerd 服务网格](https:\/\/linkerd.io\/)之上，因为它最符合我们的优先事项：低运营成本（包括计算和人力）、低认知开销、支持性社区和透明的管理，同时满足我们的功能要求和预算。在 Linkerd 指导委员会呆了很短的时间（他们喜欢诚实的反馈和社区参与），我了解到它与我自己的工程原则是多么的吻合。Linkerd 最近[在 CNCF](https:\/\/www.cncf.io\/announcements\/2021\/07\/28\/cloud-native-computing-foundation-announces-linkerd-graduation\/)达到了[毕业状态](https:\/\/www.cncf.io\/announcements\/2021\/07\/28\/cloud-native-computing-foundation-announces-linkerd-graduation\/)，这是一个漫长的过程，强调了项目的成熟度以及它的广泛采用。\n\n## 关于作者\n\n**Chris Campbell** 从事软件工程师和架构师工作超过十年，与多个团队和组织合作，采用云原生技术和最佳实践。他的工作时间分为两部分，一部分是与企业领导合作，采用软件交付策略来加速业务发展，另一部分是与工程团队合作，提供可扩展的云基础设施。他最感兴趣的是能提高开发人员生产力和体验的技术。\n', '\/trans\/service-mesh-unnecessary-complexity\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">服务网格是 Kubernetes 世界中的一个热门话题，但许多潜在的采用者已经失去了耐心。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/envoy-oss-5-year/">[译] 网络代理 Envoy 开源五周年，创始人 Matt Klein 亲述开源心路历程及经验教训</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2021/09/15</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/envoy"> 
             Envoy
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://mattklein123.dev/2021/09/14/5-years-envoy-oss/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('网络代理 Envoy 开源五周年，创始人 Matt Klein 亲述开源心路历程及经验教训', '开源网络代理 Envoy 的创始人 Matt Klein，在 Twitter 因为自己的程序 bug 造成重大事故而离职，后加入 Lyft，在开源 Envoy 之前几乎没有贡献和管理开源项目的经验，这篇文章分享了他个人及 Envoy 开源的心路历程，在投身开源 Envoy 还是为雇主 Lyft 效命，该如何抉择？', '\n译者注：本文译自 Envoy 代理的创始人 Matt Klein 于昨晚在个人博客上发布的文章 [5 year of Envoy OSS](https:\/\/mattklein123.dev\/2021\/09\/14\/5-years-envoy-oss\/)。他在 Twitter 因为自己的程序 bug 造成重大事故而离职，后加入 Lyft，在开源 Envoy 之前几乎没有贡献和管理开源项目的经验，这篇文章分享了他个人及 Envoy 开源的心路历程，在投身开源 Envoy 还是为雇主 Lyft 效命，该如何抉择？看完本文，相信对于开源项目的维护者、创业者及投资人都会大有收获。\n\n------\n\n## 前言\n\n今天是 [Envoy Proxy 开源](https:\/\/www.envoyproxy.io\/)的 [5 周年](https:\/\/eng.lyft.com\/announcing-envoy-c-l7-proxy-and-communication-bus-92520b6c8191)。毫不夸张地说，在专业方面，过去的 5 年是一个史诗般的过山车，我的情绪介于兴奋、自豪、焦虑、尴尬、无聊、倦怠之间。我想分享一下这个项目的前传和历史，以及我在发展大型开源软件项目的过程中所学到的一些经验教训。\n\n## 前传和历史\n\n### 前传\n\n除了一些小的弯路，我在技术行业二十年的职业生涯一直专注于底层系统：嵌入式系统，操作系统，虚拟化，文件系统，以及最近的分布式系统网络。我的分布式系统网络之旅始于 2010 年初在亚马逊，我有幸帮助开发了第一批高性能计算（HPC）EC2 实例类型。我学到了大量的底层高性能计算机网络知识，尽管我对分布式系统的概念接触有限。\n\n2012 年，我加入了 Twitter，在经历了几次错误的开始后，我最终加入了边缘网络团队。这是我第一次真正接触到分布式系统应用网络概念。我领导了一个新的 HTTP 边缘代理的开发，称为 Twitter 流式聚合器（TSA），它在 2013 年首次推出，以扩大 Twitter 的“firehose”API（流式所有推文）的交付。在 2014 年世界杯前夕，我们决定将 TSA 作为一个通用的 HTTP\/HTTP2\/TLS 边缘代理，在靠近巴西赛事的存在点（POPs）推出。这样做的主要原因是不可能在 POP 的少量主机托管机架上部署现有的基于 JVM 的资源匮乏的边缘代理。项目周期特别紧张，我的团队成功地完成了一届没有事故的世界杯。（我还清楚地记得有一段时间，当软件崩溃时，不管是什么时候，我都会给自己打上一页，修复错误，然后重新进行金丝雀部署，继续测试）。在 Twitter 工作期间，我还接触到了该公司通过 Finagle 库进行服务间网络通信的方式，并取得了巨大成功。\n\n2015 年元旦前后，我在 Twitter 的日子里，因为我写的一个 bug，TSA 系统故障导致数百万 Twitter 的安卓用户被下线，这将是我在 Twitter 工作的尾声。\n\n![](008i3skNly1guh3vblu9xj60tu0eu76p02.jpg) \n\n### 加入 Lyft 和创建“Lyft 代理”\n\n我在 2015 年春天离开了 Twitter，部分原因是下线事件的影响，部分原因是对没有得到晋升的挫败感，部分原因是想尝试新的东西。我跟着我的老板从 Twitter 到了 Lyft，还有我在 Twitter 的其他同事。\n\n当我加入 Lyft 时，公司规模相对较小（少于 100 名工程师），并且正在努力从单体架构迁移到微服务架构。我已经[多次](https:\/\/mattklein123.dev\/appearances\/)谈到了 Envoy 的这部分历程，所以我不会再重述，在此简短的总结下，Lyft 遇到了所有典型的微服务迁移问题，主要是源于网络和可观测性。此外，Lyft 已经是“多面手”（使用多种语言和框架），所以使用基于库的解决方案来解决这些问题似乎不切实际。因此，根据我以前建立 TSA 的经验和观察服务间通信在 Twitter 的工作方式，由于得到在 Lyft 的前 Twitter 同事们的信任，我提议建立一个新的应用网络系统，称为“Lyft 代理”。\n\n经过一些激烈的讨论，包括新的代理是否应该用 Python 构建（是的，真的），我们就项目的大致轮廓达成一致，并决定使用 C\u002b\u002b 作为实现语言。在当时，C\u002b\u002b 似乎是唯一合理的选择。今天我还会选择 C\u002b\u002b 吗？然而，如今已经不是 2015 年初了。\n\n如果不说“Envoy\u0022 这个名字的由来，这部分的历史就不完整了。我们正在为这个项目建立最初的开发脚手架的时候，一个有远见的同事（Ryan Lane）说，我们不能把这个新项目叫做“Lyft 代理”，我们必须选择一个更好的名字。我总是很实际，就去找辞典，查了一下“代理”，然后决定用 Envoy 作为新名字。\n\n### 在 Lyft 上线\n\n直到 2015 年夏天，我才开始认真地研究 Envoy 的源代码。那几个月是我职业生涯中最有趣的几个月。我们应该珍惜这段初创时期，因为它不会持续很久。我花了很长时间，争取在合理的时间内（根据我的定义，这种类型的项目需要 3-4 个月的时间）做出能给 Lyft 带来价值的东西。俗话说，Lyft 给了我大量的绳子来吊死自己，而我致力于确保这种吊死不会发生。\n\n当然，我的效率主要归功于刚从压缩的开发时间表和许多错误（主要是我自己的）中走出来，在 Twitter 的 TSA。我知道哪些错误是不能犯的，哪些抽象是需要的，哪些测试有效，哪些无效，等等。\n\n2015 年秋天准备投入生产的 Envoy 的最初版本只包含了该项目今天所包含的功能和复杂性的一小部分。它不支持 TLS，只支持 HTTP\/1，并且有极其简单的路由和弹性功能。它所拥有的是你今天所看到的东西的骨架。在这个项目的历史上，很少有重大的重构，主要是因为，正如我之前所说的，我知道将要发生什么，以及为了支持这些功能，需要有哪些抽象。Envoy 从一开始就拥有一流的可观测性输出，以指标和日志的形式。在 2021 年，这种类型的网络可观测性是桌面上的赌注（这在很大程度上要归功于 Envoy 的成功），但在当时却不是这样。\n\nEnvoy 最初是作为边缘代理在 Lyft 上线的，位于提供 TLS 终止的 AWS ELB 后面。到 2015 年秋末，Envoy 为 Lyft 的 100% 流量提供服务，该系统产生的边缘仪表盘立即得到了回报（例如，提供 API 调用百分点延迟直方图，每个终端的成功率和请求率等）。\n\n在最初推出后不久，另一位 Twitter 同事（Bill Gallagher）加入了我的项目，我们迅速增加了一些功能，如 TLS 终止、HTTP\/2 支持、更多路由和负载平衡功能等。\n\n与此同时，Lyft 基于 Envoy 的“服务网格 \u0022 也开始成形了。首先，Envoy 被部署在 PHP 单片机旁边，以取代 HAProxy 及其一些固有的运维问题（例如，当时 HAProxy 仍然是单线程的），以帮助 MongoDB 的代理。可以毫不夸张地说，Envoy 的早期开发有很大一部分是针对 MongoDB 的稳定性（负载均衡、速率限制、可观测性等）。\n\n基于 Envoy 的边缘机群和单体之间的直接观察能力的好处是非常明显的。不久之后，我们在一些高 RPS 分解的微服务旁边部署了 Envoy，以帮助排除网络问题。这方面的价值也得到了证明。随着时间的推移，我们超越了对可观测性的关注，增加了帮助系统可靠性的功能，如直接连接和服务发现（跳过内部 ELB）、异常值检测、健康检查、重试、断路等。Lyft 的基于负载的重大事件的数量从每 1-2 周一次慢慢减少。当然，Envoy 不能将所有此类事件的减少归功于此，但它提供的网络抽象确实有很大的帮助。\n\n2016 年初，我们决定推动一个 100% 覆盖的服务网格。最初，我们认为这将是一个艰难的过程，需要自上而下的授权。在实践中，**团队报名参加了迁移，因为他们将得到的好处是显而易见的**。“胡萝卜 \u0022式的迁移几乎总是成功的。而“大棒\u0022 式的迁移则很少成功，或者即使成功了，也会在组织内留下眼泪和愤怒。\n\n到 2016 年中期，Envoy 被用于 Lyft 的所有网络通信，包括边缘服务、服务间通信、数据库、外部合作伙伴等。无论从哪个角度来看，该项目都取得了巨大的成功，帮助 Lyft 完成了微服务的迁移，提高了整体的可靠性，并对网络进行了抽象，使大多数工程师不需要了解真实的系统拓扑结构。此后，Bill 离开了这个项目，在 Lyft 从事其他工作，接替他的是 Roman Dzhabarov 和 Constance Caramanolis 加入我的团队。我们的小团队为整个 Lyft 开发和运维 Envoy。\n\n### 开放源码\n\n到 2016 年夏天，我们开始认真讨论开源 Envoy 的问题。早期的 Lyft 员工对开源和它为公司所做的事情很欣赏。很明显，Envoy 并不是 Lyft 的主要业务，那么为什么不把它放在那里并给予回报呢？我可以坦率地说，我们都带着不同的目标和期望来对待开放源代码的过程，以及对项目获得巨大成功后会发生什么感到非常天真。\n\n在加入 Envoy 之前，我已经使用了相当多的开源软件，但我几乎没有开源贡献的经验，也没有维护者的经验。（虽然我在 Linux 内核中有过[一次提交](https:\/\/github.com\/torvalds\/linux\/commit\/00370b8f8dd6e3171b8202f9c5187a5f73e99497)！）开源 Envoy 似乎是一个很好的机会，可以扩展我的技能组合，学习新的东西，可能会促进我的职业生涯，坦率地说，我不希望有一个 TSA v3 在第三家公司出现。对于 Lyft 来说，Envoy 是一个重要的工程项目，领导层认为，开放源代码将使 Lyft 作为一个工程组织具有可信度，并有助于招聘工作。正如我之前所说，我们所有人都对创建成功的开源，更重要的是在它获得成功的情况下培育它所需要的东西感到天真。\n\n但是，我们决定给它一个机会。我们在 2016 年夏天花了很大一部分时间来编写文档（Jose Nino 在这个时候加入了团队，他的第一个任务就是阅读并帮助改进所有的文档），清理存储库，使其 \u0022 不那么尴尬”，制作网站，发布博文等等。我真的很感谢这段时间里我在 Lyft 的同事，他们不仅支持我们，还帮助我们完成了无数的任务，包括网站设计、logo 等等。即使在这个早期阶段，我们也觉得第一印象很重要，如果我们要在开源领域有所作为，就必须通过高质量的文档、网站等给人留下良好的第一印象。\n\n在此期间，我们还利用我们的行业关系，与 Lyft 的一些“同行公司”（湾区的“独角兽 \u0022 互联网创业公司）会面，向他们展示我们在 Envoy 方面所做的工作，并获得他们的反馈，我们认为如果我们在正式开源前成功获得一个启动合作伙伴，这将是对项目的一个重大帮助。所有这些会议都非常友好，总的来说，所有与我们会面的公司都对我们所取得的成就印象深刻。但是，事后看来，他们都表示，以他们的小型基础设施团队，不可能马上采用 Envoy。他们祝愿我们在开放源代码方面取得最好的成绩，并说他们以后会回来看看。我们不禁对这些会议的结果感到沮丧，但我们还是向前推进了。\n\n2015 年 8 月，我与谷歌进行了第一次友好的会面。一个 Lyft 的同事（Chris Burnett）在一个 gRPC 聚会上发言，提到了 Envoy，因为它与 Envoy 的 [gRPC 桥接](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/intro\/arch_overview\/other_protocols\/grpc#grpc-bridging)支持有关。我不知道的是，谷歌在发现 Envoy 的时候，正准备在 NGINX 的基础上推出 Istio。一次会议引出了另一次会议，然后是更多的会议，在 Envoy 开源之前，大量的谷歌员工已经看到了源代码和文档。(稍后会有更多关于这方面的内容）。\n\n到 9 月初，我们已经准备好了，并将开源日定为 9 月 14 日。总的来说，我是一个（过度？）自信的人，但在我的生活中，有几次我对自己成功的能力有很大的焦虑。我立即想到的是：开始上高中，开始上大学，以及大学毕业后在微软工作。而开源的 Envoy 就是其中之一。我记得我被公众的反应吓坏了。人们会怎么说？反馈会是积极的还是恶毒的？虽然我们在开源时是一个小团队，但我仍然写了 90% 或更多的代码，并且觉得把它放到公共领域是对我自己和我的能力的一种反映。\n\n如期而至，[Envoy](https:\/\/eng.lyft.com\/announcing-envoy-c-l7-proxy-and-communication-bus-92520b6c8191) 在 2016 年 9 月 14 日 [成为开源产品](https:\/\/eng.lyft.com\/announcing-envoy-c-l7-proxy-and-communication-bus-92520b6c8191)。我记得我和妻子一起庆祝，并说了一些话。“如果我们能让其他公司像 Lyft 一样使用 Envoy，我就会很高兴。”\n\n对开放源码发布的反应几乎是普遍的积极。令我们惊讶的是，几乎是立刻，我们开始听到大公司的声音，而不是小公司。在几周内，我们与苹果、微软进行了交谈，与谷歌的对话也不断加快。大公司在现有的解决方案中存在问题，并且有大量的团队准备投入到解决这些问题的工作中。具有讽刺意味的是（至少在 Twitter 的观点中），C\u002b\u002b 在这里是一种帮助，而不是一种阻碍。这些大公司都已经拥有充足的 C\/C\u002b\u002b 开发资源，以及他们想要整合的现有库，等等。对他们来说，C\u002b\u002b 是一个卖点。\n\n在这段时间里，毫不奇怪，我们与谷歌的人有最多的互动。最初主要是构建 Istio 的团队，但渐渐地，我们与 Anna Berenberg 花了更多时间，她现在是谷歌的杰出工程师，领导各种网络和负载均衡工作。这种关系将产生 \u0022 喷气燃料”，在 2017 年初真正启动该项目。\n\n### 开始起飞\n\n到了 2017 年初，很明显，Envoy 的开发正在加速。谷歌承诺用 Envoy 取代 NGINX，用于 Istio（最终在 2017 年春季推出），对项目的未来来说更重要的是，Anna 的大型团队致力于 GCP 云负载均衡功能，他们开始向使用 Envoy 的各种云负载均衡产品以及内部用例（这在这个时期都是非常秘密的，但现在已经众所周知）。\n\n我将永远记得与谷歌互动的那段时间是我职业生涯中最紧张的时期之一。说实话，那感觉就像一个收购（审讯）过程。我记得长长的会议和电子邮件线程，以证明我们的技术决定，“面试 \u0022中，谷歌试图确定我们是否会成为一个好的开源项目合作伙伴，等等。当时我们很痛苦地发现，这次\u0022 收购 \u0022 将使 Envoy 进入一个我们自己永远无法实现的轨道，所以我们尽一切努力使它获得成功，最终也获得了成功。而且，在过去 4 年多的时间里，我们与谷歌的合作确实是一种杰出的伙伴关系。早期的谷歌云工程师最终成为维护者，Harvey Tuch 和 Alyssa Wilk，为项目带来了大量的人才，包括技术上的，以及对开源和社区的支持。我对他们的感激之情溢于言表，没有他们，项目就不会有今天的成就。多年来为该项目做出贡献的其他谷歌工程师（现在有很多），除了普遍是优秀的社区管理者之外，还为该项目增加了大量的工程力量，否则该项目就不会有。我当然对最初的谷歌合作关系有顾虑（技术和理念上的分歧，等等），但我可以诚实地说，这些顾虑都没有成为现实。\n\n除了确保 Istio 和 GCP 团队与谷歌合作的成功之外，我们还花了大量时间与其他公司和维护者合作并加入他们，其中许多人对项目产生了巨大的影响，至今仍作为维护者、贡献者或用户大量参与。如果没有这些早期的社区成员，这个项目就不会有今天，我也非常感谢他们对项目的信任。\n\n同时，随着项目的不断深入，我开始收到大量投资者对 Envoy 的兴趣。有强烈的愿望让我离开 Lyft，围绕这个项目开一家公司。我[写过这部分的旅程](https:\/\/medium.com\/@mattklein123\/optimizing-impact-why-i-will-not-start-an-envoy-platform-company-8904286658cb)，所以我不会在这里重述，留在 Lyft 我会有大量的时间和精力来处理所有这些互动。正如链接的文章所描述的，我最终决定留在 Lyft，不开公司，以支持 Envoy 的持续成功。\n\n与此同时，我仍然在 Lyft 工作，正如我将在后面进一步讨论的那样，我越来越多地从事两份工作。我的第一份工作是在内部领导网络团队，并在运营上支持 Lyft 的 Envoy。我的第二份工作是作为 Envoy 的公众形象，包括 OSS 领导，代码审查，修复错误，编写可以促进项目的功能，在会议上发言，帮助其他公司采用和部署 Envoy，等等。我开始变得过于分散，并出现了倦怠的迹象。然而，到了 2017 年年中，不可否认的事实是，Envoy 的发展轨迹是大大的“向上和向右”。各大公司、“同行公司”、垂直产品和服务等的采用率继续攀升。\n\n### 捐赠给 CNCF 且感到倦怠\n\n到 2017 年秋天，有两件事是清楚的。\n\n1. Envoy 已经超出了 Lyft OSS 设备所能提供的范围。该项目需要法律、公共关系、营销、活动组织等方面的帮助。\n2. 我很快就完全倦怠了，需要找出一条可持续发展的道路。\n\n为了解决第一点，我们最终同意考虑将 Envoy 转交到 CNCF。数月来，CNCF 一直在追求该项目，但似乎从来没有任何令人信服的理由来加入。到 2017 年底，很明显，CNCF 的资源即使不是净收益，也至少对项目是中性的。我们开始了提交程序，并最终在我们最初开放项目资源的几乎整整一年后[加入了该基金会](https:\/\/eng.lyft.com\/envoy-joins-the-cncf-dc18baefbc22)。我很感谢 Alexis Richardson 和 Chris Aniszczyk 在这个过程中对项目的指导。\n\n第二点则要复杂得多。从根本上说，我的工作时间超过了我的工作能力，有效地跨越了两个不同的工作。此外，我正在期待我的第一个孩子，预产期在 2018 年初，随着到来的日期越来越近，这让我越来越焦虑。到这个时候，我已经很清楚，我在设定期望和界限方面做得不够好，不知道自己能够为 Lyft 提供什么，同时也没有从行业的角度关注 Envoy 的持续增长。在 Lyft，我越来越放任自流，陷入人际关系的争吵，在为更多的初级团队成员提供指导和领导方面，没有达到我这个级别的期望。\n\n简而言之，我当时正处于崩溃的边缘，最终我选择了 Envoy 而不是 Lyft，这对我的 Lyft 同事造成了伤害。我想，如果我在 2017 年初至年中对我的工作量与 Lyft 的领导层更加透明，我可能会避免一些最糟糕的结果，但不幸的现实是，**为开源软件行业的工作提供资源，而这些工作对雇主没有立即明显的作用，这是一个复杂的努力**。它可能会更顺利，也可能不会。在任何情况下，虽然我对一些我本可以处理得更好的人际关系问题感到遗憾，但无论好坏，**我都不后悔把精力放在 Envoy 上。我优先考虑的是 Envoy，而不是 Lyft，我做了我认为当时必须做的事情，以使它成功**。\n\n### 可持续发展道路\n\n我的第一个孩子在 2018 年 2 月出生，Lyft 极其慷慨的陪产假政策为我提供了休息和放空自己的时间。我从 Lyft 获得了一些空间，并开始更深入地思考我想要什么以及什么对我来说是可持续的。\n\n当我休完陪产假回来后，我与 Lyft 领导层明确表示，我不能再参与 Lyft 的 Envoy 的 \u0022日常\u0022 运维。相反，由于 2017 年底的一些后果，基础设施团队也希望与我分开一些。由于这个原因，**我大幅后退，实际上完全停止了在 Lyft 的基础设施工作**，在 2018 年年中至年末的 Lyft Bikes 和 Scooters 初始版本中编写固件网络代码。这是一个了不起的团队努力，在压缩的时间范围内得到了一些东西，我真的很喜欢在几个月内做一些完全不同的事情。\n\n2018 年也是我积极开始琢磨在 Envoy OSS 社区中 \u0022取代自己\u0022 的那一年。我花了大量的时间（并将继续花大量的时间）来培养维护者、新的贡献者，组织第一次专门的 EnvoyCon，等等。任何领导者都应该有一个目标，那就是确保该组织在有一天该领导者退位时能够继续良好地运作。\n\n到 2018 年底，我的主要职业倦怠风险已经得到解决，我又开始了合理的工作时间，并花了很多时间与我的妻子和儿子在一起，我的时间大致在 Envoy OSS 工作和 Lyft 的一般基础设施领导之间各占一半。明确地说，Envoy 的成功带来的特权使我能够在 Lyft 的工作生活中取得这种平衡。随着时间的推移，随着我的行业地位的提高，我的影响力也在同步增加，这使得我更容易按照自己的意愿设定就业条款。没有多少人有这样的运气，我明白我是多么幸运，能够“突破“倦怠墙的另一边而不必离开我的工作。\n\n### Envoy 长大了\n\n自 2019 年以来，因为新冠疫情，我在 Lyft 的基础设施领导和 OSS 领导之间继续保持着我上面描述的五五开的比例。当然也有单调和渴望不同的时候（从历史上看，我是一个习惯性换工作的人，6.5 年是迄今为止我在一件事情上工作的最长时间），但总的来说，我很高兴看到 Envoy 从一个“新秀 \u0022 变成更多的“少年”。我不再专注于做我所能想到的一切，使 Envoy 获得巨大的成功，因为坦率地说，Envoy 是一个巨大的成功，已经席卷了市场，并改变了用户对应用负载均衡工具的期望。相反，我更关注项目的可持续性。我们是在做长期的工作，这些天我觉得自己更像一个 CEO，看减员人数、优先级、预算编制、安全问题等等。这并不是说这不是有用的工作；它显然是有用的，它只是与早期的工作不同，早期的工作技术性更强，节奏更快。\n\n截止到 2021 年末，我对 Envoy 最引以为豪的事情是，在我看来，这个社区已经可以自我维持了。我们有一群令人难以置信的维护者、贡献者和用户，他们对项目的成功充满热情，并在使 Envoy 成为今天的样子中发挥了作用。这确实是一个团队的努力。\n\n## 经验教训\n\n过去的 5 年是一个史诗般的旅程。虽然我觉得我在技术上学到的东西相对较少，但我在领导力、社区建设和所有其他非技术性的东西方面都得到了成长和学习，这些都是建立一个成功的企业，无论是企业还是一个主要的开源成功故事。以下是我对一些主要学习内容的简短总结。\n\n### 成功的开源软件就像创办一个企业\n\n也许有争议的是，**我认为如果一个人有目标要创建一个非常成功的开源软件项目，他们需要把它想成一个企业**。除了核心技术之外，创业还涉及很多因素：\n\n- 招聘（在开源软件中，这意味着招聘贡献者和维护者）\n- 获取客户（在开源软件中，这被转化为用户）\n- 文档和技术写作\n- 公共关系\n- 市场营销\n- 法律（商标、许可等）\n- 人力资源（在开源软件中，这将转化为解决社区纠纷和制定文化）\n- 资金（在开源软件中，这转化为辅助费用，如 CI、为维护者找到允许他们在项目中部分或全部时间工作的工作，等等）\n- 总的说来，就是领导和方向的确定。资源有限，有很多事情可以做。企业 \/ 项目需要专注于最重要的事情，以实现产品的市场适应性。\n\n直观地说，我知道这一点，在最初为 Envoy 进行开源努力时，我积极地追求上述所有的领域，努力使项目从开始发展到今天的规模。上述列表中的每一项都很关键，如果没有所有这些，一个项目是不可能成功的，尤其是在技术领域有很多资金雄厚的公司竞争对手的情况下。\n\n我强烈鼓励那些考虑进行大规模开源工作的人提前在上述领域进行投资，以便在第一天就给人留下最佳印象。此外，新的开源项目应该准备在项目成长并开始看到采用时，在上述领域进行更多的投资。\n\n毫不奇怪，这些天我在 Envoy 上做的编码工作相对较少。我在项目上的时间主要是管理项目的所有非技术方面（上述列表中的所有内容，甚至更多！），并确保事情按计划进行。我所做的大多数编码项目都是“清洁 \u0022 的幕后项目，对项目有好处，但没有什么乐趣，也不可能激励其他贡献者（当然，我对他们每天的工作没有发言权，我有动力让他们尽可能的开心，这样他们就不会离开）。\n\n### 终端用户驱动的开源软件是一种结构性优势\n\n这些天来，很多“大的开源软件”，特别是在基础设施领域，是由大公司和风险投资支持的初创公司资助的。我不会绕到关于开源软件的困难经济的讨论，因为我[已经写过了](https:\/\/medium.com\/@mattklein123\/the-broken-economics-of-oss-5a1b31fc0182)。我想说的是，**我坚信终端用户的开源软件比企业和风险投资支持的开源软件有很大的优势**：最初的客户几乎肯定会从软件中获得价值，否则软件就不会得到资助。这种与客户一起建立东西的良性循环是非常强大的。它几乎普遍导致了更好的结果：软件更可靠、更专注、功能更少。有很多由最终用户驱动的开源软件的例子，然后取得了巨大的商业成功。鉴于坚实的基础和内在的产品市场适应性，这对我来说并不奇怪。我希望看到比今天更多的最终用户驱动的开源软件，尽管我认识到经济上是困难的。对于那些有机会的人来说，请向这种类型的软件所具有的结构性优势靠拢！\n\n### 不要跟风，要跟随客户\n\n这也许是 \u0022成功的开源软件就像创业\u0022 和 \u0022最终用户驱动的开源软件是一种结构性优势\u0022 的必然结果，但我无法强调坚持不懈地关注客户的实际需求而不是炒作周期所认为的客户需求是多么关键。例如，**多年来，人们一直在嘲笑 Envoy 是用 C\u002b\u002b 编写的，这引起了无数的笑话**。我喜欢 C\u002b\u002b 吗？不，不是很喜欢。它是否在 2015 年完成了工作，并吸引了最初的一批主要用户？肯定是的。这是一个关注客户和市场的例子，而不是屈服于没有实际“商业 \u0022 影响的炒作。如果一个人把开源软件当做一个企业，就会立刻明白，**以客户和市场为中心是取得巨大成功的唯一途径**。在 Envoy，我花了大量的时间为终端用户争论，以确保我们建立的东西能让所有人受益，而不仅仅是一小部分小众用户。\n\n### 可扩展性是至关重要的\n\n跟着客户走往往会导致客户的要求不能很好地融入项目的架构中。从开源软件的角度来看，失去对项目主要目标的关注会导致功能蔓延、软件无法维护和维护人员负担过重。同时，说“不 \u0022 也是失去潜在用户的一个保证。\n\n对于 Envoy，我想确保我们至少可以说“是的，但是……\u0022，即提供一个强大的可扩展性模型，让用户可以满足他们的需求，而不需要将每一个改动和功能都推到上游。这种策略已经多次得到回报，它减轻了维护者的负担，让用户能够解决他们自己的问题，更重要的是，将 Envoy 推向了我在最初设计该软件时从未想象过的用例。\n\n可扩展性，特别是对于开源软件的构建模块，是至关重要的。\n\n### 质量问题\n\n跟随客户的另一个推论是，质量确实很重要。用户希望软件易于操作，相对来说没有错误，关心安全，等等。曾几何时很多人会觉得因为开源软件是 \u0022 免费的”，所以质量就得不到保证。这在理论上也许是正确的，但实际上，在一个项目对软件质量认真对待之前，用户不会大量地聚集在一个软件上。因为获得用户是一个飞轮，可以获得更多的用户（特别是当从早期采用者转向晚期采用者时），所以确保为整个软件质量编列时间预算就更加关键了。\n\n关于 Envoy，我一直有一个 \u0022零碰撞\u0022 的理念。任何崩溃都会被调查和修复，无论多么不频繁的错误。这种对稳定性和质量的关注不会被忽视。\n\n### 社区是扩大规模的唯一途径\n\n这很明显，但我还是要说：社区是扩展开源软件的唯一途径。这是一个由维护者、贡献者和用户组成的社区。此外，社区的**基调**在项目开始时就已经确定，而且极难改变。人类倾向于遵循规范。一旦规范被确定下来，无论规范是什么，与这些规范不一致的人都会被避开。因此，**项目最初的公共基调对于设定其长期的社区轨迹极为关键**。\n\n当我们把 Envoy 做成开源软件时，我在 GitHub 上投入了大量的精力与人们一起工作，使用建设性和欢迎性的语言。总的来说，我尽我所能让 Envoy 成为一个受欢迎的地方，让人们愿意来贡献自己的力量，无论是维护、偶尔的贡献，还是用户帮助其他用户。\n\n在 Envoy 所取得的所有不同类型的成功中，到目前为止，给我带来最多个人满足感的部分是，有相当多的人告诉我，他们已经发誓不再使用开源软件，尤其是基础设施开源软件，因为他们觉得大多数项目中的人对彼此感觉都很糟糕。相反的，他们喜欢为 Envoy 做贡献，因为这个社区是如此的尊重和欢迎彼此。这需要大量的努力和纪律，尤其是在项目的早期，才能达到这样的结果，而这已经得到了众多的回报。\n\n不要低估从一开始就确定项目的文化和基调的复合效应。\n\n### 混合商业和开源软件的利益是非常困难的\n\n已经有很多关于开源软件的困难经济学的文章（[包括我自己的文章](https:\/\/medium.com\/@mattklein123\/the-broken-economics-of-oss-5a1b31fc0182)，我在上面提到的）。我只想说，**试图将商业上的成功和开放源码的成功结合起来是非常困难的，主要是因为这些成功往往是相互矛盾的**。\n\n我相信，Envoy 通过其强大的 API 和可扩展性系统穿透了这个矛盾。从本质上讲，Envoy 已经成为一个工具，现在被大量的垂直产品和服务所使用。这就产生了一个社区，该社区充满了选择在一个共同的基底上合作的公司，即使是通过在扩展 \/ API \/ 控制平面 \/ UI\/UX 层上的创新，推出相互竞争的上层产品。\n\n任何成功的开源项目都会看到大量的商业 \/ 投资人的兴趣。如果一个项目的目标是保持一个充满活力的社区，同时又能取得商业上的成功（我认为这对整个项目的成功是必要的，因为钱必须来自某处），**那么预先考虑如何将核心层和商业层分开是极其重要的**。这样做的实用性和策略会因项目和技术的不同而不同，但我相信专注于强大的 API \/ 扩展性的分割是一个富有成效的策略。\n\n### 基金会是很棘手的\n\n在现代的开源讨论中，有很多关于基金会的作用的讨论。我不打算对这一话题做大量的评论，**但我的主要建议是不要被基金会和它们可能提供的理论利益所干扰**。相反，要积极地关注产品的市场适应性，生产高质量的软件，并为用户提供价值。如果这些事情得以实现，其余的事情就会自然而然地发生。\n\n对于非常成功的项目来说，基金会，更确切地说，中立的商标持有地，是非常有用的，所以我肯定会在那个时候考虑加入一个。随着项目的成熟，Envoy 从成为 CNCF 的一部分所获得的价值也在不断增加。CNCF 雇佣了开源软件律师、营销人员、公共关系人员、一流的活动人员等等。这些额外的资源在“经营业务 \u0022 方面是非常宝贵的。\n\n### 提前考虑治理问题\n\n![](008i3skNly1guh3vqvywcj60tw0h8go702.jpg)开源治理是**非常**困难的。就其本质而言，开放源代码是无政府的，没有明确的领导结构。没有一个适合所有项目的治理方法，每个项目都必须找到自己的前进方向，可以通过“BDFL”\/CEO 类型的模式、指导委员会、类似 Apache PMC 的程序等。所有的治理模式都有优点和缺点，并且有不同的失败模式。\n\n最重要的是，在项目变得庞大和成功之前，先认真思考治理问题。写下一套规则和规范，特别是花时间记录项目的冲突解决过程。\n\n同时也要意识到，根据我在上面关于社区规范如何在早期设定的评论，早期的项目维护者将对整个对话和冲突解决的风格产生巨大的影响，就像公司的早期员工对公司的文化产生巨大的影响一样。\n\n在我的印象中，我们在 Envoy 内部非常幸运，没有发生过任何重大分歧，出现的问题也可以迅速友好地解决。在项目的历史上，我们从来没有需要援引[维护者投票程序来解决冲突](https:\/\/github.com\/envoyproxy\/envoy\/blob\/main\/GOVERNANCE.md#conflict-resolution-and-voting)。在我看来，这是一个巨大的成就，也是对所有维护者的素质和专业性的证明，尤其是考虑到该项目已经变得如此受欢迎，以及围绕它的所有商业利益。\n\n### 对开源贡献的期望是至关重要的\n\n我在上面提到过这个问题，但我自己的职业倦怠很大程度上是由于我没有很好地与我的雇主就我需要花多少时间来管理 Envoy 的开源增长设定合理的期望。我不会撒谎说，进行这样的对话就能神奇地使雇主为某人腾出大量时间来从事开源工作，特别是那些可能不直接适用于其日常工作的项目。话虽如此，我确信对所有参与的人来说，对开源过程有公开和诚实的期望是非常重要的。以下是在开源项目之前或开始以开源身份工作之前要问的合理问题：\n\n- 雇员应该问他们的雇主，为什么他们要开放源代码？\n- 雇主应该问他们的员工，为什么他们要开放源代码？(这个问题的答案和前一个问题的答案不同是完全合理的，但应该在公开场合讨论)。\n- 雇员应该问他们的雇主，如果项目成功了，会发生什么？该项目将有哪些资源可用？员工将有多少时间可以在通用的开源软件问题上工作，目的是直接推动项目的发展？\n\n**雇主和雇员之间不匹配的期望是未来怨恨和倦怠的根本原因。**\n\n### 代理容易，API 难\n\n对一些人来说，Envoy 提供的底层网络代理机制似乎是这个项目的复杂部分。事实证明，与为 Envoy 发展一个稳定的 API 生态系统所做的工作相比，代理部分（在我看来）相对简单。平衡人类和计算机消费的 API 人体工程学，保持不同版本的稳定性，发展 API 以支持其他客户端，如 gRPC，指定协议语义以使 Envoy 能够与数百（可能是数千）个不同的管理服务器对话，等等，都是非常复杂的。我为团队在这一领域取得的成就感到骄傲（特别要感谢推动这一工作的 Harvey），即使在这一过程中出现了一些错误（比如从 API 的 V2 版本强制迁移到 V3 版本）。\n\n如果一个软件提供了一个 API，而且更重要的是希望这个 API 成为其他系统的关键组件，那么不要低估提供一个稳定和符合人体工程学的 API 的成本和复杂性。反过来说，**强大的 API 是一个生态系统飞轮的重要组成部分**，会以此产生更多的产品和用户，所以在我看来，这些努力是非常值得的。\n\n### 不要忽视职业倦怠\n\n**如果一个人想成就大事业，我不相信他可以 100% 实现良好的工作生活平衡**。现实情况是，任何成功都是由现有的特权 \/ 机会、一个好的想法、良好的执行力和大量的运气（包括在正确的时间出现在正确的地点）组成的。所有这些东西都在 Envoy 中发挥作用，我不会假装我没有把自己搞得很累，特别是在 2017 年。我也会重新做一遍 2017 年的工作，因为从我的角度来看，我做了我必须做的事情，使项目获得成功。(有时我想，如果我已经有了孩子，Envoy 是否还会诞生。我不确定它是否会发生，但这是一个更长的谈话主题！)\n\n综上所述，我在 2017 年描述的那种史诗般的推动力只能持续这么久，直到一个人崩溃。我鼓励大家不断反思自己的工作生活平衡，并为自己找出一条可持续发展的道路。每个人的情况都不同，我不能提供任何一个避免职业倦怠的建议，但我认为反思是一个好的开始，也是我自己不得不努力的事情。\n\n## 感谢\n\n在过去 6 年半的时间里，在 Envoy 上工作，其中 5 年是作为开源软件，这是我职业生涯中的亮点。这个项目的成功确实是一个团队的努力，我一个人是不可能完成的，我为我们所有人（维护者、贡献者和用户）共同完成的事情感到非常自豪。在这个项目上工作的维护者和贡献者是我所共事过的最好的工程师群体，他们才华横溢，他们就职在不同公司，位于不同的地理位置，这真是开源的理论潜力在实践中的体现。作为一个团队，我们已经产生了世界性的影响，改变了用户对软件负载均衡系统的期望，同时也建立了一个充满活力和热情的社区。在我最疯狂的梦想中，我从未想过这个项目会成为今天的样子。\n\n对我来说，未来会发生什么就不那么清楚了。正如我上面所说的，我的重点已经转移到了可持续性上。我想确保，如果有一天我离开了，这个项目将保持健康。尽管如此，这一天还没有到来，我期待着在可预见的未来帮助领导项目前进，希望能取得更大的成功和采用。向前迈进！\n', '\/trans\/envoy-oss-5-year\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">开源网络代理 Envoy 的创始人 Matt Klein，在 Twitter 因为自己的程序 bug 造成重大事故而离职，后加入 Lyft，在开源 Envoy 之前几乎没有贡献和管理开源项目的经验，这篇文章分享了他个人及 Envoy 开源的心路历程，在投身开源 Envoy 还是为雇主 Lyft 效命，该如何抉择？</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/europoe-it-hiring-report-2021/">[译] 疫情期间欧洲 IT 民工招聘趋势报告解读，DevOps、AI 和平台工程师最高年薪 9 万欧</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2021/08/20</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e4%b8%9a%e6%80%81"> 
             业态
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://thechief.io/c/editorial/2021-european-tech-hiring-trends/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('疫情期间欧洲 IT 民工招聘趋势报告解读，DevOps、AI 和平台工程师最高年薪 9 万欧', '2021 年度欧洲 IT 求职报告解读。', '\n## 译者评论\n\n![官方钦定：码农属于新生代农民工如今不再是程序员的调侃了](008i3skNly1gtn7lhy8vkj60hj09ijsq02.jpg)\n\n最近在社区里看到很多人在讨论国家开始不给大型互联网企业减税，互联网公司股价普跌，大部分距离年内最高点腰斩，个人所得税成为工薪税，程序员被划归为”新生代农名工“，”贫贱不能移“等话题。让我们一起来看看欧洲的 IT 招聘趋势还有薪资水平，是否国外的月亮就是圆呢？\n\n![昨天在社区群里传的一张「北京市运维工程师薪资水平」](008i3skNly1gtn7lkeyaqj610q0u0mzs02.jpg)\n\n## 报告解读\n\n尽管新冠疫情正在逐渐消退，但其影响仍将持续一段时间。本文衡量了疫情对欧洲科技企业招聘的影响，展露了欧洲科技招聘的新趋势。\n\n- 国家的经济规模不断扩大\n- 欧洲国家的失业率保持稳定\n- 招聘活动增加\n- 软件开发人员、程序员的需求量更大\n- 雇主寻求全面发展的技术人才\n- 雇主要求软技能作为主要技能的一部分\n- 39% 的招聘信息寻求具有 0-2 年经验的专业人士\n- 薪资范围从 36000 到 90000 欧元\n- 德国和法国在科技人员招聘方面领先\n- 信息和通信业、制造业引领科技招聘\n\n在所有行业中，2020 年是一个促进招聘的年份，迫使招聘团队修改和改进他们的人才招聘模式，以满足对技术人才不断增长的需求，特别是在科技行业。与许多其他经济体一样，欧洲经济经历了疫情的冲击，并正在迅速从其影响中恢复。\n\n利用[Burning Glass](https:\/\/www.burning-glass.com\/?ref=thechiefio)汇总的雇主职位发布数据，CompTIA 开发了[欧洲科技企业招聘趋势](https:\/\/comptiacdn.azureedge.net\/webcontent\/docs\/default-source\/research-reports\/comptia-european-tech-hiring-trends---q2-2021-release.pdf?sfvrsn=c441f76b_2?ref=thechiefio)，涵盖了 2020 年第一季度欧洲国家的科技招聘活动。该报告调查了十个欧洲国家。比利时、荷兰、捷克、波兰、法国、葡萄牙、德国、罗马尼亚、意大利和西班牙，将 2021 年第一季度的招聘活动与 2020 年进行比较，以衡量科技行业从 2020 年的衰退中恢复的程度。\n\n本文重述了这份报告，并强调了关键的发现，以帮助雇主、专业人士和科技界利益相关者了解欧洲科技就业市场的招聘趋势。\n\n## 国家的经济规模不断扩大\n\n![](008i3skNly1gtn7lipq9aj60b40cvq3f02.jpg)\n\n图片来源：https:\/\/comptiacdn.azureedge.net\/webcontent\/docs\/default-source\/research-reports\/comptia-european-tech-hiring-trends---q2-2021-release.pdf\n\n众所周知，新冠疫情在 2020 年对全球经济产生了破坏性影响。随着欧洲各国封锁的缓解，经济开始逐渐回升，商业活动重新活跃起来。预计西班牙的经济增长将达到 6.4%，为 11980 亿；罗马尼亚为 6.0%，为 2370 亿；法国为 5.8%，为 24090 亿；意大利和捷克分别为 4.2%，为 17270 亿和 2260 亿。其他预测增长缓慢的国家包括比利时（4.0%，4750 亿）、葡萄牙（3.9%，2110 亿）、德国（3.6%，35420 亿）、荷兰和波兰预测各 3.5% 的经济增长。\n\n## 欧洲国家的失业率保持稳定\n\n![](008i3skNly1gtn7lfrhmaj60bz0cldgb02.jpg)\n\n图片来源：https:\/\/comptiacdn.azureedge.net\/webcontent\/docs\/default-source\/research-reports\/comptia-european-tech-hiring-trends---q2-2021-release.pdf\n\n与美国等其他国家相比，欧洲国家的失业率在新冠疫情的高峰期保持相对稳定，只有西班牙在 2020 年的失业率超过 15%。\n\n然而，尽管失业率稳定，经济活动的放缓导致整个欧洲国家的招聘活动放缓。\n\n## 招聘活动的增加\n\n![](008i3skNly1gtn7lgf2mqj60bk0bv0t102.jpg)\n\n在从疫情和招聘活动放缓的影响中恢复，2021 年第一季度的招聘活动比 2020 年第四季度恢复了 9%，比 2020 年第三季度增加了 40%。2021 年第一季度，技术职位的发布经历了一个新高，超过 90 万个职位发布，而 2020 年第一季度为 60 万个，2020 年第二季度约为 40 万个，2020 年第三季度和第四季度分别超过 60 万个和约 80 万个。\n\n## 软件开发人员、程序员的需求量更大\n\n![](008i3skNly1gtn7ljnvhoj60c30bx75202.jpg)\n\n在接受调查的十个欧洲国家中，软件开发人员、系统分析师和网络安全、系统管理员、网络开发人员、IT 专家、数据库、网络和应用程序员是招聘活动最多的技术职位。在 2021 年第一季度，有 249,017 个软件开发人员的招聘信息，231,464 个系统分析师和网络安全的招聘信息，以及超过 84,000 个系统管理员的招聘信息。进一步证实了技术的相互关联性，其他职业，如 IT 支持专家和技术员，IT 经理和首席信息官，应用程序员，数据库和网络人员的需求也很大。\n\n## 雇主寻求全面发展的技术人才\n\n![](008i3skNly1gtn7lklpyrj60bt0akjrq02.jpg)\n\n随着技术的不断扩展和新范围、工具、硬件和方法的出现，对工作要求的分析表明，雇主对了解广泛技术技能的候选人更感兴趣。以软件开发人员的职位为例，一个典型的雇主更喜欢具有多种编程语言经验的候选人，具有网络安全知识，至少有一个云平台，并熟悉[DevOps 流程](https:\/\/thechief.io\/c\/editorial\/demystifying-the-devops-career\/)。\n\n办公室\/电子表格、编程\/面向对象的编程、商业IT系统、SQL、数据库和统一建模语言是技术职位招聘中最受欢迎的一些技术技能。\n\n## 雇主要求软技能作为主要技能的一部分\n\n![](008i3skNly1gtn7lgvkm4j60b20aj74l02.jpg)\n\n商业和软技能在技术岗位上不再被视为次要。招聘信息显示了这一点，技术雇主认为软技能，如批判性思维、团队合作、解决问题、项目和时间管理，与技术技能同等重要。\n\n## 39% 的招聘信息寻求具有 0-2 年经验的专业人士\n\n![](008i3skNly1gtn7lhbac6j60dr07nglu02.jpg)\n\n虽然现在大多数科技雇主根据专业知识、技能和业绩进行招聘，但在科技岗位招聘中，工作年限仍然是一个决定性的标准。在 2021 年第一季度，雇主寻求更多具有 0-2 年经验的初级专业人士。2021 年第一季度，14% 的科技职位招聘要求有 3-10 年的经验，11% 要求有 11 年以上的经验，而 36% 没有明确要求的经验年限。\n\n## 薪资范围从 36000 到 90000 欧元\n\n![](008i3skNly1gtn7ll8kkij60ep07ejrq02.jpg)\n\n雇主提供的工资在 36,000 左右，主要是针对初级职位的招聘信息，不包括其他副业收入。随着专业知识水平、工作年限和工作地点的不同，技术类职位的[基本工资](https:\/\/thechief.io\/c\/editorial\/salary-trends-for-devops-and-cloud-native-professionals\/)最高可达 9 万，不包括其他补偿和奖金。与疫情之前的时期相比，**一些技术角色，如[DevOps](https:\/\/thechief.io\/c\/news\/devops-pros-salary-rise-despite-effect-pandemic\/)、平台工程师和 AI 工程师的工资在疫情之后也有所增加。**\n\n## 德国和法国在科技人员招聘方面领先\n\n![](008i3skNly1gtn7lj87wyj60dc07djri02.jpg)\n\n尽管比 2020 年第四季度减少了 4%，但德国在 2021 年第一季度以 421,109 名科技人员的招聘数在所有被调查的十个国家中处于领先地位。法国紧随其后，与 2020 年第四季度相比，增加了 16%，即 121,863 人，而波兰则以 105,921 人的科技人员招聘数紧随其后，与 2020 年第四季度相比，增加了 37%。意大利和荷兰在 2021 年第一季度也分别经历了 50%（60,082 人）和 43%（53,313 人）的技术招聘激增。\n\n## 信息和通信业、制造业引领科技招聘\n\n![](008i3skNly1gtn7lg1qukj60ce066wen02.jpg)\n\n随着各组织转向技术，以缓解疫情的影响并增加业务增长，信息和通信行业在招聘技术职位方面处于领先地位。其他行业，如制造业，物流和支持服务，专业、科学和技术服务，以及金融和工业行业也是招聘技术职位的主要行业之一。\n', '\/trans\/europoe-it-hiring-report-2021\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">2021 年度欧洲 IT 求职报告解读。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/takeaways-from-gartners-2021-hype-cycle-for-cloud-security-report/">[译] 从 Gartner 的 2021 年云安全炒作周期报告中得到的启示</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2021/08/15</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e4%b8%9a%e6%80%81"> 
             业态
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://venturebeat.com/2021/08/12/takeaways-from-gartners-2021-hype-cycle-for-cloud-security-report/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('从 Gartner 的 2021 年云安全炒作周期报告中得到的启示', '云原生应用保护平台（CNAPP）和安全服务边缘（SSE）在今年迎来了的云安全领域的上升周期。', '\nGartner 在该集团的最新预测中称，2021 年全球公有云服务将增长 26.2%，见 Forecast: Public Cloud Services, Worldwide, 2019-2025, 2Q21 Update。\n\n2020 年，云计算使 IT 路线图和计划不断向前推进，同时支持不断增长的虚拟劳动力和破纪录的数字转型步伐。麦肯锡对全球高管的调查发现，数字化转型的步伐在 2020 年加快了 7 年。\n\n此外，61% 的企业将云计算作为其数字化转型工作的一部分，其收入增长了 25% 或更多。云基础设施还使 IT 部门能够满足新的应用程序和系统的紧迫的上市时间表。然而，当云基础设施为应对不可预测的工作负载而扩大和缩小规模时，IT 怀疑论者变成了信徒，而之前的预测数据又无法依赖。\n\nGartner 引述了疫情之后企业对云计算的加速采用，预计这将推动五年的复合年增长率（CAGR）达到 21.5%。因此，全球公有云服务预计将从 2021 年的 3877 亿美元增长到 2025 年的 8055 亿美元。到 2023 年，所有企业工作负载的 70% 将部署在云基础设施和平台服务中，而 2020 年为 40%。\n\n## 复杂度等同于风险\n\n企业的云计算复杂性越大，网络安全风险也越大。云在企业中的主导地位带来了更复杂的网络安全风险和更多的潜在危险，需要相应的更高级别的安全技术。企业的云计算基础设施越复杂，其安全挑战就越大。Gartner 预测，到 2025 年，超过 99% 的云计算漏洞将被追溯到终端用户可预防的错误配置。Gartner 的最新云安全报告反映了企业在所有业务线和基础设施层面采用云优先战略的进展。\n\n最新的 Hype Cycle 介绍了 29 项技术，比去年的 33 项有所减少。Gartner 已经删除了云安全评估、云测试工具和服务、灾难恢复即服务（DRaaS）、以文件为中心的身份证明、OAuth 2.0 和 OpenID Connect。多云管理服务（MCMS）是今年炒作周期的一个新类别，以前被称为云服务代理（CSB）。Gartner 将 CSB 定义为一种 IT 角色和商业活动，其中公司或内部实体为一个或多个（公有或私有）云服务增加价值。\n\n## 主要启示\n\n- 云原生应用保护平台（CNAPP）是今年炒作周期的新产品。CNAPP 通过整合多种云原生工具和数据源，包括基础设施即代码（IaC）扫描，帮助保护云原生应用。随着几乎所有的企业都在向多云战略迁移，公有云的部署速度继续加快，并将最终超过私有数据中心的工作负载。Gartner 创建新类别的逻辑是跟踪多云部署的主导地位如何迫使企业结合智能自动化，包括云安全态势管理（CSPM）和云工作负载保护平台（CWPP），以保护其 IaaS 部署的应用程序。\n- 安全服务边缘（SSE）也是今年炒作周期的新内容。虚拟劳动力、数字优先的销售、服务和客户体验正在推动安全服务边缘（SSE）技术的采用。事实证明，SSE 技术和解决方案能够有效降低保护端点的复杂性，同时在企业范围内提高云服务的安全性。SSE 通过访问控制、威胁保护、数据安全、安全监控和基于网络和 API 的集成执行可接受的使用控制来提供改进的端点安全，我们看到 SSE 正在快速增长，并作为基于云的服务提供，少数供应商也提供企业内部和基于代理的组件作为其架构的一部分。据 Gartner 称，基于身份和背景的零信任、最少特权的访问是领先的 SSE 产品的核心能力。今年，SSE 也出现在网络安全和应用安全的炒作周期中。\n- 支持虚拟工作团队的挑战正在推动云安全的创新。此外，企业对其虚拟工作团队的依赖性增加，为云网络安全供应商提高新产品开发的强度和速度创造了机会。Gartner 认为，这种态势推动了对 SaaS 安全态势管理（SSPM）、增强型身份保护工具（云交付的 IAM）和零信任网络访问（ZTNA）等领域的改进工具和创新需求，以取代传统的 VPN 技术。\n- IT、安全和风险管理领导人今年优先考虑企业数字资产管理（EDRM）和能够消除错误配置的云工具。Gartner 认为，EDRM，也被称为信息权利管理（IRM），为敏感数据提供持久的保护，其中知识产权是公司高管的首要关注点。EDRM 还用于保留对通过伙伴关系在安全协作工作流程中传输的非结构化数据的控制。此外，IT 领导人正在寻找新的工具，以减少并可能消除云的错误配置，因为许多人在内部安全审计的基础上发现了新的改进领域。\n- 在过去的一年里，向 Gartner 提出的关于 CIEM 的询问增加了一倍多。据 Gartner 称，云基础设施权利管理（CIEM）工具帮助企业通过管理时间控制来管理混合和多云 IaaS 中的权利，从而管理云访问风险。CIEM 平台还依靠分析、机器学习和人工智能来识别账户定义和权限中的异常情况。CIEM 对于零信任网络访问（ZTNA）战略是不可或缺的，因为它提供了最小特权访问的执行和补救。\n\n## 结论\n\nGartner 最新的云安全炒作周期反映了当前疫情对网络安全领域秩序重建是多么迅速。IT、风险和管理专业人员最关心的是如何保持他们的知识产权（IP）的安全，并减少错误配置云基础设施的情况。内部审计对错误配置如何导致云基础设施的安全漏洞提供了宝贵的见解，特别是在混合云配置中。\n\n现在有很多机会来确保虚拟劳动力的安全，同时保护数字化转型战略取得成功所必需的混合和多云基础设施。这种压力给网络安全厂商带来了新的创新强度。这种强度体现在云原生应用保护平台（CNAPP）和安全服务边缘（SSE）在今年的云安全炒作周期中所起的关键作用。\n', '\/trans\/takeaways-from-gartners-2021-hype-cycle-for-cloud-security-report\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">云原生应用保护平台（CNAPP）和安全服务边缘（SSE）在今年迎来了的云安全领域的上升周期。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/the-future-of-microservices/">[译] 微服务的未来——更多层抽象</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2021/08/13</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e5%85%b6%e4%bb%96"> 
             其他
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://thenewstack.io/the-future-of-microservices-more-abstractions/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('微服务的未来——更多层抽象', '在进入微服务时代的十年里，思考一下我们已经走到了哪一步，以及我们还需要解决哪些问题是很有意思的。', '\n[微服务](https:\/\/thenewstack.io\/category\/microservices\/)是在 10 年前出现的，是软件融合进化的例子之一。虽然这个词可以归功于软件咨询公司 [ThoughtWorks](https:\/\/www.thoughtworks.com\/) 的 [James Lewis](https:\/\/twitter.com\/boicy) 和 Martin Fowler，[Adrian Cockcroft](https:\/\/www.linkedin.com\/in\/adriancockcroft\/) 也曾提出类似的想法。但当时在 Netflix 和许多硅谷的其他公司，如亚马逊、Google 和 eBay 等公司大致在相同的时间内独立搭建了或多或少相同的架构模式。\n\n在这个词诞生后的十年里，我们看到了 Kubernetes、服务网格和无服务器的兴起，我们也开始看到微服务被应用到了前端。除了可以横向扩展，微服务还可以让开发人员更快地部署代码，有利于组件的可替换性而不是可维护性。\n\n无论好坏，对许多人来说，微服务已经成为默认的架构选择。对于拥有自主团队和松散耦合系统的组织来说，微服务可以很好地工作，但它们带来了所有分布式系统都无法逃避的复杂性。\n\n“我坚决认为公共云比私有云和数据中心更好，这些好处是一目了然的。在许多情况下，是恐惧让人们畏缩不前。“独立技术顾问 [Sam Newman](https:\/\/www.linkedin.com\/in\/samnewman\/) 告诉 The New Stack，他的 [Building Microservices](https:\/\/samnewman.io\/books\/building_microservices_2nd_edition\/) 一书的第二版将在今年 8 月出版。“但是对于微服务，事情将比这复杂得多的多。”\n\n考虑到这一点，在进入微服务时代的十年里，思考一下我们已经走到了哪一步，以及我们还需要解决哪些问题是很有意思的。\n\n## 盘点：部署和运行时间\n\n现在有各种各样成熟的、设计良好的微服务框架，涵盖了大多数语言的基础知识，在 JVM 上有大量的选择，包括 [Spring Boot](https:\/\/spring.io\/projects\/spring-boot)、[Dropwizard](https:\/\/www.dropwizard.io\/en\/latest\/)、[Helidon](https:\/\/helidon.io\/#\/)、[Lagom](https:\/\/www.lagomframework.com\/)、[Micronaut](https:\/\/micronaut.io\/) 和 [Quarkus](https:\/\/quarkus.io\/)，同时还有 [Go kit](https:\/\/github.com\/go-kit\/kit)（Go）、[Flask](https:\/\/flask.palletsprojects.com\/en\/2.0.x\/) 和 [Falcon](https:\/\/falconframework.org\/)（Python）、[Node.js](https:\/\/nodejs.org\/en\/)（JavaScript）等选择。\n\n同样地，好的监控工具也比比皆是。[OpenTelemetry](https:\/\/thenewstack.io\/getting-started-with-opentelemetry-for-java\/) 的出现尤其重要。它由 OpenTracing 和 OpenCensus 合并而成，拥有广泛的供应商和语言支持，为分布式遥测数据提供标准化。这意味着开发人员只需要对他们的代码进行一次检测，然后就可以交换和改变监控工具，比较相互竞争的解决方案，甚至在生产中为不同的需求运行多个不同的监控解决方案。\n\n然而，当我们看向部署和运行时，情况就变得有点模糊了。Kubernetes 已经或多或少地成为微服务的代名词，它的复杂性不断增加，促使云原生咨询公司 [Container Solutions](https:\/\/www.container-solutions.com\/) 的首席科学家 [Adrian Mouat](https:\/\/twitter.com\/adrianmouat) [猜测](https:\/\/blog.container-solutions.com\/10-predictions-for-the-future-of-computing)我们将看到它的竞争对手出现。\n\n“值得注意的是，这种复杂性不仅仅是隐藏在引擎盖下。“Mouat 说：“它正在溢出到界面上，影响到用户。“黑进 kubectl 运行并得到一个演示并运行仍然相当容易。但是，运行生产应用程序并弄清楚如何安全地暴露它们需要了解大量不同的功能，这不可避免地导致 YAML 文件比大多数微服务源代码还要长。”\n\nNewman 总结了一个基本挑战：“Kubernetes 对开发者并不友好。我们仍然没有一个好的、可靠的、类似 [Heroku](https:\/\/www.heroku.com\/) 的抽象，在 Kubernetes 之上被广泛使用，这让我感到震惊。”\n\n[Spotify](https:\/\/www.spotify.com\/) 的工程总监 [Pia Nilsson](https:\/\/www.linkedin.com\/in\/pia-nilsson-02b47b1\/) 曾 [谈到](https:\/\/engineering.atspotify.com\/2021\/05\/18\/a-product-story-the-lessons-of-backstage-and-spotifys-autonomous-culture\/)，这家快速扩张的公司的新工程师平均需要 60 天才能合并他们的第 10 个 pull request。作为回应，该公司建立了一个[开发者门户网站](https:\/\/thenewstack.io\/design-a-better-kubernetes-experience-for-developers\/) [Backstage](https:\/\/engineering.atspotify.com\/2020\/09\/24\/cloud-native-computing-foundation-accepts-backstage-as-a-sandbox-project\/)，现在是 [云原生计算基金会](https:\/\/cncf.io\/?utm_content=inline-mention)的一个[沙盒项目](https:\/\/backstage.io\/)。\n\n[Netflix](https:\/\/about.netflix.com\/) 非常重视 DevEx—— 该公司为开发者铺设的“道路”—— 利用它来帮助 [加速](https:\/\/www.infoq.com\/presentations\/devex-netflix-graphql\/) [GraphQL](https:\/\/graphql.org\/) 等新技术的 [采用](https:\/\/www.infoq.com\/presentations\/devex-netflix-graphql\/)。同样，我们已经看到了内部建设和通过 [Humanitec](https:\/\/humanitec.com\/) 等供应商建设的 [开发者平台](https:\/\/info.container-solutions.com\/the-rise-of-the-internal-developer-platform)的崛起。 [Ambassador Labs](https:\/\/www.getambassador.io\/) 有一个相关的 [开发者控制平面](https:\/\/www.getambassador.io\/developer-control-plane\/)的概念 —— 它的网站声称，“使开发者能够控制和配置整个云开发循环，以便更快地发布软件”。\n\n\u003e “Kubernetes 对开发者并不友好。我们仍然没有一个好的、可靠的、类似 [Heroku](https:\/\/www.heroku.com\/) 的抽象，在 Kubernetes 之上被广泛使用，这让我感到震惊。” ——Sam Newman，Building Microservices 作者\n\nAmbassador Labs 的开发者关系总监 [Daniel Bryant](https:\/\/www.linkedin.com\/in\/danielbryantuk) 告诉 The New Stack：“如果你看看 [Airbnb](https:\/\/www.airbnb.com\/)、[Shopify](https:\/\/www.shopify.com\/) 和 [Lunar](https:\/\/tech.lunar.app\/) 等公司正在做什么，它们之间有一个明显的共同点。他们正在为他们的开发者创建一个类似于 Heroku 的 CLI，这样，像’创建新的微服务’这样的命令就会产生一些支架，插入 CI，插入管道，插入可观测性。问题是，你向开发者展示的抽象是什么，以便他们获得所需的可见性，同时也使他们所需的要求变得清晰？”\n\nBryant 特继续说：“开发者需要指定某些操作特性：这是一个内存大的服务；这个服务需要低延迟；这个服务需要非常接近那个服务。目前，你通过启动 Kubernetes 和编写大量的 YAML 来做到这一点。那里的抽象并不完全正确，特别是当你引入其他部署机制时，如[无服务器](https:\/\/thenewstack.io\/category\/serverless\/)和[低代码 \/ 无代码](https:\/\/thenewstack.io\/how-low-code-can-help-enterprise-software-development\/)。\n\n“我想知道谁能通过平台暴露出正确的抽象概念，然后让工程师决定如何打包他们的代码 —— 但他们打包的方式是一样的，而平台暴露出一些传统上属于运维的属性。”\n\n## 开放应用模型（OAM）\n\n其他几个关于 Kubernetes 的倡议也值得跟踪。由[微软和阿里云](https:\/\/thenewstack.io\/open-application-model-build-the-next-generation-of-cloud-native-applications\/)联合创建的[开放应用模型](https:\/\/oam.dev\/)（OAM）是一个描述应用的规范，将应用定义与集群的操作细节分开。因此，它使应用程序开发人员能够专注于其应用程序的关键要素，而不是其部署地点的操作细节。\n\n[Crossplane](https:\/\/crossplane.io\/) 是 [OAM](https:\/\/thenewstack.io\/oam-the-kubernetes-application-model-bridging-development-and-deployment\/) 的 Kubernetes 特定实现。它可以被企业用来在各种基础设施和云供应商之间建立和运维一个内部平台即服务（PaaS），这使得它在多云环境中特别有用，比如在那些兼并和收购越来越常见的大型企业中。\n\n虽然 OAM 试图将部署细节的责任从编写服务代码中分离出来，但服务网格旨在通过一个专门的基础设施层将服务间通信的责任从个人开发者那里转移出来，该层侧重于使用代理管理服务间的通信。不幸的是，它们也有复杂性的问题，而且还可能引入相当大的性能开销。\n\n因此，到目前为止，许多在生产中成功实施服务网格的案例都是在那些非常精通技术的初创公司。在 [2020 年与 InfoQ 的 Wes Reisz 的播客中](https:\/\/www.infoq.com\/podcasts\/monolith-microservices\/?)，Newman 建议在选择之前等待 6 个月，他告诉 The New Stack，他仍然给出同样的建议。\n\n“就该技术栈的权重、管理、影响以及性能带来的影响而言，它们的现实情况是非常可怕的，“Newman 说。“对有一些组织说，如果没有它们，有些事情是不可能完成的，[Monzo 就是一个很好的例子](https:\/\/monzo.com\/blog\/2019\/04\/03\/deploying-envoy-proxy) —— 在一个组织中，你有一个异构的技术栈，你需要做大规模的双向 TLS，我可以看到它的价值。但在我看来，它仍然是“概念很好，执行不力”。我想，我们可能会在很长时间内仍这样说。”\n\n## 隐藏服务网格\n\n有一件事可能会发生，至少对企业客户来说，性能问题往往不是那么尖锐，那就是服务网格被推到平台的更深处，并在很大程度上对开发者隐藏。例如，[红帽 OpenShift](https:\/\/www.openshift.com\/try?utm_content=inline-mention) [将 Istio 整合到平台层](https:\/\/www.openshift.com\/blog\/istio-on-openshift-in-2020)，还有多个类似的计划，将服务网格与公有云平台更紧密地整合在一起，如 [AWS App Mesh](https:\/\/aws.amazon.com\/app-mesh\/?aws-app-mesh-blogs.sort-by=item.additionalFields.createdDate\u0026aws-app-mesh-blogs.sort-order=desc\u0026whats-new-cards.sort-by=item.additionalFields.postDateTime\u0026whats-new-cards.sort-order=desc) 和 [Google Cloud Platform Traffic Director](https:\/\/cloud.google.com\/traffic-director)。\n\n关于服务网格的工作还在继续，以减少其所带来的网络开销。[Cilium](https:\/\/cilium.io\/) 团队的工作很有希望，它利用 Linux 内核中的 [eBPF](https:\/\/ebpf.io\/) 功能来实现它所说的“非常有效的网络、策略执行和负载均衡功能”。\n\n\u003e 我认为现在我们需要为其他人提供领域驱动设计（DDD）。因为即使是普通的开发者而不是架构师，也需要对如何确定实体的范围和边界有一定的了解，这其中有很多是回到了良好的 API 设计上。——Daniel Bryant，开发者关系总监，Ambassador Labs\n\n但另一种可能性是，我们可能完全转向不同的运行时。[Leading Edge Forum](https:\/\/leadingedgeforum.com\/) 的顾问 [Simon Wardley](https:\/\/www.linkedin.com\/in\/simonwardley\/) [认为](https:\/\/acloudguru.com\/blog\/engineering\/simon-wardley-is-a-big-fan-of-containers-despite-what-you-might-think)，函数即服务（Faas）\/ 无服务器将最终取代 Kubernetes，成为分布式应用事实上的标准运行时，我们也看到了一些真实的生产实例，比如 [BBC](https:\/\/www.bbc.com\/)，它的大部分在线架构已经从之前的 LAMP 堆栈 [直接转向了 AWS 上的 Lambda](https:\/\/www.infoq.com\/podcasts\/bbc-aws-lambda-react-cicd\/)。\n\n“我认为 FaaS 是一个管理部署的伟大抽象，“Newman 说。“作为一个对开发者友好的部署软件的抽象，它是自 Heroku 以来我们拥有的最好的东西。我确实认为目前的实现方式很差，但他们会改进。但他们只处理了在一次在一个地方执行一件任务。这并没有解决更大的网络系统的抽象问题”。\n\n作为一个例子，Newman 引用了[微软 Azure](https:\/\/azure.microsoft.com\/) 的 [Durable Functions](https:\/\/docs.microsoft.com\/en-us\/azure\/azure-functions\/durable\/durable-functions-overview?tabs=csharp)，它通过响应式扩展提供了类似于连续性的东西，允许开发者在无服务器环境中建立有状态的工作流和函数。但是，虽然部署抽象可能会有所改善，但如果想象你可以完全抽象出编写分布式系统的复杂性，那就太天真了。\n\n“你不能假设你说的东西就在那里，“Newman 说。“你不能假设数据会神奇地从一个时间点瞬时传送到另一个时间点。因为它不是这样的。而且，再多的抽象也无法解决这个基本问题。”\n\n## 自主团队的架构\n\n另一个仍然具有挑战性的领域与整个系统架构有关，以及围绕团队组织和结构的相关问题。正如 [IBM](https:\/\/www.ibm.com\/cloud?utm_content=logo-sponsorpage\u0026utm_source=thenewstack\u0026utm_medium=website\u0026utm_campaign=platform) 的全球开发者 leader [Holly Cummins](https:\/\/www.linkedin.com\/in\/holly-k-cummins) 在 云原生是关于文化而不是容器 一文中指出的，“即使有适当的自主团队，系统级的考虑也不会消失”。\n\nEric Evans 的《[领域驱动设计》](https:\/\/www.amazon.com\/gp\/product\/0321125215\/ref=as_li_tl?ie=UTF8\u0026camp=1789\u0026creative=9325\u0026creativeASIN=0321125215\u0026linkCode=as2\u0026tag=martinfowlerc-20)是微服务运动的基石，任何软件架构师都应该阅读，Bryant 说。但他更进一步说：\n\n“我认为现在我们需要为我们其他人提供 DDD，“他告诉 The New Stack。“因为即使是普通的开发者而不是架构师，也需要对如何确定实体和边界的范围有一定的了解，其中很多都要回到良好的 API 设计。一旦你理解了耦合和内聚的重要性，关注点和边界的分离，无论你处理的是什么抽象（模块、类、服务、应用），你都会自然而然地跳到这个齿轮上。”\n\nNewman 的 Building Microservices 一书的第二版即将推出，该书介绍了很多这些概念，并考虑到了下一代服务。\n\n在更新这本书时，Newman 告诉 The New Stack，“我想多谈一点耦合性。我想多谈一点内聚力。我想更多地谈论信息隐藏，这对我来说是现在最重要的事情。\n\n“我认为，即使人们掌握了分布式系统方面的知识，他们也没有掌握一个事实，即从根本上说，微服务只是模块化架构的一种形式。然而，很多创建微服务的人对什么是模块化架构或如何进行模块化毫无概念。”\n\nNewman 在新书中还引入了自 2014 年第一版出版以来出现的一些组织思维的变化。他特别引用了马修・斯凯尔顿（Matthew Skelton）和曼努埃尔・派斯（Manuel Pais）关于如何组织业务和技术团队以实现快速流动的极具影响力的作品[《团队拓扑（Team Topologies）》](https:\/\/teamtopologies.com\/book)，以及尼科尔・福斯格伦（Nicole Forsgren）、杰兹・汉伯（Jez Humble）和吉恩・金（Gene Kim）的[《加速（Accelerate）》](https:\/\/itrevolution.com\/accelerate-book\/)一书，该书探讨了精益管理和 DevOps 原则背后的科学。\n\n修订过程不仅揭示了有多少关于微服务的新知识可以分享，而且这些知识是如何不断积累的。\n\n“这本书可以让你广泛了解什么是微服务以及它对软件开发的影响，“Newman 说。“我发现我在向人们推荐，哦，你应该读那本书的第四章。现在我会说这个，而不是那个。我不想在推荐自己的书上一直含糊其辞。这就是为什么我写了第二版：因为我希望它是好的、准确的。”\n', '\/trans\/the-future-of-microservices\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">在进入微服务时代的十年里，思考一下我们已经走到了哪一步，以及我们还需要解决哪些问题是很有意思的。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-servicemesh-api-gateway/">如何理解 Istio Ingress，它与 API Gateway 有什么区别？</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2021/08/06</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('如何理解 Istio Ingress，它与 API Gateway 有什么区别？', '服务网格与 API 网关之间是什么关系？是不是使用了 Istio 就可以替代了 API 网关？Istio 的 API 网关是如何运作的？有哪些方式暴露 Istio mesh 中的服务？这篇文章给为你解答。', '\nAPI 网关作为客户端访问后端的入口，已经存在很长时间了，它主要是用来管理”南北向“的流量；近几年服务网格开始流行，它主要是管理系统内部，即“东西向”流量，而像 Istio 这样的服务网格还内置了网关，从而将系统内外部的流量纳入了统一管控。这经常给初次接触 Istio 的人带来困惑——服务网格与 API 网关之间是什么关系？是不是使用了 Istio 就可以替代了 API 网关？Istio 的 API 网关是如何运作的？有哪些方式暴露 Istio mesh 中的服务？这篇文章给为你解答。\n\n## 主要观点\n\n- 服务网格诞生的初衷是为了解决分布式应用的内部流量的管理问题，而在此之前 API 网关已存在很久了。\n- 虽然 Istio 中内置了 Gateway，但是你仍可以使用自定义的 Ingress Controller 来代理外部流量。\n- API 网关和服务网格正朝着融合的方向发展。\n\n## 如何暴露 Istio mesh 中的服务？\n\n下图展示了使用 Istio Gateway、Kubernetes Ingress、API Gateway 及 NodePort\/LB 暴露 Istio mesh 中服务的四种方式。\n\n![暴露 Kubernetes 中服务的几种方式](access-cluster.svg)\n\n其中阴影表示的是 Istio mesh，mesh 中的的流量属于集群内部（东西向）流量，而客户端访问 Kubernetes 集群内服务的流量属于外部（南北向）流量。不过因为 Ingress、Gateway 也是部署在 Kubernetes 集群内的，这些节点访问集群内其他服务的流量就难以归属了。\n\n| 方式                  | 控制器             | 功能                                                         |\n| --------------------- | ------------------ | ------------------------------------------------------------ |\n| NodePort\/LoadBalancer | Kubernetes         | 负载均衡                                                     |\n| Kubernetes Ingress    | Ingress Controller | 负载均衡、TLS、虚拟主机、流量路由                            |\n| Istio Gateway         | Istio              | 负载均衡、TLS、虚拟主机、高级流量路由、其他 Istio 的高级功能 |\n| API 网关              | API Gateway        | 负载均衡、TLS、虚拟主机、流量路由、API 生命周期管理、权限认证、数据聚合、账单和速率限制 |\n\n由于 NodePort\/LoadBalancer 是 Kubernetes 内置的基本的暴露服务的方式，本文就不讨论这种方式了。下文将对其他三种方式分别作出说明。\n\n## 使用 Kubernetes Ingress 暴露服务\n\n我们都知道 Kubernetes 集群的客户端是无法直接访问 Pod 的 IP 地址的，因为 Pod 是处于 Kubernetes 内置的一个网络平面中。我们可以将 Kubernetes 内的服务使用 NodePort 或者 LoadBlancer 的方式暴露到集群以外。同时为了支持虚拟主机、隐藏和节省 IP 地址，可以使用 [Ingress](https:\/\/kubernetes.io\/docs\/concepts\/services-networking\/ingress\/) 来暴露 Kubernetes 中的服务。Kubernetes Ingress 原理如下图所示。\n\n![使用 Kubernetes Ingress 暴露服务](ingress.svg)\n\n简单的说，Ingress 就是从 Kubernetes 集群外访问集群的入口，将用户的 URL 请求转发到不同的服务上。Ingress 相当于 Nginx、Apache 等负载均衡方向代理服务器，其中还包括规则定义，即 URL 的路由信息，路由信息得的刷新由 [Ingress controller](https:\/\/kubernetes.io\/docs\/concepts\/services-networking\/ingress\/#ingress-controllers)来提供。\n\n\n\u0060\u0060\u0060yaml\napiVersion: networking.k8s.io\/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    kubernetes.io\/ingress.class: istio\n  name: ingress\nspec:\n  rules:\n  - host: httpbin.example.com\n    http:\n      paths:\n      - path: \/status\/*\n        backend:\n          serviceName: httpbin\n          servicePort: 8000\n\u0060\u0060\u0060\n\n上面的例子中的 \u0060kubernetes.io\/ingress.class: istio\u0060 注解表明该 Ingress 使用的 Istio Ingress Controller。 \n\n## 使用 Istio Gateway 暴露服务\n\n我们都知道 Istio 是继承 Kubernetes 之后发展出来的一个流行的服务网格实现，它实现了 Kubernetes 没有的一些功能，请参考[什么是 Istio？为什么 Kubernetes 需要 Istio？](https:\/\/jimmysong.io\/blog\/what-is-istio-and-why-does-kubernetes-need-it\/)简要来说，正是因为 Istio 补足了 Kubernetes 对于云原生应用的流量管理、可观测性和安全方面的短板，使得流量管理变得对应用程序透明，使这部分功能从应用程序中转移到了平台层，成为了云原生基础设施。\n\nIstio 0.8 以前版本中使用 Kubernetes [Ingress](https:\/\/kubernetes.io\/docs\/concepts\/services-networking\/ingress\/) 来作为流量入口，其中使用 Envoy 作为 Ingress Controller。在 Istio 0.8 及以后的版本中，Istio 创建了 Gateway 对象。Gateway 和 VirtualService 用于表示 Istio Ingress 的配置模型，Istio Ingress 的缺省实现则采用了和 sidecar 相同的 Envoy 代理。通过该方式，Istio 控制面用一致的配置模型同时控制了入口网关和内部的 sidecar 代理。这些配置包括路由规则，策略检查、遥测收集以及其他服务管控功能。\n\nIstio Gateway 的功能与 Kubernetes Ingress 类似，它负责进出集群的南北流量。Istio Gateway 描述了一个负载均衡器，用于承载进出服务网格边缘的连接。该规范描述了一组开放端口和这些端口所使用的协议，以及用于负载均衡的 SNI 配置等。\n\nIstio Gateway 资源本身只能配置 L4 到 L6 的功能，例如暴露的端口、TLS 设置等；但 Gateway 可与 VirtualService 绑定，在 VirtualService 中可以配置七层路由规则，例如按比例和版本的流量路由，故障注入，HTTP 重定向，HTTP 重写等所有 Mesh 内部支持的路由规则。\n\n下面是一个 Gateway 与 VirtualService 绑定的示例。拥有 \u0060istio: ingressgateway\u0060 标签的 pod 将作为 Ingress Gateway 并路由对 \u0060httpbin.example.com\u0060 虚拟主机的 80 端口的 HTTP 访问，这相当于给 Kubernetes 敞开了一个外部访问的入口。这与使用 Kubernetes Ingress 最大的区别就是，需要我们手动将 VirtualService 与 Gateway 绑定，并指定 Gateway 所在的 pod。\n\n\u0060\u0060\u0060yaml\napiVersion: networking.istio.io\/v1alpha3\nkind: Gateway\nmetadata:\n  name: httpbin-gateway\nspec:\n  selector:\n    istio: ingressgateway\n  servers:\n  - port:\n      number: 80\n      name: http\n      protocol: HTTP\n    hosts:\n    - \u0022httpbin.example.com\u0022\n\u0060\u0060\u0060\n\n下面这个 VirtualService 通过 \u0060gateways\u0060 与上面的网关绑定在了一起，以接受来自该网关的流量。\n\n\u0060\u0060\u0060yaml\napiVersion: networking.istio.io\/v1alpha3\nkind: VirtualService\nmetadata:\n  name: httpbin\nspec:\n  hosts:\n  - \u0022httpbin.example.com\u0022\n  gateways:\n  - httpbin-gateway\n  http:\n  - match:\n    - uri:\n        prefix: \/status\n    route:\n    - destination:\n        port:\n          number: 8000\n        host: httpbin\n\u0060\u0060\u0060\n\n## 使用 API 网关暴露服务\n\nAPI 网关是位于客户端和后端服务之间的 API 管理工具，一种将客户端接口与后端实现分离的方式，在微服务中得到了广泛的应用。当客户端发出请求时，API 网关会将其分解为多个请求，然后将它们路由到正确的位置，生成响应，并跟踪所有内容。\n\nAPI Gateway 是微服务架构体系中的一类型特殊服务，它是所有微服务的入口，它的职责是执行路由请求、协议转换、聚合数据、认证、限流、熔断等。大多数企业 API 都是通过 API 网关部署的。API 网关通常会处理跨 API 服务系统的常见任务，例如用户身份验证、速率限制和统计信息。\n\n在网格中可以有一个或多个 API Gateway。API 网关的职责有：\n\n- 请求路由和版本控制\n- 方便单体应用到微服务的过渡\n- 权限认证\n- 数据聚合：监控和计费\n- 协议转换\n- 消息和缓存\n- 安全和报警\n\n以上很多基本功能比如路由和权限认证通过 Istio Gateway 也可以实现，只是在功能的丰富度和扩展性方面有些成熟的 API Gateway 可能更占优势，不过在 Istio mesh 中再引入 API Gateway 也可能带来一些弊端。\n\n- 引入了 API Gateway，需要考虑 API Gateway 本身的部署、运维、负载均衡等场景，增加了后端服务的复杂度\n- API Gateway 中承载了大量的接口适配，导致难以维护\n- 对于部分场景，增加了一跳可能导致性能的降低\n\n## 总结\n\n在 Istio mesh 中你可以使用多种 Kubernetes Ingress Controller 来充当入口网关，当然你还可以直接使用 Istio 内置的 Istio 网关，对于策略控制、流量管理和用量监控可以直接通过 Istio 网关来完成，这样做的好处是通过 Istio 的控制平面来直接管理网关，而不需要再借助其他工具。但是对于 API 生命周期管理、复杂的计费、协议转换和认证等功能，传统的 API 网关可能更适合你。所以，你可以根据自己的需求来选择，也可以组合使用。\n\n目前有些传统的反向代理也在向 Service Mesh 方向发展，如 Nginx 构建了 [Nginx Service Mesh](https:\/\/www.nginx.com\/products\/nginx-service-mesh\/)，Traefik 构建了 [Traefik Mesh](https:\/\/traefik.io\/traefik-mesh\/)。还有的 API 网关产品也向 Service Mesh 方向挺进，比如 Kong 发展出了 [Kuma](https:\/\/kuma.io)。在未来，我们会看到更多 API 网关、反向代理和服务网格的融合产品出现。\n\n## 参考\n\n- [利用 Gateway API 发展 Kubernetes 网络](https:\/\/cloudnative.to\/blog\/evolving-kubernetes-networking-with-the-gateway-api\/)\n- [如何为服务网格选择入口网关？](https:\/\/cloudnative.to\/blog\/how-to-pick-gateway-for-service-mesh\/)\n- [Service Mesh 和 API Gateway 关系深度探讨](https:\/\/cloudnative.to\/blog\/service-mesh-and-api-gateway\/)\n- [在 Istio 服务网格中使用 Traefik Ingress Controller](https:\/\/cloudnative.to\/blog\/using-traefik-ingress-controller-with-istio-service-mesh\/)\n', '\/blog\/istio-servicemesh-api-gateway\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">服务网格与 API 网关之间是什么关系？是不是使用了 Istio 就可以替代了 API 网关？Istio 的 API 网关是如何运作的？有哪些方式暴露 Istio mesh 中的服务？这篇文章给为你解答。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
          <div class="col-12">
 
 
 
 
 
 
 
 
 
 
 
 <nav aria-label="Page navigation">
   <ul class="pagination justify-content-center">
     
     
     <li class="page-item">
       <a class="page-link" href="/blog/">
         ««
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a href="/blog/page/20/" class="page-link">
         «
       </a>
     </li>
     
     
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item">
           <a href="/blog/page/19/" class="page-link">
             19
           </a>
         </li>
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item">
           <a href="/blog/page/20/" class="page-link">
             20
           </a>
         </li>
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item page-item active ">
           <a href="/blog/page/21/" class="page-link">
             21
           </a>
         </li>
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item">
           <a href="/blog/page/22/" class="page-link">
             22
           </a>
         </li>
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item">
           <a href="/blog/page/23/" class="page-link">
             23
           </a>
         </li>
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
     
     
     <li class="page-item">
       <a href="/blog/page/22/" class="page-link">
         »
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a class="page-link" href="/blog/page/29/">
         »»
       </a>
     </li>
     
   </ul>
 </nav>
 
</div>

        </div>
      </div>
      <!-- sidebar -->
      <aside class="col-lg-4 order-1 order-lg-2 d-none d-sm-block">
          <div class="sidebar">
          <!-- categories -->
<div class="blog-categories mb-4">
  <p class="sidebar-title">
      专栏
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/istio" class="sidebar-item">
            <span>Istio</span>
            <span>(81)</span>
        </a>
      
        <a href="/categories/service-mesh" class="sidebar-item">
            <span>Service Mesh</span>
            <span>(42)</span>
        </a>
      
        <a href="/categories/kubernetes" class="sidebar-item">
            <span>Kubernetes</span>
            <span>(25)</span>
        </a>
      
        <a href="/categories/%e9%9a%8f%e7%ac%94" class="sidebar-item">
            <span>随笔</span>
            <span>(22)</span>
        </a>
      
        <a href="/categories/%e5%85%b6%e4%bb%96" class="sidebar-item">
            <span>其他</span>
            <span>(19)</span>
        </a>
      
        <a href="/categories/envoy" class="sidebar-item">
            <span>Envoy</span>
            <span>(18)</span>
        </a>
      
        <a href="/categories/%e4%b8%9a%e6%80%81" class="sidebar-item">
            <span>业态</span>
            <span>(17)</span>
        </a>
      
        <a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f" class="sidebar-item">
            <span>云原生</span>
            <span>(14)</span>
        </a>
      
        <a href="/categories/ai" class="sidebar-item">
            <span>AI</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%ae%89%e5%85%a8" class="sidebar-item">
            <span>安全</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%bc%80%e6%ba%90" class="sidebar-item">
            <span>开源</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e6%97%85%e8%a1%8c" class="sidebar-item">
            <span>旅行</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e5%b7%a5%e5%85%b7" class="sidebar-item">
            <span>工具</span>
            <span>(6)</span>
        </a>
      
        <a href="/categories/%e5%8f%af%e8%a7%82%e6%b5%8b%e6%80%a7" class="sidebar-item">
            <span>可观测性</span>
            <span>(5)</span>
        </a>
  </div>
</div>

<div class="blog-categories mb-4">
  <p class="sidebar-title">
      资料
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/%e5%87%ba%e7%89%88%e7%89%a9" class="sidebar-item">
            <span>出版物</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e7%94%b5%e5%ad%90%e4%b9%a6" class="sidebar-item">
            <span>翻译电子书</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e6%96%87%e6%a1%a3" class="sidebar-item">
            <span>翻译文档</span>
            <span>(7)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>翻译图书</span>
            <span>(6)</span>
        </a>
      
        <a href="/categories/%e5%8e%9f%e5%88%9b%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>原创图书</span>
            <span>(2)</span>
        </a>
      
        <a href="/categories/%e6%95%99%e7%a8%8b%e6%89%8b%e5%86%8c" class="sidebar-item">
            <span>教程手册</span>
            <span>(2)</span>
        </a>
  </div>
</div>





          </div>
      </aside>
      <!-- /sidebar -->
    </div>
  </div>
</section>




<footer>
  
  <div class="footer bg-footer section-sm border-bottom overlay ">
    <div class="container-xl">
      <div class="row">
        <div class="col col-xl-4 d-sm-none mb-2 mb-lg-0 d-xl-block d-none">
          
          <p class="h3 text-white mb-4 text-uppercase">联系</p>
          
          <ul class="list-unstyled">
            
            
            <li class="mb-4 text-color">微信公众号</li>
            
            
            <li class="mb-4"><img src="/images/servicemesher-wechat.webp" width="118px" height="118px" alt="footer image"></li>
            
            
            
          
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">博客</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/blog/envoy-ext-proc-guide/">深入解析 Envoy 外部处理过滤器（ext_proc）</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/istio-ambient-l7-flow-analysis/">深入 Istio Ambient 模式：从 ztunnel 到 Waypoint 代理的 L7 流量路径解析</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/building-private-ai-knowledge-base-anythingllm/">探索 AnythingLLM：借助开源 AI 打造私有化智能知识库</a></li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">链接</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://istio.io/latest/zh/" target="_blank" rel="noopener noreferrer">
                  Istio 服务网格
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://tetrate.io/?jimmysong" target="_blank" rel="noopener noreferrer">
                  Tetrate 公司
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener noreferrer">
                  云原生学院|Bilibili
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/awesome-cloud-native/" target="_blank" rel="noopener noreferrer">
                  云原生开源项目大全
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://cloudnative.to" target="_blank" rel="noopener noreferrer">
                  云原生社区（中国）
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">教程</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/envoy-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Envoy 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/istio-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Istio 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/kubernetes-handbook/" >
                  Kubernetes 基础教程
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/envoy-made-simple/" >
                  简明 Envoy 教程
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">通知</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/notice/nist-sp-800-233-service-mesh-proxy-models/">资料分享：云原生应用服务网格代理模型的威胁分析指南</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/kubecon-china-2024-panel/">KubeCon China 2024（香港）</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/website-revamp-notice/">网站改版通知</a></li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>

  
  <div class="copyright py-4 bg-footer overlay">
    <div class="container-xl">
      <div class="row">
        <div class="col-sm-6 text-sm-left text-center">
          <p class="mb-0 text-color">© 2017-2024 Jimmy Song 保留所有权利</p>
        </div>
        <div class="col-sm-6 text-sm-right text-center">
          <ul class="list-inline">
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://twitter.com/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-x-twitter text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/contact/" >
                    <i class="fa-brands fa-weixin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://github.com/rootsongjc" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-github text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://linkedin.com/in/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-linkedin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="mailto:rootsongjc@gmail.com" >
                    <i class="fa-solid fa-envelope text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/blog/index.xml" >
                    <i class="fa-solid fa-rss text-white"></i>
              </a>
            </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>


<!-- JS Plugins -->

<script src="/plugins/popper/popper.min.js"></script>

<script src="/plugins/bootstrap/bootstrap.min.js"></script>

<script src="/plugins/slick/slick.min.js"></script>

<script src="/plugins/filterizr/jquery.filterizr.min.js"></script>

<script src="/plugins/search/fuse.min.js"></script>

<script src="/plugins/search/mark.js"></script>

<script src="/plugins/hex_md5/hex_md5.js"></script>

<script src="/plugins/anchor/anchor.min.js"></script>

<script src="/plugins/tocbot/tocbot.min.js"></script>

<script src="/plugins/bigger-picture/bigger-picture.min.js"></script>


<!-- Main Script -->

<script src="/js/script.min.f94c22b1d478bfc9e2e0a7d954429e47b7e6d36edd423758482e04154ae1842e.js"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-ESY906ZWZ0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ESY906ZWZ0');
</script>


<!-- Baidu analysis -->
<meta name="baidu-site-verification" content="g8IYR9SNLF" />





<script>
    anchors.add();
</script>






<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>










<script src="/js/wowchemy-search.min.7a37268e7bbe4a9160c2e4c33b749816.js" type="module"></script>
<script id="search-hit-fuse-template" type="text/x-template">
  <div class="search-hit" id="summary-{{key}}">
    <div class="search-hit-content border-bottom">
      <div class="search-hit-name">
        <div class='search-hit-link'><a href="{{relpermalink}}">{{title}}</a></div>
        <div class="search-hit-metadata d-flex">
            <span class="mr-1"><i class="fa-regular fa-calendar mr-1"></i>{{date}}</span>
            <span class="mr-1"><i class="fa-regular fa-folder-open mr-1"></i>{{section}}</span>
            <span class="d-sm-block d-none"><i class="fa-solid fa-link mr-1"></i>{{relpermalink}}</span>
        </div>
        <div class="search-hit-description">{{snippet}}</div>
      </div>
    </div>
  </div>
</script>



    </body>
</html>
