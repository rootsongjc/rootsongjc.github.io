<!DOCTYPE html>
<html lang="zh"><head>
  <meta charset="utf-8">
  
  <title>博客 - Jimmy Song</title>
  

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta name="description" content="专注开源技术、云原生与生活随笔的分享与思考。">
  <meta name="author" content="Jimmy Song">
  <meta name="generator" content="Hugo 0.136.0">

  <!-- CSS plugins -->
  
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
  
  <link rel="preload" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" as="style">
  <link rel="stylesheet" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" media="screen">
  

  <!-- Main Stylesheet -->
  
  <link rel="preload" href="/scss/style.min.784204edcd29c092198e88494fa2ae755eba9ae231d6fa7faf8e7da3207b4623.css" as="style">
  <link rel="stylesheet" href="/scss/style.min.784204edcd29c092198e88494fa2ae755eba9ae231d6fa7faf8e7da3207b4623.css" media="screen">

  <!-- Bigger picture css -->
  
  <link rel="stylesheet" href="/plugins/bigger-picture/bigger-picture.min.css" media="print" onload="this.media='all'">
  <!--Favicon generate by https://realfavicongenerator.net-->
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="200x200" href="/images/favicon.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">

  <link href='/opensearchdescription.xml' rel='search' title='Content search' type='application/opensearchdescription+xml'/>

  <!--Twitter card-->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="jimmysong.io" />
  <meta name="twitter:creator" content="@jimmysongio" />
  <meta property="og:url" content="https://jimmysong.io/blog/" />
  <meta property="og:title" content="博客 | Jimmy Song" />
  <meta property="twitter:title" content="博客 | Jimmy Song" />

  
  <meta property="og:description" content="专注开源技术、云原生与生活随笔的分享与思考。" />
  <meta property="twitter:description" content="专注开源技术、云原生与生活随笔的分享与思考。" />

  
  <meta property="og:image" content="https://jimmysong.io/images/banner/default.jpg" />
  <meta property="twitter:image" content="https://jimmysong.io/images/banner/default.jpg" />

  
  
</head>
<body>
<header class="fixed-top header">
  
  
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa fa-arrow-circle-up" aria-hidden="true"></i></button>
  
  <div class="navigation w-100 ">
    <div class="container-xl">
      <nav class="navbar navbar-expand-lg navbar-light p-0">
        <a class="navbar-brand" href="/">
            
            <b>JIMMY SONG</b>
            
        </a>
        <button class="navbar-toggler rounded-0" type="button" data-toggle="collapse" data-target="#navigation"
          aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse text-center" id="navigation">
          <ul class="navbar-nav ml-auto">
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/blog">博客</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/book">资料</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/tags">标签</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/notice">公告</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/contact">联系</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/about">关于</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/community/">社区</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener">视频 <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i></a>
              
            </li>
            
            

          
          
          <li class="nav-item">
            
            
            
              
              
                
                
                
                  
                    
                    <a class="nav-link" href="/en/blog/">English</a>
                    
                  
                
              
              
              
                
                  
                    
                    
                  
                
                
                
              
          </li>
          
          
          <!-- search -->
           <button type="button" class="search-btn js-search" id="searchOpen" aria-label="Search">
              <div class="search-container d-flex justify-content-center">
              <span class="search-content">
                  <i class="fa fa-search"></i>
                  <span>搜索</span>
              </span>
              <span class="search-shortcuts d-none d-sm-block">
                  <kbd class="cmd-key">⌘</kbd>
                  <kbd class="k-key">K</kbd>
              </span>
              </div>
          </button>
          
          </ul>
        </div>
      </nav>
    </div>
  </div>
</header>


            <aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between">
        <div class="col-6 search-title">
          <p>站内搜索</p> 
        </div>
        <div class="col-6 col-search-close">
          <div class="js-search" aria-label="关闭"><i class="fa-solid fa-circle-xmark text-muted" aria-hidden="true"></i></div>
        </div>
      </div>

      <div id="search-box">
        <i class="fa-solid fa-magnifying-glass" id="search-icon" aria-hidden="true"></i>
        <input name="q" id="search-query" placeholder="请输入搜索词" autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control" aria-label="请输入搜索词">
        
        <div class="mt-4">
          <span>搜索类型: </span>
          <span>
            <input type="radio" id="all" name="search_type" value="all" checked>
            <label for="all">所有</label>
            
              <input type="radio" id="blog" name="search_type" value="blog">
              <label for="blog">原创</label>
              <input type="radio" id="trans" name="search_type" value="trans">
              <label for="trans">译文</label>
            
            <input type="radio" id="book" name="search_type" value="book">
            <label for="book">资料</label>
            <input type="radio" id="notice" name="search_type" value="notice">
            <label for="notice">公告</label>
          </span>
        </div>
      </div>
      
    </section>
    <section class="section-search-results">
      <div id="search-results-count" class="search-results-count"></div>
      <div id="search-hits">
        
      </div>
    </section>
  </div>
</aside>

        
        
            

<section class="bg-cover page-title-section overlay" style="background-image: url('/images/backgrounds/circle.svg'),url('/images/backgrounds/page-title.webp');background-size: cover;">
    <div class="container-xl">
        <div class="row">
            <div class="col-12">
                <p class="h1">
                    博客
                </p>
                <p class="page-description">
                    专注开源技术、云原生与生活随笔的分享与思考。
                </p>
                
            </div>
        </div>
    </div>
</section>

        


<section class="section-sm book-list-section bg-gray">
  <div class="container-xl">
    <div class="row">
      <div class="col-lg-8 order-2 order-lg-1">
        <div class="row">
          
          
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/tracing-grpc-with-istio/">[译] 在 Istio 中跟踪 gRPC</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2018/06/08</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('在 Istio 中跟踪 gRPC', '本文介绍的是如何在 Istio 中使用 grpc 并设置跟踪（tracing）与 header 传播，包括 gRPC 到 grpc 请求传播 header、gRPC 到 HTTP 请求传播 header、使用 grpc-gateway 时传播 header 等', '\nAspen Mesh 很喜欢用[gRPC](https:\/\/grpc.io\/docs\/)。Apen Mesh 面向公众的 API 和许多内部 API 大多都是使用 gRPC 构建的。如果您还没有听说过 gRPC（熟练掌握 gRPC 真的很难），那么我先为您简单的介绍下，它是一种新型、高效和优化的远程过程调用（RPC）框架。gRPC 基于[protocol buffer](https:\/\/developers.google.com\/protocol-buffers\/)序列化格式和[HTTP\/2](https:\/\/http2.github.io\/)网络协议。\n\n使用 HTTP\/2 协议，gRPC 应用程序可以利用多路复用请求显著提高连接利用率，而且比起如 HTTP\/1.1 等[其他协议](https:\/\/http2.github.io\/faq\/)具有更多增强功能。此外，protocal buffer 是以二进制方式对结构化数据进行序列化，这比起基于文本的序列化方式更简单且可扩展，还可以显着提高性能。将这两个结果组合在一个低延迟和高度可扩展的 RPC 框架中，这实质上就是 gRPC。此外，不断增长的 gRPC 生态支持使用多种语言编写应用程序，例如（C \u002b\u002b、Java、Go 等），还包括大量第三方[库](https:\/\/github.com\/grpc-ecosystem)。\n\n除了上面列出的好处之外，gRPC 让我最喜欢的一点是可以让我以简单直观的方式指定 RPC（使用 protobuf IDL）以及客户端调用服务器端的方法，就好像是调用本地函数一样。很多代码（服务描述和处理程序、客户端方法等）都可以自动生成，这使得 gRPC 非常好用。\n\n现在我已经介绍了 gRPC 的一些背景知识，我们再把注意力转回到博客的主题。在这里，我将介绍如何在基于 gRPC 的应用程序中添加跟踪，特别是如果您使用 Istio 或 Aspen Mesh。\n\n跟踪（Tracing）非常适合于调试和理解应用程序的行为。理解所有跟踪数据的关键是能够关联来自与单个客户端请求相关的多个不同微服务的跨度（span）。\n\n为了实现这一点，应用程序中的所有微服务应该传播跟踪 header。如果您使用的是像 Istio 或 Aspen Mesh 这样的服务网格，ingress 和 sidecar 代理会自动添加适当的跟踪 header，并将这些 span 报告给跟踪收集器后端，如 Jaeger 或 Zipkin。应用程序唯一要做的就是将传入请求（sidecar 或 ingress 代理添加的）的跟踪 header 传播到其对其他微服务的所有传出请求。\n\n## gRPC 到 grpc 请求传播 header\n\n使用 gRPC，跟踪 header 传播的最简单方法是使用[grpc opentracing middleware](https:\/\/github.com\/grpc-ecosystem\/go-grpc-middleware\/tree\/master\/tracing\/opentracing)库的客户端拦截器。如果您的 gRPC 应用程序在收到传入请求时发出新的出站 gRPC 请求，则可以使用此功能。以下是将传入的跟踪 header 正确传播到传出的 gRPC 请求的示例代码：\n\n\u0060\u0060\u0060go\n  import (\n    \u0022golang.org\/x\/net\/context\u0022\n    \u0022github.com\/grpc-ecosystem\/go-grpc-middleware\/tracing\/opentracing\u0022\n    \u0022ot \u0022github.com\/opentracing\/opentracing-go\u0022\n  )\n\n  \/\/ ctx is the incoming gRPC request\u0027s context\n  \/\/ addr is the address for the new outbound request\n  func createGRPCConn(ctx context.Context, addr string) (*grpc.ClientConn, error) {\n  \tvar opts []grpc.DialOption\n  \topts = append(opts, grpc.WithStreamInterceptor(\n  \t\tgrpc_opentracing.StreamClientInterceptor(\n  \t\t\tgrpc_opentracing.WithTracer(ot.GlobalTracer()))))\n  \topts = append(opts, grpc.WithUnaryInterceptor(\n  \t\tgrpc_opentracing.UnaryClientInterceptor(\n  \t\t\tgrpc_opentracing.WithTracer(ot.GlobalTracer()))))\n  \tconn, err := grpc.DialContext(ctx, addr, opts...)\n  \tif err != nil {\n  \t\tglog.Error(\u0022Failed to connect to application addr: \u0022, err)\n  \t\treturn nil, err\n  \t}\n  \treturn conn, nil\n  }\n\u0060\u0060\u0060\n\n很简单对吧？\n\n添加 opentracing 客户端拦截器可确保在客户端连接上创建任何新的一元（unary）或流式 gRPC 请求注入正确的跟踪 header。如果传递的上下文中存在跟踪 header（如使用 Aspen Mesh 或 Istio 传入入站 gRPC 请求上下文），则新创建的 span 将作为传递的上下文中已存在的 span 的子 span。另外，如果上下文中没有跟踪信息，则会为出站 gRPC 请求创建新的根 span。\n\n## gRPC 到 HTTP 请求传播 header\n\n我们再来看下这个场景，如果您的应用程序在收到一个新传入的 gRPC 请求时发出一个出站 HTTP\/1.1 请求。以下是在此情况下完成 header 传播的示例代码：\n\n\u0060\u0060\u0060go\n  import (\n    \u0022net\/http\u0022\n    \u0022golang.org\/x\/net\/context\u0022\n    \u0022golang.org\/x\/net\/context\/ctxhttp\u0022\n    \u0022ot \u0022github.com\/opentracing\/opentracing-go\u0022\n  )\n\n  \/\/ ctx is the incoming gRPC request\u0027s context\n  \/\/ addr is the address of the application being requested\n  func makeNewRequest(ctx context.Context, addr string) {\n    if span := ot.SpanFromContext(ctx); span != nil {\n      req, _ := http.NewRequest(\u0022GET\u0022, addr, nil)\n\n      ot.GlobalTracer().Inject(\n        span.Context(),\n        ot.HTTPHeaders,\n        ot.HTTPHeadersCarrier(req.Header))\n\n      resp, err := ctxhttp.Do(ctx, nil, req)\n      \/\/ Do something with resp\n    }\n  }\n\u0060\u0060\u0060\n\n这是序列化传入请求（HTTP 或 gRPC）上下文中跟踪 header 的标准方式。\n\n很好，至此我们已经能够使用库或标准实用程序代码来实现我们想要的功能。\n\n## 使用 grpc-gateway 时传播 header\n\ngRPC 应用程序中有一个常用的库[grpc-gateway](https:\/\/github.com\/grpc-ecosystem\/grpc-gateway)，可以将 gRPC 服务作为 RESTful JSON API 暴露出来。当您想要了解 gRPC 或维护 RESTful 架构，使用 curl、web 浏览器等客户端时，这非常有用。有关如何使用\u0060grpc-gateway\u0060从 gRPC 中暴露 RESTful API 的更多细节请参考[这个博客](https:\/\/coreos.com\/blog\/grpc-protobufs-swagger.html)。如果您对此架构不熟悉，我强烈建议您阅读。\n\n当您开始使用\u0060grpc-gateway\u0060并想传播跟踪 header 时，有一些值得一提的非常有趣的交互。 \u0060grpc-gateway\u0060 [文档](https:\/\/github.com\/grpc-ecosystem\/grpc-gateway#mapping-grpc-to-http)指出，作为 gRPC 请求 header，所有 IANA（互联网号码分配局）永久 HTTP header 都以\u0060grpcgateway-\u0060作为前缀并添加。这很好，但是像\u0060x-b3-traceid\u0060、\u0060x-b3-spanid\u0060等跟踪 header 不是 IANA 认可的永久 HTTP header，当\u0060grpc-gateway\u0060代理 HTTP 请求时，它们不会被复制到 gRPC 请求中。这意味着只要将\u0060grpc-gateway\u0060添加到您的应用程序中，header 传播逻辑就会停止工作。\n\n这是个特例吗？添加一个东西打断了当前的工作。不用担心，我为您解决问题！\n\n这是一种确保使用\u0060grpc-gateway\u0060在 HTTP 和 gRPC 之间进行代理时不会丢失跟踪信息的方法：\n\n\u0060\u0060\u0060go\n  import (\n    \u0022net\/http\u0022\n    \u0022golang.org\/x\/net\/context\u0022\n    \u0022google.golang.org\/grpc\/metadata\u0022\n    \u0022github.com\/grpc-ecosystem\/grpc-gateway\/runtime\u0022\n  )\n\n  const (\n  \tprefixTracerState  = \u0022x-b3-\u0022\n  \tzipkinTraceID      = prefixTracerState \u002b \u0022traceid\u0022\n  \tzipkinSpanID       = prefixTracerState \u002b \u0022spanid\u0022\n  \tzipkinParentSpanID = prefixTracerState \u002b \u0022parentspanid\u0022\n  \tzipkinSampled      = prefixTracerState \u002b \u0022sampled\u0022\n  \tzipkinFlags        = prefixTracerState \u002b \u0022flags\u0022\n  )\n\n  var otHeaders = []string{\n  \tzipkinTraceID,\n  \tzipkinSpanID,\n  \tzipkinParentSpanID,\n  \tzipkinSampled,\n  \tzipkinFlags}\n\n  func injectHeadersIntoMetadata(ctx context.Context, req *http.Request) metadata.MD {\n  \tpairs := []string{}\n  \tfor _, h := range otHeaders {\n  \t\tif v := req.Header.Get(h); len(v) \u003e 0 {\n  \t\t\tpairs = append(pairs, h, v)\n  \t\t}\n  \t}\n  \treturn metadata.Pairs(pairs...)\n  }\n\n  type annotator func(context.Context, *http.Request) metadata.MD\n\n  func chainGrpcAnnotators(annotators ...annotator) annotator {\n  \treturn func(c context.Context, r *http.Request) metadata.MD {\n  \t\tmds := []metadata.MD{}\n  \t\tfor _, a := range annotators {\n  \t\t\tmds = append(mds, a(c, r))\n  \t\t}\n  \t\treturn metadata.Join(mds...)\n  \t}\n  }\n\n  \/\/ Main function of your application. Insert tracing headers into gRPC\n  \/\/ metadata using annotators\n  func run() {\n    ...\n\t  annotators := []annotator{injectHeadersIntoMetadata}\n\n\t  gwmux := runtime.NewServeMux(\n\t\t  runtime.WithMetadata(chainGrpcAnnotators(annotators...)),\n\t  )\n    ...\n  }\n\u0060\u0060\u0060\n\n在上面的代码中，我使用了\u0060grpc-gateway\u0060库中的[\u0060runtime.WithMetadata\u0060](https:\/\/github.com\/grpc-ecosystem\/grpc-gateway\/blob\/master\/runtime\/mux.go#L88)。该 API 从 HTTP 请求中读取属性并将其添加到 gRPC 元数据中，这一点非常有用，这正是我们想要的！虽然多了一步，但仍然使用库提供的 API。\n\n\u0060injectHeadersIntoMetadata\u0060注解器在 HTTP 请求中查找跟踪 header 并将其附加到 gRPC 元数据中，从而确保跟踪 header 可以使用前面部分中提到的技术从 gRPC 进一步传播到出站请求。\n\n您可能观察到的另一个有趣的事情是\u0060chainGrpcAnnotators\u0060包装函数。\u0060runtime.WithMetadata\u0060 API 只允许添加一个注释器，这可能不足以满足所有场景。在我们的例子中，我们有一个跟踪注释器（如上面的一个示例）和一个认证注释器，它将来自 HTTP 请求的认证数据附加到 gRPC 元数据。使用\u0060chainGrpcAnnotators\u0060允许您添加多个注释器，并且包装函数将来自各种注释器的元数据加入到 gRPC 请求的单个元数据中。\n', '\/trans\/tracing-grpc-with-istio\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文介绍的是如何在 Istio 中使用 grpc 并设置跟踪（tracing）与 header 传播，包括 gRPC 到 grpc 请求传播 header、gRPC 到 HTTP 请求传播 header、使用 grpc-gateway 时传播 header 等</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/gitops-for-istio-manage-istio-config-like-code/">[译] Istio 的 GitOps—像代码一样管理 Istio 配置</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2018/05/31</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://www.weave.works/blog/gitops-for-istio-manage-istio-config-like-code" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio 的 GitOps—像代码一样管理 Istio 配置', '本文是 Weaveworks 的 CEO 对 GitOps 工作流程和 Istio 的看法。本文还介绍了如何使用 GitOps 上线和管理 Istio 的金丝雀部署。以上观点来自哥本哈根 Kubecon 上的 Weaveworks 的分享。', '\n在今年的哥本哈根 Kubecon 大会上，Weaveworks 的 CEO Alexis Richardson 与 Varun Talwar（来自一家隐形创业公司）谈到了 GitOps 工作流程和 Istio。会后 Weaveworks 的 Stefan Prodan 进行了的演示，介绍如何使用 GitOps 上线和管理 Istio 的金丝雀部署。\n\n会谈和演示中解释了：\n\n- 什么是 GitOps？为什么需要它？\n- Istio 和 GitOps 的最佳实践是如何管理在其上运行的应用程序的。\n- 如何使用 GitOps 工作流程和 Istio 进行金丝雀部署。\n\n### 什么是 GitOps？\n\n[GitOps 是实现持续交付的一种方式](https:\/\/www.weave.works\/blog\/the-gitops-pipeline)。“GitOps 使用 Git 作为声明式基础架构和应用程序的真实来源”Alexis Richardson 说。\n\n当对 Git 进行更改时，自动化交付管道会上线对基础架构的更改。但是这个想法还可以更进一步——使用工具来比较实际的生产状态和源代码控制中描述的状态，然后告诉你什么时候集群的状态跟描述的不符。\n\n### Git 启用声明式工具\n\n通过使用 Git 这样的声明式工具可以对整套配置文件做版本控制。通过将 Git 作为唯一的配置来源，可以很方便的复制整套基础架构，从而将系统的平均恢复时间从几小时缩短到几分钟。\n\n![](https:\/\/raw.githubusercontent.com\/servicemesher\/website\/master\/content\/blog\/gitops-for-istio-manage-istio-config-like-code\/00704eQkgy1fruc9ao41vj317o0oqq80.jpg)\n\n### GitOps 赋能开发人员拥抱运维\n\n[Weave Cloud](https:\/\/cloud.weave.works\/signup) 的 GitOps 核心机制在于 CI\/CD 工具，其关键是[支持 Git 集群同步](https:\/\/github.com\/weaveworks\/flux\/blob\/master\/site\/introduction.md#automated-git-cluster-synchronisation)的持续部署（CD）和发布管理。Weave Cloud 部署专为版本控制系统和声明式应用程序堆栈而设计。以往开发人员都是使用 Git 管理代码和提交 PR（Pull Request），现在他们也可以使用 Git 来加速和简化 Kubernetes 和 Istio 等其他声明式技术的运维工作。\n\n#### GitOps 的三个核心原则\n\n根据 Alexis 的说法，下面描述的是为何 GitOps 既是 Kubernetes 又是云原生核心的原因：\n\n**1. GitOps 的核心是声明式配置**\n\n通过使用 Git 作为实体源，并使用 Kubernetes 做滚动更新，可以观察集群并将其与期望的状态进行比较。 [通过将声明性配置视为代码](https:\/\/www.weave.works\/blog\/gitops-operations-by-pull-request)，它允许您通过在未成功时重新应用更改来强制收敛。\n\n**2. 不应该直接使用 Kubectl**\n\n根据一般规则来看，将代码经过 CI 直接 push 到生产并不是个好主意。许多人通过 CI 工具驱动部署，但是当你这样做的时候[你可能不得不做一个访问生产的东西](https:\/\/www.weave.works\/blog\/how-secure-is-your-cicd-pipeline)。\n\n**3. 使用 operator 模式**\n\n通过 operator 模式，集群将始终与 Git 中签入的内容保持同步。Weave Flux 是开源的，它是使用 Istio 演示下面的金丝雀部署的基础，您可以使用 operator 管理集群中的更改。\n\n![](https:\/\/raw.githubusercontent.com\/servicemesher\/website\/master\/content\/blog\/gitops-for-istio-manage-istio-config-like-code\/00704eQkgy1fruc9qogakj312t0ls41d.jpg)\n\n无论是开发流程还是生产流程，还是从预发到合并到生产，operator 都会将更改 pull 到集群中，即使是有多个更改也能以原子的方式部署。\n\n![](https:\/\/raw.githubusercontent.com\/servicemesher\/website\/master\/content\/blog\/gitops-for-istio-manage-istio-config-like-code\/00704eQkgy1fruca1y7xqj312p0jmn09.jpg)\n\n### Istio 的 GitOps 工作流程\n\n接下来，Varun Talwar 谈到了 Istio 是什么以及如何使用 GitOps 工作流管理应用程序。\n\nIstio 是一年前发布的服务网格。它是一个专用的基础设施层，用于为微服务架构中的所有服务间交互提供服务。Istio 中的所有操作都是通过声明式配置文件驱动的。也就是说像 Istio 这样的服务网格可以让开发人员在 Git 中像管理代码一样完全的管理服务行为。\n\n![](https:\/\/raw.githubusercontent.com\/servicemesher\/website\/master\/content\/blog\/gitops-for-istio-manage-istio-config-like-code\/00704eQkgy1frucacq5nij317u0oo46y.jpg)\n\n借助 Git 工作流程，开发人员可以对 Istio 中的任何内容进行建模，包括服务行为及其交互，如超时、断路器、流量路由、负载均衡及 A\/B 测试和金丝雀发布等。\n\n### 跨团队的多组配置\n\nIstio 有四个广泛的领域应用，都是通过声明式配置驱动的：\n\n1. 流量管理：与管理入口和服务流量有关。\n2. 可观测性：监控、流量延迟、QPS、错误率等。\n3. 安全性：所有服务间调用的认证与授权。\n4. 性能：包括重试超时、故障注入和断路等。\n\n因为所有这些领域都可以跨越组织内的不同团队，所以这使得在 Istio 上管理应用程序尤其具有挑战性。\n\n![](https:\/\/raw.githubusercontent.com\/servicemesher\/website\/master\/content\/blog\/gitops-for-istio-manage-istio-config-like-code\/00704eQkgy1frucalfge7j317u0oq7aq.jpg)\n\n这些配置驱动的很多设置是跨团队的。例如，有的团队想用 Zipkin 进行跟踪，而另一个团队可能想用 Jaeger。这些决策可以针对某一项服务进行，也可以跨服务进行。当决策跨越团队时，审批工作流程将变得更加复杂，并不总是原子性的。金丝雀发布不是原子的一次性事情。\n\n### 通过 GitOps 工作流程在 Istio 上做金丝雀部署\n\nStefan Prodan 向我们展示了如何使用带有 Weave Flux 和 Prometheus 的 GitOps 工作流程在 Istio 中做一次金丝雀发布——您可以在 Weave Cloud 中使用这些工具以及金丝雀部署和可观测性。\n\n简而言之，当您想要用一部分用户测试某些新功能时，会使用金丝雀部署或发布。传统上，您可能拥有两台几乎完全相同的服务器：一台用于所有用户，另一台用于将新功能部署到某一组用户。\n\n但通过使用 GitOps 工作流程，您可以通过 Git 控制您的金丝雀，而不是设置两个独立的服务器。当出现问题时，可以回滚到旧版本，并且可以在金丝雀部署分支上进行迭代，并继续发布，直到满足预期为止。\n\n![](https:\/\/raw.githubusercontent.com\/servicemesher\/website\/master\/content\/blog\/gitops-for-istio-manage-istio-config-like-code\/00704eQkgy1frucatn3n3j312q0lw102.jpg)\n\n#### 在 Weave Cloud 中，Git 控制的金丝雀发布具有完全可观测性\n\n通过流水线推送变更，您可以向用户发送部分一定比例的流量。使用 Weave Cloud，您可以在仪表板中观察金丝雀是否按预期工作。如果有问题可以继续修改，然后推出下一个版本，对其进行标记后通过同一流水线部署。这就是 GitOps 工作流程帮助您管理的迭代过程。\n\n### 总结\n\nAlexis Richardson 给了我们关于 GitOps 的概述，以及为什么您需要在管理运行在 Kubernetes 和 Istio 上的应用程序时考虑这种方法。然后 Varun Talwar 谈到了 Istio 是什么以及如何使用 GitOps 工作流程来管理应用程序。最后，Stefan Prodan 向我们展示了一个特殊用例，其中非原子工作流程（如金丝雀发布）也可以通过像 Istio 这样的服务网格上的 GitOps 进行管理。\n\n本次演讲的视频请见：[GitOps for Istio - Manage Istio Config like Code - Varun Talwar \u0026 Alexis Richardson](https:\/\/www.youtube.com\/watch?v=VkKMf23ZokY)\n', '\/trans\/gitops-for-istio-manage-istio-config-like-code\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文是 Weaveworks 的 CEO 对 GitOps 工作流程和 Istio 的看法。本文还介绍了如何使用 GitOps 上线和管理 Istio 的金丝雀部署。以上观点来自哥本哈根 Kubecon 上的 Weaveworks 的分享。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/introducing-cloud-native-programming-language-ballerina/">云原生编程语言 Ballerina 介绍</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2018/05/12</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f"> 
             云原生
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('云原生编程语言 Ballerina 介绍', '编译式强类型基于序列图理念的开源编程语言。', '\n当我第一眼看到 [Ballerina](https:\/\/ballerina.io) 还真有点惊艳的感觉。Ballerina 这个单词的意思是“芭蕾舞女演员”。我想他们之所以给公司和这们语言起这个名字，可能是希望它成为云原生这个大舞台中，Ballerina 能像一个灵活的芭蕾舞者一样轻松自如吧！\n\nBallerina 是一款开源的编译式的强类型语言，该语言本身的代码可以通过 [GitHub](https:\/\/github.com\/ballerina-platform\/ballerina-lang) 上获取。我们可以通过 Ballerina 官网上的设计哲学页面来对这门云原生编程语言一探究竟。\n\n![云原生编程语言 Ballerina](006y8mN6ly1g88c8tj7gxj30ws0u0774.jpg)\n\n未来的应用程序应该是基于 API 的，而众多 API 之间的通讯和集成就成了关键问题。Ballerina 是一款使用文本和图形语法编译的、事务的、静态和强类型编程语言。Ballerina 包含分布式系统集成到语言的基本概念，并提供类型安全，并发环境下实现的分布式事务，可靠的消息传递，流处理和工作流。\n\n## 为什么创建 Ballerina？\n\n与 ESB 集成仍然是瀑布式开发。你必须部署服务器，配置连接器，使用 XML 编程服务逻辑以及使用 XPath 查询和转换数据。这不是开发者友好的。\n\n带有 Spring 和 Node.js 等框架的编程语言提供了灵活性，但是它没有使适合于序列并行化、并发模型编程的分布式系统结构变得简单。\n\nESB、EAI、BPM 和 DSL 需要 XML 和配置来中断迭代开发流程：编辑、构建、运行和测试。这与运行实际应用之间是有一条鸿沟的，而云原生编程语言 Ballerina 的出现就是为了解决这条“集成鸿沟”的。\n\n## Ballerina 设计理念\n\n### 序列图\n\n![云原生编程语言 Ballerina 的序列图设计理念](006y8mN6ly1g88c8ji2zdj30u00wwdgm.jpg)\n\n**语言灵感**\n\n序列图反映了设计开发人员记录的互联的系统。Ballerina 的语法和高效的编码模式要求开发人员使用强大的交互最佳实践来编码。\n\n**序列图可视化**\n\nBallerina 的语言语义模型旨在定义独立的各方如何通过结构化的交互沟通。接着，每个 Ballerina 程序都可以显示为其流程的序列图。IntelliJ 和 VS Code 的插件中提供了这些可视化。Ballerina Composer 是一款通过序列图创建 Ballerina 服务的工具。\n\n**Actor 与 action**\n\n客户端、worker 和远程系统在 Ballerina 的序列图中以不同的 actor 表示。在代码中，远程端点通过连接器进行连接，连接器提供类型安全操作。在图形上，每个连接器在序列图中表示为一个 actor（即一条垂直线），action 表示为与这些 actor 的交互。\n\n### 并发\n\n![云原生编程语言 Ballerina 的并发理念](006y8mN6ly1g88c99h584j30u00ww752.jpg)\n\n**序列图和并发**\n\nBallerina 的并发模型是并行优先的，因为与远程方的交互总是涉及多个 worker。Worker 之间的交互作为消息传递进行处理，它们之间没有共享状态。\n\n**Worker 语义**\n\nBallerina 的执行模型由称为 woker 的轻量级并行执行单元组成。Worker 使用非阻塞策略来确保没有函数锁定正在执行的线程，例如等待响应的 HTTP I\/O 调用。\n\n**编程模型**\n\nWorker 和 fork\/join 语义抽象了底层非阻塞方法，以启用更简单的并发编程模型。\n\n### 类型系统\n\n下面是 Ballerina 中支持的类型。\n\n\u0060\u0060\u0060java\nany anything; \nint integer = 0;\nfloat floatingPoint = 0.0;\nboolean b = true; \nstring hi = \u0022hello\u0022; \nblob bl = hi.toBlob(\u0022UTF-8\u0022); \njson jsonNative = { a: \u0022hello\u0022, b: 5 }; \nxml x = xml \u0060\u003cballerina\u003e\n                \u003csupports\u003eXML natively\u003c\/supports\u003e\n             \u003c\/ballerina\u003e\u0060;\nstring[] stringArray = [\u0022hi\u0022, \u0022there\u0022]; \nint[][] arrayOfArrays = [[1,2],[3,4]];\njson | xml | string unionType; \n(string, int) tuple = (\u0022hello\u0022, 5); \n() n = (); \/\/ the empty tuple acts as \u0022null\u0022\nstring | int stringOrInt = \u0022this is a union type\u0022;\nint | () intOrNull = 5;\nvar inferred = (\u0022hello\u0022, 5); \nmap\u003cboolean\u003e myMap = {\u0022ballerina\u0022: true}; \ntype myRecord { string a; int b; };\ntype myObject object {   \n    public { string x; } private { string y; }\n    new (string xi, string yi) { x = xi; y = yi; }\n    function getX() returns (string) { return x; }\n};\n\u0060\u0060\u0060\n\n**类型安全**\n\nBallerina 有一个结构化的类型系统，包括 primitive、recored、object、tuple 和 union 类型。该类型安全模型在赋值时包含了类型推断，并为连接器、逻辑和网络绑定的有效负载提供了大量的编译时完整性检查。\n\n**Union 类型和显式 Null**\n\n各个网络端点通常会根据其输入和逻辑返回具有不同有效负载类型消息或 error。Ballerina 的类型系统采用了基于 union 类型的方法。Union 类型明确地采用了这种语义，不需要开发人员创建不必要的“包装”类型。这种方法也增强了对 null 值的处理。默认情况下，类型不支持 null 值。开发人员必须明确创建 union 类型来处理 null 值。结果是 null 的异常不会发生，并且语言语法和编译器会识别是否需要 null 处理逻辑。\n\n**异构数据处理**\n\nBallerina 类型系统内置丰富的对 JSON、XML、流和表格的支持以及对 ProtoBuf 和 gRPC 的直接支持。这样做的结果是可以获得处理网络负载、SQL 编程和流处理的干净可读的代码。数据转换逻辑不受复杂的生成类型、第三方库代码或其他混淆因素的影响——简单明了的可读代码捕捉与异构数据和转换逻辑的交互。\n\n## Ballerina 如何工作？\n\nBallerina 的语法、代码和编译器创建了运行时服务和部署构件，这些工件都是云原生就绪的，您可以选择将其部署在 IaaS、编排系统或 service mesh 中的。开发人员的体验旨在维护流程，包括快速的编辑、构建、调试周期并集成到团队的生命周期工具链中。\n\n### 运行时架构\n\n![云原生编程语言 ballerina 运行时架构](006y8mN6ly1g88cazdfcnj30u00wxjsr.jpg)\n\n**Ballerina API 网关**\n\n强制执行身份策略并保证性能。通过代码注解（类似于 Spring 中的注解）进行配置和部署。可以运行嵌入式服务、作为管理多个服务的容器代理或者使用 API 管理解决方案（如 WSO2 API Manager）。\n\n**Ballerina service**\n\n表示您的 API 和执行逻辑。服务通过不同的协议运行，内部代码结构被编译为支持 OpenAPI 和 Swagger 的 API 接口。服务与端点进行通信，无论它们是调用客户端还是其他服务。\n\n**Ballerina bridge**\n\n允许传统代码和服务参与分布式事务中的 Ballerina 服务。Bridge 将您现有服务与本地代理包装起来，通过调用 Ballerina 服务参与和代理分布式事务。\n\n**消息代理、事务协调者和身份代理**\n\n为参与事务、事件驱动的通信和为认证流程的 Ballerina 服务提供代理基础设施功能。这些组件可以嵌入到单个服务部署中或者进行单独部署和扩展以管理多个服务。\n\n### 部署架构\n\n![云原生编程语言 ballerina 部署架构图](006y8mN6ly1g88cbr5hquj30u00wxq46.jpg)\n\n**IaaS**\n\n使用代码注解和构建系统，可以打包 Ballerina 服务和其他运行时组件（如 API 网关）以部署到任何云原生环境中。在 IaaS 环境中，Ballerina 服务可以以虚拟机或容器的方式运行，也可以在构建期间将镜像推送到 registry 中。\n\n**编排器**\n\n代码注解会触发编译器扩展，从而为不同的编排器（如 Kubernetes 或 Cloud Foundry）生成 Ballerina 组件的工件包。供应商或 DevOps 可以添加自定义代码注解以生成特定于环境的部署，例如自定义蓝色部署算法。\n\n**Service mesh**\n\nBallerina 可以选择断路器和事务流程逻辑委托给像 Istio 或 Envoy 这样的 service mesh（如果有的话）。如果没有 service mesh 的话，Ballerina 服务将嵌入相应的功能。\n\n### 生命周期\n\n![云原生编程语言 ballerina 生命周期架构图](006y8mN6ly1g88cck2s8xj30u00wtgni.jpg)\n\n**Ballerina 工具**\n\n使用我们的语言服务器可以在 VS Code 和 IntelliJ 中获取自动补全和调试等智能感知。Ballerina 的关键字和语法结构可以用序列图的方式来表示。使用 Ballerina Composer 可以可视化的编辑 Ballerina 代码。另外它也可以做可视化得运行时和开发环境追踪。\n\n**Ballerina 构建**\n\n将服务编译为经过优化的字节码，以便使用内存调优后的 BVM 运行。提供了使用 Testerina 的项目结构、依赖管理、包管理和单元测试。构建锁可以轻松地重新创建服务和部署。生成可执行文件（.balx）或库（.balo）。\n\n**CI\/CD**\n\n部署代码注解会触发构建扩展，从而为持续集成、持续交付或编排器环境生成工件。将构建工件推送到您的 CI\/CD 系统或完全跳过。\n\n**Registry**\n\n将端点连接器、自定义注解和代码功能作为可共享软件包组合在一起。可以在全球共享资源库——Ballerina Central 中 pull 或 push 版本化的软件包。\n\n## Ballerina 的语言特性\n\nBallerina 设计为云优先，内置对现代 Web 协议和数据格式的支持，完全支持图灵完备编程语言，以及对微服务架构的原生支持。\n\n- API 构造\n- 逻辑语言\n- 异步\n- Json 和 XML\n- 注解\n- 稳定和强大的类型\n- stream\n\n## Ballerina 中集成了哪些内容？\n\nBallerina 是一种旨在**集成简化**的语言。基于顺序图的交互，Ballerina 内置了对通用集成模式和连接器的支持，包括分布式事务、补偿和断路器。凭借对 JSON 和 XML 的一流支持，Ballerina 能够简单有效地构建跨网络终端的强大集成。\n\n- 类型安全端点集成\n- 类型安全连接器\n- 可靠的消息传递\n- 分布式事务\n- 断路器\n- 注入攻击防护\n- Docker 和 Kubernetes\n\n关于 Ballerina 中各个功能的示例代码请查阅 [ballerina-example](https:\/\/github.com\/ballerina-platform\/ballerina-examples)。\n\n## 参考\n\n- [Ballerina 官网](https:\/\/ballerina.io)\n- Microservices, Docker, Kubernetes, Serverless, Service Mesh, and Beyond\n', '\/blog\/introducing-cloud-native-programming-language-ballerina\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">编译式强类型基于序列图理念的开源编程语言。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/envoy-mesh-in-kubernetes-tutorial/">在 Kubernetes 中使用 Envoy mesh 教程</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2018/04/28</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/envoy"> 
             Envoy
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('在 Kubernetes 中使用 Envoy mesh 教程', '本文是在 Kubernetes 集群中，使用 Envoy 来做 mesh，来为一个简单的使用 Python 编写的 Flask 应用程序做反向代理和负载均衡。', '\n本文是在 Kubernetes 集群中，使用 Envoy 来做 mesh，来为一个简单的使用 Python 编写的 Flask 应用程序做反向代理和负载均衡。\n\n**注**：本教程中的示例来自 [envoy-steps](https:\/\/github.com\/datawire\/envoy-steps)，本文中使用的所有的代码和 YAML 配置见 [envoy-tutorial](https:\/\/github.com\/rootsongjc\/envoy-tutorial)。\n\n![Envoy Mesh 架构图](envoy-mesh-in-kubernetes.webp)\n\n## 前提条件\n\n使用 [kubernetes-vagrant-centos-cluster](https:\/\/github.com\/rootsongjc\/kubernetes-vagrant-centos-cluster) 部署 kubernetes 集群，只要启动集群并安装了 CoreDNS 即可，无须安装其他插件。\n\n## 部署应用\n\n我们首先将应用部署到 Kubernetes 中。\n\n部署 postgres 数据库。\n\n\u0060\u0060\u0060bash\nkubectl apply -f postgres\n\u0060\u0060\u0060\n\n创建 usersvc 镜像。\n\n\u0060\u0060\u0060bash\ndocker build -t jimmysong\/usersvc:step1 .\n\u0060\u0060\u0060\n\n部署 usersvc。\n\n\u0060\u0060\u0060bash\nkubectl apply -f usersvc\n\u0060\u0060\u0060\n\n查看 uservc 的 ClusterIP 地址。\n\n\u0060\u0060\u0060bash\n$ kubectl get svc usersvc\nkubectl get svc usersvc\nNAME      TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)    AGE\nusersvc   ClusterIP   10.254.176.248   \u003cnone\u003e        5000\/TCP   11m\n\u0060\u0060\u0060\n\n进到 node1 中访问该服务，因为我们要访问的是 ClusterIP，在我们自己的电脑上是无法直接访问的，所以进到虚拟机中操作。\n\n\u0060\u0060\u0060bash\n$ vagrant ssh node1\n$ curl 10.254.176.248:5000\n{\n  \u0022hostname\u0022: \u0022usersvc-7cf5bb9d85-9gx7w\u0022,\n  \u0022msg\u0022: \u0022user health check OK\u0022,\n  \u0022ok\u0022: true,\n  \u0022resolvedname\u0022: \u0022172.33.10.7\u0022\n}\n\u0060\u0060\u0060\n\n尝试添加一个名为 \u0060Alice\u0060 的用户。\n\n\u0060\u0060\u0060bash\n$ curl -X PUT -H \u0022Content-Type: application\/json\u0022 \\\n    -d \u0027{ \u0022fullname\u0022: \u0022Alice\u0022, \u0022password\u0022: \u0022alicerules\u0022 }\u0027 \\\n    10.254.176.248\/user\/alice\n\u0060\u0060\u0060\n\n将会看到类似如下的输出。\n\n\u0060\u0060\u0060json\n{\n  \u0022fullname\u0022: \u0022Alice\u0022,\n  \u0022hostname\u0022: \u0022usersvc-7cf5bb9d85-9gx7w\u0022,\n  \u0022ok\u0022: true,\n  \u0022resolvedname\u0022: \u0022172.33.10.7\u0022,\n  \u0022uuid\u0022: \u0022EF43B475F65848C6BE708F436305864B\u0022\n}\n\u0060\u0060\u0060\n\n尝试再添加一个名为 \u0060Bob\u0060 的用户。\n\n\u0060\u0060\u0060bash\n$ curl -X PUT -H \u0022Content-Type: application\/json\u0022 \\\n    -d \u0027{ \u0022fullname\u0022: \u0022Bob\u0022, \u0022password\u0022: \u0022bobrules\u0022 }\u0027 \\\n    10.254.176.248\/user\/bob\n\u0060\u0060\u0060\n\n将会看到类似如下的输出。\n\n\u0060\u0060\u0060json\n{\n  \u0022fullname\u0022: \u0022Bob\u0022,\n  \u0022hostname\u0022: \u0022usersvc-7cf5bb9d85-9gx7w\u0022,\n  \u0022ok\u0022: true,\n  \u0022resolvedname\u0022: \u0022172.33.10.7\u0022,\n  \u0022uuid\u0022: \u00226AC944E7D4254D9A811A82C0FDAC3046\u0022\n}\n\u0060\u0060\u0060\n\n当应用部署完毕后，我们该部署 edge envoy 了。\n\n## 部署 edge envoy\n\n部署 edge envoy 的方式很简单，执行下面的命令。\n\n\u0060\u0060\u0060bash\nkubectl apply -f edge-envoy\n\u0060\u0060\u0060\n\n现在访问 edge envoy 是就可以路由到 \u0060usersvc\u0060 上的，当然直接访问 \u0060usersvc\u0060 也是可以的。\n\n我们看下 edge-envoy 的 envoy 配置文件定义。\n\n\u0060\u0060\u0060json\n{\n  \u0022listeners\u0022: [\n    {\n      \u0022address\u0022: \u0022tcp:\/\/0.0.0.0:80\u0022,\n      \u0022filters\u0022: [\n        {\n          \u0022type\u0022: \u0022read\u0022,\n          \u0022name\u0022: \u0022http_connection_manager\u0022,\n          \u0022config\u0022: {\n            \u0022codec_type\u0022: \u0022auto\u0022,\n            \u0022stat_prefix\u0022: \u0022ingress_http\u0022,\n            \u0022route_config\u0022: {\n              \u0022virtual_hosts\u0022: [\n                {\n                  \u0022name\u0022: \u0022backend\u0022,\n                  \u0022domains\u0022: [\u0022*\u0022],\n                  \u0022routes\u0022: [\n                    {\n                      \u0022timeout_ms\u0022: 0,\n                      \u0022prefix\u0022: \u0022\/user\u0022,\n                      \u0022cluster\u0022: \u0022usersvc\u0022\n                    }\n                  ]\n                }\n              ]\n            },\n            \u0022filters\u0022: [\n              {\n                \u0022type\u0022: \u0022decoder\u0022,\n                \u0022name\u0022: \u0022router\u0022,\n                \u0022config\u0022: {}\n              }\n            ]\n          }\n        }\n      ]\n    }\n  ],\n  \u0022admin\u0022: {\n    \u0022access_log_path\u0022: \u0022\/dev\/null\u0022,\n    \u0022address\u0022: \u0022tcp:\/\/127.0.0.1:8001\u0022\n  },\n  \u0022cluster_manager\u0022: {\n    \u0022clusters\u0022: [\n      {\n        \u0022name\u0022: \u0022usersvc\u0022,\n        \u0022connect_timeout_ms\u0022: 250,\n        \u0022type\u0022: \u0022strict_dns\u0022,\n        \u0022service_name\u0022: \u0022usersvc\u0022,\n        \u0022lb_type\u0022: \u0022round_robin\u0022,\n        \u0022features\u0022: \u0022http2\u0022,\n        \u0022hosts\u0022: [\n          {\n            \u0022url\u0022: \u0022tcp:\/\/usersvc:80\u0022\n          }\n        ]\n      }\n    ]\n  }\n}\n\u0060\u0060\u0060\n\n客户端访问 \u0060edge-envoy\u0060 的 \u0060ClusterIP:8000\/user\/health\u0060 就可以检查节点的健康状况。\n\n## 部署 usersvc2\n\n删除原来的 \u0060usersvc\u0060，部署第二版 \u0060usersvc2\u0060，它与原来的 \u0060usersvc\u0060 唯一不同的地方是在 \u0060entrypoint\u0060 中集成了 envoy，查看 \u0060Dockerfile\u0060 中指定的 \u0060entrypoint.sh\u0060 的内容便可知。\n\n\u0060\u0060\u0060bash\n#!\/bin\/sh\n\npython \/application\/service.py \u0026\n\/usr\/local\/bin\/envoy -c \/application\/envoy.json\n\u0060\u0060\u0060\n\n首先删除老的 \u0060usersvc\u0060。\n\n\u0060\u0060\u0060bash\nkubectl delete -f usersvc\n\u0060\u0060\u0060\n\n使用下面的命令部署 \u0060usersvc2\u0060，它仍然使用 \u0060usersvc\u0060 这个 service 名称。\n\n\u0060\u0060\u0060bash\nkubectl apply -f usersvc2\n\u0060\u0060\u0060\n\nEnvoy 以 out-of-process 的方式运行，对应用进程没有侵入性，也可以使用 sidecar 的方式运行，让 envoy 与 应用容器运行在同一个 pod 中。\n\n增加 \u0060usersvc2\u0060 的实例个数。\n\n\u0060\u0060\u0060bash\nkubectl scale --replicas=3 deployment\/usersvc\n\u0060\u0060\u0060\n\n此时我们有 3 个 usersvc 实例，现在通过 \u0060edge-envoy\u0060 的 \u0060ClusterIP:8000\/user\/health\u0060 检查节点的健康状况时，是不是会轮询的访问到后端的的 \u0060usersvc2\u0060 的实例呢？\n\n我们当初在 \u0060edge-node\u0060 的 \u0060envoy.json\u0060 中配置过 cluster 的，其中指定了 \u0060lb_type\u0060 为 \u0060round_robin\u0060 。\n\n\u0060\u0060\u0060json\n  \u0022cluster_manager\u0022: {\n    \u0022clusters\u0022: [\n      {\n        \u0022name\u0022: \u0022usersvc\u0022,\n        \u0022connect_timeout_ms\u0022: 250,\n        \u0022type\u0022: \u0022strict_dns\u0022,\n        \u0022service_name\u0022: \u0022usersvc\u0022,\n        \u0022lb_type\u0022: \u0022round_robin\u0022,\n        \u0022features\u0022: \u0022http2\u0022,\n        \u0022hosts\u0022: [\n          {\n            \u0022url\u0022: \u0022tcp:\/\/usersvc:80\u0022\n          }\n        ]\n      }\n    ]\n  }\n\u0060\u0060\u0060\n\n而且该 \u0060Service_name\u0060 也可以被 DNS 正确解析。\n\n\u0060\u0060\u0060bash\nroot@usersvc-55b6857d44-gcg5c:\/application# nslookup usersvc\nServer:         10.254.0.2\nAddress:        10.254.0.2#53\n\nName:   usersvc.envoy-tutorial.svc.cluster.local\nAddress: 10.254.123.166\n\u0060\u0060\u0060\n\n**答案是否定的。**\n\n虽然通过 DNS 可以正确的解析出 Service 的 ClusterIP，但是负载均衡不再通过 kube-proxy 实现，所以不论我们访问多少次 \u0060edge-envoy\u0060 永远只能访问到一个固定的后端 \u0060usersvc\u0060。\n\n## 服务发现服务 - SDS\n\nKubernetes 中的 DNS 可以发现所有 Service 的 ClusterIP，但是 DNS 中不包括所有 endpoint 地址，我们需要一个 SDS（服务发现服务）来发现服务的所有的 endpoint，我们将修改 \u0060lb_type\u0060，使用 \u0060sds\u0060 替代 \u0060strict_dns\u0060。\n\n执行下面的命令部署 SDS。\n\n\u0060\u0060\u0060bassh\nkubectl apply -f usersvc-sds\n\u0060\u0060\u0060\n\n因为在添加了 SDS 之后需要修改 \u0060edge-envoy\u0060 中的 \u0060envoy.josn\u0060 配置，在 \u0060clusters\u0060 字段中增加 \u0060sds\u0060 信息，我们将所有的配置都写好了，重新打包成了镜像，我们需要先删除之前部署的 \u0060edge-envoy\u0060。\n\n\u0060\u0060\u0060bash\nkubectl delete -f edge-envoy\n\u0060\u0060\u0060\n\n部署新的 \u0060edge-envoy2\u0060。\n\n\u0060\u0060\u0060bash\nkubectl apply -f edge-envoy2\n\u0060\u0060\u0060\n\n连续访问 \u0060usersvc\u0060 12 次看看输出结果如何。\n\n\u0060\u0060\u0060bash\nURL=http:\/\/172.17.8.101:30800\/user\/alice\nfor i in \u0060seq 1 12\u0060;do curl -s $URL|grep \u0022resolvedname\u0022|tr -d \u0022 \u0022|tr -d \u0022,\u0022|tr -d \u0027\u0022\u0027;done\n\u0060\u0060\u0060\n\n我们可以看到类似如下的输出：\n\n\u0060\u0060\u0060ini\nresolvedname:172.33.71.2\nresolvedname:172.33.88.2\nresolvedname:172.33.10.2\nresolvedname:172.33.71.2\nresolvedname:172.33.88.2\nresolvedname:172.33.10.2\nresolvedname:172.33.71.2\nresolvedname:172.33.88.2\nresolvedname:172.33.10.2\nresolvedname:172.33.71.2\nresolvedname:172.33.88.2\nresolvedname:172.33.10.2\n\u0060\u0060\u0060\n\n再查看下 \u0060usersvc\u0060 服务的所有 pod 的 IP 地址。\n\n\u0060\u0060\u0060bash\n$ kubectl get pod -l service=usersvc -o wide\nNAME                       READY     STATUS    RESTARTS   AGE       IP            NODE\nusersvc-55b6857d44-mkfpv   1\/1       Running   0          9m        172.33.88.2   node1\nusersvc-55b6857d44-q98jg   1\/1       Running   0          9m        172.33.71.2   node2\nusersvc-55b6857d44-s2znk   1\/1       Running   0          9m        172.33.10.2   node3\n\u0060\u0060\u0060\n\n我们看到 round-robin 负载均衡生效了。\n\n## 参考\n\n- [Part 2: Deploying Envoy with a Python Flask webapp and Kubernetes](https:\/\/www.datawire.io\/envoyproxy\/envoy-flask-kubernetes\/)\n- [envoy-steps](https:\/\/github.com\/datawire\/envoy-steps)\n- [kubernetes-vagrant-centos-cluster](https:\/\/github.com\/rootsongjc\/kubernetes-vagrant-centos-cluster) \n- [envoy-tutorial](https:\/\/github.com\/rootsongjc\/envoy-tutorial)\n', '\/blog\/envoy-mesh-in-kubernetes-tutorial\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文是在 Kubernetes 集群中，使用 Envoy 来做 mesh，来为一个简单的使用 Python 编写的 Flask 应用程序做反向代理和负载均衡。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/envoy-archiecture-and-terminology/">Envoy 的架构与基本配置解析</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2018/04/27</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/envoy"> 
             Envoy
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Envoy 的架构与基本配置解析', '本文介绍了 Envoy proxy 中的基本概念、配置与架构解析。', '\n在了解一门技术之前一开始就要了解其中的基本概念和术语，只有融入了该语境才能理解这门技术。本文将为大家介绍 Envoy 中的基本术语和重点概念。\n\n## 架构\n\n下图是 Envoy proxy 的架构图，显示了 host B 经过 Envoy 访问 host A 的过程。每个 host 上都可能运行多个 service，Envoy 中也可能有多个 Listener，每个 Listener 中可能会有多个 filter 组成了 chain。\n\n![Envoy proxy 架构图](envoy-arch.jpg)\n\n其中的基本术语将在下面解释。\n\n## 基本术语\n\n**Host**：能够进行网络通信的实体（在手机或服务器等上的应用程序）。在 Envoy 中主机是指逻辑网络应用程序。只要每台主机都可以独立寻址，一块物理硬件上就运行多个主机。\n\n**Downstream**：下游（downstream）主机连接到 Envoy，发送请求并或获得响应。\n\n**Upstream**：上游（upstream）主机获取来自 Envoy 的链接请求和响应。\n\n**Cluster**: 集群（cluster）是 Envoy 连接到的一组逻辑上相似的上游主机。Envoy 通过服务发现发现集群中的成员。Envoy 可以通过主动运行状况检查来确定集群成员的健康状况。Envoy 如何将请求路由到集群成员由负载均衡策略确定。\n\n**Mesh**：一组互相协调以提供一致网络拓扑的主机。Envoy mesh 是指一组 Envoy 代理，它们构成了由多种不同服务和应用程序平台组成的分布式系统的消息传递基础。\n\n**运行时配置**：与 Envoy 一起部署的带外实时配置系统。可以在无需重启 Envoy 或 更改 Envoy 主配置的情况下，通过更改设置来影响操作。\n\n**Listener**: 侦听器（listener）是可以由下游客户端连接的命名网络位置（例如，端口、unix 域套接字等）。Envoy 公开一个或多个下游主机连接的侦听器。一般是每台主机运行一个 Envoy，使用单进程运行，但是每个进程中可以启动任意数量的 Listener（监听器），目前只监听 TCP，每个监听器都独立配置一定数量的（L3\/L4）网络过滤器。Listenter 也可以通过 Listener Discovery Service（**LDS**）动态获取。\n\n**Listener filter**：Listener 使用 listener filter（监听器过滤器）来操作链接的元数据。它的作用是在不更改 Envoy 的核心功能的情况下添加更多的集成功能。Listener filter 的 API 相对简单，因为这些过滤器最终是在新接受的套接字上运行。在链中可以互相衔接以支持更复杂的场景，例如调用速率限制。Envoy 已经包含了多个监听器过滤器。\n\n**Http Route Table**：HTTP 的路由规则，例如请求的域名，Path 符合什么规则，转发给哪个 Cluster。\n\n**Health checking**：健康检查会与 SDS 服务发现配合使用。但是，即使使用其他服务发现方式，也有相应需要进行主动健康检查的情况。详见 health checking。\n\n## xDS\n\nxDS 是一个关键概念，它是一类发现服务的统称，其包括如下几类：\n\n- CDS: Cluster Discovery Service\n- EDS: Endpoint Discovery Service\n- SDS: Secret Discovery Service\n- RDS: Route Discovery Service\n- LDS: Listener Discovery Service\n\n正是通过对 xDS 的请求来动态更新 Envoy 配置，另外还有个 ADS（Aggregated Discovery Service）通过聚合的方式解决以上 xDS 的更新顺序问题。\n\n## Envoy Mesh\n\nEnvoy Mesh 指的是由 envoy 做负载均衡和代理的 mesh。该 Mesh 中会包含两类 envoy：\n\n- Edge envoy：即流量进出 mesh 时候的 envoy，相当于 kubernetes 中的 ingress。\n- Service envoy：服务 envoy 是跟每个 Service 实例一起运行的，应用程序无感知的进程外工具，在 kubernetes 中会与应用容器以 sidecar 形式运行在同一个 pod 中。\n\nEnvoy 即可以单独作为 edge envoy，也可以仅做 service envoy 使用，也可以两者同时使用。Mesh 中的所有 envoy 会共享路由信息。\n\n## Envoy 配置\n\nEnvoy 中的配置包括两大类：listenner 配置和 cluster 配置。\n\n### Listener 配置\n\n我们知道 Envoy 中可以配置一组 listener 以实现复杂的处理逻辑。Listener 中设置监听的 TCP 端口，还有一组 filter 对这些端口上的数据流进行处理。\n\n\u0060\u0060\u0060yaml\n  listeners:\n  - address:\n      socket_address:\n        address: 0.0.0.0\n        port_value: 80\n    filter_chains:\n    - filters:\n      - name: envoy.http_connection_manager\n        config:\n          codec_type: auto\n          stat_prefix: ingress_http\n          route_config:\n            name: local_route\n            virtual_hosts:\n            - name: backend\n              domains:\n              - \u0022*\u0022\n              routes:\n              - match:\n                  prefix: \u0022\/service\/1\u0022\n                route:\n                  cluster: service1\n              - match:\n                  prefix: \u0022\/service\/2\u0022\n                route:\n                  cluster: service2\n\u0060\u0060\u0060\n\n这是一个 \u0060http_connection_manager\u0060 例子，其中必须包含 \u0060virtual_hosts\u0060 配置，而 \u0060virtual_hosts\u0060 配置中必须包含以下几项配置：\n\n- \u0060name\u0060：服务名称\n- \u0060domains\u0060：DNS 域名，必须能跟 \u0060virtual_host\u0060 的 URL 匹配 \n- \u0060routes\u0060：路由列表\n\n每个路由中还可以包含以下配置：\n\n- \u0060prefix\u0060：URL 路径前缀\n- \u0060cluster\u0060：处理该请求的 envoy cluster\n- \u0060timeout_ms\u0060：当出错时的超时时间\n\n如上面的例子中，我们还需要定义 \u0060service1\u0060 cluster 和 \u0060service2\u0060 cluster。\n\n### Cluster 配置\n\nCluster 是一组逻辑相似的主机配置，定义哪些主机属于一个服务，cluster 的配置中包含了服务发现和负载均衡方式配置。依然是参考使用 Envoy 作为前端代理中的配置：\n\n\u0060\u0060\u0060yaml\n clusters:\n  - name: service1\n    connect_timeout: 0.25s\n    type: strict_dns\n    lb_policy: round_robin\n    http2_protocol_options: {}\n    hosts:\n    - socket_address:\n        address: service1\n        port_value: 80\n  - name: service2\n    connect_timeout: 0.25s\n    type: strict_dns\n    lb_policy: round_robin\n    http2_protocol_options: {}\n    hosts:\n    - socket_address:\n        address: service2\n        port_value: 80\n\u0060\u0060\u0060\n\nCluster 的配置中至少包含以下信息：\n\n- \u0060name\u0060：cluster 名称，就是服务名称\n- \u0060type\u0060：该 cluster 怎么知道主机是否启动？即服务发现类型，有以下方式：\n  - \u0060static\u0060：监听 cluster 中的所有主机\n  - \u0060strict_dns\u0060：envoy 会监听 DNS，每个匹配的 A 记录都会认定为有效\n  - \u0060logical_dns\u0060：envoy 将使用 DNS 来增加主机，如果 DNS 不再返回该主机也不会删除这些主机信息\n  - \u0060sds\u0060：即 Service Discovery Service，envoy 访问外部的 REST 获取 cluster 成员信息\n- \u0060lb_type\u0060：cluster 的负载均衡类型，有以下方式：\n  - \u0060round_robin\u0060：轮询主机\n  - \u0060weighted_least_request\u0060：最近获得最少请求的主机\n  - \u0060random\u0060：随机\n- \u0060hosts\u0060：能够定义 cluster 中主机的 URL 地址，通常是\u0060tcp:\/\/\u0060 URL\n\n## 参考\n\n- [Part 1: Getting started with Envoy Proxy for microservices resilience - getambassador.io](https:\/\/www.getambassador.io\/resources\/getting-started-envoyproxy-microservices-resilience\/\/)\n', '\/blog\/envoy-archiecture-and-terminology\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文介绍了 Envoy proxy 中的基本概念、配置与架构解析。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/envoy-as-front-proxy/">使用 Envoy 作为前端代理</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2018/04/22</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/envoy"> 
             Envoy
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('使用 Envoy 作为前端代理', '本文是使用 Envoy 作为前端代理的介绍，仅使用 docker 容器和 docker-compose 做编排在单机中运行，帮助我们从更底层了解 Envoy，当我们将 Envoy 作为 Istio Service Mesh 的 data panel 的时候将更加游刃有余。', '\n[Envoy](https:\/\/github.com\/envoyproxy\/envoy) 是一款由 Lyft 开源的，使用 C\u002b\u002b 编写的 L7 代理和通信总线，目前是 [CNCF](https:\/\/cncf.io) 旗下的开源项目，代码托管在 GitHub 上，它也是 [Istio](https:\/\/istio.io) service mesh 中默认的 data plane。本文将给出使用 Envoy 作为 service mesh 的数据平面的示例，应用使用 docker-compose 编排。\n\n## 特性\n\nEnvoy 包括如下特性：\n\n- 进程外架构，不侵入应用进程\n- 使用现代版 C\u002b\u002b11 代码\n- L3\/L4 filter 架构\n- HTTP L7 filter 架构\n- 支持 HTTP\/2\n- HTTP L7 routing\n- 支持 gRPC\n- 支持 MongoDB L7\n- 动态配置\n- 最佳可观测性\n- 支持 front\/edge proxy\n- 高级负载均衡\n- 健康检查\n- 服务发现\n- 支持 DynamoDB L7\n\nEnvoy 本身无法构成一个完整的 Service Mesh，但是它可以作为 service mesh 中的应用间流量的代理，负责 service mesh 中的数据层。\n\n更多信息请参考 [Envoy 官网](https:\/\/www.envoyproxy.io\/)。\n\n## Envoy 作为前端代理\n\n本文是使用 Envoy 作为前端代理的介绍，仅使用 docker 容器和 docker-compose 做编排在单机中运行，帮助我们从更底层了解 Envoy，当我们将 Envoy 作为 Istio Service Mesh 的 data panel 的时候将更加游刃有余。\n\n## 快速开始\n\nEnvoy 中的所有规则配置跟 Kubernetes 一样都是通过 YAML 文件来完成的。在继续下面的步骤之前，首先克隆 Envoy 的 GitHub repo。\n\n\u0060\u0060\u0060bash\ngit clone https:\/\/github.com\/envoyproxy\/envoy.git\n\u0060\u0060\u0060\n\n## 运行 sandbox 测试\n\nEnvoy 官方提供了以下打包用例：\n\n- Front Proxy\n- [Zipkin Tracing](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/start\/sandboxes\/zipkin_tracing)\n- Jaeger Tracing\n- gRPC Bridge\n\n全部可以使用 \u0060docker-compose\u0060 运行，代码可以在 https:\/\/github.com\/envoyproxy\/envoy\/tree\/master\/examples 找到。\n\n## Front proxy\n\nEnvoy 在 envoymesh 的边缘做反向代理，详细使用方式见 \u003chttps:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/start\/sandboxes\/front_proxy\u003e，在此我将解说下以下问题：\n\n- Envoy 是如何作为进程外架构运行的？\n- 为何说 Envoy 是无侵入式架构？\n- Envoy 作为边缘反向代理能做什么？\n\n本示例的架构图如下所示，此时 Envoy 将作为一个反向代理，类似于 Nginx，但与 Nginx 不同的是它还会作为一个进程，伴随每个服务一起运行在同一个容器中（在 Kubernetes 中可以作为 Sidecar 与应用容器一起运行在同一个 Pod 中）。\n\n![Front proxy 部署结构图](envoyproxy-docker-compose.png)\n\n在此示例中一共有 3 个服务，我们需要为其创建容器编排的 \u0060docker-compose.yml\u0060 文件。\n\n\u0060\u0060\u0060yaml\nversion: \u00272\u0027\nservices:\n\n  front-envoy:\n    build:\n      context: .\n      dockerfile: Dockerfile-frontenvoy\n    volumes:\n      - .\/front-envoy.yaml:\/etc\/front-envoy.yaml\n    networks:\n      - envoymesh\n    expose:\n      - \u002280\u0022\n      - \u00228001\u0022\n    ports:\n      - \u00228000:80\u0022\n      - \u00228001:8001\u0022\n\n  service1:\n    build:\n      context: .\n      dockerfile: Dockerfile-service\n    volumes:\n      - .\/service-envoy.yaml:\/etc\/service-envoy.yaml\n    networks:\n      envoymesh:\n        aliases:\n          - service1\n    environment:\n      - SERVICE_NAME=1\n    expose:\n      - \u002280\u0022\n\n  service2:\n    build:\n      context: .\n      dockerfile: Dockerfile-service\n    volumes:\n      - .\/service-envoy.yaml:\/etc\/service-envoy.yaml\n    networks:\n      envoymesh:\n        aliases:\n          - service2\n    environment:\n      - SERVICE_NAME=2\n    expose:\n      - \u002280\u0022\n\nnetworks:\n  envoymesh: {}\n\u0060\u0060\u0060\n\n使用 docker-compose 启动可以保证三个服务都在同一个网络内，即 \u0060frontproxy_envoymesh\u0060 网络中。\n\n其中 \u0060front-envoy\u0060 是前端（边缘）Envoy 服务，用来做反向代理，它使用的是 \u0060Dockerfile-frontenvoy\u0060 文件来构建镜像的，我们来看下该 \u0060Dockerfile\u0060 的内容。\n\n\u0060\u0060\u0060dockerfile\nFROM envoyproxy\/envoy:latest\n\nRUN apt-get update \u0026\u0026 apt-get -q install -y \\\n    curl\nCMD \/usr\/local\/bin\/envoy -c \/etc\/front-envoy.yaml --service-cluster front-proxy\n\u0060\u0060\u0060\n\n其中 \u0060\/etc\/front-envoy.yaml\u0060 是本地的 \u0060front-envoy.yaml\u0060 挂载进去的。我们看下该文件的内容。\n\n\u0060\u0060\u0060yaml\nstatic_resources:\n  listeners:\n  - address:\n      socket_address:\n        address: 0.0.0.0\n        port_value: 80\n    filter_chains:\n    - filters:\n      - name: envoy.http_connection_manager\n        config:\n          codec_type: auto\n          stat_prefix: ingress_http\n          route_config:\n            name: local_route\n            virtual_hosts:\n            - name: backend\n              domains:\n              - \u0022*\u0022\n              routes:\n              - match:\n                  prefix: \u0022\/service\/1\u0022\n                route:\n                  cluster: service1\n              - match:\n                  prefix: \u0022\/service\/2\u0022\n                route:\n                  cluster: service2\n          http_filters:\n          - name: envoy.router\n            config: {}\n  clusters:\n  - name: service1\n    connect_timeout: 0.25s\n    type: strict_dns\n    lb_policy: round_robin\n    http2_protocol_options: {}\n    hosts:\n    - socket_address:\n        address: service1\n        port_value: 80\n  - name: service2\n    connect_timeout: 0.25s\n    type: strict_dns\n    lb_policy: round_robin\n    http2_protocol_options: {}\n    hosts:\n    - socket_address:\n        address: service2\n        port_value: 80\nadmin:\n  access_log_path: \u0022\/dev\/null\u0022\n  address:\n    socket_address:\n      address: 0.0.0.0\n      port_value: 8001\n\u0060\u0060\u0060\n\n我们看到其中包括了三大配置项：\n\n- **static_resources**：路由配置信息\n- **cluster**：envoymesh 的服务注册信息\n- **admin**：管理接口，可以通过访问 8001 端口的，访问 \u0060\/stats\u0060  获取当前 envoymesh 的一些统计信息，访问 \u0060\/server_info\u0060 获取 Envoy 的版本信息\n\n使用 \u0060docker-compose\u0060 启动三个容器。\n\n\u0060\u0060\u0060bash\n$ pwd\nenvoy\/examples\/front-proxy\n$ docker-compose up --build -d\n$ docker-compose ps\n        Name                       Command               State      Ports\n-------------------------------------------------------------------------------------------------------------\nexample_service1_1      \/bin\/sh -c \/usr\/local\/bin\/ ... Up       80\/tcp\nexample_service2_1      \/bin\/sh -c \/usr\/local\/bin\/ ... Up       80\/tcp\nexample_front-envoy_1   \/bin\/sh -c \/usr\/local\/bin\/ ... Up       0.0.0.0:8000-\u003e80\/tcp, 0.0.0.0:8001-\u003e8001\/tcp\n\u0060\u0060\u0060\n\n我们下面将过一遍 Envoy 作为前端代理的所有功能，这些功能是通用功能。\n\n### 路由\n\n访问 service1 \u003chttp:\/\/localhost:8000\/service\/1\u003e 将看到如下输出。\n\n\u0060\u0060\u0060bash\n$ curl -v localhost:8000\/service\/1\n* \nTrying ::1...\n* TCP_NODELAY set\n* Connected to localhost (::1) port 8000 (#0)\n\u003e GET \/service\/1 HTTP\/1.1\n\u003e Host: localhost:8000\n\u003e User-Agent: curl\/7.54.0\n\u003e Accept: *\/*\n\u003e\n\u003c HTTP\/1.1 200 OK\n\u003c content-type: text\/html; charset=utf-8\n\u003c content-length: 89\n\u003c server: envoy\n\u003c date: Fri, 20 Apr 2018 08:26:33 GMT\n\u003c x-envoy-upstream-service-time: 14\n\u003c\nHello from behind Envoy (service 1)! hostname: a3e4185a9a49 resolvedhostname: 172.18.0.4\n* Connection #0 to host localhost left intact\n\u0060\u0060\u0060\n\n访问 service2 \u003chttp:\/\/localhost:8000\/service\/2\u003e 将看到如下输出。\n\n\u0060\u0060\u0060bash\n*   Trying ::1...\n* TCP_NODELAY set\n* Connected to localhost (::1) port 8000 (#0)\n\u003e GET \/service\/2 HTTP\/1.1\n\u003e Host: localhost:8000\n\u003e User-Agent: curl\/7.54.0\n\u003e Accept: *\/*\n\u003e\n\u003c HTTP\/1.1 200 OK\n\u003c content-type: text\/html; charset=utf-8\n\u003c content-length: 89\n\u003c server: envoy\n\u003c date: Fri, 20 Apr 2018 08:27:27 GMT\n\u003c x-envoy-upstream-service-time: 10\n\u003c\nHello from behind Envoy (service 2)! hostname: f6650e1911a0 resolvedhostname: 172.18.0.3\n* Connection #0 to host localhost left intact\n\u0060\u0060\u0060\n\n我们看到访问请求被路由到了正确的服务后端。\n\n### 负载均衡\n\n增加 service1 的示例数。\n\n\u0060\u0060\u0060bash\n$ docker-compose scale service1=3\nWARNING: The scale command is deprecated. Use the up command with the --scale flag instead.\nStarting frontproxy_service1_1 ... done\nCreating frontproxy_service1_2 ... done\nCreating frontproxy_service1_3 ... done\n\n$ docker-compose ps\n          Name                        Command               State                            Ports\n---------------------------------------------------------------------------------------------------------------------------\nfrontproxy_front-envoy_1   \/usr\/bin\/dumb-init -- \/bin ...   Up      10000\/tcp, 0.0.0.0:8000-\u003e80\/tcp, 0.0.0.0:8001-\u003e8001\/tcp\nfrontproxy_service1_1      \/bin\/sh -c \/usr\/local\/bin\/ ...   Up      10000\/tcp, 80\/tcp\nfrontproxy_service1_2      \/bin\/sh -c \/usr\/local\/bin\/ ...   Up      10000\/tcp, 80\/tcp\nfrontproxy_service1_3      \/bin\/sh -c \/usr\/local\/bin\/ ...   Up      10000\/tcp, 80\/tcp\nfrontproxy_service2_1      \/bin\/sh -c \/usr\/local\/bin\/ ...   Up      10000\/tcp, 80\/tcp\n\u0060\u0060\u0060\n\n我们看到现在 service1 已经有了 3 个实例，现在再访问 service1 \u003chttp:\/\/localhost:8000\/service\/1\u003e。\n\n\u0060\u0060\u0060bash\n$ while true;do curl localhost:8000\/service\/1;sleep 1;done\nHello from behind Envoy (service 1)! hostname: a3e4185a9a49 resolvedhostname: 172.18.0.4\nHello from behind Envoy (service 1)! hostname: fe44dba64122 resolvedhostname: 172.18.0.5\nHello from behind Envoy (service 1)! hostname: c5b9f1289e0f resolvedhostname: 172.18.0.6\nHello from behind Envoy (service 1)! hostname: a3e4185a9a49 resolvedhostname: 172.18.0.4\nHello from behind Envoy (service 1)! hostname: fe44dba64122 resolvedhostname: 172.18.0.5\nHello from behind Envoy (service 1)! hostname: c5b9f1289e0f resolvedhostname: 172.18.0.6\n\u0060\u0060\u0060\n\n我们看到对 service1 的已经有负载均衡了，使用的策略是 \u0060round_robin\u0060，这些都是在 \u0060front-envoy.yaml\u0060 文件中的 \u0060cluster\u0060 项下配置的。\n\n### admin 端点\n\n访问 \u003chttp:\/\/localhost:8001\u003e 可以看到 Envoy admin 提供以下管理 API 端点。\n\n| 命令                 | 描述                                     |\n| -------------------- | ---------------------------------------- |\n| \/                    | Admin 主页                               |\n| \/certs               | 打印机器上的 certs                       |\n| \/clusters            | upstream cluster 状态                    |\n| \/config_dump         | 输出当前的 Envoy 配置                    |\n| \/cpuprofiler         | 开启\/关闭 CPU profiler                   |\n| \/healthcheck\/fail    | 导致服务失败健康检查                     |\n| \/healthcheck\/ok      | 导致服务通过健康检查                     |\n| \/help                | 打印管理命令的帮助信息                   |\n| \/hot_restart_version | 打印热重启兼容版本                       |\n| \/listeners           | 打印 listener 地址                       |\n| \/logging             | 查询\/更改日志级别                        |\n| \/quitquitquit        | 退出服务                                 |\n| \/reset_counters      | 将计数器重置为 1                         |\n| \/runtime             | 打印运行时值                             |\n| \/runtime_modify      | 修改运行时值                             |\n| \/server_info         | 打印服务器版本\/状态信息                  |\n| \/stats               | 打印服务器状态统计信息                   |\n| \/stats\/prometheus    | 打印 prometheus 格式的服务器状态统计信息 |\n\nEnvoy 提供了 API 管理端点，可以对 Envoy 进行动态配置，参考 v2 API reference。\n\n## 参考\n\n- Front proxy\n', '\/blog\/envoy-as-front-proxy\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文是使用 Envoy 作为前端代理的介绍，仅使用 docker 容器和 docker-compose 做编排在单机中运行，帮助我们从更底层了解 Envoy，当我们将 Envoy 作为 Istio Service Mesh 的 data panel 的时候将更加游刃有余。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-tutorial/">Istio Service Mesh 教程</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2018/04/18</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio Service Mesh 教程', '本文是 Istio 管理 Java 微服务的案例教程。', '\n本文是 Istio 管理 Java 微服务的案例教程，使用的所有工具和软件全部基于开源方案，替换了 [redhat-developer-demos\/istio-tutorial](https:\/\/github.com\/redhat-developer-demos\/istio-tutorial) 中的 minishift 环境，使用 [kubernetes-vagrant-centos-cluster](https:\/\/github.com\/rootsongjc\/kubernetes-vagrant-centos-cluster) 替代，沿用了原有的微服务示例，使用 Zipkin 做分布式追踪而不是 Jaeger。\n\n本文中的代码和 YAML 文件见 \u003chttps:\/\/github.com\/rootsongjc\/istio-tutorial\u003e。\n\n## 准备环境\n\n在进行本教程前需要先准备以下工具和环境。\n\n- 8G 以上内存\n- Vagrant 2.0\u002b\n- Virtualbox 5.0 \u002b\n- 提前下载 kubernetes1.9.1 的 release 压缩包\n- docker 1.12\u002b\n- kubectl 1.9.1\u002b\n- maven 3.5.2\u002b\n- istioctl 0.7.1\n- git\n- curl、gzip、tar\n- [kubetail](https:\/\/github.com\/johanhaleby\/kubetail)\n- [siege](https:\/\/github.com\/JoeDog\/siege)\n\n## 安装 Kubernetes\n\n请参考 [kubernetes-vagrant-centos-cluster](https:\/\/github.com\/rootsongjc\/kubernetes-vagrant-centos-cluster) 在本地启动拥有三个节点的 kubernetes 集群。\n\n\u0060\u0060\u0060bash\ngit clone https:\/\/github.com\/rootsongjc\/kubernetes-vagrant-centos-cluster.git\ncd kubernetes-vagrant-centos-cluster\nvagrant up\n\u0060\u0060\u0060\n\n## 安装 Istio\n\n在 [kubernetes-vagrant-centos-cluster](https:\/\/github.com\/rootsongjc\/kubernetes-vagrant-centos-cluster) 中的包含 Istio 0.7.1 的安装 YAML 文件，运行下面的命令安装 Istio。\n\n\u0060\u0060\u0060bash\nkubectl apply -f addon\/istio\/\n\u0060\u0060\u0060\n\n**运行示例**\n\n\u0060\u0060\u0060bash\nkubectl apply -n default -f \u003c(istioctl kube-inject -f yaml\/istio-bookinfo\/bookinfo.yaml)\n\u0060\u0060\u0060\n\n在您自己的本地主机的\u0060\/etc\/hosts\u0060文件中增加如下配置项。\n\n\u0060\u0060\u0060ini\n172.17.8.102 grafana.istio.jimmysong.io\n172.17.8.102 servicegraph.istio.jimmysong.io\n172.17.8.102 zipkin.istio.jimmysong.io\n\u0060\u0060\u0060\n\n我们可以通过下面的 URL 地址访问以上的服务。\n\n| Service      | URL                                                          |\n| ------------ | ------------------------------------------------------------ |\n| grafana      | \u0060http:\/\/grafana.istio.jimmysong.io\u0060                          |\n| servicegraph | \u0060http:\/\/servicegraph.istio.jimmysong.io\/dotviz\u0060，\u0060http:\/\/servicegraph.istio.jimmysong.io\/graph\u0060 |\n| zipkin       | \u0060http:\/\/zipkin.istio.jimmysong.io\u0060                           |\n\n详细信息请参阅 [Istio 文档](https:\/\/istio.io\/latest\/docs\/examples\/bookinfo\/)。\n\n## 部署示例应用\n\n在打包成镜像部署到 kubernetes 集群上运行之前，我们先在本地运行所有示例。\n\n本教程中三个服务之间的依赖关系如下：\n\n\u0060\u0060\u0060ini\ncustomer → preference → recommendation\n\u0060\u0060\u0060\n\n\u0060customer\u0060 和 \u0060preference\u0060 微服务是基于 Spring Boot 构建的，\u0060recommendation\u0060 微服务是基于 [vert.x](https:\/\/vertx.io) 构建的。\n\n\u0060customer\u0060 和 \u0060preference\u0060 微服务的 \u0060pom.xml\u0060 文件中都引入了 OpenTracing 和 Jeager 的依赖。\n\n\u0060\u0060\u0060xml\n\u003cdependency\u003e\n\t\u003cgroupId\u003eio.opentracing.contrib\u003c\/groupId\u003e\n\t\u003cartifactId\u003eopentracing-spring-cloud-starter\u003c\/artifactId\u003e\n\t\u003cversion\u003e0.1.7\u003c\/version\u003e\n\u003c\/dependency\u003e\n\u003cdependency\u003e\n\t\u003cgroupId\u003ecom.uber.jaeger\u003c\/groupId\u003e\n\t\u003cartifactId\u003ejaeger-tracerresolver\u003c\/artifactId\u003e\n    \u003cversion\u003e0.25.0\u003c\/version\u003e\n\u003c\/dependency\u003e\n\u0060\u0060\u0060\n\n### 本地运行\n\n我们首先在本地确定所有的微服务都可以正常运行，然后再打包镜像在 kubernetes 集群上运行。\n\n**启动 Jaeger**\n\n使用 docker 来运行 jagger。\n\n\u0060\u0060\u0060bash\ndocker run -d \\\n  --rm \\\n  -p5775:5775\/udp \\\n  -p6831:6831\/udp \\\n  -p6832:6832\/udp \\\n  -p16686:16686 \\\n  -p14268:14268 \\\n  jaegertracing\/all-in-one:1.3\n\u0060\u0060\u0060\n\nJaeger UI 地址 \u0060http:\/\/localhost:16686\u0060\n\n**Customer**\n\n\u0060\u0060\u0060bash\ncd customer\/java\/springboot\nJAEGER_SERVICE_NAME=customer mvn \\\n  spring-boot:run \\\n  -Drun.arguments=\u0022--spring.config.location=src\/main\/resources\/application-local.properties\u0022\n\u0060\u0060\u0060\n\n服务访问地址： \u0060http:\/\/localhost:8280\u0060\n\n**Preference**\n\n\u0060\u0060\u0060bash\ncd preference\/java\/springboot\nJAEGER_SERVICE_NAME=preference mvn \\\n  spring-boot:run \\\n  -Drun.arguments=\u0022--spring.config.location=src\/main\/resources\/application-local.properties\u0022\n\u0060\u0060\u0060\n\n服务访问地址：\u0060http:\/\/localhost:8180\u0060\n\n**Recommendation**\n\n\u0060\u0060\u0060bash\ncd recommendation\/java\/vertx\nmvn vertx:run\n\u0060\u0060\u0060\n\n服务访问地址：\u0060http:\/\/localhost:8080\u0060\n\n所有服务都启动之后，此时访问 \u0060http:\/\/localhost:8280\u0060 将会看到如下输出。\n\n\u0060\u0060\u0060bash\ncustomer =\u003e preference =\u003e recommendation v1 from \u0027unknown\u0027: 1\n\u0060\u0060\u0060\n\n每访问一次最后的数字就会加 1。\n\n**Jaeger**\n\n此时访问 \u0060http:\/\/localhost:16686\u0060 将看到 Jaeger query UI，所有应用将 metrics 发送到 Jeager 中。\n\n可以在 Jaeger UI 中搜索 \u0060customer\u0060 和 \u0060preference\u0060 service 的 trace 并查看每次请求的 tracing。\n\n![Jaeger query UI](jaeger-query-ui.webp)\n\n### 构建镜像\n\n在本地运行测试无误之后就可以构建镜像了。本教程中的容器镜像都是在 [fabric8\/java-jboss-openjdk8-jdk](https:\/\/hub.docker.com\/r\/fabric8\/java-jboss-openjdk8-jdk\/~\/dockerfile\/) 的基础上构建的。只要将 Java 应用构建出 Jar 包然后放到 \u0060\/deployments\u0060 目录下基础镜像就可以自动帮我们运行，所以我们看到着几个应用的 \u0060Dockerfile\u0060 文件中都没有执行入口，真正的执行入口是 [run-java.sh](https:\/\/github.com\/fabric8io-images\/java\/blob\/master\/images\/jboss\/openjdk8\/jdk\/run-java.sh)。\n\n**Customer**\n\n构建 Customer 镜像。\n\n\u0060\u0060\u0060bash\ncd customer\/java\/springboot\nmvn clean package\ndocker build -t jimmysong\/istio-tutorial-customer:v1 .\ndocker push jimmysong\/istio-tutorial-customer:v1\n\u0060\u0060\u0060\n\n第一次构建和上传需要花费一点时间，下一次构建就会很快。\n\n**Preference**\n\n构建 Preference 镜像。\n\n\u0060\u0060\u0060bash\ncd preference\/java\/springboot\nmvn clean package\ndocker build -t jimmysong\/istio-tutorial-preference:v1 .\ndocker push jimmysong\/istio-tutorial-preference:v1\n\u0060\u0060\u0060\n\n**Recommendation**\n\n构建 Recommendation 镜像。\n\n\u0060\u0060\u0060bash\ncd recommendation\/java\/vertx\nmvn clean package\ndocker build -t jimmysong\/istio-tutorial-recommendation:v1 .\ndocker push jimmysong\/istio-tutorial-recommendation:v1\n\u0060\u0060\u0060\n\n现在三个 docker 镜像都构建完成了，我们检查一下。\n\n\u0060\u0060\u0060bash\n$ docker images | grep istio-tutorial\nREPOSITORY                                TAG                 IMAGE ID            CREATED             SIZE\njimmysong\/istio-tutorial-recommendation   v1                  d31dd858c300        51 seconds ago      443MB\njimmysong\/istio-tutorial-preference       v1                  e5f0be361477        6 minutes ago       459MB\njimmysong\/istio-tutorial-customer         v1                  d9601692673e        13 minutes ago      459MB\n\u0060\u0060\u0060\n\n### 部署到 Kubernetes\n\n使用下面的命令将以上服务部署到 kubernetes。\n\n\u0060\u0060\u0060bash\n# create new namespace\nkubectl create ns istio-tutorial\n\n# deploy recommendation\nkubectl apply -f \u003c(istioctl kube-inject -f recommendation\/kubernetes\/Deployment.yml) -n istio-tutorial\nkubectl apply -f recommendation\/kubernetes\/Service.yml\n\n# deploy preferrence\nkubectl apply -f \u003c(istioctl kube-inject -f preference\/kubernetes\/Deployment.yml) -n istio-tutorial\nkubectl apply -f preference\/kubernetes\/Service.yml\n\n# deploy customer\nkubectl apply -f \u003c(istioctl kube-inject -f customer\/kubernetes\/Deployment.yml) -n istio-tutorial\nkubectl apply -f customer\/kubernetes\/Service.yml\n\u0060\u0060\u0060\n\n**注意：**\u0060preference\u0060 和 \u0060customer\u0060 应用启动速度比较慢，我们将 livenessProb 配置中的 \u0060initialDelaySeconds\u0060 设置为 **20** 秒。\n\n查看 Pod 启动状态：\n\n\u0060\u0060\u0060bash\nkubectl get pod -w -n istio-tutorial\n\u0060\u0060\u0060\n\n### 增加 Ingress 配置\n\n为了在 kubernetes 集群外部访问 customer 服务，我们需要增加 ingress 配置。\n\n\u0060\u0060\u0060bash\nkubectl apply -f ingress\/ingress.yaml\n\u0060\u0060\u0060\n\n修改本地的 \u0060\/etc\/hosts\u0060 文件，增加一条配置。\n\n\u0060\u0060\u0060ini\n172.17.8.102 customer.istio-tutorial.jimmysong.io\n\u0060\u0060\u0060\n\n现在访问 \u0060http:\/\/customer.istio-tutorial.jimmysong.io\u0060 将看到如下输出：\n\n\u0060\u0060\u0060ini\ncustomer =\u003e preference =\u003e recommendation v1 from \u00276fc97476f8-m2ntp\u0027: 1\n\u0060\u0060\u0060\n\n批量访问该地址。\n\n\u0060\u0060\u0060bash\n.\/bin\/poll_customer.sh\n\u0060\u0060\u0060\n\n访问 \u0060http:\/\/servicegraph.istio.jimmysong.io\/dotviz\u0060 查看服务的分布式追踪和依赖关系。\n\n![分布式追踪](istio-tutorial-zipkin-trace.webp)\n\n![依赖关系](istio-tutorial-zipkin-dependency.webp)\n\n访问 \u0060http:\/\/servicegraph.istio.jimmysong.io\/dotviz\u0060 查看服务间的关系图和 QPS。\n\n![服务关系图和 QPS](istio-tutorial-Servicegraph-dotviz.webp)\n\n访问 \u0060http:\/\/grafana.istio.jimmysong.io\u0060 查看 Service Mesh 的监控信息。\n\n![Grafana 监控](istio-tutorial-grafana.webp)\n\n## Istio 使用示例\n\n为了试用 Istio 中的各种功能，我们需要为应用构建多个版本，我们为 recommendation 构建 v2 版本的镜像，看看如何使用 Istio 控制微服务的流量。\n\n### 构建 recommendation:v2\n\n我们将构建新版的 \u0060recommendation\u0060 服务的镜像，并观察 \u0060customer\u0060 对不同版本的 \u0060recommendataion\u0060 服务的访问频率。\n\n修改 \u0060recommendation\/java\/vertx\/src\/main\/java\/com\/redhat\/developer\/demos\/recommendation\/RecommendationVerticle.java\u0060 程序中代码。\n\n将 \u0060private static final String RESPONSE_STRING_FORMAT = \u0022recommendation v1 from \u0027%s\u0027: %d\\n\u0022;\u0060 修改为 \u0060private static final String RESPONSE_STRING_FORMAT = \u0022recommendation v2 from \u0027%s\u0027: %d\\n\u0022;\u0060\n\n并构建 \u0060recommendation:v2\u0060 镜像。\n\n\u0060\u0060\u0060bash\ncd recommendation\/java\/vertx\nmvn clean package\ndocker build -t jimmysong\/istio-tutorial-recommendation:v2 .\ndocker push jimmysong\/istio-tutorial-recommendation:v2\n\u0060\u0060\u0060\n\n将应用部署到 kubernetes。\n\n\u0060\u0060\u0060bash\n# deploy recommendation\nkubectl apply -f \u003c(istioctl kube-inject -f recommendation\/kubernetes\/Deployment-v2.yml) -n istio-tutorial\n\u0060\u0060\u0060\n\n现在再访问 \u0060customer\u0060 服务，将看到如下输出：\n\n\u0060\u0060\u0060bash\n$ bin\/poll_customer.sh\ncustomer =\u003e preference =\u003e recommendation v2 from \u002777b9f6cc68-5xs27\u0027: 1\ncustomer =\u003e preference =\u003e recommendation v1 from \u00276fc97476f8-m2ntp\u0027: 3581\ncustomer =\u003e preference =\u003e recommendation v2 from \u002777b9f6cc68-5xs27\u0027: 2\ncustomer =\u003e preference =\u003e recommendation v1 from \u00276fc97476f8-m2ntp\u0027: 3582\ncustomer =\u003e preference =\u003e recommendation v2 from \u002777b9f6cc68-5xs27\u0027: 3\ncustomer =\u003e preference =\u003e recommendation v1 from \u00276fc97476f8-m2ntp\u0027: 3583\ncustomer =\u003e preference =\u003e recommendation v2 from \u002777b9f6cc68-5xs27\u0027: 4\n\u0060\u0060\u0060\n\n我们可以看到 v1 和 v2 版本的 \u0060recommendation\u0060 服务会被间隔访问到。\n\n我们再将 v2 版本的 \u0060recommendation\u0060 实例数设置成 2 个。\n\n\u0060\u0060\u0060bash\nkubectl scale --replicas=2 deployment\/recommendation-v2 -n istio-tutorial\nkubectl get pod -w -n istio-tutorial\n\u0060\u0060\u0060\n\n观察 \u0060recommendation-v2\u0060 Pod 达到两个之后再访问 \u0060customer\u0060 服务。\n\n\u0060\u0060\u0060bash\n$ bin\/poll_customer.sh\ncustomer =\u003e preference =\u003e recommendation v2 from \u002777b9f6cc68-j9fgj\u0027: 1\ncustomer =\u003e preference =\u003e recommendation v2 from \u002777b9f6cc68-5xs27\u0027: 71\ncustomer =\u003e preference =\u003e recommendation v1 from \u00276fc97476f8-m2ntp\u0027: 3651\ncustomer =\u003e preference =\u003e recommendation v2 from \u002777b9f6cc68-j9fgj\u0027: 2\ncustomer =\u003e preference =\u003e recommendation v2 from \u002777b9f6cc68-5xs27\u0027: 72\ncustomer =\u003e preference =\u003e recommendation v1 from \u00276fc97476f8-m2ntp\u0027: 3652\ncustomer =\u003e preference =\u003e recommendation v2 from \u002777b9f6cc68-j9fgj\u0027: 3\ncustomer =\u003e preference =\u003e recommendation v2 from \u002777b9f6cc68-5xs27\u0027: 73\ncustomer =\u003e preference =\u003e recommendation v1 from \u00276fc97476f8-m2ntp\u0027: 3653\n\u0060\u0060\u0060\n\n观察输出中 v1 和 v2 版本 \u0060recommendation\u0060 的访问频率。\n\n将 \u0060recommendataion\u0060 服务的实例数恢复为 1。\n\n\u0060\u0060\u0060bash\nkubectl scale --replicas=1 deployment\/recommendation-v2\n\u0060\u0060\u0060\n\n### 修改 Istio RouteRules\n\n以下所有路有规则都是针对 \u0060recommendation\u0060 服务，并在 repo 的根目录下执行。\n\n**将所有流量打给 v2**\n\n下面将演示如何动态的划分不同版本服务间的流量，将所有的流量都打到 \u0060recommendation:v2\u0060。\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/route-rule-recommendation-v2.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n现在再访问 \u0060customer\u0060 服务将看到所有的流量都会打到 \u0060recommendation:v2\u0060。\n\n删除 RouteRules 后再访问 \u0060customer\u0060 服务将看到又恢复了 v1 和 v2 版本的 \u0060recommendation\u0060 服务的间隔访问。\n\n\u0060\u0060\u0060bash\nistioctl delete routerule recommendation-default\n\u0060\u0060\u0060\n\n**切分流量**\n\n将 90% 的流量给 v1，10% 的流量给 v2。\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/route-rule-recommendation-v1_and_v2.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n执行\u0060bin\/poll_customer.sh\u0060 观察访问情况。\n\n要想动态切分流量只要修改 RouteRules 中的 \u0060weight\u0060 配置即可。\n\n\u0060\u0060\u0060yaml\napiVersion: config.istio.io\/v1alpha2\nkind: RouteRule\nmetadata:\n  name: recommendation-v1-v2\nspec:\n  destination:\n    namespace: istio-tutorial\n    name: recommendation\n  precedence: 5\n  route:\n  - labels:\n      version: v1\n    weight: 90\n  - labels:\n      version: v2\n    weight: 10\n\u0060\u0060\u0060\n\n因为 RouteRule 有优先级，为了继续后面的实验，在验证完成后删除该 RouteRule。\n\n\u0060\u0060\u0060bash\nistioctl delete routerule recommendation-v1-v2 -n istio-tutorial\n\u0060\u0060\u0060\n\n### 故障注入\n\n有时候我们为了增强系统的健壮性，需要对系统做混沌工程，故意注入故障，并保障服务可以自动处理这些故障。\n\n**注入 HTTP 503 错误**\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/route-rule-recommendation-503.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n有 50% 的几率报 503 错误。\n\n\u0060\u0060\u0060bash\n$ bin\/poll_customer.sh\ncustomer =\u003e preference =\u003e recommendation v2 from \u002777b9f6cc68-5xs27\u0027: 135\ncustomer =\u003e 503 preference =\u003e 503 fault filter abort\ncustomer =\u003e preference =\u003e recommendation v1 from \u00276fc97476f8-m2ntp\u0027: 3860\ncustomer =\u003e 503 preference =\u003e 503 fault filter abort\ncustomer =\u003e 503 preference =\u003e 503 fault filter abort\ncustomer =\u003e preference =\u003e recommendation v2 from \u002777b9f6cc68-5xs27\u0027: 136\ncustomer =\u003e preference =\u003e recommendation v1 from \u00276fc97476f8-m2ntp\u0027: 3861\ncustomer =\u003e 503 preference =\u003e 503 fault filter abort\ncustomer =\u003e 503 preference =\u003e 503 fault filter abort\ncustomer =\u003e preference =\u003e recommendation v2 from \u002777b9f6cc68-5xs27\u0027: 137\ncustomer =\u003e 503 preference =\u003e 503 fault filter abort\n\u0060\u0060\u0060\n\n清理 RouteRule。\n\n\u0060\u0060\u0060bash\nistioctl delete routerule recommendation-503 -n istio-tutorial\n\u0060\u0060\u0060\n\n### 增加延迟\n\n增加服务的访问延迟。\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/route-rule-recommendation-delay.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n会有 50% 的几率访问 \u0060recommendation\u0060 服务有 7 秒的延迟。百分比和延迟时间可以在 RouteRule 中配置。\n\n清理 RouteRule。\n\n\u0060\u0060\u0060bash\nistioctl delete routerule recommendation-delay -n istio-tutorial\n\u0060\u0060\u0060\n\n### 重试\n\n让服务不是直接失败，而是增加重试机制。\n\n我们下面将同时应用两条 RouteRule，让访问 \u0060recommendation\u0060 服务时有 50% 的几率出现 503 错误，并在出现错误的时候尝试访问 v2 版本，超时时间为 2 秒。\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/route-rule-recommendation-v2_503.yml -n istio-tutorial\nistioctl create -f istiofiles\/route-rule-recommendation-v2_retry.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n执行 \u0060bin\/poll_customer.sh\u0060 我们看到一开始有些 503 错误，然后所有的流量都流向了 v2。\n\n清理 RouteRules。\n\n\u0060\u0060\u0060bash\nistioctl delete routerule recommendation-v2-retry -n istio-tutorial\nistioctl delete routerule recommendation-v2-503 -n istio-tutorial\n\u0060\u0060\u0060\n\n### 超时\n\n设置超时时间，只有服务访问超时才认定服务访问失败。\n\n取消注释 \u0060recommendation\/java\/vertx\/src\/main\/java\/com\/redhat\/developer\/demos\/recommendation\/RecommendationVerticle.java\u0060 中的下面一行，增加超时时间为 3 秒。\n\n\u0060\u0060\u0060java\nrouter.get(\u0022\/\u0022).handler(this::timeout);\n\u0060\u0060\u0060\n\n重新生成镜像。\n\n\u0060\u0060\u0060bash\ncd recommendation\/java\/vertx\nmvn clean package\ndocker build -t jimmysong\/istio-tutorial-recommendation:v2 .\ndocker push jimmysong\/istio-tutorial-recommendation:v2\n\u0060\u0060\u0060\n\n重新部署到 kubernetes。\n\n\u0060\u0060\u0060bash\nkubectl delete -f recommendation\/kubernetes\/Deployment-v2.yml\n\u0060\u0060\u0060\n\n因为我们重新构建的镜像使用了同样的名字和 tag，而之前在 \u0060Deployment-v2.yml\u0060 中配置的镜像拉取策略是 \u0060IfNotPresent\u0060，这样的话即使我们构建了新的镜像也无法应用到集群上，因此将镜像拉取策略改成 \u0060Always\u0060 确保每次启动 Pod 的时候都会拉取镜像。\n\n\u0060\u0060\u0060bash\nkubectl apply -f \u003c(istioctl kube-inject -f recommendation\/kubernetes\/Deployment-v2.yml) -n istio-tutorial\n\u0060\u0060\u0060\n\n启用超时 RouteRules。\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/route-rule-recommendation-timeout.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n访问 \u0060customer\u0060 服务将看到如下输出：\n\n\u0060\u0060\u0060bash\n$ bin\/poll_customer.sh\ncustomer =\u003e 503 preference =\u003e 504 upstream request timeout\ncustomer =\u003e preference =\u003e recommendation v1 from \u00276fc97476f8-m2ntp\u0027: 4002\ncustomer =\u003e 503 preference =\u003e 504 upstream request timeout\ncustomer =\u003e preference =\u003e recommendation v1 from \u00276fc97476f8-m2ntp\u0027: 4003\ncustomer =\u003e 503 preference =\u003e 504 upstream request timeout\ncustomer =\u003e preference =\u003e recommendation v1 from \u00276fc97476f8-m2ntp\u0027: 4004\n\u0060\u0060\u0060\n\n清理 RouteRules。\n\n\u0060\u0060\u0060bash\nistioctl delete routerule recommendation-timeout -n istio-tutorial\n\u0060\u0060\u0060\n\n### 基于 user-agent 的智能路由（金丝雀发布）\n\nUser-agent 是一个字符串，其中包含了浏览器的信息，访问 https:\/\/www.whoishostingthis.com\/tools\/user-agent 获取你的 user-agent。\n\n我的 user-agent 是：\n\n\u0060\u0060\u0060ini\nMozilla\/5.0 (Macintosh; Intel Mac OS X 10_13_4) AppleWebKit\/537.36 (KHTML, like Gecko) Chrome\/65.0.3325.181 Safari\/537.36\n\u0060\u0060\u0060\n\n将所有的流量打到 v1。\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/route-rule-recommendation-v1.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n将使用 Safari 浏览器访问的流量打到 v2。\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/route-rule-safari-recommendation-v2.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n谁用 Safari 或者 Chrome（Chrome 浏览器的 user-agent 中也包含 Safari 字段）访问 \u0060http:\/\/customer.istio-tutorial.jimmysong.io\/\u0060 在经过 3 秒钟（我们在前面重新编译 v2 镜像，设置了 3 秒超时时间）后将看到访问 v2 的输出。\n\n或者使用 curl 访问。\n\n\u0060\u0060\u0060bash\ncurl -A Safari http:\/\/customer.istio-tutorial.jimmysong.io\/\ncurl -A Firefox http:\/\/customer.istio-tutorial.jimmysong.io\/\n\u0060\u0060\u0060\n\n观察返回的结果。\n\n将移动端用户的流量导到 v2。\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/route-rule-mobile-recommendation-v2.yml -n istio-tutorial\n\ncurl -A \u0022Mozilla\/5.0 (iPhone; U; CPU iPhone OS 4(KHTML, like Gecko) Version\/5.0.2 Mobile\/8J2 Safari\/6533.18.5\u0022 http:\/\/customer.istio-tutorial.jimmysong.io\/\n\u0060\u0060\u0060\n\n观察输出的结果。\n\n清理 RouteRules。\n\n\u0060\u0060\u0060bash\nistioctl delete routerule recommendation-mobile -n istio-tutorial\nistioctl delete routerule recommendation-safari -n istio-tutorial\nistioctl delete routerule recommendation-default -n istio-tutorial\n\u0060\u0060\u0060\n\n### 镜像流量\n\n确保当前至少运行了两个版本的 \u0060recommendation\u0060 服务，并且没有 RouteRule。\n\n注：可以使用 \u0060istioctl get routerule\u0060 获取 RouteRule。\n\n设置流量镜像，将所有 v1 的流量都被镜像到 v2。\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/route-rule-recommendation-v1-mirror-v2.yml -n istio-tutorial\nbin\/poll_customer.sh\n\u0060\u0060\u0060\n\n查看 recommendation-v2 的日志。\n\n\u0060\u0060\u0060bash\nkubectl logs -f \u0060oc get pods|grep recommendation-v2|awk \u0027{ print $1 }\u0027\u0060 -c recommendation\n\u0060\u0060\u0060\n\n### 访问控制\n\nIstio 可以设置服务访问的黑白名单，如果没有权限的话会返回 HTTP 404 Not Found。\n\n#### 白名单\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/acl-whitelist.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n此时访问 \u0060customer\u0060 服务。\n\n\u0060\u0060\u0060bash\n$ bin\/poll_customer.sh\ncustomer =\u003e 404 NOT_FOUND:preferencewhitelist.listchecker.istio-tutorial:customer is not whitelisted\n\u0060\u0060\u0060\n\n重置环境。\n\n\u0060\u0060\u0060bash\nistioctl delete -f istiofiles\/acl-whitelist.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n#### 黑名单\n\n设置黑名单，所有位于黑名单中的流量将获得 403 Forbidden 返回码。\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/acl-blacklist.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n此时访问 \u0060customer\u0060 服务。\n\n\u0060\u0060\u0060bash\n$ bin\/poll_customer.sh\ncustomer =\u003e 403 PERMISSION_DENIED:denycustomerhandler.denier.istio-tutorial:Not allowed\n\u0060\u0060\u0060\n\n重置环境。\n\n\u0060\u0060\u0060bash\nistioctl delete -f istiofiles\/acl-blacklist.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n### 负载均衡\n\nKubernetes 中默认的负载均衡策略是 round-robin，当然我们可以使用 Istio 把它修改成 random。\n\n增加 v1 的实例数。\n\n\u0060\u0060\u0060bash\nkubectl scale deployment recommendation-v1 --replicas=2 -n istio-tutorial\n\u0060\u0060\u0060\n\n持续访问 \u0060customer\u0060 服务。\n\n\u0060\u0060\u0060bash\nbin\/poll_customer.sh\n\u0060\u0060\u0060\n\n保持前台输出，观察流量的行为。\n\n应用负载均衡策略。\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/recommendation_lb_policy_app.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n观察一段时间流量的行为后，重置环境。\n\n\u0060\u0060\u0060bash\nistioctl delete -f istiofiles\/recommendation_lb_policy_app.yml -n istio-tutorial\nkubectl scale deployment recommendation-v1 --replicas=1 -n istio-tutorial\n\u0060\u0060\u0060\n\n### 速率限制\n\n暂时不可用\n\n### 断路器\n\n当达到最大连接数和最大挂起请求数时快速失败。\n\n将流量在 v1 和 v2 之间均分。\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/route-rule-recommendation-v1_and_v2_50_50.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n未开启断路器的时候启动负载测试。\n\n\u0060\u0060\u0060bash\n$ siege -r 2 -c 20 -v customer.istio-tutorial.jimmysong.io\nNew configuration template added to \/Users\/jimmysong\/.siege\nRun siege -C to view the current settings in that file\n** SIEGE 4.0.4\n** Preparing 20 concurrent users for battle.\nThe server is now under siege...\nHTTP\/1.1 200     0.10 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.12 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.13 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.13 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.13 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.17 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     3.12 secs:      74 bytes ==\u003e GET  \/\nHTTP\/1.1 200     3.14 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     3.15 secs:      74 bytes ==\u003e GET  \/\nHTTP\/1.1 200     3.15 secs:      74 bytes ==\u003e GET  \/\nHTTP\/1.1 200     3.17 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     3.17 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     3.20 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     3.20 secs:      74 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.05 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.12 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     3.15 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     3.25 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     3.26 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     3.14 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     3.58 secs:      74 bytes ==\u003e GET  \/\nHTTP\/1.1 200     6.15 secs:      74 bytes ==\u003e GET  \/\nHTTP\/1.1 200     6.16 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     3.03 secs:      74 bytes ==\u003e GET  \/\nHTTP\/1.1 200     6.06 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     6.04 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     3.11 secs:      74 bytes ==\u003e GET  \/\nHTTP\/1.1 200     3.09 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     6.15 secs:      74 bytes ==\u003e GET  \/\nHTTP\/1.1 200     6.71 secs:      74 bytes ==\u003e GET  \/\nHTTP\/1.1 200     3.52 secs:      75 bytes ==\u003e GET  \/\n^C\nLifting the server siege...\nTransactions:\t\t          31 hits\nAvailability:\t\t      100.00 %\nElapsed time:\t\t        7.99 secs\nData transferred:\t        0.00 MB\nResponse time:\t\t        2.99 secs\nTransaction rate:\t        3.88 trans\/sec\nThroughput:\t\t        0.00 MB\/sec\nConcurrency:\t\t       11.60\nSuccessful transactions:          31\nFailed transactions:\t           0\nLongest transaction:\t        6.71\nShortest transaction:\t        0.05\n\u0060\u0060\u0060\n\n所有的请求都成功了，但是性能很差，因为 v2 版本设置了 3 秒的超时时间。\n\n我们启用下断路器。\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/recommendation_cb_policy_version_v2.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n重新测试一下。\n\n\u0060\u0060\u0060bash\n$ siege -r 2 -c 20 -v customer.istio-tutorial.jimmysong.io\n** SIEGE 4.0.4\n** Preparing 20 concurrent users for battle.\nThe server is now under siege...\nHTTP\/1.1 200     0.07 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.07 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.07 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.12 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.12 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.16 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.16 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.21 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.21 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.24 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.24 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.14 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.29 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.13 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.18 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.13 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.11 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.39 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.24 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.44 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.43 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.44 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.40 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.47 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.42 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.42 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.06 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.07 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.15 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.12 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.57 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.18 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.52 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.65 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.42 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.09 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.43 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.04 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 200     4.15 secs:      74 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.01 secs:      75 bytes ==\u003e GET  \/\n\nTransactions:\t\t          19 hits\nAvailability:\t\t       47.50 %\nElapsed time:\t\t        4.16 secs\nData transferred:\t        0.00 MB\nResponse time:\t\t        0.72 secs\nTransaction rate:\t        4.57 trans\/sec\nThroughput:\t\t        0.00 MB\/sec\nConcurrency:\t\t        3.31\nSuccessful transactions:          19\nFailed transactions:\t          21\nLongest transaction:\t        4.15\nShortest transaction:\t        0.01\n\u0060\u0060\u0060\n\n我们可以看到在启用了断路器后各项性能都有提高。\n\n清理配置。\n\n\u0060\u0060\u0060bash\nistioctl delete routerule recommendation-v1-v2 -n istio-tutorial\nistioctl delete -f istiofiles\/recommendation_cb_policy_version_v2.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n### Pool Ejection\n\n所谓的 Pool Ejection 就是当某些实例出现错误（如返回 5xx 错误码）临时将该实例弹出一段时间后（窗口期，可配置），然后再将其加入到负载均衡池中。我们的例子中配置的窗口期是 15 秒。\n\n将 v1 和 v2 的流量均分。\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/route-rule-recommendation-v1_and_v2_50_50.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n增加 v2 的实例个数。\n\n\u0060\u0060\u0060bash\nkubectl scale deployment recommendation-v2 --replicas=2 -n istio-tutorial\nkubectl get pods -w\n\u0060\u0060\u0060\n\n等待所有的 Pod 的状态都启动完成。\n\n现在到 v2 的容器中操作。\n\n\u0060\u0060\u0060bash\n$ kubectl exec recommendation-v2-785465d9cd-225ms -c recommendation \/bin\/bash\n$ curl localhost:8080\/misbehave\nFollowing requests to \u0027\/\u0027 will return a 503\n\u0060\u0060\u0060\n\n增加 Pool Ejection 配置。\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/recommendation_cb_policy_pool_ejection.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n此时再访问 \u0060customer\u0060 服务。\n\n\u0060\u0060\u0060bash\n$ bin\/poll_customer.sh\ncustomer =\u003e preference =\u003e recommendation v1 from \u00276fc97476f8-m2ntp\u0027: 10505\ncustomer =\u003e preference =\u003e recommendation v2 from \u0027785465d9cd-225ms\u0027: 2407\ncustomer =\u003e preference =\u003e recommendation v1 from \u00276fc97476f8-m2ntp\u0027: 10506\ncustomer =\u003e preference =\u003e recommendation v2 from \u0027785465d9cd-225ms\u0027: 2408\ncustomer =\u003e preference =\u003e recommendation v1 from \u00276fc97476f8-m2ntp\u0027: 10507\ncustomer =\u003e preference =\u003e recommendation v1 from \u00276fc97476f8-m2ntp\u0027: 10508\ncustomer =\u003e preference =\u003e recommendation v1 from \u00276fc97476f8-m2ntp\u0027: 10509\ncustomer =\u003e 503 preference =\u003e 503 recommendation misbehavior from \u0027785465d9cd-ldc6j\u0027\ncustomer =\u003e preference =\u003e recommendation v2 from \u0027785465d9cd-225ms\u0027: 2409\ncustomer =\u003e preference =\u003e recommendation v2 from \u0027785465d9cd-225ms\u0027: 2410\n\u0060\u0060\u0060\n\n我们看到窗口期生效了，当出现 503 错误后至少 15 秒后才会出现第二次。\n\n即使有了负载均衡池弹出策略对于系统的弹性来说依然还不够，如果你的服务有多个可用实例，可以将**断路器**、**重试**、**Pool Ejection** 等策略组合起来使用。\n\n例如在以上的 Pool Ejection 的基础上增加重试策略。\n\n\u0060\u0060\u0060bash\nistioctl replace -f istiofiles\/route-rule-recommendation-v1_and_v2_retry.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n现在再访问 \u0060customer\u0060 服务就看不到 503 错误了。\n\n清理配置。\n\n\u0060\u0060\u0060bash\nkubectl scale deployment recommendation-v2 --replicas=1 -n istio-tutorial\nistioctl delete routerule recommendation-v1-v2 -n istio-tutorial\nistioctl delete -f istiofiles\/recommendation_cb_policy_pool_ejection.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n### Egress\n\nEgress 是用来配置 Istio Service mesh 中的服务对外部服务的访问策略。\n\n具体配置请参考 [控制 Egress 流量](http:\/\/istio.doczh.cn\/docs\/tasks\/traffic-management\/egress.html)。\n\n以下示例还有问题，无法正常工作。\n\n构建示例镜像 egresshttpbin。\n\n\u0060\u0060\u0060bash\ncd egress\/egresshttpbin\/\nmvn clean package\ndocker build -t jimmysong\/istio-tutorial-egresshttpbin:v1 .\ndocker push jimmysong\/istio-tutorial-egresshttpbin:v1\n\u0060\u0060\u0060\n\n部署到 Kubernetes。\n\n\u0060\u0060\u0060bash\nkubectl apply -f \u003c(istioctl kube-inject -f egress\/egresshttpbin\/src\/main\/kubernetes\/Deployment.yml) -n istio-toturial\nkubectl create -f egress\/egresshttpbin\/src\/main\/kubernetes\/Service.yml\n\u0060\u0060\u0060\n\n为了在 kubernetes 集群外部访问到该服务，修改增加 ingress 配置并修改本地的\u0060\/etc\/hosts\u0060 文件，我们在前面已经完成了，此处不再赘述。\n\n构建示例镜像 egressgithub。\n\n\u0060\u0060\u0060bash\ncd egress\/egressgithub\nmvn clean package\ndocker build -t jimmysong\/istio-tutorial-egressgithub:v1 .\ndocker push jimmysong\/istio-tutorial-egressgithub:v1\n\u0060\u0060\u0060\n\n部署到 Kubernetes。\n\n\u0060\u0060\u0060bash\nkubectl apply -f \u003c(istioctl kube-inject -f egress\/egressgithub\/src\/main\/kubernetes\/Deployment.yml) -n istio-tutorial\nkubectl create -f egress\/egressgithub\/src\/main\/kubernetes\/Service.yml\n\u0060\u0060\u0060\n\n增加 Egress 配置。\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/egress_httpbin.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n到 egresshttpbin 容器中测试。\n\n\u0060\u0060\u0060bash\nkubectl exec -it $(oc get pods -o jsonpath=\u0022{.items[*].metadata.name}\u0022 -l app=egresshttpbin,version=v1) -c egresshttpbin \/bin\/bash\n\ncurl localhost:8080\n\ncurl httpbin.org\/user-agent\n\ncurl httpbin.org\/headers\n\nexit\n\u0060\u0060\u0060\n\n增加对 [jimmysong.io](https:\/\/jimmysong.io) 的 egress 配置。\n\n\u0060\u0060\u0060bash\ncat \u003c\u003cEOF | istioctl create -f -\napiVersion: config.istio.io\/v1alpha2\nkind: EgressRule\nmetadata:\n  name: jimmysong-egress-rule\n  namespace: istio-tutorial\nspec:\n  destination:\n    service: jimmysong.io\n  ports:\n    - port: 443\n      protocol: https\nEOF\n\u0060\u0060\u0060\n\n增加 Egress 配置。\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/egress_github.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n到 egressgithub 容器中测试。\n\n\u0060\u0060\u0060bash\nkubectl exec -it $(oc get pods -o jsonpath=\u0022{.items[*].metadata.name}\u0022 -l app=egressgithub,version=v1) -c egressgithub \/bin\/bash\n\ncurl http:\/\/jimmysong:443\n\nexit\n\u0060\u0060\u0060\n\n清理环境。\n\n\u0060\u0060\u0060bash\nistioctl delete egressrule httpbin-egress-rule jimmysong-egress-rule github-egress-rule -n istio-tutorial\n\u0060\u0060\u0060\n\n## 参考\n\n- https:\/\/github.com\/redhat-developer-demos\/istio-tutorial\n- [Book - Introducing Istio Service Mesh for Microservices](https:\/\/developers.redhat.com\/books\/introducing-istio-service-mesh-microservices\/)\n', '\/blog\/istio-tutorial\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文是 Istio 管理 Java 微服务的案例教程。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-community-tips/">Istio 社区介绍与社区参与注意事项</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2018/04/14</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio 社区介绍与社区参与注意事项', '本文讲述了参与 Istio 社区和进行 Istio 开发时需要注意的事项。', '\n本文讲述了参与 Istio 社区和进行 Istio 开发时需要注意的事项。\n\n### 工作组\n\n绝大多数复杂的开源项目都是以工作组的方式组织的，要想为 Istio 社区做贡献可以加入到以下的工作组（Working Group）：\n\n- [API Management](https:\/\/github.com\/istio\/community\/blob\/master\/WORKING-GROUPS.md#api-management)\n- [Config](https:\/\/github.com\/istio\/community\/blob\/master\/WORKING-GROUPS.md#config)\n- [Environments](https:\/\/github.com\/istio\/community\/blob\/master\/WORKING-GROUPS.md#environments)\n- [Networking](https:\/\/github.com\/istio\/community\/blob\/master\/WORKING-GROUPS.md#networking)\n- [Performance \u0026 Scalability](https:\/\/github.com\/istio\/community\/blob\/master\/WORKING-GROUPS.md#performance-and-scalability)\n- [Policies \u0026 Telemetry](https:\/\/github.com\/istio\/community\/blob\/master\/WORKING-GROUPS.md#policies-and-telemetry)\n- [Security](https:\/\/github.com\/istio\/community\/blob\/master\/WORKING-GROUPS.md#security)\n- [Test \u0026 Release](https:\/\/github.com\/istio\/community\/blob\/master\/WORKING-GROUPS.md#test-and-release)\n\n### 代码规范\n\nIstio 的代码规范沿用 [CNCF 社区的代码规范](https:\/\/github.com\/cncf\/foundation\/blob\/master\/code-of-conduct.md)。\n\n### 开发指南\n\n进行 Istio 开发之前需要做下面几件事情：\n\n- 配置基础环境，如 Kubernetes\n- 配置代码库、下载依赖和测试\n- 配置 CircleCI 集成环境\n- 编写参考文档\n- Git workflow 配置\n\n详见 [Dev Guide wiki](https:\/\/github.com\/istio\/istio\/wiki\/Dev-Guide)。\n\n### 设计文档\n\n所有的设计文档都保存在 [Google Drive](https:\/\/drive.google.com\/drive\/u\/0\/folders\/0AIS5p3eW9BCtUk9PVA) 中，其中包括以下资源：\n\n- Technical Oversight Committee：ToC 管理的文档\n- Misc：一些杂项\n- Working Groups：最重要的部分，各个工作组相关的设计文档\n- Presentations：Istio 相关的演讲幻灯片，从这些文稿中可以快速了解 Istio\n- Logo：Istio logo\n- Eng：社区相关的维护文档\n\n### 社区角色划分\n\n根据对开发者和要求和贡献程度的不同，Istio 社区中包含以下角色：\n\n- [Collaborator](https:\/\/github.com\/istio\/community\/blob\/master\/ROLES.md#collaborator)：非正式贡献者，偶尔贡献，任何人都可以成为该角色\n- [Member](https:\/\/github.com\/istio\/community\/blob\/master\/ROLES.md#member)：正式贡献者，经常贡献，必须有 2 个已有的 member 提名\n- [Approver](https:\/\/github.com\/istio\/community\/blob\/master\/ROLES.md#approver)：老手，可以批准 member 的贡献\n- [Lead](https:\/\/github.com\/istio\/community\/blob\/master\/ROLES.md#lead)：管理功能、项目和提议，必须由 [ToC](https:\/\/github.com\/istio\/community\/blob\/master\/WORKING-GROUP-PROCESSES.md) 提名\n- [Administrator](https:\/\/github.com\/istio\/community\/blob\/master\/ROLES.md#administrator)：管理员，管理和控制权限，必须由 ToC 提名\n- [Vendor](https:\/\/github.com\/istio\/community\/blob\/master\/ROLES.md#vendor)：贡献 Istio 项目的扩展\n\n详见 [Istio Community Roles](https:\/\/github.com\/istio\/community\/blob\/master\/ROLES.md)。\n\n### 各种功能的状态\n\nIstio 中的所有 feature 根据**是否生产可用**、**API 兼容性**、**性能**、**维护策略**分为三种状态：\n\n- Alpha：仅仅可以作为 demo，无法生产上使用，也没有性能保证，随时都可能不维护\n- Beta：可以在生产上使用了，也有版本化的 API 但是无法保证性能，保证三个月的维护\n- Stable：可以上生产而且还能保证性能，API 向后兼容，保证一年的维护\n\nIstio 的 feature 分为四大类：\n\n- 流量管理：各种协议的支持、路由规则配置、Ingress TLS 等\n- 可观测性：监控、日志、分布式追踪、服务依赖拓扑\n- 安全性：各种 checker 和安全性配置\n- Core：核心功能\n\n功能划分与各种功能的状态详情请见：\u003chttps:\/\/istio.io\/latest\/about\/feature-stages\/\u003e\n\n### 云原生社区 Istio 讨论组\n\n[云原生社区](https:\/\/cloudnative.to)专门成立里 Istio SIG（微信讨论群），将原来 ServiceMesher 中关注 Istio 的人群专门集中到一个讨论组中，其中包含了百度、阿里巴巴、腾讯、网易、Tetrate、Intel、字节跳动等公司的服务网格专家及众多的终端用户，欢迎大家[申请加入群聊](https:\/\/i.cloudnative.to\/istio)。\n', '\/blog\/istio-community-tips\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文讲述了参与 Istio 社区和进行 Istio 开发时需要注意的事项。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/cncf-introduction/">CNCF - 云原生计算基金会简介</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2018/03/04</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f"> 
             云原生
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('CNCF - 云原生计算基金会简介', 'CNCF 云原生计算基金会简介以及 CNCF 的运作方式与项目成熟度级别标准介绍。', '\nCNCF，全称 Cloud Native Computing Foundation（云原生计算基金会），口号是**坚持和整合开源技术来编排容器作为微服务架构的一部分**，其作为致力于云原生应用推广和普及的一支重要力量，不论您是云原生应用的开发者、管理者还是研究人员都有必要了解。\n\nCNCF 作为一个厂商中立的基金会，致力于 Github 上的快速成长的开源技术的推广，如 Kubernetes、Prometheus、Envoy 等，帮助开发人员更快更好的构建出色的产品。\n\nhttp:\/\/github.com\/cncf\/landscape 中维护了一幅 CNCF 的全景图。\n\n其中包含了 CNCF 中托管的项目，还有很多是非 CNCF 项目，还有个交互式的浏览 CNCF 涵盖的所有的项目的页面：https:\/\/i.cncf.io\n\n关于 CNCF 的使命与组织方式请参考[CNCF 章程](https:\/\/www.cncf.io\/about\/charter\/)，概括的讲 CNCF 的使命宝库以下三点：\n\n- 容器化包装。\n- 通过中心编排系统的动态资源管理。\n- 面向微服务。\n\n以上是 CNCF 最初对云原生特征的定义。\n\nCNCF 这个角色的作用是推广技术，形成社区，开源项目管理与推进生态系统健康发展。\n\n另外 CNCF 组织由以下部分组成：\n\n- **会员**：白金、金牌、银牌、最终用户、学术和非赢利成员，不同级别的会员在治理委员会中的投票权不同。\n- **理事会**：负责事务管理\n- **TOC（技术监督委员会）**：技术管理\n- **最终用户社区**：推动 CNCF 技术的采纳并选举最终用户技术咨询委员会\n- **最终用户技术咨询委员会**：为最终用户会议或向理事会提供咨询\n- **营销委员会**：市场推广\n\n## CNCF 项目成熟度分级与毕业条件\n\n每个 CNCF 项目都需要有个成熟度等级，申请成为 CNCF 项目的时候需要确定项目的成熟度级别。\n\n成熟度级别（Maturity Level）包括以下三种：\n\n- sandbox（初级）一开始是叫 inception\n- incubating（孵化中）\n- graduated（毕业）\n\n是否可以成为 CNCF 项目需要通过 Technical Oversight Committee（技术监督委员会）简称[TOC](https:\/\/github.com\/cncf\/toc)，投票采取 fallback 策略，即**回退策略**，先从最高级别（graduated，目前是从 incubating）开始，如果 2\/3 多数投票通过的话则确认为该级别，如果没通过的话，则进行下一低级别的投票，如果一直到 inception 级别都没得到 2\/3 多数投票通过的话，则拒绝其进入 CNCF 项目。一般一个项目处于孵化阶段不会超过 2 年。\n\n当前所有的 CNCF 项目可以访问 https:\/\/www.cncf.io\/projects\/\n\n在太平洋时间 3 月 6 日，Kubernetes 成为了 CNCF 的第一个毕业项目！\n\n## TOC（技术监督委员会）\n\nTOC（Technical Oversight Committee）作为 CNCF 中的一个重要组织，它的作用是：\n\n- 定义和维护技术视野\n- 审批新项目加入组织，为项目设定概念架构\n- 接受最终用户的反馈并映射到项目中\n- 调整组件见的访问接口，协调组件之间兼容性\n\nTOC 成员通过选举产生，见[选举时间表](https:\/\/github.com\/cncf\/toc\/blob\/master\/process\/election-schedule.md)。\n\n参考 CNCF TOC：https:\/\/github.com\/cncf\/toc\n\n## CNCF 章程\n\nCNCF（云原生计算基金会）是 Linux 基金会旗下的一个基金会，加入 CNCF 等于同时加入 Linux 基金会（也意味着你还要交 Linux 基金会的份子钱），对于想加入 CNCF 基金会的企业或者组织首先要做的事情就是要了解 CNCF 的章程（charter），就像是作为一个国家的公民，必须遵守该国家的宪法一样。CNCF 之所以能在短短三年的时间内发展壮大到如此规模，很大程度上是与它出色的社区治理和运作模式有关。了解该章程可以帮助我们理解 CNCF 是如何运作的，也可以当我们自己进行开源项目治理时派上用场。\n\n该章程最后更新于 2018 年 5 月 15 日，详见 \u003chttps:\/\/www.cncf.io\/about\/charter\/\u003e。\n\n### 1. CNCF 的使命\n\nCNCF 没有偏离自己的主题，核心是解决技术问题：基金会的使命是创建并推动采用新的计算模式，该模式针对现代分布式系统环境进行了优化，能够扩展至数万个自愈式多租户节点。\n\n所谓的云原生系统须具备下面这些属性：\n\n- **应用容器化**：将软件容器中的应用程序和进程作为独立的应用程序部署单元运行，并作为实现高级别资源隔离的机制。从总体上改进开发者的体验、促进代码和组件重用，而且要为云元是国内应用简化运维工作。\n- **动态管理**：由中心化的编排来进行活跃的调度和频繁的管理，从根本上提高机器效率和资源利用率，同时降低与运维相关的成本。\n- **面向微服务**：与显式描述的依赖性松散耦合（例如通过服务端点），可以提高应用程序的整体敏捷性和可维护性。CNCF 将塑造技术的发展，推动应用管理的先进技术发展，并通过可靠的接口使技术无处不在，并且易于使用。\n\n### 2. CNCF 扮演的角色\n\nCNCF 其实是在开源社区的基础上发挥着作用，应负责：\n\na) 项目管理\n\n- 确保技术可用于社区并且没有杂七杂八的影响\n- 确保技术的品牌（商标和标识）得到社区成员的关注和使用，特别强调统一的用户体验和高水平的应用程序兼容性\n\nb) 促进生态系统的发展和演进\n\n- 评估哪些技术可以纳入云原生计算应用的愿景，鼓励社区交付这样的技术，以及集成它们，且要积极的推进总结进度。\n- 提供一种方法来培养各个部分的通用技术标准\n\nc) 推广底层技术和应用定义和管理方法，途径包括：活动和会议、营销（SEM、直接营销）、培训课程和开发人员认证。\n\nd) 通过使技术可访问和可靠来为社区服务\n\n- 旨在通过对参考架构进行明确定义的节奏，为每个组成部分提供完全集成和合格的构建。\n\n### 3. CNCF 的价值观\n\nCNCF 会极力遵循以下一些原则：\n\n1. **快速胜过磨叽**，基金会的初衷之一就是让项目快速的发展，从而支持用户能够积极的使用。\n2. **开放！** CNCF 是以开放和高度透明为最高准则的，而且是独立于任何的其它团体进行运作的。CNCF 根据贡献的内容和优点接受所有的贡献者，且遵循开源的价值观，CNCF 输出的技术是可以让所有人使用和受益的，技术社区及其决策应保持高度透明。\n3. **公平**：CNCF 会极力避免那些不好的影响、不良行为、以及“按需付费”的决策。\n4. **强大的技术身份**：CNCF 会实现并保持高度的自身技术认同，并将之同步到所有的共享项目中。\n5. **清晰的边界**：CNCF 制定明确的目标，并在某些情况下，要确定什么不是基金会的目标，并会帮助整个生态系统的运转，让人们理解新创新的重点所在。\n6. **可扩展**：能够支持从小型开发人员中心环境到企业和服务提供商规模的所有部署规模。这意味着在某些部署中可能不会部署某些可选组件，但总体设计和体系结构仍应适用。\n7. **平台中立**：CNCF 所开发的项目并不针对某个特定平台，而是旨在支持各种体系结构和操作系统。\n\n### 4. 会员制\n\nCNCF 中的会员包括白金、金牌、银牌、最终用户、学术和非赢利成员等级别，不同级别的会员在理事会中的投票权不同。\n\na) **白金会员**：在 CNCF 理事会中任命 1 名代表，在理事会的每个次级委员会和活动中任命 1 名有投票权的代表，在网站可以突出显示；如果也是终端用户成员将继承终端用户成员的所有权利\n\nb) **金牌会员**：基金会中每有 5 个金牌会员，该级别的会员就可以任命 1 名代表，最多任命 3 个；如果也是终端用户成员将继承终端用户成员的所有权利\n\nc) **银牌会员**：基金会中每有 10 个银牌会员，该级别的会员就可以任命 1 名代表，最多任命 3 个；如果也是终端用户成员将继承终端用户成员的所有权利\n\nd) **终端用户**：参加终端用户咨询社区；向终端用户技术咨询委员会中提名 1 名代表\n\ne) **学术和非赢利会员**：学术和非营利会员分别限于学术和非营利机构，需要理事会批准。学术成员和非营利成员有权将其组织认定为支持 CNCF 使命的成员以及理事会确定的任何其他权利或利益。\n\n### 5. 理事会\n\na) CNCF 理事会负责市场营销、业务监督和预算审批，不负责技术方面，除了与 TOC 配合确定 CNCF 工作范围、完成时间表 a)、更新 CNCF 网站\n\nb) 负责日常事务\n\n1. 与 TOC 协商 CNCF 的整体范围\n2. 商标和版权保护\n3. 市场营销、布道和生态系统建设\n4. 创建和执行品牌承诺项目，如果需要的话\n5. 监督运营，业务发展；\n6. 募资和财务管理\n\nc) 理事会投票成员由会员代表和社区代表组成：\n\n1. 成员代表包括：\n   - 每名白金会员任命 1 名代表\n   - 黄金和银牌成员当选代表\n2. 技术社区代表包括：\n   - 技术监督委员会主席\n   - 根据当时在任的理事会批准的程序从 CNCF 项目中选出两名提交者。\n3. 理事会可能会以白金会员比例的价格扩展白金会员资格，对年收入低于 5000 万美元的创业公司进行长达 5 年的逐年审计，这些公司被视为理事会的战略技术贡献者。\n4. 只有来自一组**关联公司**的人员可以担任会员代表。只有来自一组**关联公司**的人员可以担任技术社区代表。\n\nd) 职责\n\n1. 批准预算，指导将所有收入来源筹集的资金用于技术、市场或社区投资，以推动 CNCF 基金的使命；\n2. 选举理事会主席主持会议，批准预算批准的支出并管理日常运作；\n3. 对理事会的决定或事项进行投票；\n4. 界定和执行基金会的知识产权（版权，专利或商标）政策；\n5. 通过活动、新闻和分析师宣传、网络、社交媒体以及其他营销活动进行直接营销和布道；\n6. 监督运营，业务发展；\n7. 建立并监督为推动 CNCF 的使命而创建的任何委员会；\n8. 根据 CNCF 要求（可能包括认证测试）建立并执行品牌合规计划（如有），以使用 TOC 建立的品牌标志；\n9. 采用商标使用准则或政策；\n10. 提供整体财务管理。\n\ne) 基金会的收入用途\n\n1. 市场营销，用户扩展 CNCF 中的项目的采用\n2. 关键设施建设、运行和管理项目的基础设施\n3. 促进基于容器的计算使用 CNCF 中的项目实现\n\n### 6. 技术监督委员会（TOC）\n\n**a) 要求**\n\nCNCF 技术监督委员会，为了保持中立，则达成了以下共识：\n\n1. 定义和维护 CNCF 的技术愿景。\n2. 批准由理事会制定的 CNCF 范围内的新项目，并为项目创建一个概念架构。\n3. 纠正项目的发展方向，决策删除或存档项目。\n4. 接受最终用户委员会的反馈并反映在项目中。\n5. 在科学管理的情况下调整组件的接口（在代码标准化之前实现参考）\n6. 定义在 CNCF 项目中实施的常用做法（如果有的话）。\n\n**b) 技术监督委员会的构成**\n\n1. TOC 最多由 9 名成员组成。\n2. 选出的 TOC 成员将涵盖关键的技术领域：容器技术、操作系统、技术运维、分布式系统、用户级应用程序设计等。\n3. 理事会将选举 6 名 TOC 成员，最终用户 TAB 将选出 1 名 TOC 成员，最初的 7 名 TOC 成员应另选两名 TOC 成员。\n4. 如果超过两名 TOC 成员来自同一组关联公司，无论是在选举时还是来自后来的工作变更，他们将共同决定谁应该下台，或如果没有协商的依据，则应抽签决定。\n\n**c) 运营模式**\n\n1. TOC 会选举出 TOC 的主席来，此角色主要负责 TOC 的议程和召集会议。\n2. TOC 每个季度会面对面讨论重要的热点问题。\n3. TOC 可能会根据需要开会讨论新出现的问题。TOC 审核可能会提出以下问题：\n   - 任何的 TOC 成员\n   - 任何的理事会成员\n   - 建立的 CNCF 项目的维护者或顶级项目负责人\n   - CNCF 执行董事\n   - 最终用户技术咨询委员会获得多数票\n4. 保持透明：TOC 会议、邮件列表、以及会议记录等均是公开可访问的。\n5. 简单的 TOC 问题可以通过简短的讨论和简单的多数表决来解决。TOC 讨论可通过电子邮件或 TOC 会议进行。\n6. 在对意见和可选虚拟讨论\/辩论选项进行审查后，寻求共识并在必要时进行投票。\n7. 目的是让 TOC 在 TOC 和社区内寻找达成共识的途径。满足法定人数要求的会议的 TOC 决定应以超过 TOC 成员出席率的 50％的方式通过。\n8. TOC 会议需要 TOC 总人数的三分之二法定人数进行表决或作出任何决定。如果 TOC 会议未能达到法定人数要求，可以进行讨论，但不应有任何投票或决定。\n9. TOC 决定可以在没有会议的情况下以电子方式提出，但要通过表决则需要多少票数才能达到会议法定人数。在电子投票中，如果任何两名 TOC 成员要求召开会议讨论决定，则电子投票结束时无效，并且在会议结束后可以启动新的投票，以讨论决定已经完成。\n\n**d) 提名标准**\n\n获得 TOC 提名的开源贡献者应该具备下面条件：\n\n1. 承诺有足够的可用可用时间参与 CNCF TOC 的活动，包括在 CNCF 成立时相当早期的投入，然后需持续投入时间，而且在季度的 TOC 会议之前要进行充分的准备和审查事宜。\n2. 在 CNCF 范围内展示了高水准的专业经验。\n3. 证明其有资格能够获得额外的工作人员或社区成员协助其在 TOC 的工作。\n4. 在讨论中保持中立，并提出 CNCF 的目标和成功与公司目标或 CNCF 中的任何特定项目保持平衡。\n\n**e) TOC 成员提名和选举程序**\n\n1. TOC 由 9 位 TOC 成员组成：由理事会选出的 6 位，由最终用户 TAB 选出的 1 位和由最初的 7 位 TOC 成员选出的 2 位。\n2. 提名：每个有资格提名 TOC 成员的个人（实体或成员）可以提名至多 2 名技术代表（来自供应商、最终用户或任何其他领域），其中至多一个可能来自其各自公司。被提名者必须提前同意加入到候选人名单中。\n   - 最初的 7 名 TOC 成员（理事会选出的 6 名成员加上由最终用户 TAB 选出的 1 名成员）应使用提名程序提名并选举 2 名 TOC 成员。\n   - 提名者需要提供最多一页纸的介绍，其中包括被提名者的姓名，联系信息和支持性陈述，确定了在 CNCF 领域提名的经验。\n   - 理事会、最终用户 TAB 和 TOC 应确定提名、投票和关于 TOC 选举提名和选举过程的任何其他细节的时间表和日期。\n   - 评估期间最少保留 14 个日历日，TOC 提名者可以联系和\/或评估候选人。\n3. 选举：评估期结束后，理事会、最终用户标签和最初的 7 位 TOC 成员应分别对每位被候选人进行表决。有效投票需要满足会议法定人数所需的选票数量。每名被候选人均需要支持超过 50％的投票人数，以确认被提名者符合资格标准。以多数票通过的候选人应为合格的 TOC 成员。\n4. 如果合格的被提名者的人数等于或少于可选 TOC 席位的数量，则此被提名者应在提名期结束后获得批准。如果有更多的合格被候选人比理事会，最终用户 TAB 或 TOC 可选的开放 TOC 席位多，那么该组应通过 Condorcet 投票选出 TOC 成员。Condorcet 投票应通过康奈尔在线服务（http:\/\/civs.cs.cornell.edu\/）使用 Condorcet-IRV 方法运行。\n5. 如果理事会，最终用户 TAB 或 TOC 可供选举的公开 TOC 席位的合格被候选人数较少，该小组将启动另一轮提名，每名成员或个人有资格提名至多提名 1 名候选人。\n\n**f) 约束条件**\n\n1. TOC 的成员任期为两年，来自理事会选举的最初六名当选 TOC 成员的任期为 3 年。由最终用户 TAB 和 TOC 选出的 TOC 成员的初始任期为 2 年。\n2. TOC 成员可能会被其他 TOC 成员的三分之二投票撤除，受影响的个人不能参加投票。\n3. 任何 TOC 成员连续 3 次连续会议都将被自动暂停投票资格，直至连续参加两次会议。为避免疑义，暂停的 TOC 成员有资格在连续第二次会议中投票。\n4. TOC 章程、模式、方法、组成等可以由整个理事会的三分之二票通过修改。\n5. TOC 议程将由 TOC 制定。但是，预计最初的 TOC 讨论和决定将包括：\n   - 评估包含在 CNCF 中的技术\n   - 确定新技术纳入 CNCF 的接受标准\n   - 定义批准作为标准 API 的贡献技术的流程\n   - 找出需要进一步调查的直接差距\n\n### 7. 最终用户社区\n\na) CNCF 的最终用户成员有权协调和推动 CNCF 用户作为 CNCF 设计的消费者的重要活动。任何作为最终用户的成员或非成员，每个“最终用户参与者”均可被邀请参加。最终用户参与者将帮助向技术咨询委员会和 CNCF 社区就与用户有关的主题提供意见。\n\nb) \t最终用户技术咨询委员会是由最终用户社区成员选举所产生。\n\nc) 最终用户社区成员将获得 CNCF 执行董事的批准，或者 CNCF 执行董事缺席的话，则由 Linux 基金会执行董事来批准。\n\n### 8. 最终用户技术咨询委员会（“最终用户 TAB”）\n\na) 构成：最终用户 TAB 应由来自最终用户参与者的 7 名代表加上 TOC 的 1 名成员组成，以便于从最终用户 TAB 到 TOC 的晋级。\n\nb) 选举：为了鼓励最终用户参与 CNCF，前 7 名最终用户会员可以委任 1 名代表参加初始最终用户 TAB，并将 CNCF 董事分配给任何最终用户参与者的任何剩余席位。在第一年之后，所有最终用户参与者可以提名 1 名代表并且最终用户社区应该投票选择使用当前最终用户 TAB 批准流程的最终用户 TAB 成员。\n\nc) 经过三分之二投票通过后最终用户 TAB 可以更改最终用户社区的大小，前提是至少有 7 名可能的代表。\n\nd) 最终用户代表应当基于业务和技术敏锐度提名。候选人应该具备建设和运营体现 CNCF 原则的基础设施和应用方面的重要实践经验。\n\ne) 最终用户 TAB 将讨论和推进主题，重点是找出 TOC 和 CNCF 开发者社区的差距并提出优先事项。\n\nf) 也会侧重于主动推进最终用户关心的话题，促进 CNCF 的市场采用，为最终用户举办会议或向理事会提供咨询。\n\ng) 如果最终用户 TAB 有意愿的话，它可以批准小组委员会特别兴趣小组（“SIG”）来解决行业或专业话题。\n\nh) 最终用户 TAB 是技术监督委员会的主要输入方，应与技术监督委员会的其他输入方和反馈一起作出决策和计划。这些建议只是建议性的，在任何时候，最终用户 TAB 的建议都不能用于命令或指导任何 TOC 或项目参与者采取任何行动或结果。\n\ni) 为促进与 TOC 的双边互动，最终用户技术咨询委员会应选出 1 名 TOC 代表。最终用户 TAB 可邀请任何人参加最终用户会议、SIG 或其他讨论。\n\n### 9. CNCF 项目\n\n通常情况下，是由 CNCF 的成员公司、开源社区的成员将项目先是带到 CNCF 的技术监督委员会来进行讨论，然后决定是否被 CNCF 接纳。要贡献给 CNCF 的项目必须是经过技术监督委员会制定的标准的，之后当然还要经过理事会的批准。CNCF 的目标是希望捐赠给 CNCF 的项目和 CNCF 已有的项目在一定程度上是有关联的，而且是可集成的。\n\n和 CNCF 关联起来有以下三种方法：\n\n**1.** 已经在 CNCF 的纳管之下，毕竟 CNCF 是中立的，致力于成为大家的协作的归属地。\n\na) 项目的方方面面都交由 CNCF 来打理\nb) 项目是由 CNCF 来进行市场推广的\nc) 项目是解决云原生计算问题的核心组件，如 Kubernetes、Mesos、etcd 等等\n\n**2.** 通过 API 或规范与 CNCF 相关联 XM\n\na) 包括 CNCF 可能提供或启用多个选项的组件\nb) 该项目被称为 CNCF 集成的一个组成部分，而不是由 CNCF 主办的项目\nc) 集成和合规性由 API 或规范定义\nd) 项目或组件的开发是由上游社区所开发，而且保持一定的活跃度\n\n**3.** CNCF 使用到的\n\na) 项目或组件完全根据 OSI 批准的开源许可证进行授权，并且管理良好，并在 CNCF 中被用作组件。\n\nb) 项目并没有由 CNCF 来进行市场推广\n\nc) 项目或组件的开发是由上游社区所开发，而且保持一定的活跃度\n\n现有的开源项目应该继续保持其现有的技术治理结构，以保持凝聚力和速度。但是由技术监督委员会批准之后，则会适当的进行一些适应。\n\n应根据个人的水平和贡献期限在项目间建立一个达到提交者地位的标准协议。因为提交者是维护者的选拔人才池，有了一定程度的贡献，且经过同行们的认可，提交者就可晋升为维护者。\n\nCNCF 启动的新开源项目应完成 TOC 采纳的项目建议模板，并由 TOC 批准纳入 CNCF。TOC 成员应有充足的时间讨论和审查新的项目建议书。新的项目建议书应包括项目中的角色细节，为项目提出的治理，并确定与 CNCF 的角色和价值观保持一致。\n\n### 10. 市场委员会\n\na) 构成，市场委员会将向所有成员开放参与，应选举市场委员会主席制定会议议程，进行一般的讨论，并帮助委员会实现其目标。市场委员会应尽可能寻求共识。在市场委员会中无法达成共识的任何问题应提交给理事会。\n\nb) 职责，市场委员会代表理事会负责设计，开发和执行相关的市场工作。\n\nc) 如果市场委员会变得太大而无法有效运作，市场委员会可以选择选举市场董事，并将决策权委托给市场董事。\n\n### 11. 知识产权政策\n\na) 任何加入到 CNCF 的项目都必须将其拥有的商标和徽标资产转让给 Linux 基金会的所有权。\n\nb) 每个项目应确定是否需要使用经批准的 CNCF CLA。对于选择使用 CLA 的项目，所有代码贡献者将承担 Apache 贡献者许可协议中规定的义务，只有在必要时才作出修改，以确定 CNCF 是捐赠的接受者，并且应由理事会批准。请参阅 \u003chttps:\/\/github.com\/cncf\/cla\u003e 上提供的 CNCF 参与者许可协议。\n\nc) 所有向 CNCF 提交的新入站代码应当（i）附有开发者原始证书签名（\u003chttps:\/\/developercertificate.org\u003e和（ii）根据 Apache 许可证 2.0 版（可从\u003chttps:\/\/developercertificate.org\u003e和\u003chttp:\/\/www.apache.org\/licenses\/LICENSE-2.0\u003e 获得）该许可证除了并且不得取代根据上文（b）规定的供款许可协议所承担的义务。\n\nd) 所有出站代码将在 Apache 许可证 2.0 版下提供。\n\ne) 所有评估纳入 CNCF 的项目都必须获得 OSI 批准的开源许可证的完全许可，如果 CNCF 中包含的项目的许可证不是 Apache 许可证 2.0 版，则需要获得理事会的批准。\n\nf) 所有文档将由 CNCF 根据知识共享署名 4.0 国际许可证来提供。\n\ng) 如果需要替代入站或出站许可证以符合杠杆式开放源代码项目的许可证或为实现 CNCF 的使命而需要其他许可证，理事会可以批准使用替代许可证 对于例外情况下的接受或提供的项目捐赠。\n\n### 12. 反托拉斯指南\n\na) 所有成员均应遵守\u003chttp:\/\/www.linuxfoundation.org\/antitrust-policy\u003e上提供的 Linux 基金会反托拉斯政策中规定的 Linux 基金会的要求。\n\nb) 所有成员都应鼓励任何能够满足成员要求的组织的公开参与，而不论其竞争利益如何。换言之，理事会不应根据除用于所有成员的标准，要求或原因之外的任何标准，要求或理由寻求排除成员。\n\n### 13. 行为准则\n\n所有参与者都须同意遵守 [Linux 基金会行为准则](http:\/\/events.linuxfoundation.org\/code-of-conduct)。TSC 可以投票通过自己的 CNCF 行为准则。\n\n### 14. 关联公司\n\na) 定义：\n\n1. “子公司”是指会员直接或间接拥有所涉实体超过百分之五十有投票权的证券或会员权益的任何实体；\n2. “关联公司”是指任何控制或由成员控制的实体，或者与成员一起受第三方共同控制的实体，在所有情况下，直接或间接拥有多于所有权的控制权；\n3. “关联公司”是指各成员的关联公司。\n\nb) 只有执行了参与协议的法人实体及其子公司才有权享有该会员的权利和特权；但条件是该成员及其子公司应作为单一成员共同对待。\n\nc) 只有一名属于一组关联公司的成员有权一次性任命或提名理事会代表参加类别选举。\n\nd) 如果会员本身是会员或赞助商的基金会，联盟，开源项目，会员组织，用户组或其他实体，那么授予该成员的权利和特权只能扩展到该成员的员工代表，而不能扩展到其成员或发起人，除非理事会不时在特定情况下另行批准。\n\ne) 会员资格不得转让，不可转让、也不能转让，除非现有会员将其现有的会员利益和义务转让给其大部分业务和\/或资产的继任者，无论是通过合并，出售还是其他方式；只要受让人同意遵守 CNCF 的章程以及 Linux Foundation 成员所需的章程和政策。\n\n### 15. 预算\n\na) 理事会应批准年度预算，绝不会承诺超出筹集的资金。预算应与 Linux 基金会的非营利性使命相一致。\n\nb) Linux 基金会应定期报告预算支出。\n\n### 16. 常规和管理费用\n\na) Linux 基金会应保管任何费用，资金和其他现金收据。\n\nb) 一般和行政（G＆A）费用将用于筹集资金以支付财务、会计和运营费用。G＆A 费用应等于 CNCF 首期总收入 1,000,000 美元的 9％以及 CNCF 总收入超过 1,000,000 美元的 6％。\n\n### 17. 一般规则和操作\n\n参与 CNCF 应做到：\n\na) 展示与开源项目开发人员社区进行协调的计划和方法，包括关于代表社区的品牌、徽标和其它标志性的主题；\n\nb) 以专业的方式体现维持社区的凝聚力为目标，同时还要保持 Linux 基金会在开放源代码软件社区的善意和尊重；\n\nc) 尊重所有商标所有人的权利，包括任何品牌和使用准则；\n\nd) 参与 Linux 基金会的所有新闻和分析师关系活动；\n\ne) 根据要求，向 Linux 基金会提供关于项目参与的信息，包括参加项目赞助活动的信息；\n\nf) 直接参与到基金会旗下的任何站点。\n\ng) 根据理事会批准的规则和程序进行运营，前提是这些规则和程序不得与 Linux 基金会的宗旨和政策不一致，并且不得损害 Linux 基金会。\n\n### 18. 修正案\n\n本章程可以通过所有理事会成员的三分之二票数（不包括弃权）进行修改，前提是任何此类修改不得与 Linux 基金会的目的或政策不一致，并且不得对 Linux 基金会产生不利影响。\n\n### 时间表 A：提出 CNCF 范围愿景\n\nCNCF 背后的首要目标是支持和加速“云原生计算”的采用。以下内容是初步范围，旨在阐明 CNCF 将努力实施的“云原生计算”的核心概念。该初始范围应成为发布在 CNCF 网站上的文档。\n\nCNCF 社区坚信云原生计算包含三个核心属性：\n\n- 容器化包装和分发\n- 动态调度\n- 面向微服务\n\n**注**：关于云原生的定义正在重新设定中，已经与上述不同了。\n\n云原生计算系统支持基于这些核心属性的计算，并包含以下理想：\n\n- 开放性和可扩展性\n- 在标准化子系统的边界处定义良好的 API\n- 应用程序生命周期管理的最小障碍\n\n因为上述时间表已经有些过时了，CNCF 成立已经有三年时间了，正在规划新的方案。\n\n## 参考\n\n- [https:\/\/www.cncf.io](https:\/\/www.cncf.io\/)\n- \u003chttps:\/\/www.cncf.io\/about\/charter\/\u003e\n- \u003chttps:\/\/github.com\/cncf\/landscape\u003e\n- \u003chttps:\/\/github.com\/cncf\/toc\u003e', '\/blog\/cncf-introduction\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">CNCF 云原生计算基金会简介以及 CNCF 的运作方式与项目成熟度级别标准介绍。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/configuring-kubernetes-kube-dns/">配置 Kubernetes DNS 服务 kube-dns</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2018/01/03</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/kubernetes"> 
             Kubernetes
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('配置 Kubernetes DNS 服务 kube-dns', '配置 Kubernetes DNS Pod 的提示和定义 DNS 解析过程以及诊断 DNS 问题的指南。', '\n在我们安装 Kubernetes 集群的时候就已经安装了 kube-dns 插件，这个插件也是官方推荐安装的。通过将 Service 注册到 DNS 中，Kuberentes 可以为我们提供一种简单的服务注册发现与负载均衡方式。\n\n[CoreDNS](https:\/\/coredns.io)作为 CNCF 中的托管的一个项目，在 Kuberentes1.9 版本中，使用 kubeadm 方式安装的集群可以通过以下命令直接安装 CoreDNS。\n\n\u0060\u0060\u0060bash\nkubeadm init --feature-gates=CoreDNS=true\n\u0060\u0060\u0060\n\n您也可以使用 CoreDNS 替换 Kubernetes 插件 kube-dns，可以使用 Pod 部署也可以独立部署，请参考[Using CoreDNS for Service Discovery](https:\/\/kubernetes.io\/docs\/tasks\/administer-cluster\/coredns\/)，下文将介绍如何配置 kube-dns。\n\n本文已归档到[kubernetes-handbook](\/book\/kubernetes-handbook)中。\n\n## kube-dns\n\nkube-dns 是 Kubernetes 中的一个内置插件，目前作为一个独立的开源项目维护，见 https:\/\/github.com\/kubernetes\/dns。\n\n下文中给出了配置 DNS Pod 的提示和定义 DNS 解析过程以及诊断 DNS 问题的指南。\n\n## 前提要求\n\n- Kubernetes 1.6 及以上版本。\n- 集群必须使用 \u0060kube-dns\u0060 插件进行配置。\n\n## kube-dns 介绍\n\n从 Kubernetes v1.3 版本开始，使用 [cluster add-on 插件管理器回自动启动内置的 DNS。\n\nKubernetes DNS pod 中包括 3 个容器：\n\n- \u0060kubedns\u0060：\u0060kubedns\u0060 进程监视 Kubernetes master 中的 Service 和 Endpoint 的变化，并维护内存查找结构来服务 DNS 请求。\n- \u0060dnsmasq\u0060：\u0060dnsmasq\u0060 容器添加 DNS 缓存以提高性能。\n- \u0060sidecar\u0060：\u0060sidecar\u0060 容器在执行双重健康检查（针对 \u0060dnsmasq\u0060 和 \u0060kubedns\u0060）时提供单个健康检查端点（监听在 10054 端口）。\n\nDNS  pod 具有静态 IP 并作为 Kubernetes 服务暴露出来。该静态 IP 分配后，kubelet 会将使用 \u0060--cluster-dns = \u003cdns-service-ip\u003e\u0060 标志配置的 DNS 传递给每个容器。\n\nDNS 名称也需要域名。本地域可以使用标志 \u0060--cluster-domain = \u003cdefault-local-domain\u003e\u0060 在 kubelet 中配置。\n\nKubernetes 集群 DNS 服务器基于 [SkyDNS](https:\/\/github.com\/skynetservices\/skydns) 库。它支持正向查找（A 记录），服务查找（SRV 记录）和反向 IP 地址查找（PTR 记录）\n\n## kube-dns 支持的 DNS 格式\n\nkube-dns 将分别为 service 和 pod 生成不同格式的 DNS 记录。\n\n**Service**\n\n- A 记录：生成\u0060my-svc.my-namespace.svc.cluster.local\u0060域名，解析成 IP 地址，分为两种情况：\n  - 普通 Service：解析成 ClusterIP\n  - Headless Service：解析为指定 Pod 的 IP 列表\n- SRV 记录：为命名的端口（普通 Service 或 Headless Service）生成 \u0060_my-port-name._my-port-protocol.my-svc.my-namespace.svc.cluster.local\u0060 的域名\n\n**Pod**\n\n- A 记录：生成域名 \u0060pod-ip.my-namespace.pod.cluster.local\u0060\n\n## kube-dns 存根域名\n\n可以在 Pod 中指定 hostname 和 subdomain：\u0060hostname.custom-subdomain.default.svc.cluster.local\u0060，例如：\n\n\u0060\u0060\u0060yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: busybox\n  labels:\n    name: busybox\nspec:\n  hostname: busybox-1\n  subdomain: busybox-subdomain\n  containers:\n  name: busybox\n  - image: busybox\n    command:\n    - sleep\n    - \u00223600\u0022\n\u0060\u0060\u0060\n\n该 Pod 的域名是 \u0060busybox-1.busybox-subdomain.default.svc.cluster.local\u0060。\n\n## 继承节点的 DNS\n\n运行 Pod 时，kubelet 将预先配置集群 DNS 服务器到 Pod 中，并搜索节点自己的 DNS 设置路径。如果节点能够解析特定于较大环境的 DNS 名称，那么 Pod 应该也能够解析。请参阅下面的[已知问题](#known-issues)以了解警告。\n\n如果您不想要这个，或者您想要为 Pod 设置不同的 DNS 配置，您可以给 kubelet 指定 \u0060--resolv-conf\u0060 标志。将该值设置为 \u0022\u0022 意味着 Pod 不继承 DNS。将其设置为有效的文件路径意味着 kubelet 将使用此文件而不是 \u0060\/etc\/resolv.conf\u0060 用于 DNS 继承。\n\n## 配置存根域和上游 DNS 服务器\n\n通过为 kube-dns（\u0060kube-system:kube-dns\u0060）提供一个 ConfigMap，集群管理员能够指定自定义存根域和上游 nameserver。\n\n例如，下面的 ConfigMap 建立了一个 DNS 配置，它具有一个单独的存根域和两个上游 nameserver：\n\n\u0060\u0060\u0060yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: kube-dns\n  namespace: kube-system\ndata:\n  stubDomains: |\n    {“acme.local”: [“1.2.3.4”]}\n  upstreamNameservers: |\n    [“8.8.8.8”, “8.8.4.4”]\n\u0060\u0060\u0060\n\n如上面指定的那样，带有“.acme.local”后缀的 DNS 请求被转发到 1.2.3.4 处监听的 DNS。Google Public DNS 为上游查询提供服务。\n\n下表描述了如何将具有特定域名的查询映射到其目标 DNS 服务器：\n\n| 域名                                   | 响应查询的服务器                   |\n| ------------------------------------ | -------------------------- |\n| kubernetes.default.svc.cluster.local | kube-dns                   |\n| foo.acme.local                       | 自定义 DNS (1.2.3.4)          |\n| widget.com                           | 上游 DNS (8.8.8.8 或 8.8.4.4) |\n\n查看 [ConfigMap 选项](#configmap-options) 获取更多关于配置选项格式的详细信息。\n\n### 对 Pod 的影响\n\n自定义的上游名称服务器和存根域不会影响那些将自己的 \u0060dnsPolicy\u0060 设置为 \u0060Default\u0060 或者 \u0060None\u0060 的 Pod。\n\n如果 Pod 的 \u0060dnsPolicy\u0060 设置为“\u0060ClusterFirst\u0060”，则其名称解析将按其他方式处理，具体取决于存根域和上游 DNS 服务器的配置。\n\n**未进行自定义配置**：没有匹配上配置的集群域名后缀的任何请求，例如“www.kubernetes.io”，将会被转发到继承自节点的上游 nameserver。\n\n**进行自定义配置**：如果配置了存根域和上游 DNS 服务器（和在 [前面例子](#configuring-stub-domain-and-upstream-dns-servers) 配置的一样），DNS 查询将根据下面的流程进行路由：\n\n1. 查询首先被发送到 kube-dns 中的 DNS 缓存层。\n\n2. 从缓存层，检查请求的后缀，并转发到合适的 DNS 上，基于如下的示例：\n\n   -  *具有集群后缀的名字* （例如“.cluster.local”）：请求被发送到 kube-dns。\n   -  *具有存根域后缀的名字* （例如“.acme.local”）：请求被发送到配置的自定义 DNS 解析器（例如：监听在 1.2.3.4）。\n   -  *不具有能匹配上后缀的名字* （例如“widget.com”）：请求被转发到上游 DNS（例如：Google 公共 DNS 服务器，8.8.8.8 和 8.8.4.4）。\n\n   ![DNS lookup flow](https:\/\/d33wubrfki0l68.cloudfront.net\/340889cb80e81dcd19a16bc34697a7907e2b229a\/24ad0\/docs\/tasks\/administer-cluster\/dns-custom-nameservers\/dns.png)\n\n## ConfigMap 选项\n\nkube-dns \u0060kube-system:kube-dns\u0060 ConfigMap 的选项如下所示：\n\n| 字段                        | 格式                                       | 描述                                       |\n| ------------------------- | ---------------------------------------- | ---------------------------------------- |\n| \u0060stubDomains\u0060（可选）         | 使用 DNS 后缀 key 的 JSON map（例如“acme.local”），以及 DNS IP 的 JSON 数组作为 value。 | 目标 nameserver 可能是一个 Kubernetes Service。例如，可以运行自己的 dnsmasq 副本，将 DNS 名字暴露到 ClusterDNS namespace 中。 |\n| \u0060upstreamNameservers\u0060（可选） | DNS IP 的 JSON 数组。                        | 注意：如果指定，则指定的值会替换掉被默认从节点的 \u0060\/etc\/resolv.conf\u0060 中获取到的 nameserver。限制：最多可以指定三个上游 nameserver。 |\n\n### 示例\n\n#### 示例：存根域\n\n在这个例子中，用户有一个 Consul DNS 服务发现系统，他们希望能够与 kube-dns 集成起来。Consul 域名服务器地址为 10.150.0.1，所有的 Consul 名字具有后缀“.consul.local”。要配置 Kubernetes，集群管理员只需要简单地创建一个 ConfigMap 对象，如下所示：\n\n\u0060\u0060\u0060yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: kube-dns\n  namespace: kube-system\ndata:\n  stubDomains: |\n    {“consul.local”: [“10.150.0.1”]}\n\u0060\u0060\u0060\n\n注意，集群管理员不希望覆盖节点的上游 nameserver，所以他们不会指定可选的 \u0060upstreamNameservers\u0060 字段。\n\n#### 示例：上游 nameserver\n\n在这个示例中，集群管理员不希望显式地强制所有非集群 DNS 查询进入到他们自己的 nameserver 172.16.0.1。而且这很容易实现：他们只需要创建一个 ConfigMap，\u0060upstreamNameservers\u0060 字段指定期望的 nameserver 即可。\n\n\u0060\u0060\u0060yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: kube-dns\n  namespace: kube-system\ndata:\n  upstreamNameservers: |\n    [“172.16.0.1”]\n\u0060\u0060\u0060\n\n## 调试 DNS 解析\n\n### 创建一个简单的 Pod 用作测试环境\n\n创建一个名为 busybox.yaml 的文件，其中包括以下内容：\n\n\u0060\u0060\u0060yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: busybox\n  namespace: default\nspec:\n  containers:\n  - name: busybox\n    image: busybox\n    command:\n      - sleep\n      - \u00223600\u0022\n    imagePullPolicy: IfNotPresent\n  restartPolicy: Always\n\u0060\u0060\u0060\n\n使用该文件创建 Pod 并验证其状态：\n\n\u0060\u0060\u0060shell\n$ kubectl create -f busybox.yaml\npod \u0022busybox\u0022 created\n\n$ kubectl get pods busybox\nNAME      READY     STATUS    RESTARTS   AGE\nbusybox   1\/1       Running   0          \u003csome-time\u003e\n\u0060\u0060\u0060\n\n该 Pod 运行后，您可以在它的环境中执行 \u0060nslookup\u0060。如果您看到类似如下的输出，表示 DNS 正在正确工作。\n\n\u0060\u0060\u0060shell\n$ kubectl exec -ti busybox -- nslookup kubernetes.default\nServer:    10.0.0.10\nAddress 1: 10.0.0.10\n\nName:      kubernetes.default\nAddress 1: 10.0.0.1\n\u0060\u0060\u0060\n\n如果 \u0060nslookup\u0060 命令失败，检查如下内容：\n\n### 首先检查本地 DNS 配置\n\n查看下 resolv.conf 文件。（参考[集成节点的 DNS](#inheriting-dns-from-the-node)和 下面的[已知问题](#known-issues)获取更多信息）\n\n\u0060\u0060\u0060shell\n$ kubectl exec busybox cat \/etc\/resolv.conf\n\u0060\u0060\u0060\n\n验证搜索路径和名称服务器设置如下（请注意，搜索路径可能因不同的云提供商而异）：\n\n\u0060\u0060\u0060bash\nsearch default.svc.cluster.local svc.cluster.local cluster.local google.internal c.gce_project_id.internal\nnameserver 10.0.0.10\noptions ndots:5\n\u0060\u0060\u0060\n\n如果看到如下错误表明错误来自 kube-dns 或相关服务：\n\n\u0060\u0060\u0060bash\n$ kubectl exec -ti busybox -- nslookup kubernetes.default\nServer:    10.0.0.10\nAddress 1: 10.0.0.10\n\nnslookup: can\u0027t resolve \u0027kubernetes.default\u0027\n\u0060\u0060\u0060\n\n或者\n\n\u0060\u0060\u0060bash\n$ kubectl exec -ti busybox -- nslookup kubernetes.default\nServer:    10.0.0.10\nAddress 1: 10.0.0.10 kube-dns.kube-system.svc.cluster.local\n\nnslookup: can\u0027t resolve \u0027kubernetes.default\u0027\n\u0060\u0060\u0060\n\n### 检查 DNS pod 是否在运行\n\n使用 \u0060kubectl get pods\u0060 命令验证 DNS pod 是否正在运行。\n\n\u0060\u0060\u0060shell\n$ kubectl get pods --namespace=kube-system -l k8s-app=kube-dns\nNAME                    READY     STATUS    RESTARTS   AGE\n...\nkube-dns-v19-ezo1y      3\/3       Running   0           1h\n...\n\u0060\u0060\u0060\n\n如果您看到没有 Pod 运行或者 Pod 处于 失败\/完成 状态，DNS 插件可能没有部署到您的当前环境中，您需要手动部署。\n\n### 检查 DNS pod 中的错误\n\n使用 \u0060kubectl logs\u0060 命令查看 DNS 守护进程的日志。\n\n\u0060\u0060\u0060shell\n$ kubectl logs --namespace=kube-system $(kubectl get pods --namespace=kube-system -l k8s-app=kube-dns -o name) -c kubedns\n$ kubectl logs --namespace=kube-system $(kubectl get pods --namespace=kube-system -l k8s-app=kube-dns -o name) -c dnsmasq\n$ kubectl logs --namespace=kube-system $(kubectl get pods --namespace=kube-system -l k8s-app=kube-dns -o name) -c sidecar\n\u0060\u0060\u0060\n\n看看有没有可疑的日志。以字母“\u0060W\u0060”，“\u0060E\u0060”，“\u0060F\u0060”开头的代表警告、错误和失败。请搜索具有这些日志级别的条目，并使用 [kubernetes issues](https:\/\/github.com\/kubernetes\/kubernetes\/issues)来报告意外错误。\n\n### DNS 服务启动了吗？\n\n使用 \u0060kubectl get service\u0060 命令验证 DNS 服务是否启动。\n\n\u0060\u0060\u0060shell\n$ kubectl get svc --namespace=kube-system\nNAME          CLUSTER-IP     EXTERNAL-IP   PORT(S)             AGE\n...\nkube-dns      10.0.0.10      \u003cnone\u003e        53\/UDP,53\/TCP        1h\n...\n\u0060\u0060\u0060\n\n如果您已经创建了该服务或它本应该默认创建但没有出现，参考[调试服务](https:\/\/kubernetes.io\/docs\/tasks\/debug-application-cluster\/debug-service\/)获取更多信息。\n\n### DNS 端点暴露出来了吗？\n\n您可以使用\u0060kubectl get endpoints\u0060命令验证 DNS 端点是否被暴露。\n\n\u0060\u0060\u0060shell\n$ kubectl get ep kube-dns --namespace=kube-system\nNAME       ENDPOINTS                       AGE\nkube-dns   10.180.3.17:53,10.180.3.17:53    1h\n\u0060\u0060\u0060\n\n如果您没有看到端点，查看[调试服务](https:\/\/kubernetes.io\/docs\/tasks\/debug-application-cluster\/debug-service\/)文档中的端点部分。\n\n获取更多的 Kubernetes DNS 示例，请参考 Kubernetes GitHub 仓库中的[cluster-dns 示例](https:\/\/github.com\/kubernetes\/examples\/tree\/master\/staging\/cluster-dns)。\n\n## 已知问题\n\nKubernetes 安装时不会将节点的 resolv.conf 文件配置为默认使用集群 DNS，因为该过程本身是特定于发行版的。这一步应该放到最后实现。\n\nLinux 的 libc 不可思议的卡住（[查看该 2005 年起暴出来的 bug](https:\/\/bugzilla.redhat.com\/show_bug.cgi?id=168253)）限制只能有 3 个 DNS \u0060nameserver\u0060 记录和 6 个 DNS \u0060search\u0060 记录。Kubernetes 需要消耗 1 个 \u0060nameserver\u0060 记录和 3 个 \u0060search\u0060 记录。这意味着如果本地安装已经使用 3 个 \u0060nameserver\u0060 或使用 3 个以上的 \u0060search\u0060 记录，那么其中一些设置将会丢失。有个部分解决该问题的方法，就是节点可以运行 \u0060dnsmasq\u0060，它将提供更多的 \u0060nameserver\u0060 条目，但不会有更多的 \u0060search\u0060 条目。您也可以使用 kubelet 的 \u0060--resolv-conf\u0060 标志。\n\n如果您使用的是 Alpine 3.3 或更低版本作为基础映像，由于已知的 Alpine 问题，DNS 可能无法正常工作。点击[这里](https:\/\/github.com\/kubernetes\/kubernetes\/issues\/30215)查看更多信息。\n\n## Kubernetes 集群联邦（多可用区支持）\n\nKubernetes 1.3 版本起引入了支持多站点 Kubernetes 安装的集群联邦支持。这需要对 Kubernetes 集群 DNS 服务器处理 DNS 查询的方式进行一些小的（向后兼容的）更改，以便于查找联邦服务（跨多个 Kubernetes 集群）。有关集群联邦和多站点支持的更多详细信息，请参阅集群联邦管理员指南。\n\n## 参考\n\n- [Configure DNS Service](https:\/\/kubernetes.io\/docs\/tasks\/administer-cluster\/dns-custom-nameservers\/)\n- [Service 和 Pod 的 DNS](https:\/\/kubernetes.io\/docs\/concepts\/services-networking\/dns-pod-service\/)\n- [自动扩容集群中的 DNS 服务](https:\/\/kubernetes.io\/docs\/tasks\/administer-cluster\/dns-horizontal-autoscaling\/)\n- [Using CoreDNS for Service Discovery](https:\/\/kubernetes.io\/docs\/tasks\/administer-cluster\/coredns\/)\n\n', '\/blog\/configuring-kubernetes-kube-dns\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">配置 Kubernetes DNS Pod 的提示和定义 DNS 解析过程以及诊断 DNS 问题的指南。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
          <div class="col-12">
 
 
 
 
 
 
 
 
 
 
 
 <nav aria-label="Page navigation">
   <ul class="pagination justify-content-center">
     
     
     <li class="page-item">
       <a class="page-link" href="/blog/">
         ««
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a href="/blog/page/27/" class="page-link">
         «
       </a>
     </li>
     
     
     
       
       
       
         
         
         
           
           
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
             
           
         
         
       
       
       
       
         <li class="page-item">
           <a href="/blog/page/26/" class="page-link">
             26
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
       
       
       
       
         <li class="page-item">
           <a href="/blog/page/27/" class="page-link">
             27
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
       
       
       
       
         <li class="page-item page-item active ">
           <a href="/blog/page/28/" class="page-link">
             28
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
       
       
       
       
         <li class="page-item">
           <a href="/blog/page/29/" class="page-link">
             29
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
       
       
       
       
         <li class="page-item">
           <a href="/blog/page/30/" class="page-link">
             30
           </a>
         </li>
       
     
     
     
     <li class="page-item">
       <a href="/blog/page/29/" class="page-link">
         »
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a class="page-link" href="/blog/page/30/">
         »»
       </a>
     </li>
     
   </ul>
 </nav>
 
</div>

        </div>
      </div>
      <!-- sidebar -->
      <aside class="col-lg-4 order-1 order-lg-2 d-none d-sm-block">
          <div class="sidebar">
          <!-- categories -->
<div class="blog-categories mb-4">
  <p class="sidebar-title">
      专栏
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/istio" class="sidebar-item">
            <span>Istio</span>
            <span>(85)</span>
        </a>
      
        <a href="/categories/service-mesh" class="sidebar-item">
            <span>Service Mesh</span>
            <span>(42)</span>
        </a>
      
        <a href="/categories/kubernetes" class="sidebar-item">
            <span>Kubernetes</span>
            <span>(25)</span>
        </a>
      
        <a href="/categories/%e9%9a%8f%e7%ac%94" class="sidebar-item">
            <span>随笔</span>
            <span>(22)</span>
        </a>
      
        <a href="/categories/%e5%85%b6%e4%bb%96" class="sidebar-item">
            <span>其他</span>
            <span>(20)</span>
        </a>
      
        <a href="/categories/envoy" class="sidebar-item">
            <span>Envoy</span>
            <span>(18)</span>
        </a>
      
        <a href="/categories/%e4%b8%9a%e6%80%81" class="sidebar-item">
            <span>业态</span>
            <span>(17)</span>
        </a>
      
        <a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f" class="sidebar-item">
            <span>云原生</span>
            <span>(14)</span>
        </a>
      
        <a href="/categories/ai" class="sidebar-item">
            <span>AI</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%ae%89%e5%85%a8" class="sidebar-item">
            <span>安全</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%bc%80%e6%ba%90" class="sidebar-item">
            <span>开源</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%b7%a5%e5%85%b7" class="sidebar-item">
            <span>工具</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e6%97%85%e8%a1%8c" class="sidebar-item">
            <span>旅行</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e5%8f%af%e8%a7%82%e6%b5%8b%e6%80%a7" class="sidebar-item">
            <span>可观测性</span>
            <span>(6)</span>
        </a>
  </div>
</div>

<div class="blog-categories mb-4">
  <p class="sidebar-title">
      资料
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/%e5%87%ba%e7%89%88%e7%89%a9" class="sidebar-item">
            <span>出版物</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e7%94%b5%e5%ad%90%e4%b9%a6" class="sidebar-item">
            <span>翻译电子书</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e6%96%87%e6%a1%a3" class="sidebar-item">
            <span>翻译文档</span>
            <span>(7)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>翻译图书</span>
            <span>(6)</span>
        </a>
      
        <a href="/categories/%e5%8e%9f%e5%88%9b%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>原创图书</span>
            <span>(2)</span>
        </a>
      
        <a href="/categories/%e6%95%99%e7%a8%8b%e6%89%8b%e5%86%8c" class="sidebar-item">
            <span>教程手册</span>
            <span>(2)</span>
        </a>
  </div>
</div>





          </div>
      </aside>
      <!-- /sidebar -->
    </div>
  </div>
</section>




<footer>
  
  <div class="footer bg-footer section-sm border-bottom overlay ">
    <div class="container-xl">
      <div class="row">
        <div class="col col-xl-4 d-sm-none mb-2 mb-lg-0 d-xl-block d-none">
          
          <p class="h3 text-white mb-4 text-uppercase">联系</p>
          
          <ul class="list-unstyled">
            
            
            <li class="mb-4 text-color">微信公众号</li>
            
            
            <li class="mb-4"><img src="/images/servicemesher-wechat.webp" width="118px" height="118px" alt="footer image"></li>
            
            
            
          
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">博客</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/blog/istio-ambient-terminology/">Istio Ambient 模式：图解及概念解读</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/free-ai-drawing-tool-raphael/">免费的 AI 绘图工具推荐：Raphael.app</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/cloud-native-observability-devops/">探索云原生可观测性：技术与团队协作的深度结合</a></li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">链接</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://istio.io/latest/zh/" target="_blank" rel="noopener noreferrer">
                  Istio 服务网格
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://tetrate.io/?jimmysong" target="_blank" rel="noopener noreferrer">
                  Tetrate 公司
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener noreferrer">
                  云原生学院|Bilibili
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/awesome-cloud-native/" target="_blank" rel="noopener noreferrer">
                  云原生开源项目大全
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://cloudnative.to" target="_blank" rel="noopener noreferrer">
                  云原生社区（中国）
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">教程</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/envoy-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Envoy 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/istio-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Istio 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/kubernetes-handbook/" >
                  Kubernetes 基础教程
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/envoy-made-simple/" >
                  简明 Envoy 教程
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">通知</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/notice/kcd-beijing-2025/">KCD Beijing 2025 - 提交议题开启！</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/cloud-native-community-domain-migration/">云原生社区网站域名变更通知</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/nist-sp-800-233-service-mesh-proxy-models/">资料分享：云原生应用服务网格代理模型的威胁分析指南</a></li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>

  
  <div class="copyright py-4 bg-footer overlay">
    <div class="container-xl">
      <div class="row">
        <div class="col-sm-6 text-sm-left text-center">
          <p class="mb-0 text-color">© 2017-2025 Jimmy Song 保留所有权利</p>
        </div>
        <div class="col-sm-6 text-sm-right text-center">
          <ul class="list-inline">
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://twitter.com/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-x-twitter text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/contact/" >
                    <i class="fa-brands fa-weixin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://github.com/rootsongjc" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-github text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://linkedin.com/in/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-linkedin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="mailto:rootsongjc@gmail.com" >
                    <i class="fa-solid fa-envelope text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/blog/index.xml" >
                    <i class="fa-solid fa-rss text-white"></i>
              </a>
            </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>


<!-- JS Plugins -->

<script src="/plugins/popper/popper.min.js"></script>

<script src="/plugins/bootstrap/bootstrap.min.js"></script>

<script src="/plugins/slick/slick.min.js"></script>

<script src="/plugins/filterizr/jquery.filterizr.min.js"></script>

<script src="/plugins/search/fuse.min.js"></script>

<script src="/plugins/search/mark.js"></script>

<script src="/plugins/hex_md5/hex_md5.js"></script>

<script src="/plugins/anchor/anchor.min.js"></script>

<script src="/plugins/tocbot/tocbot.min.js"></script>

<script src="/plugins/bigger-picture/bigger-picture.min.js"></script>


<!-- Main Script -->

<script src="/js/script.min.f94c22b1d478bfc9e2e0a7d954429e47b7e6d36edd423758482e04154ae1842e.js"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-ESY906ZWZ0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ESY906ZWZ0');
</script>


<!-- Baidu analysis -->
<meta name="baidu-site-verification" content="g8IYR9SNLF" />





<script>
    anchors.add();
</script>






<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>










<script src="/js/wowchemy-search.min.7a37268e7bbe4a9160c2e4c33b749816.js" type="module"></script>
<script id="search-hit-fuse-template" type="text/x-template">
  <div class="search-hit" id="summary-{{key}}">
    <div class="search-hit-content border-bottom">
      <div class="search-hit-name">
        <div class='search-hit-link'><a href="{{relpermalink}}">{{title}}</a></div>
        <div class="search-hit-metadata d-flex">
            <span class="mr-1"><i class="fa-regular fa-calendar mr-1"></i>{{date}}</span>
            <span class="mr-1"><i class="fa-regular fa-folder-open mr-1"></i>{{section}}</span>
            <span class="d-sm-block d-none"><i class="fa-solid fa-link mr-1"></i>{{relpermalink}}</span>
        </div>
        <div class="search-hit-description">{{snippet}}</div>
      </div>
    </div>
  </div>
</script>



    </body>
</html>
