<!DOCTYPE html>
<html lang="zh"><head>
  <meta charset="utf-8">
  
  <title>博客 - Jimmy Song</title>
  

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta name="description" content="专注开源技术、云原生与生活随笔的分享与思考。">
  <meta name="author" content="Jimmy Song">
  <meta name="generator" content="Hugo 0.136.0">

  <!-- CSS plugins -->
  
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
  
  <link rel="preload" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" as="style">
  <link rel="stylesheet" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" media="screen">
  

  <!-- Main Stylesheet -->
  
  <link rel="preload" href="/scss/style.min.784204edcd29c092198e88494fa2ae755eba9ae231d6fa7faf8e7da3207b4623.css" as="style">
  <link rel="stylesheet" href="/scss/style.min.784204edcd29c092198e88494fa2ae755eba9ae231d6fa7faf8e7da3207b4623.css" media="screen">

  <!-- Bigger picture css -->
  
  <link rel="stylesheet" href="/plugins/bigger-picture/bigger-picture.min.css" media="print" onload="this.media='all'">
  <!--Favicon generate by https://realfavicongenerator.net-->
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="200x200" href="/images/favicon.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">

  <link href='/opensearchdescription.xml' rel='search' title='Content search' type='application/opensearchdescription+xml'/>

  <!--Twitter card-->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="jimmysong.io" />
  <meta name="twitter:creator" content="@jimmysongio" />
  <meta property="og:url" content="https://jimmysong.io/blog/" />
  <meta property="og:title" content="博客 | Jimmy Song" />
  <meta property="twitter:title" content="博客 | Jimmy Song" />

  
  <meta property="og:description" content="专注开源技术、云原生与生活随笔的分享与思考。" />
  <meta property="twitter:description" content="专注开源技术、云原生与生活随笔的分享与思考。" />

  
  <meta property="og:image" content="https://jimmysong.io/images/banner/default.jpg" />
  <meta property="twitter:image" content="https://jimmysong.io/images/banner/default.jpg" />

  
  
</head>
<body>
<header class="fixed-top header">
  
  
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa fa-arrow-circle-up" aria-hidden="true"></i></button>
  
  <div class="navigation w-100 ">
    <div class="container-xl">
      <nav class="navbar navbar-expand-lg navbar-light p-0">
        <a class="navbar-brand" href="/">
            
            <b>JIMMY SONG</b>
            
        </a>
        <button class="navbar-toggler rounded-0" type="button" data-toggle="collapse" data-target="#navigation"
          aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse text-center" id="navigation">
          <ul class="navbar-nav ml-auto">
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/blog">博客</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/book">资料</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/tags">标签</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/notice">公告</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/contact">联系</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/about">关于</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/community/">社区</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener">视频 <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i></a>
              
            </li>
            
            

          
          
          <li class="nav-item">
            
            
            
              
              
                
                
                
                  
                    
                    <a class="nav-link" href="/en/blog/">English</a>
                    
                  
                
              
              
              
                
                  
                    
                    
                  
                
                
                
              
          </li>
          
          
          <!-- search -->
           <button type="button" class="search-btn js-search" id="searchOpen" aria-label="Search">
              <div class="search-container d-flex justify-content-center">
              <span class="search-content">
                  <i class="fa fa-search"></i>
                  <span>搜索</span>
              </span>
              <span class="search-shortcuts d-none d-sm-block">
                  <kbd class="cmd-key">⌘</kbd>
                  <kbd class="k-key">K</kbd>
              </span>
              </div>
          </button>
          
          </ul>
        </div>
      </nav>
    </div>
  </div>
</header>


            <aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between">
        <div class="col-6 search-title">
          <p>站内搜索</p> 
        </div>
        <div class="col-6 col-search-close">
          <div class="js-search" aria-label="关闭"><i class="fa-solid fa-circle-xmark text-muted" aria-hidden="true"></i></div>
        </div>
      </div>

      <div id="search-box">
        <i class="fa-solid fa-magnifying-glass" id="search-icon" aria-hidden="true"></i>
        <input name="q" id="search-query" placeholder="请输入搜索词" autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control" aria-label="请输入搜索词">
        
        <div class="mt-4">
          <span>搜索类型: </span>
          <span>
            <input type="radio" id="all" name="search_type" value="all" checked>
            <label for="all">所有</label>
            
              <input type="radio" id="blog" name="search_type" value="blog">
              <label for="blog">原创</label>
              <input type="radio" id="trans" name="search_type" value="trans">
              <label for="trans">译文</label>
            
            <input type="radio" id="book" name="search_type" value="book">
            <label for="book">资料</label>
            <input type="radio" id="notice" name="search_type" value="notice">
            <label for="notice">公告</label>
          </span>
        </div>
      </div>
      
    </section>
    <section class="section-search-results">
      <div id="search-results-count" class="search-results-count"></div>
      <div id="search-hits">
        
      </div>
    </section>
  </div>
</aside>

        
        
            

<section class="bg-cover page-title-section overlay" style="background-image: url('/images/backgrounds/circle.svg'),url('/images/backgrounds/page-title.webp');background-size: cover;">
    <div class="container-xl">
        <div class="row">
            <div class="col-12">
                <p class="h1">
                    博客
                </p>
                <p class="page-description">
                    专注开源技术、云原生与生活随笔的分享与思考。
                </p>
                
            </div>
        </div>
    </div>
</section>

        


<section class="section-sm book-list-section bg-gray">
  <div class="container-xl">
    <div class="row">
      <div class="col-lg-8 order-2 order-lg-1">
        <div class="row">
          
          
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/envoy-archiecture-and-terminology/">Envoy 的架构与基本配置解析</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2018/04/27</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/envoy"> 
             Envoy
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Envoy 的架构与基本配置解析', '本文介绍了 Envoy proxy 中的基本概念、配置与架构解析。', '\n在了解一门技术之前一开始就要了解其中的基本概念和术语，只有融入了该语境才能理解这门技术。本文将为大家介绍 Envoy 中的基本术语和重点概念。\n\n## 架构\n\n下图是 Envoy proxy 的架构图，显示了 host B 经过 Envoy 访问 host A 的过程。每个 host 上都可能运行多个 service，Envoy 中也可能有多个 Listener，每个 Listener 中可能会有多个 filter 组成了 chain。\n\n![Envoy proxy 架构图](envoy-arch.jpg)\n\n其中的基本术语将在下面解释。\n\n## 基本术语\n\n**Host**：能够进行网络通信的实体（在手机或服务器等上的应用程序）。在 Envoy 中主机是指逻辑网络应用程序。只要每台主机都可以独立寻址，一块物理硬件上就运行多个主机。\n\n**Downstream**：下游（downstream）主机连接到 Envoy，发送请求并或获得响应。\n\n**Upstream**：上游（upstream）主机获取来自 Envoy 的链接请求和响应。\n\n**Cluster**: 集群（cluster）是 Envoy 连接到的一组逻辑上相似的上游主机。Envoy 通过服务发现发现集群中的成员。Envoy 可以通过主动运行状况检查来确定集群成员的健康状况。Envoy 如何将请求路由到集群成员由负载均衡策略确定。\n\n**Mesh**：一组互相协调以提供一致网络拓扑的主机。Envoy mesh 是指一组 Envoy 代理，它们构成了由多种不同服务和应用程序平台组成的分布式系统的消息传递基础。\n\n**运行时配置**：与 Envoy 一起部署的带外实时配置系统。可以在无需重启 Envoy 或 更改 Envoy 主配置的情况下，通过更改设置来影响操作。\n\n**Listener**: 侦听器（listener）是可以由下游客户端连接的命名网络位置（例如，端口、unix 域套接字等）。Envoy 公开一个或多个下游主机连接的侦听器。一般是每台主机运行一个 Envoy，使用单进程运行，但是每个进程中可以启动任意数量的 Listener（监听器），目前只监听 TCP，每个监听器都独立配置一定数量的（L3\/L4）网络过滤器。Listenter 也可以通过 Listener Discovery Service（**LDS**）动态获取。\n\n**Listener filter**：Listener 使用 listener filter（监听器过滤器）来操作链接的元数据。它的作用是在不更改 Envoy 的核心功能的情况下添加更多的集成功能。Listener filter 的 API 相对简单，因为这些过滤器最终是在新接受的套接字上运行。在链中可以互相衔接以支持更复杂的场景，例如调用速率限制。Envoy 已经包含了多个监听器过滤器。\n\n**Http Route Table**：HTTP 的路由规则，例如请求的域名，Path 符合什么规则，转发给哪个 Cluster。\n\n**Health checking**：健康检查会与 SDS 服务发现配合使用。但是，即使使用其他服务发现方式，也有相应需要进行主动健康检查的情况。详见 health checking。\n\n## xDS\n\nxDS 是一个关键概念，它是一类发现服务的统称，其包括如下几类：\n\n- CDS: Cluster Discovery Service\n- EDS: Endpoint Discovery Service\n- SDS: Secret Discovery Service\n- RDS: Route Discovery Service\n- LDS: Listener Discovery Service\n\n正是通过对 xDS 的请求来动态更新 Envoy 配置，另外还有个 ADS（Aggregated Discovery Service）通过聚合的方式解决以上 xDS 的更新顺序问题。\n\n## Envoy Mesh\n\nEnvoy Mesh 指的是由 envoy 做负载均衡和代理的 mesh。该 Mesh 中会包含两类 envoy：\n\n- Edge envoy：即流量进出 mesh 时候的 envoy，相当于 kubernetes 中的 ingress。\n- Service envoy：服务 envoy 是跟每个 Service 实例一起运行的，应用程序无感知的进程外工具，在 kubernetes 中会与应用容器以 sidecar 形式运行在同一个 pod 中。\n\nEnvoy 即可以单独作为 edge envoy，也可以仅做 service envoy 使用，也可以两者同时使用。Mesh 中的所有 envoy 会共享路由信息。\n\n## Envoy 配置\n\nEnvoy 中的配置包括两大类：listenner 配置和 cluster 配置。\n\n### Listener 配置\n\n我们知道 Envoy 中可以配置一组 listener 以实现复杂的处理逻辑。Listener 中设置监听的 TCP 端口，还有一组 filter 对这些端口上的数据流进行处理。\n\n\u0060\u0060\u0060yaml\n  listeners:\n  - address:\n      socket_address:\n        address: 0.0.0.0\n        port_value: 80\n    filter_chains:\n    - filters:\n      - name: envoy.http_connection_manager\n        config:\n          codec_type: auto\n          stat_prefix: ingress_http\n          route_config:\n            name: local_route\n            virtual_hosts:\n            - name: backend\n              domains:\n              - \u0022*\u0022\n              routes:\n              - match:\n                  prefix: \u0022\/service\/1\u0022\n                route:\n                  cluster: service1\n              - match:\n                  prefix: \u0022\/service\/2\u0022\n                route:\n                  cluster: service2\n\u0060\u0060\u0060\n\n这是一个 \u0060http_connection_manager\u0060 例子，其中必须包含 \u0060virtual_hosts\u0060 配置，而 \u0060virtual_hosts\u0060 配置中必须包含以下几项配置：\n\n- \u0060name\u0060：服务名称\n- \u0060domains\u0060：DNS 域名，必须能跟 \u0060virtual_host\u0060 的 URL 匹配 \n- \u0060routes\u0060：路由列表\n\n每个路由中还可以包含以下配置：\n\n- \u0060prefix\u0060：URL 路径前缀\n- \u0060cluster\u0060：处理该请求的 envoy cluster\n- \u0060timeout_ms\u0060：当出错时的超时时间\n\n如上面的例子中，我们还需要定义 \u0060service1\u0060 cluster 和 \u0060service2\u0060 cluster。\n\n### Cluster 配置\n\nCluster 是一组逻辑相似的主机配置，定义哪些主机属于一个服务，cluster 的配置中包含了服务发现和负载均衡方式配置。依然是参考使用 Envoy 作为前端代理中的配置：\n\n\u0060\u0060\u0060yaml\n clusters:\n  - name: service1\n    connect_timeout: 0.25s\n    type: strict_dns\n    lb_policy: round_robin\n    http2_protocol_options: {}\n    hosts:\n    - socket_address:\n        address: service1\n        port_value: 80\n  - name: service2\n    connect_timeout: 0.25s\n    type: strict_dns\n    lb_policy: round_robin\n    http2_protocol_options: {}\n    hosts:\n    - socket_address:\n        address: service2\n        port_value: 80\n\u0060\u0060\u0060\n\nCluster 的配置中至少包含以下信息：\n\n- \u0060name\u0060：cluster 名称，就是服务名称\n- \u0060type\u0060：该 cluster 怎么知道主机是否启动？即服务发现类型，有以下方式：\n  - \u0060static\u0060：监听 cluster 中的所有主机\n  - \u0060strict_dns\u0060：envoy 会监听 DNS，每个匹配的 A 记录都会认定为有效\n  - \u0060logical_dns\u0060：envoy 将使用 DNS 来增加主机，如果 DNS 不再返回该主机也不会删除这些主机信息\n  - \u0060sds\u0060：即 Service Discovery Service，envoy 访问外部的 REST 获取 cluster 成员信息\n- \u0060lb_type\u0060：cluster 的负载均衡类型，有以下方式：\n  - \u0060round_robin\u0060：轮询主机\n  - \u0060weighted_least_request\u0060：最近获得最少请求的主机\n  - \u0060random\u0060：随机\n- \u0060hosts\u0060：能够定义 cluster 中主机的 URL 地址，通常是\u0060tcp:\/\/\u0060 URL\n\n## 参考\n\n- [Part 1: Getting started with Envoy Proxy for microservices resilience - getambassador.io](https:\/\/www.getambassador.io\/resources\/getting-started-envoyproxy-microservices-resilience\/\/)\n', '\/blog\/envoy-archiecture-and-terminology\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文介绍了 Envoy proxy 中的基本概念、配置与架构解析。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/envoy-as-front-proxy/">使用 Envoy 作为前端代理</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2018/04/22</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/envoy"> 
             Envoy
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('使用 Envoy 作为前端代理', '本文是使用 Envoy 作为前端代理的介绍，仅使用 docker 容器和 docker-compose 做编排在单机中运行，帮助我们从更底层了解 Envoy，当我们将 Envoy 作为 Istio Service Mesh 的 data panel 的时候将更加游刃有余。', '\n[Envoy](https:\/\/github.com\/envoyproxy\/envoy) 是一款由 Lyft 开源的，使用 C\u002b\u002b 编写的 L7 代理和通信总线，目前是 [CNCF](https:\/\/cncf.io) 旗下的开源项目，代码托管在 GitHub 上，它也是 [Istio](https:\/\/istio.io) service mesh 中默认的 data plane。本文将给出使用 Envoy 作为 service mesh 的数据平面的示例，应用使用 docker-compose 编排。\n\n## 特性\n\nEnvoy 包括如下特性：\n\n- 进程外架构，不侵入应用进程\n- 使用现代版 C\u002b\u002b11 代码\n- L3\/L4 filter 架构\n- HTTP L7 filter 架构\n- 支持 HTTP\/2\n- HTTP L7 routing\n- 支持 gRPC\n- 支持 MongoDB L7\n- 动态配置\n- 最佳可观测性\n- 支持 front\/edge proxy\n- 高级负载均衡\n- 健康检查\n- 服务发现\n- 支持 DynamoDB L7\n\nEnvoy 本身无法构成一个完整的 Service Mesh，但是它可以作为 service mesh 中的应用间流量的代理，负责 service mesh 中的数据层。\n\n更多信息请参考 [Envoy 官网](https:\/\/www.envoyproxy.io\/)。\n\n## Envoy 作为前端代理\n\n本文是使用 Envoy 作为前端代理的介绍，仅使用 docker 容器和 docker-compose 做编排在单机中运行，帮助我们从更底层了解 Envoy，当我们将 Envoy 作为 Istio Service Mesh 的 data panel 的时候将更加游刃有余。\n\n## 快速开始\n\nEnvoy 中的所有规则配置跟 Kubernetes 一样都是通过 YAML 文件来完成的。在继续下面的步骤之前，首先克隆 Envoy 的 GitHub repo。\n\n\u0060\u0060\u0060bash\ngit clone https:\/\/github.com\/envoyproxy\/envoy.git\n\u0060\u0060\u0060\n\n## 运行 sandbox 测试\n\nEnvoy 官方提供了以下打包用例：\n\n- Front Proxy\n- [Zipkin Tracing](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/start\/sandboxes\/zipkin_tracing)\n- Jaeger Tracing\n- gRPC Bridge\n\n全部可以使用 \u0060docker-compose\u0060 运行，代码可以在 https:\/\/github.com\/envoyproxy\/envoy\/tree\/master\/examples 找到。\n\n## Front proxy\n\nEnvoy 在 envoymesh 的边缘做反向代理，详细使用方式见 \u003chttps:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/start\/sandboxes\/front_proxy\u003e，在此我将解说下以下问题：\n\n- Envoy 是如何作为进程外架构运行的？\n- 为何说 Envoy 是无侵入式架构？\n- Envoy 作为边缘反向代理能做什么？\n\n本示例的架构图如下所示，此时 Envoy 将作为一个反向代理，类似于 Nginx，但与 Nginx 不同的是它还会作为一个进程，伴随每个服务一起运行在同一个容器中（在 Kubernetes 中可以作为 Sidecar 与应用容器一起运行在同一个 Pod 中）。\n\n![Front proxy 部署结构图](envoyproxy-docker-compose.png)\n\n在此示例中一共有 3 个服务，我们需要为其创建容器编排的 \u0060docker-compose.yml\u0060 文件。\n\n\u0060\u0060\u0060yaml\nversion: \u00272\u0027\nservices:\n\n  front-envoy:\n    build:\n      context: .\n      dockerfile: Dockerfile-frontenvoy\n    volumes:\n      - .\/front-envoy.yaml:\/etc\/front-envoy.yaml\n    networks:\n      - envoymesh\n    expose:\n      - \u002280\u0022\n      - \u00228001\u0022\n    ports:\n      - \u00228000:80\u0022\n      - \u00228001:8001\u0022\n\n  service1:\n    build:\n      context: .\n      dockerfile: Dockerfile-service\n    volumes:\n      - .\/service-envoy.yaml:\/etc\/service-envoy.yaml\n    networks:\n      envoymesh:\n        aliases:\n          - service1\n    environment:\n      - SERVICE_NAME=1\n    expose:\n      - \u002280\u0022\n\n  service2:\n    build:\n      context: .\n      dockerfile: Dockerfile-service\n    volumes:\n      - .\/service-envoy.yaml:\/etc\/service-envoy.yaml\n    networks:\n      envoymesh:\n        aliases:\n          - service2\n    environment:\n      - SERVICE_NAME=2\n    expose:\n      - \u002280\u0022\n\nnetworks:\n  envoymesh: {}\n\u0060\u0060\u0060\n\n使用 docker-compose 启动可以保证三个服务都在同一个网络内，即 \u0060frontproxy_envoymesh\u0060 网络中。\n\n其中 \u0060front-envoy\u0060 是前端（边缘）Envoy 服务，用来做反向代理，它使用的是 \u0060Dockerfile-frontenvoy\u0060 文件来构建镜像的，我们来看下该 \u0060Dockerfile\u0060 的内容。\n\n\u0060\u0060\u0060dockerfile\nFROM envoyproxy\/envoy:latest\n\nRUN apt-get update \u0026\u0026 apt-get -q install -y \\\n    curl\nCMD \/usr\/local\/bin\/envoy -c \/etc\/front-envoy.yaml --service-cluster front-proxy\n\u0060\u0060\u0060\n\n其中 \u0060\/etc\/front-envoy.yaml\u0060 是本地的 \u0060front-envoy.yaml\u0060 挂载进去的。我们看下该文件的内容。\n\n\u0060\u0060\u0060yaml\nstatic_resources:\n  listeners:\n  - address:\n      socket_address:\n        address: 0.0.0.0\n        port_value: 80\n    filter_chains:\n    - filters:\n      - name: envoy.http_connection_manager\n        config:\n          codec_type: auto\n          stat_prefix: ingress_http\n          route_config:\n            name: local_route\n            virtual_hosts:\n            - name: backend\n              domains:\n              - \u0022*\u0022\n              routes:\n              - match:\n                  prefix: \u0022\/service\/1\u0022\n                route:\n                  cluster: service1\n              - match:\n                  prefix: \u0022\/service\/2\u0022\n                route:\n                  cluster: service2\n          http_filters:\n          - name: envoy.router\n            config: {}\n  clusters:\n  - name: service1\n    connect_timeout: 0.25s\n    type: strict_dns\n    lb_policy: round_robin\n    http2_protocol_options: {}\n    hosts:\n    - socket_address:\n        address: service1\n        port_value: 80\n  - name: service2\n    connect_timeout: 0.25s\n    type: strict_dns\n    lb_policy: round_robin\n    http2_protocol_options: {}\n    hosts:\n    - socket_address:\n        address: service2\n        port_value: 80\nadmin:\n  access_log_path: \u0022\/dev\/null\u0022\n  address:\n    socket_address:\n      address: 0.0.0.0\n      port_value: 8001\n\u0060\u0060\u0060\n\n我们看到其中包括了三大配置项：\n\n- **static_resources**：路由配置信息\n- **cluster**：envoymesh 的服务注册信息\n- **admin**：管理接口，可以通过访问 8001 端口的，访问 \u0060\/stats\u0060  获取当前 envoymesh 的一些统计信息，访问 \u0060\/server_info\u0060 获取 Envoy 的版本信息\n\n使用 \u0060docker-compose\u0060 启动三个容器。\n\n\u0060\u0060\u0060bash\n$ pwd\nenvoy\/examples\/front-proxy\n$ docker-compose up --build -d\n$ docker-compose ps\n        Name                       Command               State      Ports\n-------------------------------------------------------------------------------------------------------------\nexample_service1_1      \/bin\/sh -c \/usr\/local\/bin\/ ... Up       80\/tcp\nexample_service2_1      \/bin\/sh -c \/usr\/local\/bin\/ ... Up       80\/tcp\nexample_front-envoy_1   \/bin\/sh -c \/usr\/local\/bin\/ ... Up       0.0.0.0:8000-\u003e80\/tcp, 0.0.0.0:8001-\u003e8001\/tcp\n\u0060\u0060\u0060\n\n我们下面将过一遍 Envoy 作为前端代理的所有功能，这些功能是通用功能。\n\n### 路由\n\n访问 service1 \u003chttp:\/\/localhost:8000\/service\/1\u003e 将看到如下输出。\n\n\u0060\u0060\u0060bash\n$ curl -v localhost:8000\/service\/1\n* \nTrying ::1...\n* TCP_NODELAY set\n* Connected to localhost (::1) port 8000 (#0)\n\u003e GET \/service\/1 HTTP\/1.1\n\u003e Host: localhost:8000\n\u003e User-Agent: curl\/7.54.0\n\u003e Accept: *\/*\n\u003e\n\u003c HTTP\/1.1 200 OK\n\u003c content-type: text\/html; charset=utf-8\n\u003c content-length: 89\n\u003c server: envoy\n\u003c date: Fri, 20 Apr 2018 08:26:33 GMT\n\u003c x-envoy-upstream-service-time: 14\n\u003c\nHello from behind Envoy (service 1)! hostname: a3e4185a9a49 resolvedhostname: 172.18.0.4\n* Connection #0 to host localhost left intact\n\u0060\u0060\u0060\n\n访问 service2 \u003chttp:\/\/localhost:8000\/service\/2\u003e 将看到如下输出。\n\n\u0060\u0060\u0060bash\n*   Trying ::1...\n* TCP_NODELAY set\n* Connected to localhost (::1) port 8000 (#0)\n\u003e GET \/service\/2 HTTP\/1.1\n\u003e Host: localhost:8000\n\u003e User-Agent: curl\/7.54.0\n\u003e Accept: *\/*\n\u003e\n\u003c HTTP\/1.1 200 OK\n\u003c content-type: text\/html; charset=utf-8\n\u003c content-length: 89\n\u003c server: envoy\n\u003c date: Fri, 20 Apr 2018 08:27:27 GMT\n\u003c x-envoy-upstream-service-time: 10\n\u003c\nHello from behind Envoy (service 2)! hostname: f6650e1911a0 resolvedhostname: 172.18.0.3\n* Connection #0 to host localhost left intact\n\u0060\u0060\u0060\n\n我们看到访问请求被路由到了正确的服务后端。\n\n### 负载均衡\n\n增加 service1 的示例数。\n\n\u0060\u0060\u0060bash\n$ docker-compose scale service1=3\nWARNING: The scale command is deprecated. Use the up command with the --scale flag instead.\nStarting frontproxy_service1_1 ... done\nCreating frontproxy_service1_2 ... done\nCreating frontproxy_service1_3 ... done\n\n$ docker-compose ps\n          Name                        Command               State                            Ports\n---------------------------------------------------------------------------------------------------------------------------\nfrontproxy_front-envoy_1   \/usr\/bin\/dumb-init -- \/bin ...   Up      10000\/tcp, 0.0.0.0:8000-\u003e80\/tcp, 0.0.0.0:8001-\u003e8001\/tcp\nfrontproxy_service1_1      \/bin\/sh -c \/usr\/local\/bin\/ ...   Up      10000\/tcp, 80\/tcp\nfrontproxy_service1_2      \/bin\/sh -c \/usr\/local\/bin\/ ...   Up      10000\/tcp, 80\/tcp\nfrontproxy_service1_3      \/bin\/sh -c \/usr\/local\/bin\/ ...   Up      10000\/tcp, 80\/tcp\nfrontproxy_service2_1      \/bin\/sh -c \/usr\/local\/bin\/ ...   Up      10000\/tcp, 80\/tcp\n\u0060\u0060\u0060\n\n我们看到现在 service1 已经有了 3 个实例，现在再访问 service1 \u003chttp:\/\/localhost:8000\/service\/1\u003e。\n\n\u0060\u0060\u0060bash\n$ while true;do curl localhost:8000\/service\/1;sleep 1;done\nHello from behind Envoy (service 1)! hostname: a3e4185a9a49 resolvedhostname: 172.18.0.4\nHello from behind Envoy (service 1)! hostname: fe44dba64122 resolvedhostname: 172.18.0.5\nHello from behind Envoy (service 1)! hostname: c5b9f1289e0f resolvedhostname: 172.18.0.6\nHello from behind Envoy (service 1)! hostname: a3e4185a9a49 resolvedhostname: 172.18.0.4\nHello from behind Envoy (service 1)! hostname: fe44dba64122 resolvedhostname: 172.18.0.5\nHello from behind Envoy (service 1)! hostname: c5b9f1289e0f resolvedhostname: 172.18.0.6\n\u0060\u0060\u0060\n\n我们看到对 service1 的已经有负载均衡了，使用的策略是 \u0060round_robin\u0060，这些都是在 \u0060front-envoy.yaml\u0060 文件中的 \u0060cluster\u0060 项下配置的。\n\n### admin 端点\n\n访问 \u003chttp:\/\/localhost:8001\u003e 可以看到 Envoy admin 提供以下管理 API 端点。\n\n| 命令                 | 描述                                     |\n| -------------------- | ---------------------------------------- |\n| \/                    | Admin 主页                               |\n| \/certs               | 打印机器上的 certs                       |\n| \/clusters            | upstream cluster 状态                    |\n| \/config_dump         | 输出当前的 Envoy 配置                    |\n| \/cpuprofiler         | 开启\/关闭 CPU profiler                   |\n| \/healthcheck\/fail    | 导致服务失败健康检查                     |\n| \/healthcheck\/ok      | 导致服务通过健康检查                     |\n| \/help                | 打印管理命令的帮助信息                   |\n| \/hot_restart_version | 打印热重启兼容版本                       |\n| \/listeners           | 打印 listener 地址                       |\n| \/logging             | 查询\/更改日志级别                        |\n| \/quitquitquit        | 退出服务                                 |\n| \/reset_counters      | 将计数器重置为 1                         |\n| \/runtime             | 打印运行时值                             |\n| \/runtime_modify      | 修改运行时值                             |\n| \/server_info         | 打印服务器版本\/状态信息                  |\n| \/stats               | 打印服务器状态统计信息                   |\n| \/stats\/prometheus    | 打印 prometheus 格式的服务器状态统计信息 |\n\nEnvoy 提供了 API 管理端点，可以对 Envoy 进行动态配置，参考 v2 API reference。\n\n## 参考\n\n- Front proxy\n', '\/blog\/envoy-as-front-proxy\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文是使用 Envoy 作为前端代理的介绍，仅使用 docker 容器和 docker-compose 做编排在单机中运行，帮助我们从更底层了解 Envoy，当我们将 Envoy 作为 Istio Service Mesh 的 data panel 的时候将更加游刃有余。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-tutorial/">Istio Service Mesh 教程</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2018/04/18</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio Service Mesh 教程', '本文是 Istio 管理 Java 微服务的案例教程。', '\n本文是 Istio 管理 Java 微服务的案例教程，使用的所有工具和软件全部基于开源方案，替换了 [redhat-developer-demos\/istio-tutorial](https:\/\/github.com\/redhat-developer-demos\/istio-tutorial) 中的 minishift 环境，使用 [kubernetes-vagrant-centos-cluster](https:\/\/github.com\/rootsongjc\/kubernetes-vagrant-centos-cluster) 替代，沿用了原有的微服务示例，使用 Zipkin 做分布式追踪而不是 Jaeger。\n\n本文中的代码和 YAML 文件见 \u003chttps:\/\/github.com\/rootsongjc\/istio-tutorial\u003e。\n\n## 准备环境\n\n在进行本教程前需要先准备以下工具和环境。\n\n- 8G 以上内存\n- Vagrant 2.0\u002b\n- Virtualbox 5.0 \u002b\n- 提前下载 kubernetes1.9.1 的 release 压缩包\n- docker 1.12\u002b\n- kubectl 1.9.1\u002b\n- maven 3.5.2\u002b\n- istioctl 0.7.1\n- git\n- curl、gzip、tar\n- [kubetail](https:\/\/github.com\/johanhaleby\/kubetail)\n- [siege](https:\/\/github.com\/JoeDog\/siege)\n\n## 安装 Kubernetes\n\n请参考 [kubernetes-vagrant-centos-cluster](https:\/\/github.com\/rootsongjc\/kubernetes-vagrant-centos-cluster) 在本地启动拥有三个节点的 kubernetes 集群。\n\n\u0060\u0060\u0060bash\ngit clone https:\/\/github.com\/rootsongjc\/kubernetes-vagrant-centos-cluster.git\ncd kubernetes-vagrant-centos-cluster\nvagrant up\n\u0060\u0060\u0060\n\n## 安装 Istio\n\n在 [kubernetes-vagrant-centos-cluster](https:\/\/github.com\/rootsongjc\/kubernetes-vagrant-centos-cluster) 中的包含 Istio 0.7.1 的安装 YAML 文件，运行下面的命令安装 Istio。\n\n\u0060\u0060\u0060bash\nkubectl apply -f addon\/istio\/\n\u0060\u0060\u0060\n\n**运行示例**\n\n\u0060\u0060\u0060bash\nkubectl apply -n default -f \u003c(istioctl kube-inject -f yaml\/istio-bookinfo\/bookinfo.yaml)\n\u0060\u0060\u0060\n\n在您自己的本地主机的\u0060\/etc\/hosts\u0060文件中增加如下配置项。\n\n\u0060\u0060\u0060ini\n172.17.8.102 grafana.istio.jimmysong.io\n172.17.8.102 servicegraph.istio.jimmysong.io\n172.17.8.102 zipkin.istio.jimmysong.io\n\u0060\u0060\u0060\n\n我们可以通过下面的 URL 地址访问以上的服务。\n\n| Service      | URL                                                          |\n| ------------ | ------------------------------------------------------------ |\n| grafana      | \u0060http:\/\/grafana.istio.jimmysong.io\u0060                          |\n| servicegraph | \u0060http:\/\/servicegraph.istio.jimmysong.io\/dotviz\u0060，\u0060http:\/\/servicegraph.istio.jimmysong.io\/graph\u0060 |\n| zipkin       | \u0060http:\/\/zipkin.istio.jimmysong.io\u0060                           |\n\n详细信息请参阅 [Istio 文档](https:\/\/istio.io\/latest\/docs\/examples\/bookinfo\/)。\n\n## 部署示例应用\n\n在打包成镜像部署到 kubernetes 集群上运行之前，我们先在本地运行所有示例。\n\n本教程中三个服务之间的依赖关系如下：\n\n\u0060\u0060\u0060ini\ncustomer → preference → recommendation\n\u0060\u0060\u0060\n\n\u0060customer\u0060 和 \u0060preference\u0060 微服务是基于 Spring Boot 构建的，\u0060recommendation\u0060 微服务是基于 [vert.x](https:\/\/vertx.io) 构建的。\n\n\u0060customer\u0060 和 \u0060preference\u0060 微服务的 \u0060pom.xml\u0060 文件中都引入了 OpenTracing 和 Jeager 的依赖。\n\n\u0060\u0060\u0060xml\n\u003cdependency\u003e\n\t\u003cgroupId\u003eio.opentracing.contrib\u003c\/groupId\u003e\n\t\u003cartifactId\u003eopentracing-spring-cloud-starter\u003c\/artifactId\u003e\n\t\u003cversion\u003e0.1.7\u003c\/version\u003e\n\u003c\/dependency\u003e\n\u003cdependency\u003e\n\t\u003cgroupId\u003ecom.uber.jaeger\u003c\/groupId\u003e\n\t\u003cartifactId\u003ejaeger-tracerresolver\u003c\/artifactId\u003e\n    \u003cversion\u003e0.25.0\u003c\/version\u003e\n\u003c\/dependency\u003e\n\u0060\u0060\u0060\n\n### 本地运行\n\n我们首先在本地确定所有的微服务都可以正常运行，然后再打包镜像在 kubernetes 集群上运行。\n\n**启动 Jaeger**\n\n使用 docker 来运行 jagger。\n\n\u0060\u0060\u0060bash\ndocker run -d \\\n  --rm \\\n  -p5775:5775\/udp \\\n  -p6831:6831\/udp \\\n  -p6832:6832\/udp \\\n  -p16686:16686 \\\n  -p14268:14268 \\\n  jaegertracing\/all-in-one:1.3\n\u0060\u0060\u0060\n\nJaeger UI 地址 \u0060http:\/\/localhost:16686\u0060\n\n**Customer**\n\n\u0060\u0060\u0060bash\ncd customer\/java\/springboot\nJAEGER_SERVICE_NAME=customer mvn \\\n  spring-boot:run \\\n  -Drun.arguments=\u0022--spring.config.location=src\/main\/resources\/application-local.properties\u0022\n\u0060\u0060\u0060\n\n服务访问地址： \u0060http:\/\/localhost:8280\u0060\n\n**Preference**\n\n\u0060\u0060\u0060bash\ncd preference\/java\/springboot\nJAEGER_SERVICE_NAME=preference mvn \\\n  spring-boot:run \\\n  -Drun.arguments=\u0022--spring.config.location=src\/main\/resources\/application-local.properties\u0022\n\u0060\u0060\u0060\n\n服务访问地址：\u0060http:\/\/localhost:8180\u0060\n\n**Recommendation**\n\n\u0060\u0060\u0060bash\ncd recommendation\/java\/vertx\nmvn vertx:run\n\u0060\u0060\u0060\n\n服务访问地址：\u0060http:\/\/localhost:8080\u0060\n\n所有服务都启动之后，此时访问 \u0060http:\/\/localhost:8280\u0060 将会看到如下输出。\n\n\u0060\u0060\u0060bash\ncustomer =\u003e preference =\u003e recommendation v1 from \u0027unknown\u0027: 1\n\u0060\u0060\u0060\n\n每访问一次最后的数字就会加 1。\n\n**Jaeger**\n\n此时访问 \u0060http:\/\/localhost:16686\u0060 将看到 Jaeger query UI，所有应用将 metrics 发送到 Jeager 中。\n\n可以在 Jaeger UI 中搜索 \u0060customer\u0060 和 \u0060preference\u0060 service 的 trace 并查看每次请求的 tracing。\n\n![Jaeger query UI](jaeger-query-ui.webp)\n\n### 构建镜像\n\n在本地运行测试无误之后就可以构建镜像了。本教程中的容器镜像都是在 [fabric8\/java-jboss-openjdk8-jdk](https:\/\/hub.docker.com\/r\/fabric8\/java-jboss-openjdk8-jdk\/~\/dockerfile\/) 的基础上构建的。只要将 Java 应用构建出 Jar 包然后放到 \u0060\/deployments\u0060 目录下基础镜像就可以自动帮我们运行，所以我们看到着几个应用的 \u0060Dockerfile\u0060 文件中都没有执行入口，真正的执行入口是 [run-java.sh](https:\/\/github.com\/fabric8io-images\/java\/blob\/master\/images\/jboss\/openjdk8\/jdk\/run-java.sh)。\n\n**Customer**\n\n构建 Customer 镜像。\n\n\u0060\u0060\u0060bash\ncd customer\/java\/springboot\nmvn clean package\ndocker build -t jimmysong\/istio-tutorial-customer:v1 .\ndocker push jimmysong\/istio-tutorial-customer:v1\n\u0060\u0060\u0060\n\n第一次构建和上传需要花费一点时间，下一次构建就会很快。\n\n**Preference**\n\n构建 Preference 镜像。\n\n\u0060\u0060\u0060bash\ncd preference\/java\/springboot\nmvn clean package\ndocker build -t jimmysong\/istio-tutorial-preference:v1 .\ndocker push jimmysong\/istio-tutorial-preference:v1\n\u0060\u0060\u0060\n\n**Recommendation**\n\n构建 Recommendation 镜像。\n\n\u0060\u0060\u0060bash\ncd recommendation\/java\/vertx\nmvn clean package\ndocker build -t jimmysong\/istio-tutorial-recommendation:v1 .\ndocker push jimmysong\/istio-tutorial-recommendation:v1\n\u0060\u0060\u0060\n\n现在三个 docker 镜像都构建完成了，我们检查一下。\n\n\u0060\u0060\u0060bash\n$ docker images | grep istio-tutorial\nREPOSITORY                                TAG                 IMAGE ID            CREATED             SIZE\njimmysong\/istio-tutorial-recommendation   v1                  d31dd858c300        51 seconds ago      443MB\njimmysong\/istio-tutorial-preference       v1                  e5f0be361477        6 minutes ago       459MB\njimmysong\/istio-tutorial-customer         v1                  d9601692673e        13 minutes ago      459MB\n\u0060\u0060\u0060\n\n### 部署到 Kubernetes\n\n使用下面的命令将以上服务部署到 kubernetes。\n\n\u0060\u0060\u0060bash\n# create new namespace\nkubectl create ns istio-tutorial\n\n# deploy recommendation\nkubectl apply -f \u003c(istioctl kube-inject -f recommendation\/kubernetes\/Deployment.yml) -n istio-tutorial\nkubectl apply -f recommendation\/kubernetes\/Service.yml\n\n# deploy preferrence\nkubectl apply -f \u003c(istioctl kube-inject -f preference\/kubernetes\/Deployment.yml) -n istio-tutorial\nkubectl apply -f preference\/kubernetes\/Service.yml\n\n# deploy customer\nkubectl apply -f \u003c(istioctl kube-inject -f customer\/kubernetes\/Deployment.yml) -n istio-tutorial\nkubectl apply -f customer\/kubernetes\/Service.yml\n\u0060\u0060\u0060\n\n**注意：**\u0060preference\u0060 和 \u0060customer\u0060 应用启动速度比较慢，我们将 livenessProb 配置中的 \u0060initialDelaySeconds\u0060 设置为 **20** 秒。\n\n查看 Pod 启动状态：\n\n\u0060\u0060\u0060bash\nkubectl get pod -w -n istio-tutorial\n\u0060\u0060\u0060\n\n### 增加 Ingress 配置\n\n为了在 kubernetes 集群外部访问 customer 服务，我们需要增加 ingress 配置。\n\n\u0060\u0060\u0060bash\nkubectl apply -f ingress\/ingress.yaml\n\u0060\u0060\u0060\n\n修改本地的 \u0060\/etc\/hosts\u0060 文件，增加一条配置。\n\n\u0060\u0060\u0060ini\n172.17.8.102 customer.istio-tutorial.jimmysong.io\n\u0060\u0060\u0060\n\n现在访问 \u0060http:\/\/customer.istio-tutorial.jimmysong.io\u0060 将看到如下输出：\n\n\u0060\u0060\u0060ini\ncustomer =\u003e preference =\u003e recommendation v1 from \u00276fc97476f8-m2ntp\u0027: 1\n\u0060\u0060\u0060\n\n批量访问该地址。\n\n\u0060\u0060\u0060bash\n.\/bin\/poll_customer.sh\n\u0060\u0060\u0060\n\n访问 \u0060http:\/\/servicegraph.istio.jimmysong.io\/dotviz\u0060 查看服务的分布式追踪和依赖关系。\n\n![分布式追踪](istio-tutorial-zipkin-trace.webp)\n\n![依赖关系](istio-tutorial-zipkin-dependency.webp)\n\n访问 \u0060http:\/\/servicegraph.istio.jimmysong.io\/dotviz\u0060 查看服务间的关系图和 QPS。\n\n![服务关系图和 QPS](istio-tutorial-Servicegraph-dotviz.webp)\n\n访问 \u0060http:\/\/grafana.istio.jimmysong.io\u0060 查看 Service Mesh 的监控信息。\n\n![Grafana 监控](istio-tutorial-grafana.webp)\n\n## Istio 使用示例\n\n为了试用 Istio 中的各种功能，我们需要为应用构建多个版本，我们为 recommendation 构建 v2 版本的镜像，看看如何使用 Istio 控制微服务的流量。\n\n### 构建 recommendation:v2\n\n我们将构建新版的 \u0060recommendation\u0060 服务的镜像，并观察 \u0060customer\u0060 对不同版本的 \u0060recommendataion\u0060 服务的访问频率。\n\n修改 \u0060recommendation\/java\/vertx\/src\/main\/java\/com\/redhat\/developer\/demos\/recommendation\/RecommendationVerticle.java\u0060 程序中代码。\n\n将 \u0060private static final String RESPONSE_STRING_FORMAT = \u0022recommendation v1 from \u0027%s\u0027: %d\\n\u0022;\u0060 修改为 \u0060private static final String RESPONSE_STRING_FORMAT = \u0022recommendation v2 from \u0027%s\u0027: %d\\n\u0022;\u0060\n\n并构建 \u0060recommendation:v2\u0060 镜像。\n\n\u0060\u0060\u0060bash\ncd recommendation\/java\/vertx\nmvn clean package\ndocker build -t jimmysong\/istio-tutorial-recommendation:v2 .\ndocker push jimmysong\/istio-tutorial-recommendation:v2\n\u0060\u0060\u0060\n\n将应用部署到 kubernetes。\n\n\u0060\u0060\u0060bash\n# deploy recommendation\nkubectl apply -f \u003c(istioctl kube-inject -f recommendation\/kubernetes\/Deployment-v2.yml) -n istio-tutorial\n\u0060\u0060\u0060\n\n现在再访问 \u0060customer\u0060 服务，将看到如下输出：\n\n\u0060\u0060\u0060bash\n$ bin\/poll_customer.sh\ncustomer =\u003e preference =\u003e recommendation v2 from \u002777b9f6cc68-5xs27\u0027: 1\ncustomer =\u003e preference =\u003e recommendation v1 from \u00276fc97476f8-m2ntp\u0027: 3581\ncustomer =\u003e preference =\u003e recommendation v2 from \u002777b9f6cc68-5xs27\u0027: 2\ncustomer =\u003e preference =\u003e recommendation v1 from \u00276fc97476f8-m2ntp\u0027: 3582\ncustomer =\u003e preference =\u003e recommendation v2 from \u002777b9f6cc68-5xs27\u0027: 3\ncustomer =\u003e preference =\u003e recommendation v1 from \u00276fc97476f8-m2ntp\u0027: 3583\ncustomer =\u003e preference =\u003e recommendation v2 from \u002777b9f6cc68-5xs27\u0027: 4\n\u0060\u0060\u0060\n\n我们可以看到 v1 和 v2 版本的 \u0060recommendation\u0060 服务会被间隔访问到。\n\n我们再将 v2 版本的 \u0060recommendation\u0060 实例数设置成 2 个。\n\n\u0060\u0060\u0060bash\nkubectl scale --replicas=2 deployment\/recommendation-v2 -n istio-tutorial\nkubectl get pod -w -n istio-tutorial\n\u0060\u0060\u0060\n\n观察 \u0060recommendation-v2\u0060 Pod 达到两个之后再访问 \u0060customer\u0060 服务。\n\n\u0060\u0060\u0060bash\n$ bin\/poll_customer.sh\ncustomer =\u003e preference =\u003e recommendation v2 from \u002777b9f6cc68-j9fgj\u0027: 1\ncustomer =\u003e preference =\u003e recommendation v2 from \u002777b9f6cc68-5xs27\u0027: 71\ncustomer =\u003e preference =\u003e recommendation v1 from \u00276fc97476f8-m2ntp\u0027: 3651\ncustomer =\u003e preference =\u003e recommendation v2 from \u002777b9f6cc68-j9fgj\u0027: 2\ncustomer =\u003e preference =\u003e recommendation v2 from \u002777b9f6cc68-5xs27\u0027: 72\ncustomer =\u003e preference =\u003e recommendation v1 from \u00276fc97476f8-m2ntp\u0027: 3652\ncustomer =\u003e preference =\u003e recommendation v2 from \u002777b9f6cc68-j9fgj\u0027: 3\ncustomer =\u003e preference =\u003e recommendation v2 from \u002777b9f6cc68-5xs27\u0027: 73\ncustomer =\u003e preference =\u003e recommendation v1 from \u00276fc97476f8-m2ntp\u0027: 3653\n\u0060\u0060\u0060\n\n观察输出中 v1 和 v2 版本 \u0060recommendation\u0060 的访问频率。\n\n将 \u0060recommendataion\u0060 服务的实例数恢复为 1。\n\n\u0060\u0060\u0060bash\nkubectl scale --replicas=1 deployment\/recommendation-v2\n\u0060\u0060\u0060\n\n### 修改 Istio RouteRules\n\n以下所有路有规则都是针对 \u0060recommendation\u0060 服务，并在 repo 的根目录下执行。\n\n**将所有流量打给 v2**\n\n下面将演示如何动态的划分不同版本服务间的流量，将所有的流量都打到 \u0060recommendation:v2\u0060。\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/route-rule-recommendation-v2.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n现在再访问 \u0060customer\u0060 服务将看到所有的流量都会打到 \u0060recommendation:v2\u0060。\n\n删除 RouteRules 后再访问 \u0060customer\u0060 服务将看到又恢复了 v1 和 v2 版本的 \u0060recommendation\u0060 服务的间隔访问。\n\n\u0060\u0060\u0060bash\nistioctl delete routerule recommendation-default\n\u0060\u0060\u0060\n\n**切分流量**\n\n将 90% 的流量给 v1，10% 的流量给 v2。\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/route-rule-recommendation-v1_and_v2.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n执行\u0060bin\/poll_customer.sh\u0060 观察访问情况。\n\n要想动态切分流量只要修改 RouteRules 中的 \u0060weight\u0060 配置即可。\n\n\u0060\u0060\u0060yaml\napiVersion: config.istio.io\/v1alpha2\nkind: RouteRule\nmetadata:\n  name: recommendation-v1-v2\nspec:\n  destination:\n    namespace: istio-tutorial\n    name: recommendation\n  precedence: 5\n  route:\n  - labels:\n      version: v1\n    weight: 90\n  - labels:\n      version: v2\n    weight: 10\n\u0060\u0060\u0060\n\n因为 RouteRule 有优先级，为了继续后面的实验，在验证完成后删除该 RouteRule。\n\n\u0060\u0060\u0060bash\nistioctl delete routerule recommendation-v1-v2 -n istio-tutorial\n\u0060\u0060\u0060\n\n### 故障注入\n\n有时候我们为了增强系统的健壮性，需要对系统做混沌工程，故意注入故障，并保障服务可以自动处理这些故障。\n\n**注入 HTTP 503 错误**\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/route-rule-recommendation-503.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n有 50% 的几率报 503 错误。\n\n\u0060\u0060\u0060bash\n$ bin\/poll_customer.sh\ncustomer =\u003e preference =\u003e recommendation v2 from \u002777b9f6cc68-5xs27\u0027: 135\ncustomer =\u003e 503 preference =\u003e 503 fault filter abort\ncustomer =\u003e preference =\u003e recommendation v1 from \u00276fc97476f8-m2ntp\u0027: 3860\ncustomer =\u003e 503 preference =\u003e 503 fault filter abort\ncustomer =\u003e 503 preference =\u003e 503 fault filter abort\ncustomer =\u003e preference =\u003e recommendation v2 from \u002777b9f6cc68-5xs27\u0027: 136\ncustomer =\u003e preference =\u003e recommendation v1 from \u00276fc97476f8-m2ntp\u0027: 3861\ncustomer =\u003e 503 preference =\u003e 503 fault filter abort\ncustomer =\u003e 503 preference =\u003e 503 fault filter abort\ncustomer =\u003e preference =\u003e recommendation v2 from \u002777b9f6cc68-5xs27\u0027: 137\ncustomer =\u003e 503 preference =\u003e 503 fault filter abort\n\u0060\u0060\u0060\n\n清理 RouteRule。\n\n\u0060\u0060\u0060bash\nistioctl delete routerule recommendation-503 -n istio-tutorial\n\u0060\u0060\u0060\n\n### 增加延迟\n\n增加服务的访问延迟。\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/route-rule-recommendation-delay.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n会有 50% 的几率访问 \u0060recommendation\u0060 服务有 7 秒的延迟。百分比和延迟时间可以在 RouteRule 中配置。\n\n清理 RouteRule。\n\n\u0060\u0060\u0060bash\nistioctl delete routerule recommendation-delay -n istio-tutorial\n\u0060\u0060\u0060\n\n### 重试\n\n让服务不是直接失败，而是增加重试机制。\n\n我们下面将同时应用两条 RouteRule，让访问 \u0060recommendation\u0060 服务时有 50% 的几率出现 503 错误，并在出现错误的时候尝试访问 v2 版本，超时时间为 2 秒。\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/route-rule-recommendation-v2_503.yml -n istio-tutorial\nistioctl create -f istiofiles\/route-rule-recommendation-v2_retry.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n执行 \u0060bin\/poll_customer.sh\u0060 我们看到一开始有些 503 错误，然后所有的流量都流向了 v2。\n\n清理 RouteRules。\n\n\u0060\u0060\u0060bash\nistioctl delete routerule recommendation-v2-retry -n istio-tutorial\nistioctl delete routerule recommendation-v2-503 -n istio-tutorial\n\u0060\u0060\u0060\n\n### 超时\n\n设置超时时间，只有服务访问超时才认定服务访问失败。\n\n取消注释 \u0060recommendation\/java\/vertx\/src\/main\/java\/com\/redhat\/developer\/demos\/recommendation\/RecommendationVerticle.java\u0060 中的下面一行，增加超时时间为 3 秒。\n\n\u0060\u0060\u0060java\nrouter.get(\u0022\/\u0022).handler(this::timeout);\n\u0060\u0060\u0060\n\n重新生成镜像。\n\n\u0060\u0060\u0060bash\ncd recommendation\/java\/vertx\nmvn clean package\ndocker build -t jimmysong\/istio-tutorial-recommendation:v2 .\ndocker push jimmysong\/istio-tutorial-recommendation:v2\n\u0060\u0060\u0060\n\n重新部署到 kubernetes。\n\n\u0060\u0060\u0060bash\nkubectl delete -f recommendation\/kubernetes\/Deployment-v2.yml\n\u0060\u0060\u0060\n\n因为我们重新构建的镜像使用了同样的名字和 tag，而之前在 \u0060Deployment-v2.yml\u0060 中配置的镜像拉取策略是 \u0060IfNotPresent\u0060，这样的话即使我们构建了新的镜像也无法应用到集群上，因此将镜像拉取策略改成 \u0060Always\u0060 确保每次启动 Pod 的时候都会拉取镜像。\n\n\u0060\u0060\u0060bash\nkubectl apply -f \u003c(istioctl kube-inject -f recommendation\/kubernetes\/Deployment-v2.yml) -n istio-tutorial\n\u0060\u0060\u0060\n\n启用超时 RouteRules。\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/route-rule-recommendation-timeout.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n访问 \u0060customer\u0060 服务将看到如下输出：\n\n\u0060\u0060\u0060bash\n$ bin\/poll_customer.sh\ncustomer =\u003e 503 preference =\u003e 504 upstream request timeout\ncustomer =\u003e preference =\u003e recommendation v1 from \u00276fc97476f8-m2ntp\u0027: 4002\ncustomer =\u003e 503 preference =\u003e 504 upstream request timeout\ncustomer =\u003e preference =\u003e recommendation v1 from \u00276fc97476f8-m2ntp\u0027: 4003\ncustomer =\u003e 503 preference =\u003e 504 upstream request timeout\ncustomer =\u003e preference =\u003e recommendation v1 from \u00276fc97476f8-m2ntp\u0027: 4004\n\u0060\u0060\u0060\n\n清理 RouteRules。\n\n\u0060\u0060\u0060bash\nistioctl delete routerule recommendation-timeout -n istio-tutorial\n\u0060\u0060\u0060\n\n### 基于 user-agent 的智能路由（金丝雀发布）\n\nUser-agent 是一个字符串，其中包含了浏览器的信息，访问 https:\/\/www.whoishostingthis.com\/tools\/user-agent 获取你的 user-agent。\n\n我的 user-agent 是：\n\n\u0060\u0060\u0060ini\nMozilla\/5.0 (Macintosh; Intel Mac OS X 10_13_4) AppleWebKit\/537.36 (KHTML, like Gecko) Chrome\/65.0.3325.181 Safari\/537.36\n\u0060\u0060\u0060\n\n将所有的流量打到 v1。\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/route-rule-recommendation-v1.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n将使用 Safari 浏览器访问的流量打到 v2。\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/route-rule-safari-recommendation-v2.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n谁用 Safari 或者 Chrome（Chrome 浏览器的 user-agent 中也包含 Safari 字段）访问 \u0060http:\/\/customer.istio-tutorial.jimmysong.io\/\u0060 在经过 3 秒钟（我们在前面重新编译 v2 镜像，设置了 3 秒超时时间）后将看到访问 v2 的输出。\n\n或者使用 curl 访问。\n\n\u0060\u0060\u0060bash\ncurl -A Safari http:\/\/customer.istio-tutorial.jimmysong.io\/\ncurl -A Firefox http:\/\/customer.istio-tutorial.jimmysong.io\/\n\u0060\u0060\u0060\n\n观察返回的结果。\n\n将移动端用户的流量导到 v2。\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/route-rule-mobile-recommendation-v2.yml -n istio-tutorial\n\ncurl -A \u0022Mozilla\/5.0 (iPhone; U; CPU iPhone OS 4(KHTML, like Gecko) Version\/5.0.2 Mobile\/8J2 Safari\/6533.18.5\u0022 http:\/\/customer.istio-tutorial.jimmysong.io\/\n\u0060\u0060\u0060\n\n观察输出的结果。\n\n清理 RouteRules。\n\n\u0060\u0060\u0060bash\nistioctl delete routerule recommendation-mobile -n istio-tutorial\nistioctl delete routerule recommendation-safari -n istio-tutorial\nistioctl delete routerule recommendation-default -n istio-tutorial\n\u0060\u0060\u0060\n\n### 镜像流量\n\n确保当前至少运行了两个版本的 \u0060recommendation\u0060 服务，并且没有 RouteRule。\n\n注：可以使用 \u0060istioctl get routerule\u0060 获取 RouteRule。\n\n设置流量镜像，将所有 v1 的流量都被镜像到 v2。\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/route-rule-recommendation-v1-mirror-v2.yml -n istio-tutorial\nbin\/poll_customer.sh\n\u0060\u0060\u0060\n\n查看 recommendation-v2 的日志。\n\n\u0060\u0060\u0060bash\nkubectl logs -f \u0060oc get pods|grep recommendation-v2|awk \u0027{ print $1 }\u0027\u0060 -c recommendation\n\u0060\u0060\u0060\n\n### 访问控制\n\nIstio 可以设置服务访问的黑白名单，如果没有权限的话会返回 HTTP 404 Not Found。\n\n#### 白名单\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/acl-whitelist.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n此时访问 \u0060customer\u0060 服务。\n\n\u0060\u0060\u0060bash\n$ bin\/poll_customer.sh\ncustomer =\u003e 404 NOT_FOUND:preferencewhitelist.listchecker.istio-tutorial:customer is not whitelisted\n\u0060\u0060\u0060\n\n重置环境。\n\n\u0060\u0060\u0060bash\nistioctl delete -f istiofiles\/acl-whitelist.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n#### 黑名单\n\n设置黑名单，所有位于黑名单中的流量将获得 403 Forbidden 返回码。\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/acl-blacklist.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n此时访问 \u0060customer\u0060 服务。\n\n\u0060\u0060\u0060bash\n$ bin\/poll_customer.sh\ncustomer =\u003e 403 PERMISSION_DENIED:denycustomerhandler.denier.istio-tutorial:Not allowed\n\u0060\u0060\u0060\n\n重置环境。\n\n\u0060\u0060\u0060bash\nistioctl delete -f istiofiles\/acl-blacklist.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n### 负载均衡\n\nKubernetes 中默认的负载均衡策略是 round-robin，当然我们可以使用 Istio 把它修改成 random。\n\n增加 v1 的实例数。\n\n\u0060\u0060\u0060bash\nkubectl scale deployment recommendation-v1 --replicas=2 -n istio-tutorial\n\u0060\u0060\u0060\n\n持续访问 \u0060customer\u0060 服务。\n\n\u0060\u0060\u0060bash\nbin\/poll_customer.sh\n\u0060\u0060\u0060\n\n保持前台输出，观察流量的行为。\n\n应用负载均衡策略。\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/recommendation_lb_policy_app.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n观察一段时间流量的行为后，重置环境。\n\n\u0060\u0060\u0060bash\nistioctl delete -f istiofiles\/recommendation_lb_policy_app.yml -n istio-tutorial\nkubectl scale deployment recommendation-v1 --replicas=1 -n istio-tutorial\n\u0060\u0060\u0060\n\n### 速率限制\n\n暂时不可用\n\n### 断路器\n\n当达到最大连接数和最大挂起请求数时快速失败。\n\n将流量在 v1 和 v2 之间均分。\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/route-rule-recommendation-v1_and_v2_50_50.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n未开启断路器的时候启动负载测试。\n\n\u0060\u0060\u0060bash\n$ siege -r 2 -c 20 -v customer.istio-tutorial.jimmysong.io\nNew configuration template added to \/Users\/jimmysong\/.siege\nRun siege -C to view the current settings in that file\n** SIEGE 4.0.4\n** Preparing 20 concurrent users for battle.\nThe server is now under siege...\nHTTP\/1.1 200     0.10 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.12 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.13 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.13 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.13 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.17 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     3.12 secs:      74 bytes ==\u003e GET  \/\nHTTP\/1.1 200     3.14 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     3.15 secs:      74 bytes ==\u003e GET  \/\nHTTP\/1.1 200     3.15 secs:      74 bytes ==\u003e GET  \/\nHTTP\/1.1 200     3.17 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     3.17 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     3.20 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     3.20 secs:      74 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.05 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.12 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     3.15 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     3.25 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     3.26 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     3.14 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     3.58 secs:      74 bytes ==\u003e GET  \/\nHTTP\/1.1 200     6.15 secs:      74 bytes ==\u003e GET  \/\nHTTP\/1.1 200     6.16 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     3.03 secs:      74 bytes ==\u003e GET  \/\nHTTP\/1.1 200     6.06 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     6.04 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     3.11 secs:      74 bytes ==\u003e GET  \/\nHTTP\/1.1 200     3.09 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     6.15 secs:      74 bytes ==\u003e GET  \/\nHTTP\/1.1 200     6.71 secs:      74 bytes ==\u003e GET  \/\nHTTP\/1.1 200     3.52 secs:      75 bytes ==\u003e GET  \/\n^C\nLifting the server siege...\nTransactions:\t\t          31 hits\nAvailability:\t\t      100.00 %\nElapsed time:\t\t        7.99 secs\nData transferred:\t        0.00 MB\nResponse time:\t\t        2.99 secs\nTransaction rate:\t        3.88 trans\/sec\nThroughput:\t\t        0.00 MB\/sec\nConcurrency:\t\t       11.60\nSuccessful transactions:          31\nFailed transactions:\t           0\nLongest transaction:\t        6.71\nShortest transaction:\t        0.05\n\u0060\u0060\u0060\n\n所有的请求都成功了，但是性能很差，因为 v2 版本设置了 3 秒的超时时间。\n\n我们启用下断路器。\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/recommendation_cb_policy_version_v2.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n重新测试一下。\n\n\u0060\u0060\u0060bash\n$ siege -r 2 -c 20 -v customer.istio-tutorial.jimmysong.io\n** SIEGE 4.0.4\n** Preparing 20 concurrent users for battle.\nThe server is now under siege...\nHTTP\/1.1 200     0.07 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.07 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.07 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.12 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.12 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.16 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.16 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.21 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.21 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.24 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.24 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.14 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.29 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.13 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.18 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.13 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.11 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.39 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.24 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.44 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.43 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.44 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.40 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.47 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.42 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.42 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.06 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.07 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.15 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.12 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.57 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.18 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.52 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.65 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.42 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.09 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.43 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.04 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 200     4.15 secs:      74 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.01 secs:      75 bytes ==\u003e GET  \/\n\nTransactions:\t\t          19 hits\nAvailability:\t\t       47.50 %\nElapsed time:\t\t        4.16 secs\nData transferred:\t        0.00 MB\nResponse time:\t\t        0.72 secs\nTransaction rate:\t        4.57 trans\/sec\nThroughput:\t\t        0.00 MB\/sec\nConcurrency:\t\t        3.31\nSuccessful transactions:          19\nFailed transactions:\t          21\nLongest transaction:\t        4.15\nShortest transaction:\t        0.01\n\u0060\u0060\u0060\n\n我们可以看到在启用了断路器后各项性能都有提高。\n\n清理配置。\n\n\u0060\u0060\u0060bash\nistioctl delete routerule recommendation-v1-v2 -n istio-tutorial\nistioctl delete -f istiofiles\/recommendation_cb_policy_version_v2.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n### Pool Ejection\n\n所谓的 Pool Ejection 就是当某些实例出现错误（如返回 5xx 错误码）临时将该实例弹出一段时间后（窗口期，可配置），然后再将其加入到负载均衡池中。我们的例子中配置的窗口期是 15 秒。\n\n将 v1 和 v2 的流量均分。\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/route-rule-recommendation-v1_and_v2_50_50.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n增加 v2 的实例个数。\n\n\u0060\u0060\u0060bash\nkubectl scale deployment recommendation-v2 --replicas=2 -n istio-tutorial\nkubectl get pods -w\n\u0060\u0060\u0060\n\n等待所有的 Pod 的状态都启动完成。\n\n现在到 v2 的容器中操作。\n\n\u0060\u0060\u0060bash\n$ kubectl exec recommendation-v2-785465d9cd-225ms -c recommendation \/bin\/bash\n$ curl localhost:8080\/misbehave\nFollowing requests to \u0027\/\u0027 will return a 503\n\u0060\u0060\u0060\n\n增加 Pool Ejection 配置。\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/recommendation_cb_policy_pool_ejection.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n此时再访问 \u0060customer\u0060 服务。\n\n\u0060\u0060\u0060bash\n$ bin\/poll_customer.sh\ncustomer =\u003e preference =\u003e recommendation v1 from \u00276fc97476f8-m2ntp\u0027: 10505\ncustomer =\u003e preference =\u003e recommendation v2 from \u0027785465d9cd-225ms\u0027: 2407\ncustomer =\u003e preference =\u003e recommendation v1 from \u00276fc97476f8-m2ntp\u0027: 10506\ncustomer =\u003e preference =\u003e recommendation v2 from \u0027785465d9cd-225ms\u0027: 2408\ncustomer =\u003e preference =\u003e recommendation v1 from \u00276fc97476f8-m2ntp\u0027: 10507\ncustomer =\u003e preference =\u003e recommendation v1 from \u00276fc97476f8-m2ntp\u0027: 10508\ncustomer =\u003e preference =\u003e recommendation v1 from \u00276fc97476f8-m2ntp\u0027: 10509\ncustomer =\u003e 503 preference =\u003e 503 recommendation misbehavior from \u0027785465d9cd-ldc6j\u0027\ncustomer =\u003e preference =\u003e recommendation v2 from \u0027785465d9cd-225ms\u0027: 2409\ncustomer =\u003e preference =\u003e recommendation v2 from \u0027785465d9cd-225ms\u0027: 2410\n\u0060\u0060\u0060\n\n我们看到窗口期生效了，当出现 503 错误后至少 15 秒后才会出现第二次。\n\n即使有了负载均衡池弹出策略对于系统的弹性来说依然还不够，如果你的服务有多个可用实例，可以将**断路器**、**重试**、**Pool Ejection** 等策略组合起来使用。\n\n例如在以上的 Pool Ejection 的基础上增加重试策略。\n\n\u0060\u0060\u0060bash\nistioctl replace -f istiofiles\/route-rule-recommendation-v1_and_v2_retry.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n现在再访问 \u0060customer\u0060 服务就看不到 503 错误了。\n\n清理配置。\n\n\u0060\u0060\u0060bash\nkubectl scale deployment recommendation-v2 --replicas=1 -n istio-tutorial\nistioctl delete routerule recommendation-v1-v2 -n istio-tutorial\nistioctl delete -f istiofiles\/recommendation_cb_policy_pool_ejection.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n### Egress\n\nEgress 是用来配置 Istio Service mesh 中的服务对外部服务的访问策略。\n\n具体配置请参考 [控制 Egress 流量](http:\/\/istio.doczh.cn\/docs\/tasks\/traffic-management\/egress.html)。\n\n以下示例还有问题，无法正常工作。\n\n构建示例镜像 egresshttpbin。\n\n\u0060\u0060\u0060bash\ncd egress\/egresshttpbin\/\nmvn clean package\ndocker build -t jimmysong\/istio-tutorial-egresshttpbin:v1 .\ndocker push jimmysong\/istio-tutorial-egresshttpbin:v1\n\u0060\u0060\u0060\n\n部署到 Kubernetes。\n\n\u0060\u0060\u0060bash\nkubectl apply -f \u003c(istioctl kube-inject -f egress\/egresshttpbin\/src\/main\/kubernetes\/Deployment.yml) -n istio-toturial\nkubectl create -f egress\/egresshttpbin\/src\/main\/kubernetes\/Service.yml\n\u0060\u0060\u0060\n\n为了在 kubernetes 集群外部访问到该服务，修改增加 ingress 配置并修改本地的\u0060\/etc\/hosts\u0060 文件，我们在前面已经完成了，此处不再赘述。\n\n构建示例镜像 egressgithub。\n\n\u0060\u0060\u0060bash\ncd egress\/egressgithub\nmvn clean package\ndocker build -t jimmysong\/istio-tutorial-egressgithub:v1 .\ndocker push jimmysong\/istio-tutorial-egressgithub:v1\n\u0060\u0060\u0060\n\n部署到 Kubernetes。\n\n\u0060\u0060\u0060bash\nkubectl apply -f \u003c(istioctl kube-inject -f egress\/egressgithub\/src\/main\/kubernetes\/Deployment.yml) -n istio-tutorial\nkubectl create -f egress\/egressgithub\/src\/main\/kubernetes\/Service.yml\n\u0060\u0060\u0060\n\n增加 Egress 配置。\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/egress_httpbin.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n到 egresshttpbin 容器中测试。\n\n\u0060\u0060\u0060bash\nkubectl exec -it $(oc get pods -o jsonpath=\u0022{.items[*].metadata.name}\u0022 -l app=egresshttpbin,version=v1) -c egresshttpbin \/bin\/bash\n\ncurl localhost:8080\n\ncurl httpbin.org\/user-agent\n\ncurl httpbin.org\/headers\n\nexit\n\u0060\u0060\u0060\n\n增加对 [jimmysong.io](https:\/\/jimmysong.io) 的 egress 配置。\n\n\u0060\u0060\u0060bash\ncat \u003c\u003cEOF | istioctl create -f -\napiVersion: config.istio.io\/v1alpha2\nkind: EgressRule\nmetadata:\n  name: jimmysong-egress-rule\n  namespace: istio-tutorial\nspec:\n  destination:\n    service: jimmysong.io\n  ports:\n    - port: 443\n      protocol: https\nEOF\n\u0060\u0060\u0060\n\n增加 Egress 配置。\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/egress_github.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n到 egressgithub 容器中测试。\n\n\u0060\u0060\u0060bash\nkubectl exec -it $(oc get pods -o jsonpath=\u0022{.items[*].metadata.name}\u0022 -l app=egressgithub,version=v1) -c egressgithub \/bin\/bash\n\ncurl http:\/\/jimmysong:443\n\nexit\n\u0060\u0060\u0060\n\n清理环境。\n\n\u0060\u0060\u0060bash\nistioctl delete egressrule httpbin-egress-rule jimmysong-egress-rule github-egress-rule -n istio-tutorial\n\u0060\u0060\u0060\n\n## 参考\n\n- https:\/\/github.com\/redhat-developer-demos\/istio-tutorial\n- [Book - Introducing Istio Service Mesh for Microservices](https:\/\/developers.redhat.com\/books\/introducing-istio-service-mesh-microservices\/)\n', '\/blog\/istio-tutorial\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文是 Istio 管理 Java 微服务的案例教程。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-community-tips/">Istio 社区介绍与社区参与注意事项</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2018/04/14</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio 社区介绍与社区参与注意事项', '本文讲述了参与 Istio 社区和进行 Istio 开发时需要注意的事项。', '\n本文讲述了参与 Istio 社区和进行 Istio 开发时需要注意的事项。\n\n### 工作组\n\n绝大多数复杂的开源项目都是以工作组的方式组织的，要想为 Istio 社区做贡献可以加入到以下的工作组（Working Group）：\n\n- [API Management](https:\/\/github.com\/istio\/community\/blob\/master\/WORKING-GROUPS.md#api-management)\n- [Config](https:\/\/github.com\/istio\/community\/blob\/master\/WORKING-GROUPS.md#config)\n- [Environments](https:\/\/github.com\/istio\/community\/blob\/master\/WORKING-GROUPS.md#environments)\n- [Networking](https:\/\/github.com\/istio\/community\/blob\/master\/WORKING-GROUPS.md#networking)\n- [Performance \u0026 Scalability](https:\/\/github.com\/istio\/community\/blob\/master\/WORKING-GROUPS.md#performance-and-scalability)\n- [Policies \u0026 Telemetry](https:\/\/github.com\/istio\/community\/blob\/master\/WORKING-GROUPS.md#policies-and-telemetry)\n- [Security](https:\/\/github.com\/istio\/community\/blob\/master\/WORKING-GROUPS.md#security)\n- [Test \u0026 Release](https:\/\/github.com\/istio\/community\/blob\/master\/WORKING-GROUPS.md#test-and-release)\n\n### 代码规范\n\nIstio 的代码规范沿用 [CNCF 社区的代码规范](https:\/\/github.com\/cncf\/foundation\/blob\/master\/code-of-conduct.md)。\n\n### 开发指南\n\n进行 Istio 开发之前需要做下面几件事情：\n\n- 配置基础环境，如 Kubernetes\n- 配置代码库、下载依赖和测试\n- 配置 CircleCI 集成环境\n- 编写参考文档\n- Git workflow 配置\n\n详见 [Dev Guide wiki](https:\/\/github.com\/istio\/istio\/wiki\/Dev-Guide)。\n\n### 设计文档\n\n所有的设计文档都保存在 [Google Drive](https:\/\/drive.google.com\/drive\/u\/0\/folders\/0AIS5p3eW9BCtUk9PVA) 中，其中包括以下资源：\n\n- Technical Oversight Committee：ToC 管理的文档\n- Misc：一些杂项\n- Working Groups：最重要的部分，各个工作组相关的设计文档\n- Presentations：Istio 相关的演讲幻灯片，从这些文稿中可以快速了解 Istio\n- Logo：Istio logo\n- Eng：社区相关的维护文档\n\n### 社区角色划分\n\n根据对开发者和要求和贡献程度的不同，Istio 社区中包含以下角色：\n\n- [Collaborator](https:\/\/github.com\/istio\/community\/blob\/master\/ROLES.md#collaborator)：非正式贡献者，偶尔贡献，任何人都可以成为该角色\n- [Member](https:\/\/github.com\/istio\/community\/blob\/master\/ROLES.md#member)：正式贡献者，经常贡献，必须有 2 个已有的 member 提名\n- [Approver](https:\/\/github.com\/istio\/community\/blob\/master\/ROLES.md#approver)：老手，可以批准 member 的贡献\n- [Lead](https:\/\/github.com\/istio\/community\/blob\/master\/ROLES.md#lead)：管理功能、项目和提议，必须由 [ToC](https:\/\/github.com\/istio\/community\/blob\/master\/WORKING-GROUP-PROCESSES.md) 提名\n- [Administrator](https:\/\/github.com\/istio\/community\/blob\/master\/ROLES.md#administrator)：管理员，管理和控制权限，必须由 ToC 提名\n- [Vendor](https:\/\/github.com\/istio\/community\/blob\/master\/ROLES.md#vendor)：贡献 Istio 项目的扩展\n\n详见 [Istio Community Roles](https:\/\/github.com\/istio\/community\/blob\/master\/ROLES.md)。\n\n### 各种功能的状态\n\nIstio 中的所有 feature 根据**是否生产可用**、**API 兼容性**、**性能**、**维护策略**分为三种状态：\n\n- Alpha：仅仅可以作为 demo，无法生产上使用，也没有性能保证，随时都可能不维护\n- Beta：可以在生产上使用了，也有版本化的 API 但是无法保证性能，保证三个月的维护\n- Stable：可以上生产而且还能保证性能，API 向后兼容，保证一年的维护\n\nIstio 的 feature 分为四大类：\n\n- 流量管理：各种协议的支持、路由规则配置、Ingress TLS 等\n- 可观测性：监控、日志、分布式追踪、服务依赖拓扑\n- 安全性：各种 checker 和安全性配置\n- Core：核心功能\n\n功能划分与各种功能的状态详情请见：\u003chttps:\/\/istio.io\/latest\/about\/feature-stages\/\u003e\n\n### 云原生社区 Istio 讨论组\n\n[云原生社区](https:\/\/cloudnative.to)专门成立里 Istio SIG（微信讨论群），将原来 ServiceMesher 中关注 Istio 的人群专门集中到一个讨论组中，其中包含了百度、阿里巴巴、腾讯、网易、Tetrate、Intel、字节跳动等公司的服务网格专家及众多的终端用户，欢迎大家[申请加入群聊](https:\/\/i.cloudnative.to\/istio)。\n', '\/blog\/istio-community-tips\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文讲述了参与 Istio 社区和进行 Istio 开发时需要注意的事项。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/cncf-introduction/">CNCF - 云原生计算基金会简介</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2018/03/04</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f"> 
             云原生
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('CNCF - 云原生计算基金会简介', 'CNCF 云原生计算基金会简介以及 CNCF 的运作方式与项目成熟度级别标准介绍。', '\nCNCF，全称 Cloud Native Computing Foundation（云原生计算基金会），口号是**坚持和整合开源技术来编排容器作为微服务架构的一部分**，其作为致力于云原生应用推广和普及的一支重要力量，不论您是云原生应用的开发者、管理者还是研究人员都有必要了解。\n\nCNCF 作为一个厂商中立的基金会，致力于 Github 上的快速成长的开源技术的推广，如 Kubernetes、Prometheus、Envoy 等，帮助开发人员更快更好的构建出色的产品。\n\nhttp:\/\/github.com\/cncf\/landscape 中维护了一幅 CNCF 的全景图。\n\n其中包含了 CNCF 中托管的项目，还有很多是非 CNCF 项目，还有个交互式的浏览 CNCF 涵盖的所有的项目的页面：https:\/\/i.cncf.io\n\n关于 CNCF 的使命与组织方式请参考[CNCF 章程](https:\/\/www.cncf.io\/about\/charter\/)，概括的讲 CNCF 的使命宝库以下三点：\n\n- 容器化包装。\n- 通过中心编排系统的动态资源管理。\n- 面向微服务。\n\n以上是 CNCF 最初对云原生特征的定义。\n\nCNCF 这个角色的作用是推广技术，形成社区，开源项目管理与推进生态系统健康发展。\n\n另外 CNCF 组织由以下部分组成：\n\n- **会员**：白金、金牌、银牌、最终用户、学术和非赢利成员，不同级别的会员在治理委员会中的投票权不同。\n- **理事会**：负责事务管理\n- **TOC（技术监督委员会）**：技术管理\n- **最终用户社区**：推动 CNCF 技术的采纳并选举最终用户技术咨询委员会\n- **最终用户技术咨询委员会**：为最终用户会议或向理事会提供咨询\n- **营销委员会**：市场推广\n\n## CNCF 项目成熟度分级与毕业条件\n\n每个 CNCF 项目都需要有个成熟度等级，申请成为 CNCF 项目的时候需要确定项目的成熟度级别。\n\n成熟度级别（Maturity Level）包括以下三种：\n\n- sandbox（初级）一开始是叫 inception\n- incubating（孵化中）\n- graduated（毕业）\n\n是否可以成为 CNCF 项目需要通过 Technical Oversight Committee（技术监督委员会）简称[TOC](https:\/\/github.com\/cncf\/toc)，投票采取 fallback 策略，即**回退策略**，先从最高级别（graduated，目前是从 incubating）开始，如果 2\/3 多数投票通过的话则确认为该级别，如果没通过的话，则进行下一低级别的投票，如果一直到 inception 级别都没得到 2\/3 多数投票通过的话，则拒绝其进入 CNCF 项目。一般一个项目处于孵化阶段不会超过 2 年。\n\n当前所有的 CNCF 项目可以访问 https:\/\/www.cncf.io\/projects\/\n\n在太平洋时间 3 月 6 日，Kubernetes 成为了 CNCF 的第一个毕业项目！\n\n## TOC（技术监督委员会）\n\nTOC（Technical Oversight Committee）作为 CNCF 中的一个重要组织，它的作用是：\n\n- 定义和维护技术视野\n- 审批新项目加入组织，为项目设定概念架构\n- 接受最终用户的反馈并映射到项目中\n- 调整组件见的访问接口，协调组件之间兼容性\n\nTOC 成员通过选举产生，见[选举时间表](https:\/\/github.com\/cncf\/toc\/blob\/master\/process\/election-schedule.md)。\n\n参考 CNCF TOC：https:\/\/github.com\/cncf\/toc\n\n## CNCF 章程\n\nCNCF（云原生计算基金会）是 Linux 基金会旗下的一个基金会，加入 CNCF 等于同时加入 Linux 基金会（也意味着你还要交 Linux 基金会的份子钱），对于想加入 CNCF 基金会的企业或者组织首先要做的事情就是要了解 CNCF 的章程（charter），就像是作为一个国家的公民，必须遵守该国家的宪法一样。CNCF 之所以能在短短三年的时间内发展壮大到如此规模，很大程度上是与它出色的社区治理和运作模式有关。了解该章程可以帮助我们理解 CNCF 是如何运作的，也可以当我们自己进行开源项目治理时派上用场。\n\n该章程最后更新于 2018 年 5 月 15 日，详见 \u003chttps:\/\/www.cncf.io\/about\/charter\/\u003e。\n\n### 1. CNCF 的使命\n\nCNCF 没有偏离自己的主题，核心是解决技术问题：基金会的使命是创建并推动采用新的计算模式，该模式针对现代分布式系统环境进行了优化，能够扩展至数万个自愈式多租户节点。\n\n所谓的云原生系统须具备下面这些属性：\n\n- **应用容器化**：将软件容器中的应用程序和进程作为独立的应用程序部署单元运行，并作为实现高级别资源隔离的机制。从总体上改进开发者的体验、促进代码和组件重用，而且要为云元是国内应用简化运维工作。\n- **动态管理**：由中心化的编排来进行活跃的调度和频繁的管理，从根本上提高机器效率和资源利用率，同时降低与运维相关的成本。\n- **面向微服务**：与显式描述的依赖性松散耦合（例如通过服务端点），可以提高应用程序的整体敏捷性和可维护性。CNCF 将塑造技术的发展，推动应用管理的先进技术发展，并通过可靠的接口使技术无处不在，并且易于使用。\n\n### 2. CNCF 扮演的角色\n\nCNCF 其实是在开源社区的基础上发挥着作用，应负责：\n\na) 项目管理\n\n- 确保技术可用于社区并且没有杂七杂八的影响\n- 确保技术的品牌（商标和标识）得到社区成员的关注和使用，特别强调统一的用户体验和高水平的应用程序兼容性\n\nb) 促进生态系统的发展和演进\n\n- 评估哪些技术可以纳入云原生计算应用的愿景，鼓励社区交付这样的技术，以及集成它们，且要积极的推进总结进度。\n- 提供一种方法来培养各个部分的通用技术标准\n\nc) 推广底层技术和应用定义和管理方法，途径包括：活动和会议、营销（SEM、直接营销）、培训课程和开发人员认证。\n\nd) 通过使技术可访问和可靠来为社区服务\n\n- 旨在通过对参考架构进行明确定义的节奏，为每个组成部分提供完全集成和合格的构建。\n\n### 3. CNCF 的价值观\n\nCNCF 会极力遵循以下一些原则：\n\n1. **快速胜过磨叽**，基金会的初衷之一就是让项目快速的发展，从而支持用户能够积极的使用。\n2. **开放！** CNCF 是以开放和高度透明为最高准则的，而且是独立于任何的其它团体进行运作的。CNCF 根据贡献的内容和优点接受所有的贡献者，且遵循开源的价值观，CNCF 输出的技术是可以让所有人使用和受益的，技术社区及其决策应保持高度透明。\n3. **公平**：CNCF 会极力避免那些不好的影响、不良行为、以及“按需付费”的决策。\n4. **强大的技术身份**：CNCF 会实现并保持高度的自身技术认同，并将之同步到所有的共享项目中。\n5. **清晰的边界**：CNCF 制定明确的目标，并在某些情况下，要确定什么不是基金会的目标，并会帮助整个生态系统的运转，让人们理解新创新的重点所在。\n6. **可扩展**：能够支持从小型开发人员中心环境到企业和服务提供商规模的所有部署规模。这意味着在某些部署中可能不会部署某些可选组件，但总体设计和体系结构仍应适用。\n7. **平台中立**：CNCF 所开发的项目并不针对某个特定平台，而是旨在支持各种体系结构和操作系统。\n\n### 4. 会员制\n\nCNCF 中的会员包括白金、金牌、银牌、最终用户、学术和非赢利成员等级别，不同级别的会员在理事会中的投票权不同。\n\na) **白金会员**：在 CNCF 理事会中任命 1 名代表，在理事会的每个次级委员会和活动中任命 1 名有投票权的代表，在网站可以突出显示；如果也是终端用户成员将继承终端用户成员的所有权利\n\nb) **金牌会员**：基金会中每有 5 个金牌会员，该级别的会员就可以任命 1 名代表，最多任命 3 个；如果也是终端用户成员将继承终端用户成员的所有权利\n\nc) **银牌会员**：基金会中每有 10 个银牌会员，该级别的会员就可以任命 1 名代表，最多任命 3 个；如果也是终端用户成员将继承终端用户成员的所有权利\n\nd) **终端用户**：参加终端用户咨询社区；向终端用户技术咨询委员会中提名 1 名代表\n\ne) **学术和非赢利会员**：学术和非营利会员分别限于学术和非营利机构，需要理事会批准。学术成员和非营利成员有权将其组织认定为支持 CNCF 使命的成员以及理事会确定的任何其他权利或利益。\n\n### 5. 理事会\n\na) CNCF 理事会负责市场营销、业务监督和预算审批，不负责技术方面，除了与 TOC 配合确定 CNCF 工作范围、完成时间表 a)、更新 CNCF 网站\n\nb) 负责日常事务\n\n1. 与 TOC 协商 CNCF 的整体范围\n2. 商标和版权保护\n3. 市场营销、布道和生态系统建设\n4. 创建和执行品牌承诺项目，如果需要的话\n5. 监督运营，业务发展；\n6. 募资和财务管理\n\nc) 理事会投票成员由会员代表和社区代表组成：\n\n1. 成员代表包括：\n   - 每名白金会员任命 1 名代表\n   - 黄金和银牌成员当选代表\n2. 技术社区代表包括：\n   - 技术监督委员会主席\n   - 根据当时在任的理事会批准的程序从 CNCF 项目中选出两名提交者。\n3. 理事会可能会以白金会员比例的价格扩展白金会员资格，对年收入低于 5000 万美元的创业公司进行长达 5 年的逐年审计，这些公司被视为理事会的战略技术贡献者。\n4. 只有来自一组**关联公司**的人员可以担任会员代表。只有来自一组**关联公司**的人员可以担任技术社区代表。\n\nd) 职责\n\n1. 批准预算，指导将所有收入来源筹集的资金用于技术、市场或社区投资，以推动 CNCF 基金的使命；\n2. 选举理事会主席主持会议，批准预算批准的支出并管理日常运作；\n3. 对理事会的决定或事项进行投票；\n4. 界定和执行基金会的知识产权（版权，专利或商标）政策；\n5. 通过活动、新闻和分析师宣传、网络、社交媒体以及其他营销活动进行直接营销和布道；\n6. 监督运营，业务发展；\n7. 建立并监督为推动 CNCF 的使命而创建的任何委员会；\n8. 根据 CNCF 要求（可能包括认证测试）建立并执行品牌合规计划（如有），以使用 TOC 建立的品牌标志；\n9. 采用商标使用准则或政策；\n10. 提供整体财务管理。\n\ne) 基金会的收入用途\n\n1. 市场营销，用户扩展 CNCF 中的项目的采用\n2. 关键设施建设、运行和管理项目的基础设施\n3. 促进基于容器的计算使用 CNCF 中的项目实现\n\n### 6. 技术监督委员会（TOC）\n\n**a) 要求**\n\nCNCF 技术监督委员会，为了保持中立，则达成了以下共识：\n\n1. 定义和维护 CNCF 的技术愿景。\n2. 批准由理事会制定的 CNCF 范围内的新项目，并为项目创建一个概念架构。\n3. 纠正项目的发展方向，决策删除或存档项目。\n4. 接受最终用户委员会的反馈并反映在项目中。\n5. 在科学管理的情况下调整组件的接口（在代码标准化之前实现参考）\n6. 定义在 CNCF 项目中实施的常用做法（如果有的话）。\n\n**b) 技术监督委员会的构成**\n\n1. TOC 最多由 9 名成员组成。\n2. 选出的 TOC 成员将涵盖关键的技术领域：容器技术、操作系统、技术运维、分布式系统、用户级应用程序设计等。\n3. 理事会将选举 6 名 TOC 成员，最终用户 TAB 将选出 1 名 TOC 成员，最初的 7 名 TOC 成员应另选两名 TOC 成员。\n4. 如果超过两名 TOC 成员来自同一组关联公司，无论是在选举时还是来自后来的工作变更，他们将共同决定谁应该下台，或如果没有协商的依据，则应抽签决定。\n\n**c) 运营模式**\n\n1. TOC 会选举出 TOC 的主席来，此角色主要负责 TOC 的议程和召集会议。\n2. TOC 每个季度会面对面讨论重要的热点问题。\n3. TOC 可能会根据需要开会讨论新出现的问题。TOC 审核可能会提出以下问题：\n   - 任何的 TOC 成员\n   - 任何的理事会成员\n   - 建立的 CNCF 项目的维护者或顶级项目负责人\n   - CNCF 执行董事\n   - 最终用户技术咨询委员会获得多数票\n4. 保持透明：TOC 会议、邮件列表、以及会议记录等均是公开可访问的。\n5. 简单的 TOC 问题可以通过简短的讨论和简单的多数表决来解决。TOC 讨论可通过电子邮件或 TOC 会议进行。\n6. 在对意见和可选虚拟讨论\/辩论选项进行审查后，寻求共识并在必要时进行投票。\n7. 目的是让 TOC 在 TOC 和社区内寻找达成共识的途径。满足法定人数要求的会议的 TOC 决定应以超过 TOC 成员出席率的 50％的方式通过。\n8. TOC 会议需要 TOC 总人数的三分之二法定人数进行表决或作出任何决定。如果 TOC 会议未能达到法定人数要求，可以进行讨论，但不应有任何投票或决定。\n9. TOC 决定可以在没有会议的情况下以电子方式提出，但要通过表决则需要多少票数才能达到会议法定人数。在电子投票中，如果任何两名 TOC 成员要求召开会议讨论决定，则电子投票结束时无效，并且在会议结束后可以启动新的投票，以讨论决定已经完成。\n\n**d) 提名标准**\n\n获得 TOC 提名的开源贡献者应该具备下面条件：\n\n1. 承诺有足够的可用可用时间参与 CNCF TOC 的活动，包括在 CNCF 成立时相当早期的投入，然后需持续投入时间，而且在季度的 TOC 会议之前要进行充分的准备和审查事宜。\n2. 在 CNCF 范围内展示了高水准的专业经验。\n3. 证明其有资格能够获得额外的工作人员或社区成员协助其在 TOC 的工作。\n4. 在讨论中保持中立，并提出 CNCF 的目标和成功与公司目标或 CNCF 中的任何特定项目保持平衡。\n\n**e) TOC 成员提名和选举程序**\n\n1. TOC 由 9 位 TOC 成员组成：由理事会选出的 6 位，由最终用户 TAB 选出的 1 位和由最初的 7 位 TOC 成员选出的 2 位。\n2. 提名：每个有资格提名 TOC 成员的个人（实体或成员）可以提名至多 2 名技术代表（来自供应商、最终用户或任何其他领域），其中至多一个可能来自其各自公司。被提名者必须提前同意加入到候选人名单中。\n   - 最初的 7 名 TOC 成员（理事会选出的 6 名成员加上由最终用户 TAB 选出的 1 名成员）应使用提名程序提名并选举 2 名 TOC 成员。\n   - 提名者需要提供最多一页纸的介绍，其中包括被提名者的姓名，联系信息和支持性陈述，确定了在 CNCF 领域提名的经验。\n   - 理事会、最终用户 TAB 和 TOC 应确定提名、投票和关于 TOC 选举提名和选举过程的任何其他细节的时间表和日期。\n   - 评估期间最少保留 14 个日历日，TOC 提名者可以联系和\/或评估候选人。\n3. 选举：评估期结束后，理事会、最终用户标签和最初的 7 位 TOC 成员应分别对每位被候选人进行表决。有效投票需要满足会议法定人数所需的选票数量。每名被候选人均需要支持超过 50％的投票人数，以确认被提名者符合资格标准。以多数票通过的候选人应为合格的 TOC 成员。\n4. 如果合格的被提名者的人数等于或少于可选 TOC 席位的数量，则此被提名者应在提名期结束后获得批准。如果有更多的合格被候选人比理事会，最终用户 TAB 或 TOC 可选的开放 TOC 席位多，那么该组应通过 Condorcet 投票选出 TOC 成员。Condorcet 投票应通过康奈尔在线服务（http:\/\/civs.cs.cornell.edu\/）使用 Condorcet-IRV 方法运行。\n5. 如果理事会，最终用户 TAB 或 TOC 可供选举的公开 TOC 席位的合格被候选人数较少，该小组将启动另一轮提名，每名成员或个人有资格提名至多提名 1 名候选人。\n\n**f) 约束条件**\n\n1. TOC 的成员任期为两年，来自理事会选举的最初六名当选 TOC 成员的任期为 3 年。由最终用户 TAB 和 TOC 选出的 TOC 成员的初始任期为 2 年。\n2. TOC 成员可能会被其他 TOC 成员的三分之二投票撤除，受影响的个人不能参加投票。\n3. 任何 TOC 成员连续 3 次连续会议都将被自动暂停投票资格，直至连续参加两次会议。为避免疑义，暂停的 TOC 成员有资格在连续第二次会议中投票。\n4. TOC 章程、模式、方法、组成等可以由整个理事会的三分之二票通过修改。\n5. TOC 议程将由 TOC 制定。但是，预计最初的 TOC 讨论和决定将包括：\n   - 评估包含在 CNCF 中的技术\n   - 确定新技术纳入 CNCF 的接受标准\n   - 定义批准作为标准 API 的贡献技术的流程\n   - 找出需要进一步调查的直接差距\n\n### 7. 最终用户社区\n\na) CNCF 的最终用户成员有权协调和推动 CNCF 用户作为 CNCF 设计的消费者的重要活动。任何作为最终用户的成员或非成员，每个“最终用户参与者”均可被邀请参加。最终用户参与者将帮助向技术咨询委员会和 CNCF 社区就与用户有关的主题提供意见。\n\nb) \t最终用户技术咨询委员会是由最终用户社区成员选举所产生。\n\nc) 最终用户社区成员将获得 CNCF 执行董事的批准，或者 CNCF 执行董事缺席的话，则由 Linux 基金会执行董事来批准。\n\n### 8. 最终用户技术咨询委员会（“最终用户 TAB”）\n\na) 构成：最终用户 TAB 应由来自最终用户参与者的 7 名代表加上 TOC 的 1 名成员组成，以便于从最终用户 TAB 到 TOC 的晋级。\n\nb) 选举：为了鼓励最终用户参与 CNCF，前 7 名最终用户会员可以委任 1 名代表参加初始最终用户 TAB，并将 CNCF 董事分配给任何最终用户参与者的任何剩余席位。在第一年之后，所有最终用户参与者可以提名 1 名代表并且最终用户社区应该投票选择使用当前最终用户 TAB 批准流程的最终用户 TAB 成员。\n\nc) 经过三分之二投票通过后最终用户 TAB 可以更改最终用户社区的大小，前提是至少有 7 名可能的代表。\n\nd) 最终用户代表应当基于业务和技术敏锐度提名。候选人应该具备建设和运营体现 CNCF 原则的基础设施和应用方面的重要实践经验。\n\ne) 最终用户 TAB 将讨论和推进主题，重点是找出 TOC 和 CNCF 开发者社区的差距并提出优先事项。\n\nf) 也会侧重于主动推进最终用户关心的话题，促进 CNCF 的市场采用，为最终用户举办会议或向理事会提供咨询。\n\ng) 如果最终用户 TAB 有意愿的话，它可以批准小组委员会特别兴趣小组（“SIG”）来解决行业或专业话题。\n\nh) 最终用户 TAB 是技术监督委员会的主要输入方，应与技术监督委员会的其他输入方和反馈一起作出决策和计划。这些建议只是建议性的，在任何时候，最终用户 TAB 的建议都不能用于命令或指导任何 TOC 或项目参与者采取任何行动或结果。\n\ni) 为促进与 TOC 的双边互动，最终用户技术咨询委员会应选出 1 名 TOC 代表。最终用户 TAB 可邀请任何人参加最终用户会议、SIG 或其他讨论。\n\n### 9. CNCF 项目\n\n通常情况下，是由 CNCF 的成员公司、开源社区的成员将项目先是带到 CNCF 的技术监督委员会来进行讨论，然后决定是否被 CNCF 接纳。要贡献给 CNCF 的项目必须是经过技术监督委员会制定的标准的，之后当然还要经过理事会的批准。CNCF 的目标是希望捐赠给 CNCF 的项目和 CNCF 已有的项目在一定程度上是有关联的，而且是可集成的。\n\n和 CNCF 关联起来有以下三种方法：\n\n**1.** 已经在 CNCF 的纳管之下，毕竟 CNCF 是中立的，致力于成为大家的协作的归属地。\n\na) 项目的方方面面都交由 CNCF 来打理\nb) 项目是由 CNCF 来进行市场推广的\nc) 项目是解决云原生计算问题的核心组件，如 Kubernetes、Mesos、etcd 等等\n\n**2.** 通过 API 或规范与 CNCF 相关联 XM\n\na) 包括 CNCF 可能提供或启用多个选项的组件\nb) 该项目被称为 CNCF 集成的一个组成部分，而不是由 CNCF 主办的项目\nc) 集成和合规性由 API 或规范定义\nd) 项目或组件的开发是由上游社区所开发，而且保持一定的活跃度\n\n**3.** CNCF 使用到的\n\na) 项目或组件完全根据 OSI 批准的开源许可证进行授权，并且管理良好，并在 CNCF 中被用作组件。\n\nb) 项目并没有由 CNCF 来进行市场推广\n\nc) 项目或组件的开发是由上游社区所开发，而且保持一定的活跃度\n\n现有的开源项目应该继续保持其现有的技术治理结构，以保持凝聚力和速度。但是由技术监督委员会批准之后，则会适当的进行一些适应。\n\n应根据个人的水平和贡献期限在项目间建立一个达到提交者地位的标准协议。因为提交者是维护者的选拔人才池，有了一定程度的贡献，且经过同行们的认可，提交者就可晋升为维护者。\n\nCNCF 启动的新开源项目应完成 TOC 采纳的项目建议模板，并由 TOC 批准纳入 CNCF。TOC 成员应有充足的时间讨论和审查新的项目建议书。新的项目建议书应包括项目中的角色细节，为项目提出的治理，并确定与 CNCF 的角色和价值观保持一致。\n\n### 10. 市场委员会\n\na) 构成，市场委员会将向所有成员开放参与，应选举市场委员会主席制定会议议程，进行一般的讨论，并帮助委员会实现其目标。市场委员会应尽可能寻求共识。在市场委员会中无法达成共识的任何问题应提交给理事会。\n\nb) 职责，市场委员会代表理事会负责设计，开发和执行相关的市场工作。\n\nc) 如果市场委员会变得太大而无法有效运作，市场委员会可以选择选举市场董事，并将决策权委托给市场董事。\n\n### 11. 知识产权政策\n\na) 任何加入到 CNCF 的项目都必须将其拥有的商标和徽标资产转让给 Linux 基金会的所有权。\n\nb) 每个项目应确定是否需要使用经批准的 CNCF CLA。对于选择使用 CLA 的项目，所有代码贡献者将承担 Apache 贡献者许可协议中规定的义务，只有在必要时才作出修改，以确定 CNCF 是捐赠的接受者，并且应由理事会批准。请参阅 \u003chttps:\/\/github.com\/cncf\/cla\u003e 上提供的 CNCF 参与者许可协议。\n\nc) 所有向 CNCF 提交的新入站代码应当（i）附有开发者原始证书签名（\u003chttps:\/\/developercertificate.org\u003e和（ii）根据 Apache 许可证 2.0 版（可从\u003chttps:\/\/developercertificate.org\u003e和\u003chttp:\/\/www.apache.org\/licenses\/LICENSE-2.0\u003e 获得）该许可证除了并且不得取代根据上文（b）规定的供款许可协议所承担的义务。\n\nd) 所有出站代码将在 Apache 许可证 2.0 版下提供。\n\ne) 所有评估纳入 CNCF 的项目都必须获得 OSI 批准的开源许可证的完全许可，如果 CNCF 中包含的项目的许可证不是 Apache 许可证 2.0 版，则需要获得理事会的批准。\n\nf) 所有文档将由 CNCF 根据知识共享署名 4.0 国际许可证来提供。\n\ng) 如果需要替代入站或出站许可证以符合杠杆式开放源代码项目的许可证或为实现 CNCF 的使命而需要其他许可证，理事会可以批准使用替代许可证 对于例外情况下的接受或提供的项目捐赠。\n\n### 12. 反托拉斯指南\n\na) 所有成员均应遵守\u003chttp:\/\/www.linuxfoundation.org\/antitrust-policy\u003e上提供的 Linux 基金会反托拉斯政策中规定的 Linux 基金会的要求。\n\nb) 所有成员都应鼓励任何能够满足成员要求的组织的公开参与，而不论其竞争利益如何。换言之，理事会不应根据除用于所有成员的标准，要求或原因之外的任何标准，要求或理由寻求排除成员。\n\n### 13. 行为准则\n\n所有参与者都须同意遵守 [Linux 基金会行为准则](http:\/\/events.linuxfoundation.org\/code-of-conduct)。TSC 可以投票通过自己的 CNCF 行为准则。\n\n### 14. 关联公司\n\na) 定义：\n\n1. “子公司”是指会员直接或间接拥有所涉实体超过百分之五十有投票权的证券或会员权益的任何实体；\n2. “关联公司”是指任何控制或由成员控制的实体，或者与成员一起受第三方共同控制的实体，在所有情况下，直接或间接拥有多于所有权的控制权；\n3. “关联公司”是指各成员的关联公司。\n\nb) 只有执行了参与协议的法人实体及其子公司才有权享有该会员的权利和特权；但条件是该成员及其子公司应作为单一成员共同对待。\n\nc) 只有一名属于一组关联公司的成员有权一次性任命或提名理事会代表参加类别选举。\n\nd) 如果会员本身是会员或赞助商的基金会，联盟，开源项目，会员组织，用户组或其他实体，那么授予该成员的权利和特权只能扩展到该成员的员工代表，而不能扩展到其成员或发起人，除非理事会不时在特定情况下另行批准。\n\ne) 会员资格不得转让，不可转让、也不能转让，除非现有会员将其现有的会员利益和义务转让给其大部分业务和\/或资产的继任者，无论是通过合并，出售还是其他方式；只要受让人同意遵守 CNCF 的章程以及 Linux Foundation 成员所需的章程和政策。\n\n### 15. 预算\n\na) 理事会应批准年度预算，绝不会承诺超出筹集的资金。预算应与 Linux 基金会的非营利性使命相一致。\n\nb) Linux 基金会应定期报告预算支出。\n\n### 16. 常规和管理费用\n\na) Linux 基金会应保管任何费用，资金和其他现金收据。\n\nb) 一般和行政（G＆A）费用将用于筹集资金以支付财务、会计和运营费用。G＆A 费用应等于 CNCF 首期总收入 1,000,000 美元的 9％以及 CNCF 总收入超过 1,000,000 美元的 6％。\n\n### 17. 一般规则和操作\n\n参与 CNCF 应做到：\n\na) 展示与开源项目开发人员社区进行协调的计划和方法，包括关于代表社区的品牌、徽标和其它标志性的主题；\n\nb) 以专业的方式体现维持社区的凝聚力为目标，同时还要保持 Linux 基金会在开放源代码软件社区的善意和尊重；\n\nc) 尊重所有商标所有人的权利，包括任何品牌和使用准则；\n\nd) 参与 Linux 基金会的所有新闻和分析师关系活动；\n\ne) 根据要求，向 Linux 基金会提供关于项目参与的信息，包括参加项目赞助活动的信息；\n\nf) 直接参与到基金会旗下的任何站点。\n\ng) 根据理事会批准的规则和程序进行运营，前提是这些规则和程序不得与 Linux 基金会的宗旨和政策不一致，并且不得损害 Linux 基金会。\n\n### 18. 修正案\n\n本章程可以通过所有理事会成员的三分之二票数（不包括弃权）进行修改，前提是任何此类修改不得与 Linux 基金会的目的或政策不一致，并且不得对 Linux 基金会产生不利影响。\n\n### 时间表 A：提出 CNCF 范围愿景\n\nCNCF 背后的首要目标是支持和加速“云原生计算”的采用。以下内容是初步范围，旨在阐明 CNCF 将努力实施的“云原生计算”的核心概念。该初始范围应成为发布在 CNCF 网站上的文档。\n\nCNCF 社区坚信云原生计算包含三个核心属性：\n\n- 容器化包装和分发\n- 动态调度\n- 面向微服务\n\n**注**：关于云原生的定义正在重新设定中，已经与上述不同了。\n\n云原生计算系统支持基于这些核心属性的计算，并包含以下理想：\n\n- 开放性和可扩展性\n- 在标准化子系统的边界处定义良好的 API\n- 应用程序生命周期管理的最小障碍\n\n因为上述时间表已经有些过时了，CNCF 成立已经有三年时间了，正在规划新的方案。\n\n## 参考\n\n- [https:\/\/www.cncf.io](https:\/\/www.cncf.io\/)\n- \u003chttps:\/\/www.cncf.io\/about\/charter\/\u003e\n- \u003chttps:\/\/github.com\/cncf\/landscape\u003e\n- \u003chttps:\/\/github.com\/cncf\/toc\u003e', '\/blog\/cncf-introduction\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">CNCF 云原生计算基金会简介以及 CNCF 的运作方式与项目成熟度级别标准介绍。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/configuring-kubernetes-kube-dns/">配置 Kubernetes DNS 服务 kube-dns</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2018/01/03</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/kubernetes"> 
             Kubernetes
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('配置 Kubernetes DNS 服务 kube-dns', '配置 Kubernetes DNS Pod 的提示和定义 DNS 解析过程以及诊断 DNS 问题的指南。', '\n在我们安装 Kubernetes 集群的时候就已经安装了 kube-dns 插件，这个插件也是官方推荐安装的。通过将 Service 注册到 DNS 中，Kuberentes 可以为我们提供一种简单的服务注册发现与负载均衡方式。\n\n[CoreDNS](https:\/\/coredns.io)作为 CNCF 中的托管的一个项目，在 Kuberentes1.9 版本中，使用 kubeadm 方式安装的集群可以通过以下命令直接安装 CoreDNS。\n\n\u0060\u0060\u0060bash\nkubeadm init --feature-gates=CoreDNS=true\n\u0060\u0060\u0060\n\n您也可以使用 CoreDNS 替换 Kubernetes 插件 kube-dns，可以使用 Pod 部署也可以独立部署，请参考[Using CoreDNS for Service Discovery](https:\/\/kubernetes.io\/docs\/tasks\/administer-cluster\/coredns\/)，下文将介绍如何配置 kube-dns。\n\n本文已归档到[kubernetes-handbook](\/book\/kubernetes-handbook)中。\n\n## kube-dns\n\nkube-dns 是 Kubernetes 中的一个内置插件，目前作为一个独立的开源项目维护，见 https:\/\/github.com\/kubernetes\/dns。\n\n下文中给出了配置 DNS Pod 的提示和定义 DNS 解析过程以及诊断 DNS 问题的指南。\n\n## 前提要求\n\n- Kubernetes 1.6 及以上版本。\n- 集群必须使用 \u0060kube-dns\u0060 插件进行配置。\n\n## kube-dns 介绍\n\n从 Kubernetes v1.3 版本开始，使用 [cluster add-on 插件管理器回自动启动内置的 DNS。\n\nKubernetes DNS pod 中包括 3 个容器：\n\n- \u0060kubedns\u0060：\u0060kubedns\u0060 进程监视 Kubernetes master 中的 Service 和 Endpoint 的变化，并维护内存查找结构来服务 DNS 请求。\n- \u0060dnsmasq\u0060：\u0060dnsmasq\u0060 容器添加 DNS 缓存以提高性能。\n- \u0060sidecar\u0060：\u0060sidecar\u0060 容器在执行双重健康检查（针对 \u0060dnsmasq\u0060 和 \u0060kubedns\u0060）时提供单个健康检查端点（监听在 10054 端口）。\n\nDNS  pod 具有静态 IP 并作为 Kubernetes 服务暴露出来。该静态 IP 分配后，kubelet 会将使用 \u0060--cluster-dns = \u003cdns-service-ip\u003e\u0060 标志配置的 DNS 传递给每个容器。\n\nDNS 名称也需要域名。本地域可以使用标志 \u0060--cluster-domain = \u003cdefault-local-domain\u003e\u0060 在 kubelet 中配置。\n\nKubernetes 集群 DNS 服务器基于 [SkyDNS](https:\/\/github.com\/skynetservices\/skydns) 库。它支持正向查找（A 记录），服务查找（SRV 记录）和反向 IP 地址查找（PTR 记录）\n\n## kube-dns 支持的 DNS 格式\n\nkube-dns 将分别为 service 和 pod 生成不同格式的 DNS 记录。\n\n**Service**\n\n- A 记录：生成\u0060my-svc.my-namespace.svc.cluster.local\u0060域名，解析成 IP 地址，分为两种情况：\n  - 普通 Service：解析成 ClusterIP\n  - Headless Service：解析为指定 Pod 的 IP 列表\n- SRV 记录：为命名的端口（普通 Service 或 Headless Service）生成 \u0060_my-port-name._my-port-protocol.my-svc.my-namespace.svc.cluster.local\u0060 的域名\n\n**Pod**\n\n- A 记录：生成域名 \u0060pod-ip.my-namespace.pod.cluster.local\u0060\n\n## kube-dns 存根域名\n\n可以在 Pod 中指定 hostname 和 subdomain：\u0060hostname.custom-subdomain.default.svc.cluster.local\u0060，例如：\n\n\u0060\u0060\u0060yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: busybox\n  labels:\n    name: busybox\nspec:\n  hostname: busybox-1\n  subdomain: busybox-subdomain\n  containers:\n  name: busybox\n  - image: busybox\n    command:\n    - sleep\n    - \u00223600\u0022\n\u0060\u0060\u0060\n\n该 Pod 的域名是 \u0060busybox-1.busybox-subdomain.default.svc.cluster.local\u0060。\n\n## 继承节点的 DNS\n\n运行 Pod 时，kubelet 将预先配置集群 DNS 服务器到 Pod 中，并搜索节点自己的 DNS 设置路径。如果节点能够解析特定于较大环境的 DNS 名称，那么 Pod 应该也能够解析。请参阅下面的[已知问题](#known-issues)以了解警告。\n\n如果您不想要这个，或者您想要为 Pod 设置不同的 DNS 配置，您可以给 kubelet 指定 \u0060--resolv-conf\u0060 标志。将该值设置为 \u0022\u0022 意味着 Pod 不继承 DNS。将其设置为有效的文件路径意味着 kubelet 将使用此文件而不是 \u0060\/etc\/resolv.conf\u0060 用于 DNS 继承。\n\n## 配置存根域和上游 DNS 服务器\n\n通过为 kube-dns（\u0060kube-system:kube-dns\u0060）提供一个 ConfigMap，集群管理员能够指定自定义存根域和上游 nameserver。\n\n例如，下面的 ConfigMap 建立了一个 DNS 配置，它具有一个单独的存根域和两个上游 nameserver：\n\n\u0060\u0060\u0060yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: kube-dns\n  namespace: kube-system\ndata:\n  stubDomains: |\n    {“acme.local”: [“1.2.3.4”]}\n  upstreamNameservers: |\n    [“8.8.8.8”, “8.8.4.4”]\n\u0060\u0060\u0060\n\n如上面指定的那样，带有“.acme.local”后缀的 DNS 请求被转发到 1.2.3.4 处监听的 DNS。Google Public DNS 为上游查询提供服务。\n\n下表描述了如何将具有特定域名的查询映射到其目标 DNS 服务器：\n\n| 域名                                   | 响应查询的服务器                   |\n| ------------------------------------ | -------------------------- |\n| kubernetes.default.svc.cluster.local | kube-dns                   |\n| foo.acme.local                       | 自定义 DNS (1.2.3.4)          |\n| widget.com                           | 上游 DNS (8.8.8.8 或 8.8.4.4) |\n\n查看 [ConfigMap 选项](#configmap-options) 获取更多关于配置选项格式的详细信息。\n\n### 对 Pod 的影响\n\n自定义的上游名称服务器和存根域不会影响那些将自己的 \u0060dnsPolicy\u0060 设置为 \u0060Default\u0060 或者 \u0060None\u0060 的 Pod。\n\n如果 Pod 的 \u0060dnsPolicy\u0060 设置为“\u0060ClusterFirst\u0060”，则其名称解析将按其他方式处理，具体取决于存根域和上游 DNS 服务器的配置。\n\n**未进行自定义配置**：没有匹配上配置的集群域名后缀的任何请求，例如“www.kubernetes.io”，将会被转发到继承自节点的上游 nameserver。\n\n**进行自定义配置**：如果配置了存根域和上游 DNS 服务器（和在 [前面例子](#configuring-stub-domain-and-upstream-dns-servers) 配置的一样），DNS 查询将根据下面的流程进行路由：\n\n1. 查询首先被发送到 kube-dns 中的 DNS 缓存层。\n\n2. 从缓存层，检查请求的后缀，并转发到合适的 DNS 上，基于如下的示例：\n\n   -  *具有集群后缀的名字* （例如“.cluster.local”）：请求被发送到 kube-dns。\n   -  *具有存根域后缀的名字* （例如“.acme.local”）：请求被发送到配置的自定义 DNS 解析器（例如：监听在 1.2.3.4）。\n   -  *不具有能匹配上后缀的名字* （例如“widget.com”）：请求被转发到上游 DNS（例如：Google 公共 DNS 服务器，8.8.8.8 和 8.8.4.4）。\n\n   ![DNS lookup flow](https:\/\/d33wubrfki0l68.cloudfront.net\/340889cb80e81dcd19a16bc34697a7907e2b229a\/24ad0\/docs\/tasks\/administer-cluster\/dns-custom-nameservers\/dns.png)\n\n## ConfigMap 选项\n\nkube-dns \u0060kube-system:kube-dns\u0060 ConfigMap 的选项如下所示：\n\n| 字段                        | 格式                                       | 描述                                       |\n| ------------------------- | ---------------------------------------- | ---------------------------------------- |\n| \u0060stubDomains\u0060（可选）         | 使用 DNS 后缀 key 的 JSON map（例如“acme.local”），以及 DNS IP 的 JSON 数组作为 value。 | 目标 nameserver 可能是一个 Kubernetes Service。例如，可以运行自己的 dnsmasq 副本，将 DNS 名字暴露到 ClusterDNS namespace 中。 |\n| \u0060upstreamNameservers\u0060（可选） | DNS IP 的 JSON 数组。                        | 注意：如果指定，则指定的值会替换掉被默认从节点的 \u0060\/etc\/resolv.conf\u0060 中获取到的 nameserver。限制：最多可以指定三个上游 nameserver。 |\n\n### 示例\n\n#### 示例：存根域\n\n在这个例子中，用户有一个 Consul DNS 服务发现系统，他们希望能够与 kube-dns 集成起来。Consul 域名服务器地址为 10.150.0.1，所有的 Consul 名字具有后缀“.consul.local”。要配置 Kubernetes，集群管理员只需要简单地创建一个 ConfigMap 对象，如下所示：\n\n\u0060\u0060\u0060yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: kube-dns\n  namespace: kube-system\ndata:\n  stubDomains: |\n    {“consul.local”: [“10.150.0.1”]}\n\u0060\u0060\u0060\n\n注意，集群管理员不希望覆盖节点的上游 nameserver，所以他们不会指定可选的 \u0060upstreamNameservers\u0060 字段。\n\n#### 示例：上游 nameserver\n\n在这个示例中，集群管理员不希望显式地强制所有非集群 DNS 查询进入到他们自己的 nameserver 172.16.0.1。而且这很容易实现：他们只需要创建一个 ConfigMap，\u0060upstreamNameservers\u0060 字段指定期望的 nameserver 即可。\n\n\u0060\u0060\u0060yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: kube-dns\n  namespace: kube-system\ndata:\n  upstreamNameservers: |\n    [“172.16.0.1”]\n\u0060\u0060\u0060\n\n## 调试 DNS 解析\n\n### 创建一个简单的 Pod 用作测试环境\n\n创建一个名为 busybox.yaml 的文件，其中包括以下内容：\n\n\u0060\u0060\u0060yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: busybox\n  namespace: default\nspec:\n  containers:\n  - name: busybox\n    image: busybox\n    command:\n      - sleep\n      - \u00223600\u0022\n    imagePullPolicy: IfNotPresent\n  restartPolicy: Always\n\u0060\u0060\u0060\n\n使用该文件创建 Pod 并验证其状态：\n\n\u0060\u0060\u0060shell\n$ kubectl create -f busybox.yaml\npod \u0022busybox\u0022 created\n\n$ kubectl get pods busybox\nNAME      READY     STATUS    RESTARTS   AGE\nbusybox   1\/1       Running   0          \u003csome-time\u003e\n\u0060\u0060\u0060\n\n该 Pod 运行后，您可以在它的环境中执行 \u0060nslookup\u0060。如果您看到类似如下的输出，表示 DNS 正在正确工作。\n\n\u0060\u0060\u0060shell\n$ kubectl exec -ti busybox -- nslookup kubernetes.default\nServer:    10.0.0.10\nAddress 1: 10.0.0.10\n\nName:      kubernetes.default\nAddress 1: 10.0.0.1\n\u0060\u0060\u0060\n\n如果 \u0060nslookup\u0060 命令失败，检查如下内容：\n\n### 首先检查本地 DNS 配置\n\n查看下 resolv.conf 文件。（参考[集成节点的 DNS](#inheriting-dns-from-the-node)和 下面的[已知问题](#known-issues)获取更多信息）\n\n\u0060\u0060\u0060shell\n$ kubectl exec busybox cat \/etc\/resolv.conf\n\u0060\u0060\u0060\n\n验证搜索路径和名称服务器设置如下（请注意，搜索路径可能因不同的云提供商而异）：\n\n\u0060\u0060\u0060bash\nsearch default.svc.cluster.local svc.cluster.local cluster.local google.internal c.gce_project_id.internal\nnameserver 10.0.0.10\noptions ndots:5\n\u0060\u0060\u0060\n\n如果看到如下错误表明错误来自 kube-dns 或相关服务：\n\n\u0060\u0060\u0060bash\n$ kubectl exec -ti busybox -- nslookup kubernetes.default\nServer:    10.0.0.10\nAddress 1: 10.0.0.10\n\nnslookup: can\u0027t resolve \u0027kubernetes.default\u0027\n\u0060\u0060\u0060\n\n或者\n\n\u0060\u0060\u0060bash\n$ kubectl exec -ti busybox -- nslookup kubernetes.default\nServer:    10.0.0.10\nAddress 1: 10.0.0.10 kube-dns.kube-system.svc.cluster.local\n\nnslookup: can\u0027t resolve \u0027kubernetes.default\u0027\n\u0060\u0060\u0060\n\n### 检查 DNS pod 是否在运行\n\n使用 \u0060kubectl get pods\u0060 命令验证 DNS pod 是否正在运行。\n\n\u0060\u0060\u0060shell\n$ kubectl get pods --namespace=kube-system -l k8s-app=kube-dns\nNAME                    READY     STATUS    RESTARTS   AGE\n...\nkube-dns-v19-ezo1y      3\/3       Running   0           1h\n...\n\u0060\u0060\u0060\n\n如果您看到没有 Pod 运行或者 Pod 处于 失败\/完成 状态，DNS 插件可能没有部署到您的当前环境中，您需要手动部署。\n\n### 检查 DNS pod 中的错误\n\n使用 \u0060kubectl logs\u0060 命令查看 DNS 守护进程的日志。\n\n\u0060\u0060\u0060shell\n$ kubectl logs --namespace=kube-system $(kubectl get pods --namespace=kube-system -l k8s-app=kube-dns -o name) -c kubedns\n$ kubectl logs --namespace=kube-system $(kubectl get pods --namespace=kube-system -l k8s-app=kube-dns -o name) -c dnsmasq\n$ kubectl logs --namespace=kube-system $(kubectl get pods --namespace=kube-system -l k8s-app=kube-dns -o name) -c sidecar\n\u0060\u0060\u0060\n\n看看有没有可疑的日志。以字母“\u0060W\u0060”，“\u0060E\u0060”，“\u0060F\u0060”开头的代表警告、错误和失败。请搜索具有这些日志级别的条目，并使用 [kubernetes issues](https:\/\/github.com\/kubernetes\/kubernetes\/issues)来报告意外错误。\n\n### DNS 服务启动了吗？\n\n使用 \u0060kubectl get service\u0060 命令验证 DNS 服务是否启动。\n\n\u0060\u0060\u0060shell\n$ kubectl get svc --namespace=kube-system\nNAME          CLUSTER-IP     EXTERNAL-IP   PORT(S)             AGE\n...\nkube-dns      10.0.0.10      \u003cnone\u003e        53\/UDP,53\/TCP        1h\n...\n\u0060\u0060\u0060\n\n如果您已经创建了该服务或它本应该默认创建但没有出现，参考[调试服务](https:\/\/kubernetes.io\/docs\/tasks\/debug-application-cluster\/debug-service\/)获取更多信息。\n\n### DNS 端点暴露出来了吗？\n\n您可以使用\u0060kubectl get endpoints\u0060命令验证 DNS 端点是否被暴露。\n\n\u0060\u0060\u0060shell\n$ kubectl get ep kube-dns --namespace=kube-system\nNAME       ENDPOINTS                       AGE\nkube-dns   10.180.3.17:53,10.180.3.17:53    1h\n\u0060\u0060\u0060\n\n如果您没有看到端点，查看[调试服务](https:\/\/kubernetes.io\/docs\/tasks\/debug-application-cluster\/debug-service\/)文档中的端点部分。\n\n获取更多的 Kubernetes DNS 示例，请参考 Kubernetes GitHub 仓库中的[cluster-dns 示例](https:\/\/github.com\/kubernetes\/examples\/tree\/master\/staging\/cluster-dns)。\n\n## 已知问题\n\nKubernetes 安装时不会将节点的 resolv.conf 文件配置为默认使用集群 DNS，因为该过程本身是特定于发行版的。这一步应该放到最后实现。\n\nLinux 的 libc 不可思议的卡住（[查看该 2005 年起暴出来的 bug](https:\/\/bugzilla.redhat.com\/show_bug.cgi?id=168253)）限制只能有 3 个 DNS \u0060nameserver\u0060 记录和 6 个 DNS \u0060search\u0060 记录。Kubernetes 需要消耗 1 个 \u0060nameserver\u0060 记录和 3 个 \u0060search\u0060 记录。这意味着如果本地安装已经使用 3 个 \u0060nameserver\u0060 或使用 3 个以上的 \u0060search\u0060 记录，那么其中一些设置将会丢失。有个部分解决该问题的方法，就是节点可以运行 \u0060dnsmasq\u0060，它将提供更多的 \u0060nameserver\u0060 条目，但不会有更多的 \u0060search\u0060 条目。您也可以使用 kubelet 的 \u0060--resolv-conf\u0060 标志。\n\n如果您使用的是 Alpine 3.3 或更低版本作为基础映像，由于已知的 Alpine 问题，DNS 可能无法正常工作。点击[这里](https:\/\/github.com\/kubernetes\/kubernetes\/issues\/30215)查看更多信息。\n\n## Kubernetes 集群联邦（多可用区支持）\n\nKubernetes 1.3 版本起引入了支持多站点 Kubernetes 安装的集群联邦支持。这需要对 Kubernetes 集群 DNS 服务器处理 DNS 查询的方式进行一些小的（向后兼容的）更改，以便于查找联邦服务（跨多个 Kubernetes 集群）。有关集群联邦和多站点支持的更多详细信息，请参阅集群联邦管理员指南。\n\n## 参考\n\n- [Configure DNS Service](https:\/\/kubernetes.io\/docs\/tasks\/administer-cluster\/dns-custom-nameservers\/)\n- [Service 和 Pod 的 DNS](https:\/\/kubernetes.io\/docs\/concepts\/services-networking\/dns-pod-service\/)\n- [自动扩容集群中的 DNS 服务](https:\/\/kubernetes.io\/docs\/tasks\/administer-cluster\/dns-horizontal-autoscaling\/)\n- [Using CoreDNS for Service Discovery](https:\/\/kubernetes.io\/docs\/tasks\/administer-cluster\/coredns\/)\n\n', '\/blog\/configuring-kubernetes-kube-dns\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">配置 Kubernetes DNS Pod 的提示和定义 DNS 解析过程以及诊断 DNS 问题的指南。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/accessing-kubernetes-pods-from-outside-of-the-cluster/">从外部访问 Kubernetes 中的 Pod</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2017/11/21</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/kubernetes"> 
             Kubernetes
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('从外部访问 Kubernetes 中的 Pod', '关于在 Kubernetes 中暴露 Pod 及服务的五种方式。', '\n本文主要讲解访问 Kubernetes 中的 Pod 和 Service 的几种方式，包括如下几种：\n\n- hostNetwork\n- hostPort\n- NodePort\n- LoadBalancer\n- Ingress\n\n说是暴露 Pod 其实跟暴露 Service 是一回事，因为 Pod 就是 Service 的 backend。\n\n## hostNetwork: true\n\n这是一种直接定义 Pod 网络的方式。\n\n如果在 Pod 中使用 \u0060hostNetwork:true\u0060 配置的话，在这种 pod 中运行的应用程序可以直接看到 pod 启动的主机的网络接口。在主机的所有网络接口上都可以访问到该应用程序。以下是使用主机网络的 pod 的示例定义：\n\n\u0060\u0060\u0060yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: influxdb\nspec:\n  hostNetwork: true\n  containers:\n    - name: influxdb\n      image: influxdb\n\u0060\u0060\u0060\n\n部署该 Pod：\n\n\u0060\u0060\u0060bash\n$ kubectl create -f influxdb-hostnetwork.yml\n\u0060\u0060\u0060\n\n访问该 pod 所在主机的 8086 端口：\n\n\u0060\u0060\u0060bash\ncurl -v http:\/\/$POD_IP:8086\/ping\n\u0060\u0060\u0060\n\n将看到 204 No Content 的 204 返回码，说明可以正常访问。\n\n注意每次启动这个 Pod 的时候都可能被调度到不同的节点上，所有外部访问 Pod 的 IP 也是变化的，而且调度 Pod 的时候还需要考虑是否与宿主机上的端口冲突，因此一般情况下除非您知道需要某个特定应用占用特定宿主机上的特定端口时才使用 \u0060hostNetwork: true\u0060 的方式。\n\n这种 Pod 的网络模式有一个用处就是可以将网络插件包装在 Pod 中然后部署在每个宿主机上，这样该 Pod 就可以控制该宿主机上的所有网络。\n\n## hostPort\n\n这是一种直接定义 Pod 网络的方式。\n\n\u0060hostPort\u0060 是直接将容器的端口与所调度的节点上的端口路由，这样用户就可以通过宿主机的 IP 加上来访问 Pod 了，如:。\n\n\u0060\u0060\u0060yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: influxdb\nspec:\n  containers:\n    - name: influxdb\n      image: influxdb\n      ports:\n        - containerPort: 8086\n          hostPort: 8086\n\u0060\u0060\u0060\n\n这样做有个缺点，因为 Pod 重新调度的时候该 Pod 被调度到的宿主机可能会变动，这样就变化了，用户必须自己维护一个 Pod 与所在宿主机的对应关系。\n\n这种网络方式可以用来做 nginx [Ingress controller](https:\/\/github.com\/kubernetes\/ingress\/tree\/master\/controllers\/nginx) 。外部流量都需要通过 Kubernetes node 节点的 80 和 443 端口。\n\n## NodePort\n\nNodePort 在 Kubernetes 里是一个广泛应用的服务暴露方式。Kubernetes 中的 service 默认情况下都是使用的 \u0060ClusterIP\u0060 这种类型，这样的 service 会产生一个 ClusterIP，这个 IP 只能在集群内部访问，要想让外部能够直接访问 service，需要将 service type 修改为 \u0060nodePort\u0060。\n\n\u0060\u0060\u0060yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: influxdb\n  labels:\n    name: influxdb\nspec:\n  containers:\n    - name: influxdb\n      image: influxdb\n      ports:\n        - containerPort: 8086\n\u0060\u0060\u0060\n\n同时还可以给 service 指定一个 \u0060nodePort\u0060 值，范围是 30000-32767，这个值在 API server 的配置文件中，用 \u0060--service-node-port-range\u0060 定义。\n\n\u0060\u0060\u0060yaml\nkind: Service\napiVersion: v1\nmetadata:\n  name: influxdb\nspec:\n  type: NodePort\n  ports:\n    - port: 8086\n      nodePort: 30000\n  selector:\n    name: influxdb\n\u0060\u0060\u0060\n\n集群外就可以使用 kubernetes 任意一个节点的 IP 加上 30000 端口访问该服务了。kube-proxy 会自动将流量以 round-robin 的方式转发给该 service 的每一个 pod。\n\n这种服务暴露方式，无法让你指定自己想要的应用常用端口，不过可以在集群上再部署一个反向代理作为流量入口。\n\n## LoadBalancer\n\n\u0060LoadBalancer\u0060 只能在 service 上定义。这是公有云提供的负载均衡器，如 AWS、Azure、CloudStack、GCE 等。\n\n\u0060\u0060\u0060yaml\nkind: Service\napiVersion: v1\nmetadata:\n  name: influxdb\nspec:\n  type: LoadBalancer\n  ports:\n    - port: 8086\n  selector:\n    name: influxdb\n\u0060\u0060\u0060\n\n查看服务：\n\n\u0060\u0060\u0060bash\n$ kubectl get svc influxdb\nNAME       CLUSTER-IP     EXTERNAL-IP     PORT(S)          AGE\ninfluxdb   10.97.121.42   10.13.242.236   8086:30051\/TCP   39s\n\u0060\u0060\u0060\n\n内部可以使用 ClusterIP 加端口来访问服务，如 19.97.121.42:8086。\n\n外部可以用以下两种方式访问该服务：\n\n- 使用任一节点的 IP 加 30051 端口访问该服务\n- 使用 \u0060EXTERNAL-IP\u0060 来访问，这是一个 VIP，是云供应商提供的负载均衡器 IP，如 10.13.242.236:8086。\n\n## Ingress\n\n\u0060Ingress\u0060 是自 kubernetes1.1 版本后引入的资源类型。必须要部署 [Ingress controller](https:\/\/github.com\/kubernetes\/ingress\/tree\/master\/controllers\/nginx) 才能创建 Ingress 资源，Ingress controller 是以一种插件的形式提供。Ingress controller 是部署在 Kubernetes 之上的 Docker 容器。它的 Docker 镜像包含一个像 nginx 或 HAProxy 的负载均衡器和一个控制器守护进程。控制器守护程序从 Kubernetes 接收所需的 Ingress 配置。它会生成一个 nginx 或 HAProxy 配置文件，并重新启动负载平衡器进程以使更改生效。换句话说，Ingress controller 是由 Kubernetes 管理的负载均衡器。\n\nKubernetes Ingress 提供了负载平衡器的典型特性：HTTP 路由，粘性会话，SSL 终止，SSL 直通，TCP 和 UDP 负载平衡等。目前并不是所有的 Ingress controller 都实现了这些功能，需要查看具体的 Ingress controller 文档。\n\n\u0060\u0060\u0060yaml\napiVersion: extensions\/v1beta1\nkind: Ingress\nmetadata:\n  name: influxdb\nspec:\n  rules:\n    - host: influxdb.kube.example.com\n      http:\n        paths:\n          - backend:\n              serviceName: influxdb\n              servicePort: 8086\n\u0060\u0060\u0060\n\n外部访问 URL \u0060http:\/\/influxdb.kube.example.com\/ping\u0060 访问该服务，入口就是 80 端口，然后 Ingress controller 直接将流量转发给后端 Pod，不需再经过 kube-proxy 的转发，比 LoadBalancer 方式更高效。\n\n## 总结\n\n总的来说 Ingress 是一个非常灵活和越来越得到厂商支持的服务暴露方式，包括 Nginx、HAProxy、Traefik，还有各种 Service Mesh，而其它服务暴露方式可以更适用于服务调试、特殊应用的部署。\n', '\/blog\/accessing-kubernetes-pods-from-outside-of-the-cluster\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">关于在 Kubernetes 中暴露 Pod 及服务的五种方式。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/how-to-translate-a-book/">如何翻译一本外文书</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2017/10/27</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e9%9a%8f%e7%ac%94"> 
             随笔
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('如何翻译一本外文书', '如何翻译一本外文书，从图书引进到翻译出版全攻略。', '\n截止本文发稿时，笔者是以下两本云原生图书的译者：\n\n- [Cloud Native Go](\/book\/cloud-native-go)：已由电子工业出版社出版\n- [Cloud Native Python](\/book\/cloud-native-python)：正在翻译中\n\n同时我还参与了 [Kubernetes](https:\/\/kubernetes.io\/)、[Istio](https:\/\/istio.io) 的文档翻译，撰写了开源电子书 [kubernetes-handbook](\/book\/kubernetes-handbook)，下面是我本人在翻译过程中的的一些心得。\n\n{{\u003ccallout note 说明\u003e}}\n本文中使用的方法仅供参考，机器翻译有助您快速了解全书或文章的梗概，距离出版还需要大量的调整优化，请勿直接使用机器翻译结果输出。\n{{\u003c\/callout\u003e}}\n\n## 图书引进\n\n### 1. 联系出版社\n\n假如您看到一本很好的外文书籍想要翻译，首先需要联系出版社，询问该书是否已被引进，因为每年国内引进的外文书籍是有数量控制的，而且有的书也不是你先给引进就可以引进的，每年都有版权引进会议，国内的出版社统一参加确定引进的书籍，哪家引进多少本，哪一本分给哪一家等。可以与出版社编辑沟通，查看该书是否可以引进，是否已经有别的出版社引进且在翻译中，这个过程基本不需要你与原作者沟通。\n\n### 2. 取得图书引进的版权\n\n如果很幸运的，这本书可以引进到国内，而且还没有人来翻译，可以跟出版社编辑要求翻译这本书，如果书籍内容适当可以一个人翻译，如果内容较多可以分多个人翻译，建议人数不要超过 4 人。\n\n## 环境准备\n\n首先需要准备如下环境：\n\n- **Git**：用户版本管理，也方便在线查看，我使用 [码云](https:\/\/gitee.com) 私有代码库管理。\n- **Markdown 编辑器**：我推荐使用 [typora](https:\/\/typora.io)。\n- **Gitbook**：使用 [Gitbook](https:\/\/gitbook.com) 生成 web 页面便于阅读和查看，注意不要公开发布到 Github 上。\n- **Word**：虽然我们使用 markdown 编辑器来编辑，但是 word 还是需要的，因为编辑会在 word 中批注，再返回给你修改。\n- **Translation-shell**：命令行翻译工具，见 [Github](https:\/\/github.com\/soimort\/translate-shell)。如今的 AI 工具翻译效果更好，推荐使用 ChatGPT。\n\n## 翻译过程\n\n以下是我个人总结的图书翻译流程，仅供参考。\n\n### 1. 分析原版压缩包的结构\n\n以 [Cloud Native Python](\/book\/cloud-native-python) 这本书为例，原文的压缩包里包含以下目录：\n\n- **Code**：书中的代码示例\n- **Cover**：本书的封面图片\n- **E-Book**：本书的完成 PDF 文档（一个文件）\n- **Graphics**：书中的图片，按照章节和顺序编号，放在一个目录下，不一定与图片在书中出现的顺序相同，有些后来补充的图片会另外编号\n- **Printers**：用于印刷的 PDF 文档，分为封面和正文\n\n### 2. 初始化翻译项目\n\n我们使用 Git 来管理，使用 Gitbook 来预览，需要先初始化一些目录结构和 gitbook 配置。\n\n初始化的目录和文件：\n\n- **LANGS.md**：语言配置文件\n- **README.md**：项目说明\n- **book.json**：gitbook 配置文件\n- **cn**：中文翻译（按章节划分成不同的文件）\n- **corrigendum.md**：勘误表\n- **cover.jpg**：书籍封面\n- **en**：英文原文（按章节划分成不同的文件）\n- **glossary.md**：术语表\n- **images**：保存书中的图片\n\n让 Gitbook 支持多语言的 \u0060book.json\u0060 配置如下：\n\n\u0060\u0060\u0060json\n{\n    \u0022title\u0022: \u0022Cloud Native Python\u0022,\n    \u0022description\u0022: \u0022Cloud Native Python\u0022,\n    \u0022language\u0022: \u0022zh-hans\u0022,\n    \u0022author\u0022: \u0022Jimmy Song\u0022,\n    \u0022links\u0022: {\n    \u0022sidebar\u0022: {\u0022Home\u0022: \u0022https:\/\/jimmysong.io\u0022}\n    },\n    \u0022plugins\u0022: [\n        \u0022codesnippet\u0022,\n        \u0022splitter\u0022,\n        \u0022page-toc-button\u0022,\n        \u0022back-to-top-button\u0022,\n        \u0022-lunr\u0022, \u0022-search\u0022, \u0022search-plus\u0022,\n        \u0022tbfed-pagefooter@^0.0.1\u0022\n    ],\n    \u0022pluginsConfig\u0022: {\n        \u0022tbfed-pagefooter\u0022: {\n            \u0022copyright\u0022: \u0022Copyright © jimmysong.io 2017\u0022,\n            \u0022modify_label\u0022: \u0022Updated:\u0022,\n            \u0022modify_format\u0022: \u0022YYYY-MM-DD HH:mm:ss\u0022\n        }\n    }\n}\n\u0060\u0060\u0060\n\n\u0060LANG.md\u0060 文件中定义不同语言的文件目录：\n\n\u0060\u0060\u0060markdown\n# Languages\n\n* [中文](cn\/)\n* [English](en\/)\n\u0060\u0060\u0060\n\n### 3. 原文 Markdown 化\n\n{{\u003ccallout note 关于文档结构\u003e}}\n建议采用 Markdown 格式编辑翻译稿件。虽然 Gitbook 是一个推荐的结构组织方式，但考虑到出版物通常由多个章节构成，使用 Markdown 文件自主管理结构同样是一个良好的选择。同时，务必留意图片文件的存储位置。\n{{\u003c\/callout\u003e}}\n\n之所以将原文 Markdown 化一是便于我们后续翻译的时候对照英文和引用其中的原文，二是为了生成 gitbook 便于浏览。将每一章的内容都划分成一个 Markdown 文件，按照章节的名字为文档命名，分别在 \u0060cn\u0060 和 \u0060en\u0060 目录下都放一份。\n\n![中英文目录](cloud-native-python-cn-en.jpg)\n\n### 4. 开始正文的翻译\n\n建议从头开始按顺序翻译，如果前后章节联系不大的可以跳跃翻译，翻译的过程中将一些关键的术语，包括翻译不明确的，需要后续参考的数据记录在 \u0060glossary.md\u0060 文档中。\n\n格式如下所示：\n\n| English                       | 中文     | 说明             | 是否翻译 |\n| ----------------------------- | ------ | -------------- | ---- |\n| Cross-Origin Resource Sharing | 跨源资源共享 |                | 是    |\n| HTTP header                   |        |                | 否    |\n| Observable                    | 观察者    | 可以不翻译，中文翻译比较模糊 | 否    |\n| cookies                       |        | 不翻译，保持复数       | 否    |\n| module                        | 模块     |                | 是    |\n| origin                        | 源      | 有争议            | 是    |\n| session                       | 会话     |                | 否    |\n\n可以不断向其中追加新的术语。\n\n翻译的过程中需要用到翻译工具，我使用的是 [translation-shell](https:\/\/github.com\/soimort\/translate-shell)，一款基于命令行的翻译工具，可以使用 Google、bing 或者 Yandex 翻译，十分方便快捷。也推荐大家使用 [DeepL](https:\/\/www.deepl.com\/)，翻译效果更好。\n\n注：使用翻译工具是为了将书籍快速汉化，减少大量的人工输入，但是因为机器翻译比较生硬，而且其中难免有错误，需要译者投入大量心思去优化。\n\n#### Translation-shell\n\n使用 \u0060trans :zh -b -shell\u0060 进入 translation-shell 交互式界面，拷贝英文段落进去翻译成中文。\n\n![Translation-shell](translation-trans-terminal.jpg)\n\n注：推荐使用翻译质量更高的工具 [DeepL](https:\/\/deepl.com\/)（更新于 2022 年 02 月 22 日）。\n\n#### 使用 Typora 编辑中文翻译\n\n同时打开 \u0060en\u0060 和 \u0060cn\u0060 目录下的同一章节开始翻译。\n\n![中英文翻译界面](translation-typora-multi-language.jpg)\n\n#### 在 Gitbook 中查看\n\n使用 \u0060gitbook serve\u0060 启用 gitbook 服务，在 http:\/\/localhost:4000 页面上查看内容。\n\n首先会出来语言选择页面，我们可以分别选择中文和英文内容浏览，语言是在 \u0060LAGNS.md\u0060 文件中定义的。\n\n![Gitbook](translation-gitbook-cn-en.jpg)\n\n#### 导出为不同格式\n\n使用 typora 编辑完中文翻译后，可以导出为 pdf、word 等其它格式，我们导出为 word 格式后发送给编辑批阅。\n\n生成的 word 内容格式是这样的：\n\n![word 文档格式](translation-word-cn.jpg)\n\n我们可以看到生产的 word 文档仍然保留了代码的高亮，而且可读性也很好。\n\n### 5. 审校\n\n每当翻译完一章内容后就发送给编辑，编辑会使用 word 进行审校批注，根据编辑的批注修改后再发回给编辑。\n\n![word review 界面](translation-word-review.jpg)\n\n### 6. 二审\n\n当所有的章节分别翻译和审校完成后，需要在通读一遍全书，更正前后不一致和翻译中的谬误，然后交给编辑等待排版。这时候还要准备写译者序，还要找人写推荐序。翻译版的图书封面会沿用原书的封面。\n\n### 7. 印刷\n\n当正文、译者序、推荐序都完成后就可以交给出版社印刷了，一般初次会印刷几千本。\n\n### 8. 后续事宜\n\n书籍印刷后后续事宜主要包括：\n\n- 出版社支付稿费：翻译图书稿费 = 图书销量 x 定价 x4%，著作一般为 8%\n- 配合图书宣传：一些 meetup、大会、线上交流时推荐图书\n- 读者交流：可以开设社区、微信群、网站等交流\n\n## 贴士\n\n图书翻译耗时费力，倾注了原作者和译者的很多心力，打击盗版，维护正版！\n\n## 参考\n\n- [自用的 “科技文章翻译 GPT” 和它的 Prompt - baoyu.io](https:\/\/baoyu.io\/blog\/prompt-engineering\/my-translator-bot)\n- [非文学翻译理论与实践 - book.douban.com](https:\/\/book.douban.com\/subject\/1289408\/)\n', '\/blog\/how-to-translate-a-book\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">如何翻译一本外文书，从图书引进到翻译出版全攻略。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/keuc-china-2017/">记 Kubernetes 中国用户大会 KEUC 2017</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2017/10/14</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e9%9a%8f%e7%ac%94"> 
             随笔
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('记 Kubernetes 中国用户大会 KEUC 2017', '2017 年 10 月 15 日，杭州，一场顶级的 Kubernetes 行业用户落地大会。', '\n今天受 k8smeetup 社区邀请来到杭州，参加 Kubernetes 中国用户大会简称 [KEUC](http:\/\/keuc.k8smeetup.com\/)，这已经是我第三次来杭州了，算是再续前缘吧！\n\n其实今年 6 月 19 日 LinuxCon \u002b ContainerCon \u002b CloudOpen 简称 [L3 大会](https:\/\/www.bagevent.com\/event\/561769)在北京国家会议中心召开，那是我跟 [CNCF](https:\/\/cncf.io) 首次相会，也获得了我的首批贴纸，该社区的一系列活动吸引了我浓浓的兴趣，自那以后开始持续关注 CNCF 的社区活动。\n\n借用孙中山先生在黄埔军校的训词，愿 Kubernetes 携手云原生应用，让 IT 基础设施和软件开发流程进入新的纪元。\n\n**云原生主义歌**\n\n\u003e 库巴内提，吾辈所宗；携云原生，以进大同。\n\u003e 咨尔多士，为民前锋；夙夜匪懈，主义是从。\n\u003e 创业维艰，矢勤矢勇；同心共德，贯彻始终。\n\n祝愿明天的大会圆满成功！\n\n---\n\n今天不小心获得了 k8smeetup 最佳技术专栏作者和社区最佳译者奖，感谢 CNCF 和 k8smeetup 社区。\n\n![k8smeetup 译者合影](kubc-translator.jpg)\n\n然后跟 CNCF 执行副总裁 Dan Kohn 探讨了下云原生技术在中国的推广，明年在中国会有云原生相关大会。\n\n![Jimmy 和 CNCF 执行副总裁 Dan Kohn 在一起](keuc-with-dan-kohn.jpg)\n\n欢迎大家持续关注云原生的发展。\n', '\/blog\/keuc-china-2017\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">2017 年 10 月 15 日，杭州，一场顶级的 Kubernetes 行业用户落地大会。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/what-is-a-service-mesh/">什么是 Service Mesh（服务网格）？</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2017/09/20</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('什么是 Service Mesh（服务网格）？', '本文介绍了 Service Mesh 是什么，其工作原理并提供了一些有用的链接。', '\nService Mesh 又译作“服务网格”，作为服务间通信的基础设施层。Buoyant 公司的 CEO Willian Morgan 在他的这篇文章 WHAT’S A Service Mesh? AND WHY DO I NEED ONE? 中解释了什么是 Service Mesh，为什么云原生应用需要 Service Mesh。\n\n下面是 [Willian Morgan](https:\/\/twitter.com\/wm) 对 Service Mesh 的解释。\n\n\u003e A Service Mesh is a dedicated infrastructure layer for handling service-to-service communication. It’s responsible for the reliable delivery of requests through the complex topology of services that comprise a modern, cloud native application. In practice, the Service Mesh is typically implemented as an array of lightweight network proxies that are deployed alongside application code, without the application needing to be aware.\n\n翻译成中文是：\n\n\u003e 服务网格（Service Mesh）是处理服务间通信的基础设施层。它负责构成现代云原生应用程序的复杂服务拓扑来可靠地交付请求。在实践中，Service Mesh 通常以轻量级网络代理阵列的形式实现，这些代理与应用程序代码部署在一起，对应用程序来说无需感知代理的存在。\n\n## Service Mesh 的特点\n\nService Mesh 有如下几个特点：\n\n- 应用程序间通信的中间层\n- 轻量级网络代理\n- 应用程序无感知\n- 解耦应用程序的重试\/超时、监控、追踪和服务发现\n\n目前两款流行的 Service Mesh 开源软件 [Istio](https:\/\/istio.io) 和 [Linkerd](https:\/\/linkerd.io) 都可以直接在 Kubernetes 中集成，其中 Linkerd 已经成为 CNCF 中的项目。\n\n## 理解 Service Mesh\n\n如果用一句话来解释什么是 Service Mesh，可以将它比作是应用程序或者说微服务间的 TCP\/IP，负责服务之间的网络调用、限流、熔断和监控。对于编写应用程序来说一般无须关心 TCP\/IP 这一层（比如通过 HTTP 协议的 RESTful 应用），同样使用 Service Mesh 也就无须关心服务之间的那些原本通过服务框架实现的事情，比如 Spring Cloud、Netflix OSS 和其他中间件，现在只要交给 Service Mesh 就可以了。\n\n[Phil Calçado](http:\/\/philcalcado.com\/) 在他的这篇博客 [Pattern: Service Mesh](http:\/\/philcalcado.com\/2017\/08\/03\/pattern_service_mesh.html) 中详细解释了 Service Mesh 的来龙去脉：\n\n1. 从最原始的主机之间直接使用网线相连\n2. 网络层的出现\n3. 集成到应用程序内部的控制流\n4. 分解到应用程序外部的控制流\n5. 应用程序的中集成服务发现和断路器\n6. 出现了专门用于服务发现和断路器的软件包\/库，如 [Twitter 的 Finagle](https:\/\/finagle.github.io\/) 和 [Facebook  的 Proxygen](https:\/\/code.facebook.com\/posts\/1503205539947302)，这时候还是集成在应用程序内部\n7. 出现了专门用于服务发现和断路器的开源软件，如 [Netflix OSS](http:\/\/netflix.github.io\/)、Airbnb 的 [synapse](https:\/\/github.com\/airbnb\/synapse) 和 [nerve](https:\/\/github.com\/airbnb\/nerve)\n8. 最后作为微服务的中间层 Service Mesh 出现\n\nService Mesh 的架构如下图所示：\n\n![Service Mesh 架构图](service-mesh-arch.png)\n\n图片来自：[Pattern: Service Mesh](http:\/\/philcalcado.com\/2017\/08\/03\/pattern_service_mesh.html)\n\nService Mesh 作为 sidecar 运行，对应用程序来说是透明，所有应用程序间的流量都会通过它，所以对应用程序流量的控制都可以在 Service mesh 中实现。\n\n## Service Mesh 如何工作？\n\n下面以 Istio 为例讲解 Service Mesh 如何工作，后续文章将会详解 Istio 如何在 Kubernetes 中工作。\n\n1. Sidecar（Istio 中使用 [Envoy](https:\/\/envoyproxy.io) 作为 sidecar 代理）将服务请求路由到目的地址，根据请求中的参数判断是到生产环境、测试环境还是 staging 环境中的服务（服务可能同时部署在这三个环境中），是路由到本地环境还是公有云环境？所有的这些路由信息可以动态配置，可以是全局配置也可以为某些服务单独配置。这些配置是由服务网格的控制平面推送给各个 sidecar 的，\n2. 当 sidecar 确认了目的地址后，将流量发送到相应服务发现端点，在 Kubernetes 中是 service，然后 service 会将服务转发给后端的实例。\n3. Sidecar 根据它观测到最近请求的延迟时间，选择出所有应用程序的实例中响应最快的实例。\n4. Sidecar 将请求发送给该实例，同时记录响应类型和延迟数据。\n5. 如果该实例挂了、不响应了或者进程不工作了，sidecar 会将把请求发送到其他实例上重试。\n6. 如果该实例持续返回 error，sidecar 会将该实例从负载均衡池中移除，稍后再周期性得重试。\n7. 如果请求的截止时间已过，sidecar 主动标记该请求为失败，而不是再次尝试添加负载。\n8. SIdecar 以 metric 和分布式追踪的形式捕获上述行为的各个方面，这些追踪信息将发送到集中 metric 系统。\n\n## 为何使用 Service Mesh？\n\nService Mesh 并没有给我们带来新功能，它是用于解决其他工具已经解决过的问题，只不过这次是在以 Kubernetes 为基础的云原生生态环境下的实现。\n\n在传统的 MVC 三层 Web 应用程序架构下，服务之间的通讯并不复杂，在应用程序内部自己管理即可，但是在现今的复杂的大型网站情况下，单体应用被分解为众多的微服务，服务之间的依赖和通讯十分复杂，出现了 twitter 开发的 [Finagle](https:\/\/twitter.github.io\/finagle\/)、Netflix 开发的 [Hystrix](https:\/\/github.com\/Netflix\/Hystrix) 和 Google 的 Stubby 这样的“胖客户端”库，这些就是早期的 Service Mesh，但是它们都仅适用于特定的环境和特定的开发语言，并不能作为平台级的 Service Mesh 支持。\n\n在 Cloud Native 架构下，容器的使用赋予了异构应用程序更多的可能性，Kubernetes 增强了应用的横向扩容能力，用户可以快速的编排出复杂环境、复杂依赖关系的应用程序，同时开发者又无须过分关心应用程序的监控、扩展性、服务发现和分布式追踪这些繁琐的事情，进而专注于程序开发，赋予开发者更多的创造性。\n\n## 参考\n\n- What\u0027s a Service Mesh? And why do I need one?\n- [So what even is a Service Mesh? Hot take on Istio and Linkerd](http:\/\/redmonk.com\/jgovernor\/2017\/05\/31\/so-what-even-is-a-service-mesh-hot-take-on-istio-and-linkerd)\n- [linkerd: A Service Mesh for AWS ECS](https:\/\/medium.com\/attest-engineering\/linkerd-a-service-mesh-for-aws-ecs-937f201f847a)\n- [Introducing Istio: A robust Service Mesh for microservices](https:\/\/istio.io\/blog\/istio-service-mesh-for-microservices.html)\n- [Application Network Functions With ESBs, API Management, and Now.. Service Mesh?](http:\/\/blog.christianposta.com\/microservices\/application-network-functions-with-esbs-api-management-and-now-service-mesh\/)\n- [Pattern: Service Mesh](http:\/\/philcalcado.com\/2017\/08\/03\/pattern_service_mesh.html)\n- [Envoy 官方文档](https:\/\/envoyproxy.io)\n- [Istio 官方文档](https:\/\/istio.io\/)\n\n', '\/blog\/what-is-a-service-mesh\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文介绍了 Service Mesh 是什么，其工作原理并提供了一些有用的链接。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
          <div class="col-12">
 
 
 
 
 
 
 
 
 
 
 
 <nav aria-label="Page navigation">
   <ul class="pagination justify-content-center">
     
     
     <li class="page-item">
       <a class="page-link" href="/blog/">
         ««
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a href="/blog/page/27/" class="page-link">
         «
       </a>
     </li>
     
     
     
       
       
       
         
         
         
           
           
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
             
           
         
         
       
       
       
       
         <li class="page-item">
           <a href="/blog/page/25/" class="page-link">
             25
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
       
       
       
       
         <li class="page-item">
           <a href="/blog/page/26/" class="page-link">
             26
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
       
       
       
       
         <li class="page-item">
           <a href="/blog/page/27/" class="page-link">
             27
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
       
       
       
       
         <li class="page-item page-item active ">
           <a href="/blog/page/28/" class="page-link">
             28
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
       
       
       
       
         <li class="page-item">
           <a href="/blog/page/29/" class="page-link">
             29
           </a>
         </li>
       
     
     
     
     <li class="page-item">
       <a href="/blog/page/29/" class="page-link">
         »
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a class="page-link" href="/blog/page/29/">
         »»
       </a>
     </li>
     
   </ul>
 </nav>
 
</div>

        </div>
      </div>
      <!-- sidebar -->
      <aside class="col-lg-4 order-1 order-lg-2 d-none d-sm-block">
          <div class="sidebar">
          <!-- categories -->
<div class="blog-categories mb-4">
  <p class="sidebar-title">
      专栏
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/istio" class="sidebar-item">
            <span>Istio</span>
            <span>(83)</span>
        </a>
      
        <a href="/categories/service-mesh" class="sidebar-item">
            <span>Service Mesh</span>
            <span>(42)</span>
        </a>
      
        <a href="/categories/kubernetes" class="sidebar-item">
            <span>Kubernetes</span>
            <span>(25)</span>
        </a>
      
        <a href="/categories/%e9%9a%8f%e7%ac%94" class="sidebar-item">
            <span>随笔</span>
            <span>(22)</span>
        </a>
      
        <a href="/categories/%e5%85%b6%e4%bb%96" class="sidebar-item">
            <span>其他</span>
            <span>(20)</span>
        </a>
      
        <a href="/categories/envoy" class="sidebar-item">
            <span>Envoy</span>
            <span>(18)</span>
        </a>
      
        <a href="/categories/%e4%b8%9a%e6%80%81" class="sidebar-item">
            <span>业态</span>
            <span>(17)</span>
        </a>
      
        <a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f" class="sidebar-item">
            <span>云原生</span>
            <span>(14)</span>
        </a>
      
        <a href="/categories/ai" class="sidebar-item">
            <span>AI</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%ae%89%e5%85%a8" class="sidebar-item">
            <span>安全</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%bc%80%e6%ba%90" class="sidebar-item">
            <span>开源</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e6%97%85%e8%a1%8c" class="sidebar-item">
            <span>旅行</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e5%b7%a5%e5%85%b7" class="sidebar-item">
            <span>工具</span>
            <span>(7)</span>
        </a>
      
        <a href="/categories/%e5%8f%af%e8%a7%82%e6%b5%8b%e6%80%a7" class="sidebar-item">
            <span>可观测性</span>
            <span>(5)</span>
        </a>
  </div>
</div>

<div class="blog-categories mb-4">
  <p class="sidebar-title">
      资料
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/%e5%87%ba%e7%89%88%e7%89%a9" class="sidebar-item">
            <span>出版物</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e7%94%b5%e5%ad%90%e4%b9%a6" class="sidebar-item">
            <span>翻译电子书</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e6%96%87%e6%a1%a3" class="sidebar-item">
            <span>翻译文档</span>
            <span>(7)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>翻译图书</span>
            <span>(6)</span>
        </a>
      
        <a href="/categories/%e5%8e%9f%e5%88%9b%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>原创图书</span>
            <span>(2)</span>
        </a>
      
        <a href="/categories/%e6%95%99%e7%a8%8b%e6%89%8b%e5%86%8c" class="sidebar-item">
            <span>教程手册</span>
            <span>(2)</span>
        </a>
  </div>
</div>





          </div>
      </aside>
      <!-- /sidebar -->
    </div>
  </div>
</section>




<footer>
  
  <div class="footer bg-footer section-sm border-bottom overlay ">
    <div class="container-xl">
      <div class="row">
        <div class="col col-xl-4 d-sm-none mb-2 mb-lg-0 d-xl-block d-none">
          
          <p class="h3 text-white mb-4 text-uppercase">联系</p>
          
          <ul class="list-unstyled">
            
            
            <li class="mb-4 text-color">微信公众号</li>
            
            
            <li class="mb-4"><img src="/images/servicemesher-wechat.webp" width="118px" height="118px" alt="footer image"></li>
            
            
            
          
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">博客</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/blog/napkin-ai-visualization-tool/">AI 工具推荐 Napkin.ai：让复杂想法一键变成直观图表</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/cilium-annual-report-2024/">Cilium 2024 年度报告解读</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/istio-ambient-packet-lifecycle-optimization/">Istio Ambient 模式中的数据包生命周期及流量优化</a></li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">链接</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://istio.io/latest/zh/" target="_blank" rel="noopener noreferrer">
                  Istio 服务网格
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://tetrate.io/?jimmysong" target="_blank" rel="noopener noreferrer">
                  Tetrate 公司
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener noreferrer">
                  云原生学院|Bilibili
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/awesome-cloud-native/" target="_blank" rel="noopener noreferrer">
                  云原生开源项目大全
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://cloudnative.to" target="_blank" rel="noopener noreferrer">
                  云原生社区（中国）
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">教程</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/envoy-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Envoy 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/istio-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Istio 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/kubernetes-handbook/" >
                  Kubernetes 基础教程
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/envoy-made-simple/" >
                  简明 Envoy 教程
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">通知</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/notice/cloud-native-community-domain-migration/">云原生社区网站域名变更通知</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/nist-sp-800-233-service-mesh-proxy-models/">资料分享：云原生应用服务网格代理模型的威胁分析指南</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/kubecon-china-2024-panel/">KubeCon China 2024（香港）</a></li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>

  
  <div class="copyright py-4 bg-footer overlay">
    <div class="container-xl">
      <div class="row">
        <div class="col-sm-6 text-sm-left text-center">
          <p class="mb-0 text-color">© 2017-2024 Jimmy Song 保留所有权利</p>
        </div>
        <div class="col-sm-6 text-sm-right text-center">
          <ul class="list-inline">
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://twitter.com/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-x-twitter text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/contact/" >
                    <i class="fa-brands fa-weixin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://github.com/rootsongjc" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-github text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://linkedin.com/in/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-linkedin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="mailto:rootsongjc@gmail.com" >
                    <i class="fa-solid fa-envelope text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/blog/index.xml" >
                    <i class="fa-solid fa-rss text-white"></i>
              </a>
            </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>


<!-- JS Plugins -->

<script src="/plugins/popper/popper.min.js"></script>

<script src="/plugins/bootstrap/bootstrap.min.js"></script>

<script src="/plugins/slick/slick.min.js"></script>

<script src="/plugins/filterizr/jquery.filterizr.min.js"></script>

<script src="/plugins/search/fuse.min.js"></script>

<script src="/plugins/search/mark.js"></script>

<script src="/plugins/hex_md5/hex_md5.js"></script>

<script src="/plugins/anchor/anchor.min.js"></script>

<script src="/plugins/tocbot/tocbot.min.js"></script>

<script src="/plugins/bigger-picture/bigger-picture.min.js"></script>


<!-- Main Script -->

<script src="/js/script.min.f94c22b1d478bfc9e2e0a7d954429e47b7e6d36edd423758482e04154ae1842e.js"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-ESY906ZWZ0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ESY906ZWZ0');
</script>


<!-- Baidu analysis -->
<meta name="baidu-site-verification" content="g8IYR9SNLF" />





<script>
    anchors.add();
</script>






<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>










<script src="/js/wowchemy-search.min.7a37268e7bbe4a9160c2e4c33b749816.js" type="module"></script>
<script id="search-hit-fuse-template" type="text/x-template">
  <div class="search-hit" id="summary-{{key}}">
    <div class="search-hit-content border-bottom">
      <div class="search-hit-name">
        <div class='search-hit-link'><a href="{{relpermalink}}">{{title}}</a></div>
        <div class="search-hit-metadata d-flex">
            <span class="mr-1"><i class="fa-regular fa-calendar mr-1"></i>{{date}}</span>
            <span class="mr-1"><i class="fa-regular fa-folder-open mr-1"></i>{{section}}</span>
            <span class="d-sm-block d-none"><i class="fa-solid fa-link mr-1"></i>{{relpermalink}}</span>
        </div>
        <div class="search-hit-description">{{snippet}}</div>
      </div>
    </div>
  </div>
</script>



    </body>
</html>
