<!DOCTYPE html>
<html lang="zh"><head>
  <meta charset="utf-8">
  
  <title>博客 - Jimmy Song</title>
  

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta name="description" content="专注开源技术、云原生与生活随笔的分享与思考。">
  <meta name="author" content="Jimmy Song">
  <meta name="generator" content="Hugo 0.136.0">

  <!-- CSS plugins -->
  
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
  
  <link rel="preload" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" as="style">
  <link rel="stylesheet" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" media="screen">
  

  <!-- Main Stylesheet -->
  
  <link rel="preload" href="/scss/style.min.f6911c0ac7d2b5b69c3f2d9f2a2b3b496b5da0608580347fdb4dc11ef74f3ec5.css" as="style">
  <link rel="stylesheet" href="/scss/style.min.f6911c0ac7d2b5b69c3f2d9f2a2b3b496b5da0608580347fdb4dc11ef74f3ec5.css" media="screen">

  <!-- Bigger picture css -->
  
  <link rel="stylesheet" href="/plugins/bigger-picture/bigger-picture.min.css" media="print" onload="this.media='all'">
  <!--Favicon generate by https://realfavicongenerator.net-->
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="200x200" href="/images/favicon.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">

  <link href='/opensearchdescription.xml' rel='search' title='Content search' type='application/opensearchdescription+xml'/>

  <!--Twitter card-->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="jimmysong.io" />
  <meta name="twitter:creator" content="@jimmysongio" />
  <meta property="og:url" content="https://jimmysong.io/blog/" />
  <meta property="og:title" content="博客 | Jimmy Song" />
  <meta property="twitter:title" content="博客 | Jimmy Song" />

  
  <meta property="og:description" content="专注开源技术、云原生与生活随笔的分享与思考。" />
  <meta property="twitter:description" content="专注开源技术、云原生与生活随笔的分享与思考。" />

  
  <meta property="og:image" content="https://jimmysong.io/images/banner/default.jpg" />
  <meta property="twitter:image" content="https://jimmysong.io/images/banner/default.jpg" />

  
  
</head>
<body>
<header class="fixed-top header">
  
  
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa fa-arrow-circle-up" aria-hidden="true"></i></button>
  
  <div class="navigation w-100 ">
    <div class="container-xl">
      <nav class="navbar navbar-expand-lg navbar-light p-0">
        <a class="navbar-brand" href="/">
            
            <b>JIMMY SONG</b>
            
        </a>
        <button class="navbar-toggler rounded-0" type="button" data-toggle="collapse" data-target="#navigation"
          aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse text-center" id="navigation">
          <ul class="navbar-nav ml-auto">
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/blog">博客</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/book">资料</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/tags">标签</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/notice">公告</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/contact">联系</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/about">关于</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/community/">社区</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener">视频 <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i></a>
              
            </li>
            
            

          
          
          <li class="nav-item">
            
            
            
              
              
                
                
                
                  
                    
                    <a class="nav-link" href="/en/blog/">English</a>
                    
                  
                
              
              
              
                
                  
                    
                    
                  
                
                
                
              
          </li>
          
          
          <!-- search -->
           <button type="button" class="search-btn js-search" id="searchOpen" aria-label="Search">
              <div class="search-container d-flex justify-content-center">
              <span class="search-content">
                  <i class="fa fa-search"></i>
                  <span>搜索</span>
              </span>
              <span class="search-shortcuts d-none d-sm-block">
                  <kbd class="cmd-key">⌘</kbd>
                  <kbd class="k-key">K</kbd>
              </span>
              </div>
          </button>
          
          </ul>
        </div>
      </nav>
    </div>
  </div>
</header>


            <aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between">
        <div class="col-6 search-title">
          <p>站内搜索</p> 
        </div>
        <div class="col-6 col-search-close">
          <div class="js-search" aria-label="关闭"><i class="fa-solid fa-circle-xmark text-muted" aria-hidden="true"></i></div>
        </div>
      </div>

      <div id="search-box">
        <i class="fa-solid fa-magnifying-glass" id="search-icon" aria-hidden="true"></i>
        <input name="q" id="search-query" placeholder="请输入搜索词" autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control" aria-label="请输入搜索词">
        
        <div class="mt-4">
          <span>搜索类型: </span>
          <span>
            <input type="radio" id="all" name="search_type" value="all" checked>
            <label for="all">所有</label>
            
              <input type="radio" id="blog" name="search_type" value="blog">
              <label for="blog">原创</label>
              <input type="radio" id="trans" name="search_type" value="trans">
              <label for="trans">译文</label>
            
            <input type="radio" id="book" name="search_type" value="book">
            <label for="book">资料</label>
            <input type="radio" id="notice" name="search_type" value="notice">
            <label for="notice">公告</label>
          </span>
        </div>
      </div>
      
    </section>
    <section class="section-search-results">
      <div id="search-results-count" class="search-results-count"></div>
      <div id="search-hits">
        
      </div>
    </section>
  </div>
</aside>

        
        
            

<section class="bg-cover page-title-section overlay" style="background-image: url('/images/backgrounds/circle.svg'),url('/images/backgrounds/page-title.webp');background-size: cover;">
    <div class="container-xl">
        <div class="row">
            <div class="col-12">
                <p class="h1">
                    博客
                </p>
                <p class="page-description">
                    专注开源技术、云原生与生活随笔的分享与思考。
                </p>
                
            </div>
        </div>
    </div>
</section>

        


<section class="section-sm book-list-section bg-gray">
  <div class="container-xl">
    <div class="row">
      <div class="col-lg-8 order-2 order-lg-1">
        <div class="row">
          
          
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/crossing-the-chasm/">跨越鸿沟：理解鸿沟理论</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/01/09</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e9%9a%8f%e7%ac%94"> 
             随笔
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('跨越鸿沟：理解鸿沟理论', '本文将为读者分享一些关于“鸿沟理论”有关的一些知识，希望能够引发大家对于新技术推广的一些思考。', '\n最近为某网站撰写服务网格技术的 2021 年总结，笔者关注该领域也有 4 年时间了，再结合自己最近这几年对云原生行业发展的观察，越发觉得《跨越鸿沟》（Crossing the chasm）这本书中所写的新技术的推广生命周期一一应验了。虽然该理论由 Jeffery Moore 于 1991 年提出，距今已有 30 年时间，但该理论至今依然奏效，另外该理论也在 [CNCF 项目](https:\/\/www.cncf.io\/projects\/)的成熟度划分中得到应用，还有人指出过[云原生技术需要跨越的鸿沟](https:\/\/www.infoq.cn\/article\/hv5dft_bgjdfpqongzqx)。本文将为读者分享一些关于”鸿沟理论“有关的一些知识，希望能够引发大家对于新技术推广的一些思考。\n\n## 什么是鸿沟理论？\n\n鸿沟理论指的就是高科技产品在市场营销过程中遭遇的最大障碍：高科技企业的早期市场和主流市场之间存在着一条巨大的鸿沟，能否顺利跨越鸿沟并进入主流市场，成功赢得实用主义者的支持，就决定了一项高科技产品的成败。实际上每项新技术都会经历鸿沟。关键在予采取适当的策略令高科技企业成功地“跨越鸿沟”，摩尔在这本书中就告诉了人们一些欠经考验的制胜秘诀。\n\n## 前言\n\n基于经典的钟形曲线分布，“跨越鸿沟 \u0022 是一个将新技术的采用随时间推移而可视化的概念：从一小撮早期采用者开始，经过大规模的中端市场，最终进入最抗拒变化的消费者手中。\n\n1962 年，社会学家 [Everett Rogers](https:\/\/en.wikipedia.org\/wiki\/Everett_Rogers) 出版了 [Diffusion of Innovasions](https:\/\/en.wikipedia.org\/wiki\/Diffusion_of_innovations)（创新扩散）一书。在这本书中，他根据消费者的购买行为，将他们分为不同的群体。他以 500 多项扩散研究的结果为基础进行分类。今天，这个模型被称为“技术采用生命周期”。这个模型全面地描述了新技术产品或创新的采用或接受情况。在《跨越鸿沟》一书中，杰弗里・摩尔根据扩散生命周期中的客户群体，阐述了成功锁定主流消费者的营销技巧。\n\n## 客户群体\n\n基于人口学和心理学特征，客户群保护以下五种：\n\n- 创新者\n- 早期采用者\n- 早期大众\n- 后期大众\n- 落后者\n\n![图：”鸿沟理论“客户分布情况](crossing-the-chasm.jpg)\n\n## 分布情况\n\n正如可以观察到的，技术采用的生命周期有一个钟形曲线。各个分界线大约相当于标准差的落点。这意味着：\n\n- 创新者约占总人口的 2.5%\n- 早期采用者约占 13.5%\n- 早期大众和后期大众均为 34%\n- 落后者占剩余的 16%\n\n每个群体都代表着一个独特的心理特征，即心理和人口特征的组合。因此，针对这些群体的营销需要与其他群体完全不同的策略。营销人员通过更好地了解这些群体之间的差异，可以通过正确的营销技术更好地锁定所有这些消费者。\n\n### 创新者\n\n创新者是技术爱好者。这是第一个有可能投资于你产品的消费者群体。创新者积极地追求新的产品和技术。有时，他们甚至在公司启动正式的营销计划之前就开始寻求创新。这是因为技术在他们的生活或业务中占据了核心利益。对于这个客户群体来说，产品功能组合的完整性或性能是次要的。\n\n不幸的是，在任何特定的细分市场中，都没有很多创新者（大约 2.5%）。通常情况下，他们不愿意为新产品付出很多。尽管如此，赢得他们是很重要的，因为他们的认可为市场上的其他消费者提供了必要的保证。此外，技术爱好者可以作为一个测试小组，在面向主流市场之前进行必要的修改。\n\n### 早期采用者\n\n和创新者一样，早期采用者也是有远见的人，他们在新产品的生命周期的早期就接受了新产品的概念。然而，与创新者不同，他们不是技术专家。相反，他们是有远见的人，不只是在寻找一种改进，而且是一种革命性的突破。因此，他们愿意承担高风险，尝试新事物。他们是对价格最不敏感的客户群体，对产品的功能设置和性能要求很高。\n\n早期采用者在做出购买决定时不依赖成熟的参考资料。相反，他们更愿意依靠自己的直觉和眼光。此外，他们愿意作为其他采用者群体的参考。由于有远见的人善于提醒其他人群，他们是最重要的争取对象。\n\n### 早期大众\n\n这个客户群由实用主义者组成。前两个采用者群体属于早期市场。然而，为了获得真正的成功，一个公司必须从早期大众开始，赢得主流市场。这些实用主义者与早期采用者有一些相同的能力，能够与技术产生联系。然而，他们受到强烈的实用意识的驱动。他们知道，很多发明最终会成为过眼云烟。因此，在自己投资之前，他们更期望等待，看看其他客户对该技术的使用情况如何。他们希望在进行大量投资之前看到成熟的参考资料。因为这部分人很多（大约 34%），对于任何努力争取大量利润和增长的企业来说，赢得这些人的支持是最基本的。\n\n### 后期大众\n\n这个群体主要由保守派组成。后期大众作为一个群体与早期大众一样大（占总人口的 34%）。他们与早期大众有着同样的担忧。此外，他们对传统的信仰远远多于对进步的信仰。早期大众的顾客如果决定购买新技术产品，他们对自己处理该产品的能力感到满意。相比之下，“后期大众 \u0022 的成员则不然。因此，这些保守派更愿意等到某样东西已经成为一种惯例时才购买。\n\n### 落后者\n\n这个群体是由怀疑论者组成的。这一部分人占总数的 16%。这些人根本不希望与新技术有任何关系。他们唯一一次购买技术产品是当它被深埋在另一个产品中时。这些持怀疑态度的人强烈认为，颠覆性的创新很少能实现他们的承诺。他们总是担心意外的后果。从市场发展的角度来看，落后者通常被认为是不值得追求的。然而，他们对产品功能设置和性能的批评为技术公司提供了宝贵的反馈。\n\n## 鸿沟\n\n在技术采用生命周期中，你可以看到早期采用者和早期大众群体之间的差距。这个差距代表了技术必须跨越的鸿沟。它标志着将左边的群体作为右边的客户群的参考基础而产生的可信度差距。**鸿沟的存在是因为消费者信任属于他们自己的采用者群体的人的推荐。**\n\n当然，这给技术公司带来了一个具有挑战性的困境。\n\n如果他们还没有从你这里买过东西，你怎么能利用首选参考群体的人呢？\n\n换句话说，将一个群体的客户作为其他群体的参考是无效的。因此，鸿沟就是这样产生的！\n\n由于从早期采用者到早期大众的飞跃意味着从早期市场到主流市场的过渡，跨越鸿沟对于新推出的产品 \/ 技术真正实现市场成功是最重要的。\n\n## 总结\n\n根据摩尔的说法，成功跨越鸿沟可以通过首先瞄准早期大众中一个非常具体的利基市场来实现。组织试图跨越鸿沟的唯一目标应该是在主流市场上获得一个桥头堡，以创造一个可供参考的实用主义客户群。在这里，细分就是一切：将你所有的营销资源集中在一个特定的细分市场上，并确保你在这个特定的细分市场上成为领导者，然后再去做下一个细分市场。这就是所谓的“大鱼小池 \u0022 的方法。营销漏斗或 AIDA 模型是一个很好的营销框架，它可以帮助为潜在客户挑选正确的营销技术。此外，确保你的产品提供一个完整的解决方案，并且服务水平高（即整个产品解决方案）。实用主义者对你的产品的用户体验将最终决定他们是否也会激起他们的同行。一旦你在早期大众的不同部分建立了强大的口碑，你就成功地跨越了鸿沟。\n\n## 更多\n\n你觉得服务网格目前处于鸿沟理论的哪个阶段呢？你又是何种受众？\n\n## 参考\n\n- [《Crossing the Chasm》丨 NOTES - jianshu.com](https:\/\/www.jianshu.com\/p\/a305fa93580b)\n- [灵雀云 CTO 陈恺：从“鸿沟理论”看云原生，哪些技术能够跨越鸿沟？ - infoq.cn](https:\/\/www.infoq.cn\/article\/hv5dft_bgjdfpqongzqx)\n', '\/blog\/crossing-the-chasm\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文将为读者分享一些关于“鸿沟理论”有关的一些知识，希望能够引发大家对于新技术推广的一些思考。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/ebpf-solve-service-mesh-sidecar/">[译] 告别 Sidecar——使用 eBPF 解锁内核级服务网格</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2021/12/09</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://isovalent.com/blog/post/2021-12-08-ebpf-servicemesh" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('告别 Sidecar——使用 eBPF 解锁内核级服务网格', '本文回顾了 Linux 内核的连接性，实现服务网格的几种模式，以及如何使用 eBPF 实现无 Sidecar 的服务网格。', '\n译者注：本文作者是 Isovalent 联合创始人\u0026CTO，原文标题 [How eBPF will solve Service Mesh - Goodbye Sidecars](https:\/\/isovalent.com\/blog\/post\/2021-12-08-ebpf-servicemesh)，作者回顾了 Linux 内核的连接性，实现服务网格的几种模式，以及如何使用 eBPF 实现无 Sidecar 的服务网格。\n\n------\n\n## 什么是服务网格？\n\n随着分布式应用的引入，额外的可见性、连接性和安全性要求也浮出水面。应用程序组件通过不受信任的网络跨越云和集群边界进行通信，负载均衡、弹性变得至关重要，安全必须发展到发送者和接收者都可以验证彼此的身份的模式。在分布式应用的早期，这些要求是通过直接将所需的逻辑嵌入到应用中来解决的。服务网格将这些功能从应用程序中提取出来，作为基础设施的一部分提供给所有应用程序使用，因此不再需要修改每个应用程序。\n\n![服务网格示意图](008i3skNly1gx7wyna8jsj32e20sojtx.jpg)\n\n纵观今天服务网格的功能设置，可以总结为以下几点：\n\n- **弹性连接**：服务与服务之间的通信必须能够跨越边界，如云、集群和场所。通信必须是有弹性的和容错的。\n- **L7 流量管理**：负载均衡、速率限制和弹性必须是 L7 感知的（HTTP、REST、gRPC、WebSocket 等）。\n- **基于身份的安全**：依靠网络标识符来实现安全已经不够了，发送和接收服务都必须能够根据身份而不是网络标识符来验证对方。\n- **可观测性和跟踪**：追踪和指标形式的可观测性对于理解、监控和排除应用程序的稳定性、性能和可用性至关重要。\n- **透明**：该功能必须以透明的方式提供给应用程序，即不需要改变应用程序代码。\n\n在早期，服务网格的功能通常是以库的形式实现的，要求网格中的每个应用程序都要链接到以应用程序的语言框架编写的库。类似的事情也发生在互联网的早期：曾几何时，应用程序还需要运行自己的 TCP\/IP 协议栈！正如我们将在这篇文章中讨论的那样，服务网格正在发展成为一种内核责任，就像网络堆栈一样。\n\n![基于库的服务网格模型](008i3skNly1gx7wyowb55j31pi0k076p.jpg)\n\n今天，服务网格通常使用一种叫做 sidecar 模型的架构来实现。这种架构将实现上述功能的代码封装到第四层代理中，服务间的流量被重定向到这个所谓的 sidecar 代理。它之所以被称为“挎斗”，是因为每个应用程序都有一个代理，就像挎斗附着在摩托车上一样。\n\n![基于 Sidecar 的服务网格模型](008i3skNly1gx7wyqsefhj31pe0moq5h.jpg)\n\n这种架构的优点是，服务不再需要自己实现服务网格的功能。如果许多服务是用不同的语言编写部署的，或者如果你正在运行不可变的第三方应用程序，这就很有好处。\n\n这种模式的缺点是有大量的代理，许多额外的网络连接，以及复杂的重定向逻辑，将网络流量输入代理。除此之外，在什么类型的网络流量可以被重定向到第四层代理上也有限制。代理（Proxy）在其能支持的网络协议方面是有限的。\n\n## 连接性转移到内核中的历史\n\n几十年来，在应用程序之间提供安全可靠的连接一直是操作系统的责任。有些人可能还记得早期 Unix 和 Linux 时代的 [TCP 包装器](https:\/\/en.wikipedia.org\/wiki\/TCP_Wrappers)和 tcpd。tcpd 允许用户在不修改应用程序的情况下透明地添加日志、访问控制、主机名验证和欺骗保护。它使用了 libwrap，而且，在一个有趣的平行于服务网格的故事中，这个库也是以前应用程序提供这些功能的链接对象。tcpd 所带来的是能够在不修改现有应用程序的情况下将这些功能透明地添加到现有应用程序中。最终，所有这些功能都进入了 Linux 本身，并以一种更有效、更强大的方式提供给所有应用程序。今天，这已经发展到了我们所知道的 iptables。\n\n然而，iptables 显然不适合解决现代应用的连接性、安全性和可观测性要求，因为它只在网络层面上操作，对应用协议层缺乏任何了解。自然，阻力最小的路径是回到库模型，然后是 sidecar 模型。现在，我们正处于这样一个阶段：为了最佳的透明度、效率和安全性，在操作系统中原生地支持这种模式是有意义的。\n\n![服务网格的进化](008i3skNly1gx7y8ybphhj31h30u041s.jpg) \n\n在 tcpd 时代，曾经的连接记录现在是追踪。IP 层面的访问控制已经演变成应用协议层面的授权，例如使用 JWT。主机名验证已被更强大的认证所取代，如 mTLS。网络负载均衡已经扩展到 L7 流量管理。HTTP 重试是新的 TCP 重传。过去用黑洞路由解决的问题今天被称为断路。这些都不是根本性的新问题，但所需的环境和控制已经发生了变化。\n\n## 扩展内核命名空间概念\n\nLinux 内核已经有一个概念，可以共享共同的功能，并使其对系统上运行的许多应用程序可用。这个概念被称为命名空间（Namespace），它构成了我们今天所知的容器技术的基础。命名空间（内核的那种，不是 Kubernetes 的命名空间）存在于各种抽象中，包括文件系统、用户管理、挂载设备、进程、网络等。这就是允许单个容器呈现不同的文件系统视图、不同的用户集，以及允许多个容器绑定到单个主机上的同一网络端口。在 cgroups 的帮助下，这个概念得到了扩展，可以对 CPU、内存和网络等资源进行管理和优先排序。从云原生应用开发者的角度来看，cgroups 和资源被紧密地整合到我们所知的 \u0022容器\u0022 概念中。\n\n符合逻辑的是，如果我们认为服务网格是操作系统的责任，那么它必须符合并整合命名空间和 cgroup 的概念。这看起来会是这样的。\n\n![Service Mesh Namespace](008i3skNly1gx7wypvr2zj31p20q0q75.jpg)\n\n不出所料，这看起来非常自然，而且可能是大多数用户从简单的角度所期望的。应用程序保持不变，它们继续使用套接字进行通信，就像以前那样。理想的服务网格是作为 Linux 的一部分透明地提供的。它就在那里，就像今天的 TCP 一样。\n\n### 注入 Sidecar 的成本\n\n如果我们仔细研究一下 sidecar 模型，我们会发现它实际上是在试图模仿这种模型。应用程序继续使用套接字，一切都被塞进 Linux 内核的网络命名空间。然而，这比它看起来要复杂得多，需要许多额外的步骤来透明地注入 sidecar 代理。\n\n![注入 Sidecar 的成本](008i3skNly1gx7y8nu479j31h30u041s.jpg) \n\n \n\n这种额外的复杂性在延迟和额外资源消耗方面付出了巨大的代价。早期的基准测试表明，这对延迟的影响高达 3-4 倍，而且所有代理都需要大量的额外内存。在这篇文章的后面，我们将研究这两点，因为我们将其与基于 eBPF 的模型进行比较。\n\n## 用 eBPF 解锁内核服务网格\n\n为什么我们以前没有在内核中创建一个服务网格？有些人半开玩笑地说，kube-proxy 是最初的服务网格（见[我们已经构建了相当多的服务网格 - Tim Hockin, Google](https:\/\/www.youtube.com\/watch?v=lUF88T16YqY\u0026ab_channel=CloudNativeRejekts)）。这句话是有一定道理的。Kube-proxy 是一个很好的例子，说明了 Linux 内核在依靠传统的基于网络的 iptables 功能实现服务网格时，可以达到多么接近。然而，这还不够，L7 上下文是缺失的。Kube-proxy 完全在网络数据包层面运作。现代应用需要 L7 流量管理、跟踪、认证和额外的可靠性保证。Kube-proxy 不能在网络层面上提供这些。\n\neBPF 改变了这个模式。它允许动态地扩展 Linux 内核的功能。我们一直在使用 eBPF 为 Cilium 建立一个高效的网络、安全和可观测性数据通路，并将其直接嵌入到 Linux 内核。应用这个相同的概念，我们也可以在内核层面上解决服务网格的要求。事实上，Cilium 已经实现了各种所需的概念，如基于身份的安全、L3-L7 可观测性和授权、加密和负载均衡。缺少的部分现在正在向 Cilium 涌来。在本博客的末尾，你会发现如何加入由 Cilium 社区推动的 Cilium 服务网格测试项目的细节。\n\n![eBPF 服务网格架构](008i3skNly1gx7wyrufdyj31w90u0q6o.jpg) \n\n**有人可能想知道为什么 Linux 内核社区不直接解决这些需求**。eBPF 有一个巨大的优势，eBPF 代码可以在运行时插入到现有的 Linux 内核中，类似于 Linux 内核模块，但与内核模块不同，它可以以安全和可移植的方式进行。这使得 eBPF 的实现能够随着服务网格社区的发展而继续发展。**新的内核版本需要几年时间才能进入用户手中**。eBPF 是一项关键技术，它使 Linux 内核能够跟上快速发展的云原生技术栈。\n\n## 无 Sidecar 的基于 eBPF 的 L7 追踪和度量\n\n让我们看看 L7 追踪和指标可观测性，作为一个具体的例子，说明基于 eBPF 的服务网格对保持低延迟和提高观察性有巨大的影响。应用程序团队依靠应用程序的可见性和监控作为基本要求这些，这包括请求跟踪、HTTP 响应率和服务延迟信息等能力。然而，这种可观测性应该没有明显的成本（延迟、复杂性、资源…）。\n\n![基于 eBPF 的可视性](008i3skNly1gx7wysxpr4j31ne0iugq1.jpg)\n\n在下面的基准测试中，我们可以看到早期的测量结果，即通过 eBPF 或 sidecar 方法实现 HTTP 可见性对延迟的影响。该设置是在两个不同节点上运行的两个 pod 之间通过固定数量的连接每秒稳定运行 10K 个 HTTP 请求，并测量请求的平均延时。\n\n![基于 eBPF 的延迟基准测试 vs 基于 Sidecar 的 L7 可视性](008i3skNly1gx7wyt6izdj31ns0rawfw.jpg)\n\n我们故意不提这些测量中使用的具体代理，因为它并不重要。对于我们测试过的所有代理，结果几乎都是一样的。要明确的是，这不是关于 Envoy、Linkerd、Nginx 或其他代理是否更快。所提到的代理有差异，但与首先注入代理的成本相比，它们是微不足道的。**几乎没有开销是来自代理本身的逻辑。开销是通过注入代理，将网络流量重定向到它，终止连接和启动新的连接而增加的。**\n\n这些早期的测量结果表明，基于 eBPF 的内核方法是非常有前途的，可以实现完全透明的服务网格的愿望，而且没有明显的开销。\n\n## 使用 eBPF 加速的 per-node 代理\n\n越来越多的用例可以用这种仅有 eBPF 的方法来覆盖，从而完全取消 L4 代理。有些用例，仍然需要代理。例如，当连接需要拼接时，当 TLS 终止被执行时，或对于某些形式的 HTTP 授权。\n\n我们的 eBPF 服务网格工作将继续关注那些从性能角度可以获得最大收益的领域。如果你必须执行 TLS 终止，你可能不介意在流量流入集群时用代理终止一次连接。然而，你会更关心在每个连接的路径中注入两个代理的影响，以提取 HTTP 指标和跟踪数据。\n\n当一个用例不能用纯 eBPF 的方法来实现时，网格可以回退到每个节点的代理模型，直接将代理与内核的套接字层结合起来。\n\n![eBPF per-node Proxy](008i3skNly1gx7wyvrfmfj31vq0u0q87.jpg) \n\neBPF 不依赖网络级的重定向，而是直接在套接字级别注入代理，保持路径短。在 Cilium 的案例中，正在使用 Envoy 代理，尽管从架构的角度来看，任何代理都可以被整合到这个模型。从概念上讲，这允许将 Linux 内核网络命名空间的概念直接扩展到 Envoy 监听器配置的概念，并将 Envoy 变成一个多用户代理。\n\n## Sidecar 与 per-Node 代理\n\n即使需要代理，代理的成本也会根据部署的架构而有所不同。让我们来看看每个节点的代理模式与 sidecar 模式的比较。\n\n### 每个连接的代理\n\n所需的网络连接数将因是否有代理而不同。最简单的情况是无 sidecar 模式，这意味着网络连接的数量没有变化。一个单一的连接将为请求提供服务，eBPF 将提供服务网格功能，如跟踪或现有连接上的负载均衡。\n\n![基于 eBPF 的模型](008i3skNly1gx7wyy16o4j32960kcwg9.jpg)\n\n用 sidecar 模型提供同样的功能需要在连接中注入两次代理，这导致需要维护三个连接。这导致了开销的增加和所有额外的套接字缓冲区所需内存的倍增，表现为更高的服务间延迟。这就是我们之前在无 sidecar L7 可见性部分看到的 sidecar 开销。\n\n![基于 Sidecar 代理的模型](008i3skNly1gx7wz3o1f6j32860lego3.jpg)\n\n切换到 per-node 的代理模式使我们能够摆脱其中一个代理，因为我们不再依赖在每个工作负载中运行一个 sidecar。比起不需要额外的连接，这还是不够理想，但比起总是需要两个额外的连接要好。\n\n![Per-node 代理模式](008i3skNly1gx7wyx2lulj32980o4dhz.jpg)\n\n### 所需的代理总数\n\n在每个工作负载中运行一个 sidecar 会导致大量的代理。即使每个单独的代理实例在其内存占用方面是相当优化的，但实例的数量之多将导致总的影响很大。此外，每个代理维护的数据结构，如路由和端点表，随着集群的增长而增长，所以集群越大，每个代理的内存消耗就越高。今天，一些服务网格试图通过将部分路由表推送给单个代理来解决这个问题，限制它们可以路由到哪里。\n\n![代理数量](008i3skNly1gx7y8synvej31z40oiq6n.jpg) \n\n \n\n让我们假设在一个 500 个节点的集群中，每一个节点有 30 个 pod，一个基于 sidecar 的架构将需要运行 15K 个代理。在每个代理消耗 70MB 内存的情况下（假设已经经过极致优化过的路由表），这仍然导致集群中所有 sidecar 消耗 1.5TB 的内存。在 per-node 模型中，假设每个代理的内存足迹相同，500 个代理将消耗不超过 34GB 的内存。\n\n### 多租户\n\n当我们从 sidecar 模型转向 per-node 模型时，代理将为多个应用程序提供连接。代理必须具有多租户感知。这与我们从使用单个虚拟机转向使用容器时发生的过渡完全相同。由于我们不再使用在每个虚拟机中运行的完全独立的操作系统副本，而开始与多个应用程序共享操作系统，Linux 必须具有多租户感知。这就是命名空间和 cgroup 存在的原因。如果没有它们，一个容器可能会消耗一个系统的所有资源，容器可能会以不受控制的方式访问对方的文件系统。\n\n![Envoy Namespace](008i3skNly1gx7z3klyfhj31hx0u0djs.jpg)\n\n如果这在服务网格级别的网络资源上表现得完全一样，那不是很好吗？Envoy 已经有了命名空间的初步概念，它们被称为监听器。监听器可以携带单独的配置并独立运行。这将开启全新的可能性：突然间，我们可以很容易地控制资源消耗，建立公平的排队规则，并将可用的资源平等地分配给所有的应用程序，或者按照指定的规则分配。这可以而且应该与我们今天在 Kubernetes 中定义应用程序的 CPU 和内存约束的方式完全一样。如果你想了解这个话题，我曾在 EnvoyCon 上讲过这个问题（[Envoy Namespace - 以更小的代价运维基于 Envoy 的服务网格，Thomas Graf，EnvoyCon 2019](https:\/\/www.youtube.com\/watch?v=08opgZkdYIw)）。\n\n## 想参与其中吗？- 加入 Cilium 服务网格测试版\n\n![测试版](008i3skNly1gx7wz1obexj327t0u0dkm.jpg) \n\n伴随着即将发布的 Cilium 1.11 版本，Cilium 社区正在举办一个新的 Cilium Service Mesh 测试计划。它的特点是一个新的构建，将使以下功能可用。\n\n- L7 流量管理和负载均衡（HTTP，gRPC，…）\n- 跨集群、云和集群的拓扑感知路由\n- TLS 终止\n- 通过 Envoy 配置的金丝雀发布、重试、速率限制、断路等\n- 用 OpenTelemetry 和 Jaeger 集成进行追踪\n- 内置 Kubernetes Ingress 支持\n\n上述所有功能都可以在 [github.com\/cilium\/cilium](https:\/\/github.com\/cilium\/cilium) 功能分支中找到。测试计划允许 Cilium 维护者直接与用户接触，了解他们的需求。要注册，你可以直接填写 [这个表格](https:\/\/forms.gle\/j9fwhAC6HnHRJQKeA)，或者你可以在 Cilium 社区的[公告](https:\/\/cilium.io\/blog\/2021\/12\/01\/cilium-service-mesh-beta)中阅读更多关于该计划的信息。\n\n## 总结\n\neBPF 是提供本地和高效的服务网格实现的答案。它将把我们从 sidecar 模型中解放出来，并允许将现有的代理技术整合到现有的内核命名概念中，使它们成为我们每天都在使用的容器抽象的一部分。除此之外，eBPF 将能够卸载越来越多的目前由代理执行的功能，以进一步减少开销和复杂性。通过整合几乎任何现有的代理，该架构也允许与大多数现有的服务网格控制平面（Istio、SMI、Linkerd…）整合。这可以将 eBPF 的好处提供给广大的终端用户，同时将数据通路的效率和开销的讨论与控制平面方面相分离。\n\n如果你有兴趣探索这个话题，我们很想听到你的意见。请随时通过 [Twitter](https:\/\/twitter.com\/tgraf__) 或 [eBPF \u0026 Cilium Slack 联系我们](http:\/\/ebpf.io\/slack)。\n\n## 进一步阅读\n\n- [eBPF 如何简化服务网格](\/trans\/how-ebpf-streamlines-the-service-mesh\/)，Liz Rice，The New Stack\n- [Cilium 服务网格测试计划](https:\/\/cilium.io\/blog\/2021\/12\/01\/cilium-service-mesh-beta)，Cilium 社区\n- [了解更多关于 Cilium 的信息](https:\/\/cilium.io\/learn)\n', '\/trans\/ebpf-solve-service-mesh-sidecar\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文回顾了 Linux 内核的连接性，实现服务网格的几种模式，以及如何使用 eBPF 实现无 Sidecar 的服务网格。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/slime-intro/">网易开源 Istio 扩展项目 Slime 简介——基于 Istio 的智能服务网格管理器</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2021/11/24</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('网易开源 Istio 扩展项目 Slime 简介——基于 Istio 的智能服务网格管理器', '本文介绍的是由网易数帆微服务团队开源的一款基于 Istio 的智能网格管理器 Slime。', '\n最近我在研究 Istio 生态中的开源项目，[Slime](https:\/\/github.com\/slime-io\/slime\/) 这个项目开源与 2021 年初，是由网易数帆微服务团队开源的一款基于 Istio 的智能网格管理器。Slime 基于 Kubernetes Operator 实现，可作为 Istio 的 CRD 管理器，无须对 Istio 做任何定制化改造，就可以定义动态的服务治理策略，从而达到自动便捷使用 Istio 和 Envoy 高阶功能的目的。\n\n## Slime 试图解决的问题\n\nSlime 项目的诞生主要为了解决以下问题：\n\n1. 网格内所有服务配置全量下到所有 Sidecar Proxy，导致其消耗大量资源使得应用性能变差的问题\n2. 如何在 Istio 中实现高阶扩展的问题：比如扩展 HTTP 插件；根据服务的资源使用率做到自适应限流\n\nSlime 解决以上问题的答案是构建 Istio 的控制平面，具体做法是：\n\n- 构建可拔插控制器\n- 数据平面监控\n- CRD 转换\n\n通过以上方式 Slime 可以实现**配置懒加载**和**插件管理器**。\n\n## Slime 架构\n\nSlime 内部分为三大模块，其架构图如下所示。\n\n![Slime 内部架构图](slime-internal-arch.jpg)\n\nSlime 内部三大组件为：\n\n1. \u0060slime-boot\u0060：在 Kubernetes 上部署 Slime 模块的 operator。\n2. \u0060slime-controller\u0060：Slime 的核心组件，监听 Slime CRD 并将其转换为 Istio CRD。\n3. \u0060slime-metric\u0060：用于获取服务 metrics 信息的组件，\u0060slime-controller\u0060 会根据其获取的信息动态调整服务治理规则。\n\n目前 Slime 内置了三个控制器子模块：\n\n1. **配置懒加载（按需加载）**：用户无须手动配置 \u0060SidecarScope\u0060，Istio 可以按需加载服务配置和服务发现信息；\n2. **HTTP 插件管理**：使用新的 CRD——\u0060pluginmanager\/envoyplugin\u0060 包装了可读性，摒弃了可维护性较差的 \u0060envoyfilter\u0060，使得插件扩展更为便捷；\n3. **自适应限流**：结合监控信息自动调整限流策略；\n\n\u003e **什么是 SidecarScope？**\n\u003e\n\u003e SidecarScope 是在 Istio 1.1 版本中引入的，它并不是一个直接面向用户的配置项，而是 Sidecar 资源的包装器，具体来说就是 Sidecar 资源中的 \u0060egress\u0060 选项。通过该配置可以减少 Istio 向 Sidecar 下发的数据量，例如只向某个命名空间中的某些服务下发某些 hosts 的访问配置，从而提高应用提高性能。\n\n## 使用 Slime 作为 Istio 的控制平面\n\n为了解决这些问题，Slime 在 Istio 之上构建了更高层次的抽象，相当于为 Istio 构建了一层管理平面，其工作流程图如下所示。\n\n![Slime 工作流程图](slime-flow-chart.jpg)\n\n具体步骤如下：\n\n1. Slime Operator 根据管理员的配置在 Kubernetes 中完成 Slime 组件的初始化；\n2. 开发者创建符合 Slime CRD 规范的配置并应用到 Kubernetes 集群中；\n3. Slime 查询 Prometheus 中保存的相关服务的监控数据，结合 Slime CRD 中自适应部分的配置，将 Slime CRD 转换为 Istio CRD，同时将其推送到 Global Proxy 中；\n4. Istio 监听 Istio CRD 的创建；\n5. Istio 将 Sidecar Proxy 的配置信息推送到数据平面相应的 Sidecar Proxy 中；\n\n以上只是一个对 Slime 工作流程的一个笼统的介绍，更多详细信息请参考 [Slime GitHub](https:\/\/github.com\/slime-io\/slime\/)。\n\n## 配置懒加载\n\n为了解决数据平面中 Sidecar Proxy 资源消耗过大及网络延迟问题，Slime 使用了配置懒加载（按需加载 Sidecar 配置）的方案。该方案的核心思想是向每个 Sidecar Proxy 中只下发其所 Pod 中服务所需的配置，而不是将网格中的所有服务信息全量下发。所以 Slime 需要获取每个服务的调用关系这样才能得到其所需的 Sidecar Proxy 配置。\n\nSlime 实现 Sidecar Proxy 配置懒加载的方法是：\n\n- 让数据平面中的所有服务的首次调用都通过一个 Global Proxy，该 Proxy 可以记录所有服务的调用和依赖信息，根据该依赖信息更新 Istio 中 Sidecar 资源的配置；\n- 当某个服务的调用链被 VirtualService 中的路由信息重新定义时，Global Proxy 原有记录就失效了，需要一个新的数据结构来维护该服务的调用关系。Slime 创建了名为 \u0060ServiceFence\u0060  的 CRD 来维护服务调用关系以解决服务信息缺失问题。\n\n### 使用 Global Proxy 初始化服务调用拓扑\n\nSlime 在数据平面中部署 Global Proxy（也叫做 Global Sidecar，但其与应用的 Pod 不是一对一的关系，笔者更倾向于称其为 Global Proxy），该代理同样使用 Envoy 构建，在每个需要启动配置懒加载的命名空间中部署一个或在整个网格中只部署一个，所有缺失服务发现信息的调用（你也可以手动配置服务调用关系），都会被兜底路由劫持到 Global Proxy，经过其首次转发后，Slime 便可感知到被调用方的信息，然后根据其对应服务的 VirtualService，找到服务名和真实后端的映射关系，将两者的都加入 SidecarScope，以后该服务的调用就不再需要经过 Global Proxy 了。\n\n### 使用 ServiceFence 维护服务调用拓扑\n\n在使用 Global Proxy 初始化服务调用拓扑后，一旦服务调用链有变动的话怎么办？对此 Slime 创建了 ServiceFence 的 CRD。使用 ServiceFence 可以维护服务名和后端服务的映射关系。Slime 根据其对应服务的 VirtualService，找到 Kubernetes 服务名和真实后端（host）的映射关系，将两者的都加入 Sidecar 的配置中。ServiceFence 管理生成的 SidecarScope 的生命周期，自动清理长时间不用的调用关系，从而避免上述问题。\n\n### 如何开启配置懒加载\n\n配置懒加载功能对于终端用户是透明的，只需要 Kubernetes  Service 上打上 \u0060istio.dependency.servicefence\/status:\u0022true\u0022\u0060 的标签，表明该服务需要开启配置懒加载，剩下的事情交给 Slime Operator 来完成即可。\n\n## HTTP 插件管理\n\nIstio 中的插件扩展只能通过 EnvoyFilter 来实现，因为它是 xDS 层面的配置，管理和维护这样的配置需要耗费大量的精力，也极容易出错。因此，Slime 在 EnvoyFilter 的基础上做了一层面向插件的抽象。\n\nSlime 共有两个 CRD 用于 HTTP 插件管理，分别是：\n\n- **PluginManager**：配置为哪些负载开启哪些插件，插件的配置顺序即为执行顺序；\n- **EnvoyPlugin**：EnvoyPlugin 不关心每个插件的具体配置，具体配置会被放在 EnvoyFilter 资源的 \u0060patch.typed_config\u0060 结构中透传），EnvoyPlugin 的核心思想是将插件配置在需要的维度中做聚合，从而限定插件的生鲜范围。这样做一方面更加贴合插件使用者的习惯，另一方面也降低了上层配置的冗余，\n\n关于 Slime 中插件管理的详细使用方式请见 [Slime GitHub](https:\/\/github.com\/slime-io\/slime\/blob\/master\/doc\/zh\/plugin_manager.md)。\n\n## 自适应限流\n\nEnvoy 内置的限流组件功能单一，只能以实例维度配置限流值，无法做到根据应用负载的自适应限流。Slime 通过与 Prometheus metric server 对接，实时的获取监控情况，来动态配置限流值。\n\nSlime 自适应限流的流程图如下所示。\n\n![Slime 的自适应限流流程图](slime-smart-limiter.jpg)\n\nSlime 的自适应限流的流程分为两部分，一部分为 SmartLimiter 到 EnvoyFilter 的转换，另一部分为获取监控数据。目前 Slime 支持从 Kubernetes Metric Server 获取服务的 CPU、内存、副本数等数据。Slime 还对外提供了一套监控数据接口（Metric Discovery Server），通过 MDS，可以将自定义的监控指标同步给限流组件。\n\nSlime 创建的 CRD \u0060SmartLimiter\u0060 用于配置自适应限流。其的配置是接近自然语义，例如希望在 CPU 超过 80% 时触发服务 A 的访问限制，限额为 30QPS，对应的 SmartLimiter 定义如下：\n\n\u0060\u0060\u0060yaml\napiVersion: microservice.netease.com\/v1alpha1\nkind: SmartLimiter\nmetadata:\n  name: a\n  namespace: default\nspec:\n  descriptors:\n  - action:\n      fill_interval:\n        seconds: 1\n      quota: \u002230\/{pod}\u0022    # 30 为该服务的额度，将其均分给每个 pod，加入有 3 个 pod，则每个 pod 的限流为 10\n    condition: \u0022{cpu}\u003e0.8\u0022 # 根据监控项{cpu}的值自动填充该模板\n\u0060\u0060\u0060\n\n## 更多\n\nSlime 开源于 2021 年初，本文发稿时该项目仍处于初级阶段，本文大量参考了杨笛航在云原生社区中的分享 [Slime：让 Istio 服务网格变得更加高效与智能](https:\/\/cloudnative.to\/blog\/netease-slime\/) 及 Slime 的 [GitHub](https:\/\/github.com\/slime-io\/slime)。感兴趣的读者可以关注下这个项目的 GitHub，进一步了解它。\n\n另外欢迎关注服务网格和 Istio 的朋友加入云原生社区 Istio SIG，一起参与讨论和交流。\n\n## 参考\n\n- [Slime：让 Istio 服务网格变得更加高效与智能 - cloudnative.to](https:\/\/cloudnative.to\/blog\/netease-slime\/)\n- [Slime GitHub 文档 - github.com](https:\/\/github.com\/slime-io\/slime\/blob\/master\/README_ZH.md)\n- [Sidecar - istio.io](https:\/\/istio.io\/latest\/docs\/reference\/config\/networking\/sidecar\/)\n', '\/blog\/slime-intro\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文介绍的是由网易数帆微服务团队开源的一款基于 Istio 的智能网格管理器 Slime。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/service-mesh-insight/">服务网格现状之我见</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2021/11/23</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('服务网格现状之我见', '本文探讨了服务网格和云原生的关系，社区发展现状，开源生态，及未来发展。', '\n本文根据 2021 年 11 月 22 日晚我应极客邦邀请在「极客时间训练营」的直播分享《云原生漫谈：聊聊 Service Mesh 的现状》整理而成。\n\n本来极客时间是想邀请我分享云原生的，但我觉得那个范围太大，在一次分享中只能泛泛而谈，无法聚焦到一个具体的点，因此我想还是先聚焦在服务网格这一个专题上吧。云原生社区最近倒是在做一个[云原生系列的分享](https:\/\/mp.weixin.qq.com\/s\/FWUkc1HJobhZgb26pG73Cg)，大家可以关注下。\n\n这是我今天分享的大纲：\n\n1. 第一探讨下服务网格跟云原生的关系\n2. 第二是给大家陈述下我观察到的目前社区里关于服务网格有哪些争论\n3. 第三是给大家介绍几个服务网格的相关的开源项目\n4. 最后是畅想下服务网格未来的发展\n\n## 服务网格与云原生的关系\n\n首先我们将探讨下服务网格与云原生的关系。\n\n### 服务网格——容器编排大战后的产物\n\n![Docker Swarm vs Kubernetes vs Mesos](008i3skNly1gwp7oq2980j313w0eqq56.jpg)\n\n如果你关注云原生领域足够早的话，应该还会对 2015 到 2017 年间的容器编排大战记忆犹新。关于服务网格的起源已经无需多言。2017 年 Kubernetes 获得了容器大战的胜利，微服务的理念已经深入人心，容器化的趋势可谓势不可挡。Kubernetes 架构趋向成熟，慢慢变得无聊，以 Linkerd、Istio 为代表的服务网格技术进入了 CNCF 定义的云原生关键技术视野中。\n\n服务网格将微服务中的通用的功能给下沉到了基础设施层，让开发者可以更加专注于业务逻辑，从而加快服务交付，这与整个云原生的理念的一致的。你不需要再在应用中集成笨重的 SDK，为不同语言开发和维护 SDK，应用部署完后，使用服务网格进行 Day 2 操作即可。\n\nKubernetes 设计之初就是按照云原生的理念设计的，云原生中有个重要概念就是微服务的架构设计，当将单体应用拆分微服务后，随着服务数量的增多，如何微服务进行管理以保证服务的 SLA 呢？为了从架构层面上解决这个问题，解放程序员的创造性，避免繁琐的服务发现、监控、分布式追踪等事务，服务网格应运而生。\n\n![微服务关注点](008i3skNly1gwp7qas2vtj30v70u0whb.jpg)\n\n来源：[RedHat](https:\/\/developers.redhat.com\/blog\/2016\/12\/09\/spring-cloud-for-microservices-compared-to-kubernetes)\n\n服务网格被誉为下一代微服务，从右面这幅图里我们可以看到微服务的一些关注点，这些关注点很多与 Kubernetes 的功能是重合的，既然这些作为平台级的功能 Kubernetes 已经提供了，为什么还要使用服务网格呢？其实 Kubernetes 关注的还是应用的生命周期，它管理的对象是资源和部署，对于服务的管控力度很小。而服务网格正好弥补了这个缺陷。服务网格可以连接、控制、观察和保护微服务。\n\n### Kubernetes vs xDS vs Istio\n\n这幅图展示的是 Kubernetes 和 Istio 的分层架构图。\n\n![Kubernetes vs Service mesh](008i3skNly1gxdhnnh4lxj31820p0gps.jpg)\n\n从图中我们可以看到 kube-proxy 的设置是全局的，无法对每个服务进行细粒度的控制，Kubernetes 可以做的只有拓扑感知路由、将流量就近路由，为 Pod 设置进出站的网络策略。\n\n而服务网格通过 sidecar proxy 的方式将 Kubernetes 中的流量控制从服务层中抽离出来，为每个 Pod 中注入代理，并通过一个控制平面来操控这些分布式代理。这样可以实现更大的弹性。\n\nKube-proxy 实现了一个 Kubernetes 服务的多个 pod 实例之间的流量负载均衡，但如何对这些服务之间的流量进行精细化控制–比如将流量按百分比划分给不同的应用版本（这些应用版本都是同一个服务的一部分，但在不同的部署上），或者做金丝雀发布（灰度发布）和蓝绿发布？\n\nKubernetes 社区给出了一个使用 Deployment 做金丝雀发布的方法，本质上是通过修改 pod 的标签来给部署的服务分配不同的 pod。\n\n![Envoy 架构图](envoy-arch.jpg)\n\n目前在中国最流行的服务网格开源实现是 Istio，也有很多公司对 Istio 进行了二次开发，比如蚂蚁、网易、腾讯等，其实 Istio 是在 Envoy 的基础上开发的，从它开源的第一天起就默认使用了 Envoy 作为它的分布式代理。Envoy 开创性的创造了 xDS 协议，用于分布式网关配置，大大简化了大规模分布式网络的配置。2019 年蚂蚁开源的 MOSN 同样支持了 xDS。Envoy 还是 CNCF 中最早毕业的项目之一，经过大规模的生产应用考验。可以说 Istio 的诞生已经有了很好的基础。\n\n下表是 Kubernetes、xDS、Istio 三者之间的资源抽象对比。\n\n| **Kubernetes** | **xDS**  | **Istio 服务网格** |\n| -------------- | -------- | ------------------ |\n| Endpoint       | Endpoint | WorkloadEntry      |\n| Service        | Route    | VirtualService     |\n| kube-proxy     | Route    | DestinationRule    |\n| kube-proxy     | Listener | EnvoyFilter        |\n| Ingress        | Listener | Gateway            |\n| Service        | Cluster  | ServiceEntry       |\n\nkube-proxy 组件、xDS 和 Istio 对流量管理的抽象后，现在我们仅从流量管理的角度来看看这三个组件 \/ 协议的比较。请注意，三者并不完全等同。Kubernetes 更加注重的是应用层面的流量管理，xDS 是更加抽象的协议层面的配置下发，而 Istio 是服务层面的配置。\n\n### 服务网格——云原生网络基础设施\n\n在列举过以上 Kubernetes 和服务网格的对比后，我们可以看出服务网格在云原生应用架构中的地位。那就是构建一个云原生网络基础设施，具体来说就是：\n\n- 流量管理：控制服务间的流量和 API 调用流，使调用更可靠，增强不同环境下的网络鲁棒性。\n- 可观测性：了解服务之间的依赖关系和它们之间的性质和流量，提供快速识别定位问题的能力。\n- 策略实施：通过配置网格而不是以改变代码的方式来控制服务之间的访问策略。\n- 服务识别与安全：提供在网格里的服务可识别性和安全性保护。\n\n## 社区里关于 Istio 和服务网格的争论\n\n然而构建基础设施，可谓牵一发而动全身。理想很丰满，现实很骨感。关于服务网格和 Istio，在社区中也不乏争论。我们来看看有这些争论主要有哪些。\n\n这里列举了我在社区中观察到的关于 Istio 和服务网格最常见的几个问题。\n\n1. 有人在生产使用 Istio 吗？\n2. 为 pod 注入 sidecar 后带来的大量资源消耗，影响应用性能？\n3. Istio 支持的协议有限，不易扩展？\n4. Istio 太过复杂，老的服务迁移成本太高，业界经验太少，学习曲线陡峭？\n\n第一个问题，也是很多人刚加入社区和了解这门技术的时候，问的第一个问题，那是有人在生产使用 Istio 吗？\n\n随着对 Istio 研究的深入，很多人就会抛出第二个问题，为 pod 注入 sidecar 后带来的大量资源消耗，会影响应用性能吗？\n\n如果能问到第三个问题，说明对 Istio 有比较强的需求了，大多是使用了自定义的 RPC，对 Istio 的协议扩展有需求。\n 最后一个问题是抱怨 Istio 的概念太过复杂，也没有一个清晰的迁移路径可以使用，学习曲线太过陡峭。\n\n下面我将一一回答这些问题。\n\n### Istio 架构稳定，生产可用，生态渐起\n\n![Istio 发布时间表](008i3skNly1gwp7wvt1g8j32yo0nk78g.jpg)\n\n首先我们来看下 Istio 的发布时间表，1.12 版本在上周刚刚发布，这里列举了从它开源到 1.8 版本发布的时间表。2018 年可以说是服务网格爆发之年，Tetrate 也在这一年成立。自 1.5 版本起 Istio 正式确立了当前的架构。Istio 社区也也举办了丰富多彩的活动，2021 年 3 月首届 IstioCon 召开，7 月 Istio Meetup China 在北京举行，2022 年 1 月，Service Mesh Summit 2022 也将在上海举行。\n\nIstio 有着庞大的社区以及[供应商和用户群体](https:\/\/istio.io\/latest\/about\/case-studies\/)。目前主流公有云全都支持了 Istio 服务网格，如阿里云、华为云、腾讯云、网易云等，Istio 的官网上也列举了几十个社区用户，云原生社区 Istio SIG 还陆续举办了八场 Istio 大咖说，百度、腾讯、网易、小红书、小电科技都来分享过他们的 Istio 实践。\n\n还有很多企业基于 Istio 做了二次开发或者适配或者为其开发插件，可以说是 Istio 架构已稳定，生产可用，生态正在萌芽中。\n\n### 服务网格对应用性能的影响\n\n服务网格为了做到对应用程序透明，默认采用了 iptables 流量劫持的方式，当服务数量大的时候会有大量的 iptables 规则，影响网络性能，你可以使用 [eBPF](https:\/\/cloudnative.to\/blog\/how-ebpf-streamlines-the-service-mesh\/) 这样的技术来提高应用性能，但是该技术对操作系统内核的版本要求比较高，很少有企业能够达到。\n\n![Istio 中的智能 DNS 代理](008i3skNly1gwp81fy0vqj31lq0nq41q.jpg)\n\n来源：\u003chttps:\/\/cloudnative.to\/blog\/istio-dns-proxy\/\u003e\n\n还有一种方式，也是小红书使用的方式，那就是利用 Istio 1.8 中引入的智能 DNS 代理功能。首先使用 ServiceEntry 定义服务，让所有服务属于一个 VIP 范围，再利用 Istio 的智能 DNS 代理功能，让 sidecar 只拦截 VIP 网段的流量，这样可以减少 iptables 规则，从而提高性能。如果想深入了解这个做法的细节，大家可以去浏览 [Istio 大咖说第八期的分享视频](https:\/\/www.bilibili.com\/video\/BV12b4y187ae\/)。\n\nIstio 在初期是将整个网格内的所有服务的路由信息全量下发到所有的 proxy sidecar 中，会导致 sidecar 占用大量资源，后来 Istio 引入了 [Sidecar 资源](https:\/\/istio.io\/latest\/docs\/reference\/config\/networking\/sidecar\/)来精细化控制需要下发的代理配置范围，另外还有企业自己开发了配置懒加载功能，例如腾讯云开源的 [Aeraki](https:\/\/github.com\/aeraki-framework\/aeraki)、网易开源的 [Slime](https:\/\/github.com\/slime-io\/slime) 都可以实现配置懒加载。我们会在 Istio 开源生态中介绍这两个开源项目。\n\n最后是一个涉及到 Sidecar proxy 运维的问题，如何在保证流量不断的情况下，升级所有 Envoy 代理，这个阿里开源的 [OpenKruise](https:\/\/github.com\/openkruise\/kruise) 中的 [SidecarSet](https:\/\/xie.infoq.cn\/article\/23ae6d3f0d0260b4797a708a0) 资源已经给出了解决方案。\n\n另外 Sidecar 的引入带来的资源消耗以及网络延迟也是在合理的范围内，大家可以参考 Istio 官方博客上的 [Service Mesh 基准性能测试](https:\/\/istio.io\/latest\/zh\/blog\/2019\/performance-best-practices\/)。\n\n### 扩展 Istio 服务网格\n\n下一个问题是关于扩展 Istio 服务网格的。目前官方社区给出的方案是使用 WebAssembly，目前这种扩展方式在国内用的还比较少，而且性能也堪忧。我观察到的大部分解决方案都是自定义 CRD，基于 Istio 构建服务网格管理平面。\n\n另外，让 Istio 支持异构环境，适用于一切工作负载，如虚拟机、容器，这个对于终端用户来说也有很强的需求，因为这可以让用户很方便的从传统负载迁移应用到服务网格中。最后是多集群、多网格的混合云流量管理，这个属于比较高阶的需求了。\n\n### 陡峭的学习曲线\n\n以下列举的是 Istio 学习资源：\n\n- [Istio 官网中文文档](https:\/\/istio.io\/latest\/zh\/)\n- [IstioCon 2021](https:\/\/events.istio.io\/istiocon-2021\/)\n- Istio Meetup China\n- [Istio 大咖说\/Istio Weekly](https:\/\/github.com\/tetratelabs\/istio-weekly)\n- 云原生社区 Istio SIG\n- [Istio 基础教程（中文）](https:\/\/academy.tetrate.io\/courses\/istio-fundamentals-zh)\n- [Certified Istio Administrator](https:\/\/academy.tetrate.io\/courses\/certified-istio-administrator)\n\nIstio 开源至今已有 4 年时间，2018 年时我和敖小剑一起创建了 ServiceMesher 社区，当时组织过 9 次 Service Mesh Meetup，同其他服务网格爱好者一起翻译了 Istio 的官方文档。我还在今年初参与了 IstioCon 2021 的筹办及首届 Istio Meetup China。可以说是亲眼目睹了国内服务网格技术的应用和发展，在这期间也写过和翻译过大量的文章，加入 Tetrate 后，我还参与发布了 Istio 基础教程，免费提供给大家学习。同时 Tetrate 也推出了认证 Istio 管理员考试，用于培养更多行业人才。\n\n云原生社区组织了 Istio SIG，还推出了 Istio 大咖说直播栏目，为大家分享 Istio 服务网格实践经验。\n\n下图是 [Istio 基础教程](https:\/\/academy.tetrate.io\/courses\/istio-fundamentals-zh)的首页截图。\n\n![Istio 基础教程（Tetrate 出品）](008i3skNly1gwp8rr51ikj31ah0u043i.jpg)\n\n如果你是刚开始接触服务网格和 Istio，可以先从 Istio 基础教程开始学起。这个线上系列课程是图文并茂的中文课程，可以免费参加。\n\n好了，我们再来了解下服务网格的社区项目。\n\n## Istio 开源生态\n\n下表中罗列的是基于 Istio 的开源项目。\n\n| **项目名称**                                                 | **开源时间**  | **类别** | **描述**                                               | **主导公司** | **Star 数量** | **与 Istio 的关系**                           |\n| ------------------------------------------------------------ | ------------- | -------- | ------------------------------------------------------ | ------------ | ------------- | --------------------------------------------- |\n| [Envoy](https:\/\/github.com\/envoyproxy\/envoy)                 | 2016 年 9 月   | 网络代理 | 云原生高性能边缘\/中间服务代理                          | Lyft         | 18300         | 默认的数据平面                                |\n| [Istio](https:\/\/github.com\/istio\/istio\/)                     | 2017 年 5 月  | 服务网格 | 连接、保护、控制和观察服务。                           | Google       | 28400         | 控制平面                                      |\n| [Emissary Gateway](https:\/\/github.com\/emissary-ingress\/emissary) | 2018 年 2 月  | 网关     | 用于微服务的 Kubernetes 原生 API 网关，基于 Envoy 构建 | Ambassador   | 3500          | 可连接 Istio                                  |\n| [APISIX](https:\/\/github.com\/apache\/apisix)                   | 2019 年 6 月  | 网关     | 云原生 API 网关                                        | API7         | 7400          | 可作为 Istio 的数据平面运行也可以单独作为网关 |\n| [MOSN](https:\/\/github.com\/mosn\/mosn)                         | 2019 年 12 月 | 代理     | 云原生边缘网关及代理                                   | 蚂蚁         | 3400          | 可作为 Istio 数据平面                         |\n| [Slime](https:\/\/github.com\/slime-io\/slime)                   | 2021 年 1 月   | 扩展     | 基于 Istio 的智能服务网格管理器                        | 网易         | 204           | 为 Istio 增加一个管理平面                     |\n| [GetMesh](https:\/\/github.com\/tetratelabs\/getmesh)            | 2021 年 2 月  | 工具     | Istio 集成和命令行管理工具                             | Tetrate      | 91            | 实用工具，可用于 Istio 多版本管理             |\n| [Aeraki](https:\/\/github.com\/aeraki-framework\/aeraki)         | 2021 年 3 月  | 扩展     | 管理 Istio 的任何七层负载                              | 腾讯         | 280           | 扩展多协议支持                                |\n| [Layotto](https:\/\/github.com\/mosn\/layotto\/)                  | 2021 年 6 月  | 运行时   | 云原生应用运行时                                       | 蚂蚁         | 325           | 可以作为 Istio 的数据平面                     |\n| [Hango Gateway](https:\/\/github.com\/hango-io\/hango-gateway)   | 2021 年 8 月  | 网关     | 基于 Envoy 和 Istio 构建的 API 网关                    | 网易         | 187           | 可与 Istio 集成                               |\n\n从 2017 年 5 月 Istio 开源至今也有 4 年多了，虽然该项目在 GitHub 上已经有很高的关注度，并发布了 10 几个版本，但其开源生态还在萌芽期。这张表列举了 Istio 生态中的开源项目，统计截止到 2021 年 11 月 11 日，表格按照开源时间排序。这些项目在 Istio 服务网格之上增强了网关、扩展和实用工具等。我将挑选其中 2 个来着重分享下。\n\n### Slime：基于 Istio 的智能服务网格管理器\n\nSlime 是由网易数帆微服务团队开源的一款基于 Istio 的智能网格管理器。Slime 基于 Kubernetes Operator 实现，可作为 Istio 的 CRD 管理器，无缝对接 Istio，无须做任何定制化改造，定义动态的服务治理策略，从而达到自动便捷使用 Istio 和 Envoy 高阶功能的目的。\n\nSlime 试图解决以下问题：\n\n- 在 Istio 中如何实现高阶扩展的问题，比如扩展 HTTP 插件，限流功能比较单薄，无法根据服务的资源使用率做到自适应限流\n- 解决 Sidecar 配置全量下发消耗大量资源导致应用性能变差的问题\n\nSlime 解决以上问题的答案是构建 Istio 的管理平面，其核心思路是：\n\n- 构建可拔插控制器\n- 数据平面监控\n- CRD 转换\n\n下图是 Istio 作为 Istio 管理平面的流程图。\n\n![Slime 如何作为 Istio 的控制平面](008i3skNly1gwp8td6cowj31i90u0aei.jpg)\n\nSlime 管理 Istio 的具体步骤如下：\n\n1. Slime Operator 根据管理员的配置在 Kubernetes 中完成 Slime 组件的初始化；\n2. 开发者创建符合 Slime CRD 规范的配置并应用到 Kubernetes 集群中；\n3. Slime 查询 Prometheus 中保存的相关服务的监控数据，结合 Slime CRD 中自适应部分的配置，将 Slime CRD 转换为 Istio CRD，同时将其推送到 Global Proxy 中；\n4. Istio 监听 Istio CRD 的创建；\n5. Istio 将 Sidecar Proxy 的配置信息推送到数据平面相应的 Sidecar Proxy 中；\n\n下图展示的 Slime 的内部架构图。\n\n![Slime 内部架构图](008i3skNly1gwp8uzsj2wj31ac0oktb4.jpg)\n\n作为 Istio 的管理平面，可以将 Slime 的核心看做是 Istio 的一个 Operator。\n\nSlime 内部分为三大组件：\n\n- **slime-boot**：在 Kubernetes 上部署 Slime 模块的 operator。\n- **slime-controller**：Slime 的核心组件，监听 Slime CRD 并将其转换为 Istio CRD。\n- **slime-metric**：用于获取服务 metrics 信息的组件，slime-controller 会根据其获取的信息动态调整服务治理规则。\n\n下图展示的是 Slime 自适应限流的架构图。\n\n![Slime 自适应限流架构图](008i3skNly1gwp8xghoh2j311k0u0dim.jpg)\n\nEnvoy 内置的限流组件功能单一，只能以实例维度配置限流值，无法做到根据应用负载的自适应限流。Slime 通过与 Prometheus metric server 对接，实时的获取监控情况，来动态配置限流值。\n\nSlime 的自适应限流的流程分为两部分，一部分为 SmartLimiter 到 [EnvoyFilter](https:\/\/istio.io\/latest\/docs\/reference\/config\/networking\/envoy-filter\/) 的转换，另一部分为获取监控数据。目前 Slime 支持从 Kubernetes Metric Server 获取服务的 CPU、内存、副本数等数据。Slime 还对外提供了一套监控数据接口（Metric Discovery Server），通过 MDS，可以将自定义的监控指标同步给限流组件。\n\nSlime 创建的 CRD SmartLimiter 用于配置自适应限流。其的配置是接近自然语义，例如希望在 CPU 超过 80% 时触发服务 A 的访问限制，限额为 30QPS，对应的 SmartLimiter 定义如下：\n\n\u0060\u0060\u0060yaml\napiVersion: microservice.netease.com\/v1alpha1\nkind: SmartLimiter\nmetadata:\n  name: a\n  namespace: default\nspec:\n  descriptors:\n  - action:\n      fill_interval:\n        seconds: 1\n      quota: \u002230\/{pod}\u0022    # 30 为该服务的额度，将其均分给每个 pod，加入有 3 个 pod，则每个 pod 的限流为 10\n    condition: \u0022{cpu}\u003e0.8\u0022 # 根据监控项{cpu}的值自动填充该模板\n\u0060\u0060\u0060\n\n### Aeraki：在 Istio 中管理任何七层协议\n\nAeraki 是腾讯云在 2021 年 3 月开源的一个服务网格领域的项目。Aeraki 提供了一个端到端的云原生服务网格协议扩展解决方案，以一种非侵入的方式为 Istio 提供了强大的第三方协议扩展能力，支持在 Istio 中对 Dubbo、Thrift、Redis，以及对私有协议进行流量管理。Aeraki 的架构如下图所示：\n\n![Aeraki 架构图](008i3skNly1gwp8ytw57sj31f40u0785.png)\n\n来源：\u003chttps:\/\/istio.io\/latest\/blog\/2021\/aeraki\/\u003e\n\n从 Aeraki 架构图中可以看到，Aeraki 协议扩展解决方案包含了两个组件：\n\n- Aeraki：Aeraki 作为一个 Istio 增强组件运行在控制面，通过自定义 CRD 向运维提供了用户友好的流量规则配置。Aeraki 将这些流量规则配置翻译为 Envoy 配置，通过 Istio 下发到数据面的 sidecar 代理上。Aeraki 还作为一个 RDS 服务器为数据面的 MetaProtocol Proxy 提供动态路由。Aeraki 提供的 RDS 和 Envoy 的 RDS 有所不同，Envoy RDS 主要为 HTTP 协议提供动态路由，而 Aeraki RDS 旨在为所有基于 MetaProtocol 框架开发的七层协议提供动态路由能力。\n- MetaProtocol Proxy：基于 Envoy 实现的一个通用七层协议代理。依托 Envoy 成熟的基础库，MetaProtocol Proxy 是在 Envoy 代码基础上的扩展。它为七层协议统一实现了服务发现、负载均衡、RDS 动态路由、流量镜像、故障注入、本地\/全局限流等基础能力，大大降低了在 Envoy 上开发第三方协议的难度，只需要实现编解码的接口，就可以基于 MetaProtocol 快速开发一个第三方协议插件。\n\n如果没有使用 MetaProtocol Proxy，要让 Envoy 识别一个七层协议，则需要编写一个完整的 TCP filter，这个 filter 需要实现路由、限流、遥测等能力，需要投入大量的人力。对于大部分的七层协议来说，需要的流量管理能力是类似的，因此没有必要在每个七层协议的 filter 实现中重复这部分工作。Aeraki 项目采用了一个 MetaProtocol Proxy 来统一实现这些能力，如下图所示：\n\n![MetaProtocol Proxy 架构图](metaprotocol-proxy.png)\n\n基于 MetaProtocol Proxy，只需要实现编解码接口部分的代码就可以编写一个新的七层协议 Envoy Filter。除此之外，无需添加一行代码，Aeraki 就可以在控制面提供该七层协议的配置下发和 RDS 动态路由配置。\n\n![采用 MetaProtocol 编写 Envoy Filter 的对比](metaprotocol-proxy-codec.png)\n\nAeraki \u002b MetaProtocol 套件降低了在 Istio 中管理第三方协议的难度，将 Istio 扩展成为一个支持所有协议的全栈服务网格。目前 Aeraki 项目已经基于 MetaProtocol 实现了 Dubbo 和 Thrift 协议。相对 Envoy 自带的 Dubbo 和 Thrift Filter，基于 MetaProtocol 的 Dubbo 和 Thrift 实现功能更为强大，提供了 RDS 动态路由，可以在不中断存量链接的情况下对流量进行高级的路由管理，并且提供了非常灵活的 Metadata 路由机制，理论上可以采用协议数据包中携带的任意字段进行路由。QQ 音乐和央视频 APP 等业务也正在基于 Aeraki 和 MetaProtocol 进行开发，以将一些私有协议纳入到服务网格中进行管理。\n\n除此之外，[Aeraki Framework](https:\/\/github.com\/aeraki-framework) 中还提供了 xDS 配置下发优化的 lazyXDS 插件、Consul、etcd、Zookeeper 等各种第三方服务注册表对接适配，Istio 运维实战电子书等工具，旨在解决 Istio 在落地中遇到的各种实际问题，加速服务网格的成熟和产品化。\n\n## 服务网格的未来发展\n\n最后我想讲一下对于服务网格未来发展的一些看法。\n\n### 让 Istio 适用于一切环境和一切工作负载\n\n我们看到了网易、腾讯主要是通过构建 Operator 来扩展 Istio，然而这种扩展对于多集群管理来说并不够用。我们知道我们目前的基础设施很多是在向云原生化或者是容器化转型，那么就存在一个容器、虚拟机等共存的环境。这就是异构环境，这些不同环境的流量如何统一管理呢？其实使用 Istio 是可以做到的。同样是要在 Istio 之上构建一个管理平面，并增加一个抽象层，增加适用于集群管理的 CRD，比如集群流量配置、集群策略配置等。另外还要在每个集群中部署一个 Gateway，统一连接到一个边缘代理，让所有的集群互联。这也是 Tetrate Service Bridge 的产品理念。\n\n下图展示的 [Tetrate Service Bridge](https:\/\/www.tetrate.io\/tetrate-service-bridge\/) 架构图。\n\n![Tetrate Service Bridge 架构图](tsb.png)\n\n### API 网关与服务网格的融合\n\n下图展示了使用 Istio Gateway、Kubernetes Ingress、API Gateway 及 NodePort\/LB 暴露 Istio mesh 中服务的四种方式。\n\n![访问 Istio 网格中服务的几种方式](008i3skNly1gwp935mcd0j31200u0n10.jpg)\n\n其中阴影表示的是 Istio mesh，mesh 中的的流量属于集群内部（东西向）流量，而客户端访问 Kubernetes 集群内服务的流量属于外部（南北向）流量。不过因为 Ingress、Gateway 也是部署在 Kubernetes 集群内的，这些节点访问集群内其他服务的流量就难以归属了。\n\n在 Istio mesh 中你可以使用多种 Kubernetes Ingress Controller 来充当入口网关，当然你还可以直接使用 Istio 内置的 Istio 网关，对于策略控制、流量管理和用量监控可以直接通过 Istio 网关来完成，这样做的好处是通过 Istio 的控制平面来直接管理网关，而不需要再借助其他工具。但是对于 API 声明周期管理、复杂的计费、协议转换和认证等功能，传统的 API 网关可能更适合你。所以，你可以根据自己的需求来选择，也可以组合使用。\n\n下表中列出了 Istio Mesh 中暴露服务的四种方式。\n\n| **方式**              | **控制器**         | **功能**                                                     |\n| --------------------- | ------------------ | ------------------------------------------------------------ |\n| NodePort\/LoadBalancer | Kubernetes         | 负载均衡                                                     |\n| Kubernetes Ingress    | Ingress Controller | 负载均衡、TLS、虚拟主机、流量路由                            |\n| Istio Gateway         | Istio              | 负载均衡、TLS、虚拟主机、高级流量路由、其他 Istio 的高级功能 |\n| API 网关              | API Gateway        | 负载均衡、TLS、虚拟主机、流量路由、API 生命周期管理、权限认证、数据聚合、账单和速率限制 |\n\n目前有些传统的反向代理也在向 Service Mesh 方向发展，如 Nginx 构建了 Nginx Service Mesh，Traefik 构建了 Traefik Mesh。还有的 API 网关产品也向 Service Mesh 方向挺进，比如 Kong 发展出了 Kuma。在未来，我们会看到更多 API 网关、反向代理和服务网格的融合产品出现。\n\n### 你是否真的需要服务网格？\n\n在使用服务网格前，请考虑以下问题：\n\n- 你的团队多少人里投入服务网格开发？使用 Kubernetes、Istio 的经验？\n- 你有多少微服务？这些微服务使用什么语言？\n- 你的服务都运行在哪些平台上？\n- 你的应用已经容器化并使用 Kubernetes 管理了吗？\n- 你的服务有多少是部署在虚拟机、有多少是部署到 Kubernetes 集群上，比例如何？\n- 你的团队有制定转移到云原生架构的计划吗？\n- 你想使用 Istio 的什么功能？Istio 的稳定性是否能够满足你的需求？\n- 你是否可以忍受 Istio 带来的性能损耗？\n- 你选择自建或者采购？\n\n## 总结\n\n最后总结一下今天的分享：\n\n- 从容器编排争霸到服务网格，我们可以看到云原生乃至整个云计算就是标准之争。\n- 服务网格的目标是成为云原生的网络基础设施，任重而道远。\n- 服务网格只是云原生庞大技术栈中的一环，不要一叶障目，技术的发展是永无止境的。\n- Istio 架构已经稳定，生产可用，生态正处于萌芽中。\n- 对于终端用户来说适合自己的才是最好的。\n\n本人才疏学浅，因为时间的原因，很多内容没有深入展开和探讨，最后欢迎大家加入云原生社区 Istio SIG 一起交流学习 Istio 和服务网格技术。\n', '\/blog\/service-mesh-insight\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文探讨了服务网格和云原生的关系，社区发展现状，开源生态，及未来发展。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/grpc-proxyless-service-mesh/">[译] 基于 gRPC 和 Istio 的无 sidecar 代理的服务网格</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2021/11/23</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://istio.io/latest/blog/2021/proxyless-grpc/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('基于 gRPC 和 Istio 的无 sidecar 代理的服务网格', '本文介绍了 Istio 对 gRPC 的无代理服务网格功能的支持。', '\n译者注：本文译自 Istio 官方博客，博客原标题 [gRPC Proxyless Service Mesh](https:\/\/istio.io\/latest\/blog\/2021\/proxyless-grpc\/)，其实是 Istio 1.11 版本中支持的实验特性，可以直接将 gRPC 服务添加到 Istio 中，而不需要再向 Pod 中注入 Envoy 代理。本文中还给出了一个 Demo 性能测试数据，这种做法可以极大的提升应用性能，降低网络延迟。\n\n------\n\nIstio 使用一组发现 API（统称为 [xDS API](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/intro\/arch_overview\/operations\/dynamic_configuration) 来动态配置其 Envoy sidecar 代理。这些 API 的目标是成为一个 [通用的数据平面 API](https:\/\/blog.envoyproxy.io\/the-universal-data-plane-api-d15cec7a?gi=64aa2eea0283)。gRPC 项目对 xDS API 有很好的支持，也就是说你可以管理 gRPC 工作负载，而不需要同时部署 Envoy sidecar。你可以在 [Megan Yahya 的 KubeCon EU 2021 演讲](https:\/\/www.youtube.com\/watch?v=cGJXkZ7jiDk)中了解更多关于该集成的信息。关于 gRPC 支持的最新情况，可以在他们的[提案](https:\/\/github.com\/grpc\/proposal\/search?q=xds)中找到，还有实现状态。\n\nIstio 1.11 增加了实验性支持，可以直接将 gRPC 服务添加到网格中。我们支持基本的服务发现，一些基于 VirtualService 的流量策略，以及双向 TLS。\n\n## 支持的功能\n\n与 Envoy 相比，目前 gRPC 内的 xDS API 的实现在某些方面是有限的。以下功能应该可以使用，尽管这不是一个详尽的列表，其他功能可能部分可用。\n\n- 基本的服务发现。你的 gRPC 服务可以接触到在网格中注册的其他 pod 和虚拟机。\n- \u0060DestinationRule\u0060\n  - \u0060Subset\u0060：你的 gRPC 服务可以根据标签选择器将流量分割到不同的实例组。\n  - 目前唯一支持的 Istio \u0060loadBalancer\u0060 是 \u0060ROUND_ROBIN\u0060，\u0060consistentHash\u0060 将在未来的 Istio 版本中加入（支持 gRPC）。\n  - \u0060tls\u0060 设置被限制为 \u0060DISABLE\u0060 或 \u0060ISTIO_MUTUAL\u0060。其他模式将被视为 \u0060DISABLE\u0060。\n- \u0060VirtualService\u0060\n  - Header 匹配和 URI 匹配的格式为 \u0060\/ServiceName\/RPCName\u0060。\n  - 覆盖目标主机和子集。\n  - 加权的流量转移。\n- \u0060PeerAuthentication\u0060\n  - 只支持 \u0060DISABLE\u0060 和 \u0060STRICT\u0060。其他模式将被视为 \u0060DISABLE\u0060。\n  - 在未来的版本中可能会有对 auto-mTLS 的支持。\n\n其他功能包括故障、重试、超时、镜像和重写规则，可能会在未来的版本中支持。其中一些功能正等待在 gRPC 中实现，而其他功能则需要在 Istio 中支持。gRPC 中 xDS 功能的状态可以[在这里](https:\/\/github.com\/grpc\/grpc\/blob\/master\/doc\/grpc_xds_features.md)找到。Istio 的支持状况将存在于未来的官方文档中。\n\n这个功能是[实验性的](https:\/\/istio.io\/latest\/docs\/releases\/feature-stages\/)。标准的 Istio 功能将随着时间的推移和整体设计的改进而得到支持。\n\n## 架构概述\n\n![gRPC 服务如何与 istiod 通信的示意图](008i3skNly1gwp3lh9za5j311q0hm75n.jpg)\n\n虽然不使用 proxy 进行数据面通信，但它仍然需要一个 agent 来进行初始化和与控制面的通信。首先，agent 在启动时生成一个[引导文件](https:\/\/github.com\/grpc\/proposal\/blob\/master\/A27-xds-global-load-balancing.md#xdsclient-and-bootstrap-file)，与为 Envoy 生成引导文件的方式相同。这告诉 gRPC 库如何连接到 istiod，在哪里可以找到数据面通信的证书，以及向控制面发送什么元数据。接下来，agent 作为一个 xDS proxy，代表应用程序与 istiod 进行连接和认证。最后，agent 获取并轮换数据平面通信中使用的证书。\n\n## 对应用程序代码的修改\n\n本节介绍了 gRPC 在 Go 中的 xDS 支持。其他语言也有类似的 API。\n\n为了启用 gRPC 中的 xDS 功能，你的应用程序必须做一些必要的修改。你的 gRPC 版本应该至少是 1.39.0。\n\n### 客户端\n\n下面的导入将在 gRPC 中注册 xDS 解析器和均衡器。它应该被添加到你的主包或调用 \u0060grpc.Dial\u0060 的同一个包中。\n\n\u0060\u0060\u0060go\nimport _ \u0022google.golang.org\/grpc\/xds\u0022\n\u0060\u0060\u0060\n\n当创建一个 gRPC 连接时，URL 必须使用 \u0060xds:\/\/\/\u0060 scheme。\n\n\u0060\u0060\u0060go\nconn, err := grpc.DialContext(ctx, \u0022xds:\/\/\/foo.ns.svc.cluster.local:7070\u0022)\n\u0060\u0060\u0060\n\n此外，为了支持（m）TLS，必须向 \u0060DialContext\u0060 传递一个特殊的 \u0060TransportCredentials\u0060 选项。\u0060FallbackCreds\u0060 允许我们在 istiod 不发送安全配置时成功。\n\n\u0060\u0060\u0060go\nimport \u0022google.golang.org\/grpc\/credentials\/xds\u0022\n\n...\n\ncreds, err := xds.NewClientCredentials(xds.ClientOptions{\nFallbackCreds: insecure.NewCredentials()\n})\n\/\/ handle err\nconn, err := grpc.DialContext(\nctx,\n\u0022xds:\/\/\/foo.ns.svc.cluster.local:7070\u0022,\ngrpc.WithTransportCredentials(creds),\n)\n\u0060\u0060\u0060\n\n### 服务端\n\n为了支持服务器端的配置，如 mTLS，必须做一些修改。\n\n首先，我们使用一个特殊的构造函数来创建 \u0060GRPCServer\u0060。\n\n\u0060\u0060\u0060go\nimport \u0022google.golang.org\/grpc\/xds\u0022\n\n...\n\nserver = xds.NewGRPCServer()\nRegisterFooServer(server, \u0026fooServerImpl)\n\u0060\u0060\u0060\n\n如果你的 \u0060protoc\u0060 生成的 Go 代码已经过期，你可能需要重新生成，以便与 xDS 服务器兼容。你生成的 \u0060RegisterFooServer\u0060 函数应该像下面这样。\n\n\u0060\u0060\u0060go\nfunc RegisterFooServer(s grpc.ServiceRegistrar, srv FooServer) {\ns.RegisterService(\u0026FooServer_ServiceDesc, srv)\n}\n\u0060\u0060\u0060\n\n最后，与客户端的变化一样，我们必须启用安全支持。\n\n\u0060\u0060\u0060go\ncreds, err := xds.NewServerCredentials(xdscreds.ServerOptions{FallbackCreds: insecure.NewCredentials()})\n\/\/ handle err\nserver = xds.NewGRPCServer(grpc.Creds(creds))\n\u0060\u0060\u0060\n\n### 在你的 Kubernetes 部署中\n\n假设你的应用代码是兼容的，Pod 只需要注释 \u0060inject.istio.io\/templates：grpc-agent\u0060。这增加了一个运行上述代理的 sidecar 容器，以及一些环境变量，gRPC 使用这些变量来寻找引导文件并启用某些功能。\n\n对于 gRPC 服务端，你的 Pod 也应该用 \u0060proxy.istio.io\/config: \u0027{\u0022holdApplicationUntilProxyStarts\u0022: true}\u0027\u0060 来注释，以确保在你的 gRPC 服务端初始化之前，代理中的 xDS 代理和引导文件已经准备就绪。\n\n## 例子\n\n在本指南中，你将部署 echo，一个已经支持服务器端和客户端无代理的 gRPC 的应用。通过这个应用程序，你可以尝试一些支持的流量策略，启用 mTLS。\n\n### 先决条件\n\n本指南要求在进行之前[安装](https:\/\/istio.io\/latest\/docs\/setup\/install\/) Istio（1.11\u002b）控制平面。\n\n### 部署应用程序\n\n创建一个支持注入的命名空间 \u0060echo-grpc\u0060。接下来部署两个 \u0060echo\u0060 应用程序的实例以及服务。\n\n\u0060\u0060\u0060sh\n$ kubectl create namespace echo-grpc\n$ kubectl label namespace echo-grpc istio-injection=enabled\n$ kubectl -n echo-grpc apply -f samples\/grpc-echo\/grpc-echo.yaml\n\u0060\u0060\u0060\n\n确保两个 Pod 正在运行。\n\n\u0060\u0060\u0060sh\n$ kubectl -n echo-grpc get pods\n\nNAME                       READY   STATUS    RESTARTS   AGE\necho-v1-69d6d96cb7-gpcpd   2\/2     Running   0          58s\necho-v2-5c6cbf6dc7-dfhcb   2\/2     Running   0          58s\n\u0060\u0060\u0060\n\n### 测试 gRPC 解析器\n\n首先，将 17171 端口转发到其中一个 Pod 上。这个端口是一个非 xDS 支持的 gRPC 服务端，允许从端口转发的 Pod 发出请求。\n\n\u0060\u0060\u0060sh\n$ kubectl -n echo-grpc port-forward $(kubectl -n echo-grpc get pods -l version=v1 -ojsonpath=\u0027{.items[0].metadata.name}\u0027) 17171 \u0026\n\u0060\u0060\u0060\n\n接下来，我们可以发送一批 5 个请求。\n\n\u0060\u0060\u0060sh\n$ grpcurl -plaintext -d \u0027{\u0022url\u0022: \u0022xds:\/\/\/echo.echo-grpc.svc.cluster.local:7070\u0022, \u0022count\u0022: 5}\u0027 :17171 proto.EchoTestService\/ForwardEcho | jq -r \u0027.output | join(\u0022\u0022)\u0027  | grep Hostname\n\nHandling connection for 17171\n[0 body] Hostname=echo-v1-7cf5b76586-bgn6t\n[1 body] Hostname=echo-v2-cf97bd94d-qf628\n[2 body] Hostname=echo-v1-7cf5b76586-bgn6t\n[3 body] Hostname=echo-v2-cf97bd94d-qf628\n[4 body] Hostname=echo-v1-7cf5b76586-bgn6t\n\u0060\u0060\u0060\n\n你也可以使用类似 Kubernetes 名称解析的短名称。\n\n\u0060\u0060\u0060sh\n$ grpcurl -plaintext -d \u0027{\u0022url\u0022: \u0022xds:\/\/\/echo:7070\u0022}\u0027 :17171 proto.EchoTestService\/ForwardEcho | jq -r \u0027.output | join\n(\u0022\u0022)\u0027  | grep Hostname\n[0 body] Hostname=echo-v1-7cf5b76586-ltr8q\n$ grpcurl -plaintext -d \u0027{\u0022url\u0022: \u0022xds:\/\/\/echo.echo-grpc:7070\u0022}\u0027 :17171 proto.EchoTestService\/ForwardEcho | jq -r\n\u0027.output | join(\u0022\u0022)\u0027  | grep Hostname\n[0 body] Hostname=echo-v1-7cf5b76586-ltr8q\n$ grpcurl -plaintext -d \u0027{\u0022url\u0022: \u0022xds:\/\/\/echo.echo-grpc.svc:7070\u0022}\u0027 :17171 proto.EchoTestService\/ForwardEcho | jq -r\n\u0027.output | join(\u0022\u0022)\u0027  | grep Hostname\n[0 body] Hostname=echo-v2-cf97bd94d-jt5mf\n\u0060\u0060\u0060\n\n### 用目的地规则创建子集\n\n首先，为每个版本的工作负载创建一个子集。\n\n\u0060\u0060\u0060sh\n$ cat \u003c\u003cEOF | kubectl apply -f -\napiVersion: networking.istio.io\/v1alpha3\nkind: DestinationRule\nmetadata:\n  name: echo-versions\n  namespace: echo-grpc\nspec:\n  host: echo.echo-grpc.svc.cluster.local\n  subsets:\n  - name: v1\n    labels:\n      version: v1\n  - name: v2\n    labels:\n      version: v2\nEOF\n\u0060\u0060\u0060\n\n### 流量转移\n\n使用上面定义的子集，你可以把 80% 的流量发送到一个特定的版本。\n\n\u0060\u0060\u0060sh\n$ cat \u003c\u003cEOF | kubectl apply -f -\napiVersion: networking.istio.io\/v1beta1\nkind: VirtualService\nmetadata:\n  name: echo-weights\n  namespace: echo-grpc\nspec:\n  hosts:\n  - echo.echo-grpc.svc.cluster.local\n  http:\n  - route:\n    - destination:\n        host: echo.echo-grpc.svc.cluster.local\n        subset: v1\n      weight: 20\n    - destination:\n        host: echo.echo-grpc.svc.cluster.local\n        subset: v2\n      weight: 80\nEOF\n\u0060\u0060\u0060\n\n现在，发送一组 10 个请求。\n\n\u0060\u0060\u0060sh\ngrpcurl -plaintext -d \u0027{\u0022url\u0022: \u0022xds:\/\/\/echo.echo-grpc.svc.cluster.local:7070\u0022, \u0022count\u0022: 10}\u0027 :17171 proto.EchoTestService\/ForwardEcho | jq -r \u0027.output | join(\u0022\u0022)\u0027  | grep ServiceVersion\n\u0060\u0060\u0060\n\n响应应主要包含 v2 响应。\n\n\u0060\u0060\u0060plain\n[0 body] ServiceVersion=v2\n[1 body] ServiceVersion=v2\n[2 body] ServiceVersion=v1\n[3 body] ServiceVersion=v2\n[4 body] ServiceVersion=v1\n[5 body] ServiceVersion=v2\n[6 body] ServiceVersion=v2\n[7 body] ServiceVersion=v2\n[8 body] ServiceVersion=v2\n[9 body] ServiceVersion=v2\n\u0060\u0060\u0060\n\n### 启用 mTLS\n\n由于在 gRPC 中启用安全所需的应用程序本身的变化，Istio 的自动检测 mTLS 支持的传统方法是不可靠的。出于这个原因，初始版本需要在客户端和服务端上明确启用 mTLS。\n\n要启用客户端的 mTLS，请应用带有 \u0060tls\u0060 设置的 \u0060DestinationRule\u0060。\n\n\u0060\u0060\u0060sh\n$ cat \u003c\u003cEOF | kubectl apply -f -\napiVersion: networking.istio.io\/v1alpha3\nkind: DestinationRule\nmetadata:\n  name: echo-mtls\n  namespace: echo-grpc\nspec:\n  host: echo.echo-grpc.svc.cluster.local\n  trafficPolicy:\n    tls:\n      mode: ISTIO_MUTUAL\nEOF\n\u0060\u0060\u0060\n\n现在，试图调用尚未配置 mTLS 的服务器将会失败。\n\n\u0060\u0060\u0060sh\n$ grpcurl -plaintext -d \u0027{\u0022url\u0022: \u0022xds:\/\/\/echo.echo-grpc.svc.cluster.local:7070\u0022}\u0027 :17171 proto.EchoTestService\/ForwardEcho | jq -r \u0027.output | join(\u0022\u0022)\u0027\n\nHandling connection for 17171\nERROR:\nCode: Unknown\nMessage: 1\/1 requests had errors; first error: rpc error: code = Unavailable desc = all SubConns are in TransientFailure\n\u0060\u0060\u0060\n\n为了启用服务器端的 mTLS，应用一个 \u0060PeerAuthentication\u0060。\n\n以下策略对整个命名空间强制采用 STRICT mTLS。\n\n\u0060\u0060\u0060sh\n$ cat \u003c\u003cEOF | kubectl apply -f -\napiVersion: security.istio.io\/v1beta1\nkind: PeerAuthentication\nmetadata:\n  name: echo-mtls\n  namespace: echo-grpc\nspec:\n  mtls:\n    mode: STRICT\nEOF\n\u0060\u0060\u0060\n\n应用该政策后，请求将开始成功。\n\n\u0060\u0060\u0060sh\n$ grpcurl -plaintext -d \u0027{\u0022url\u0022: \u0022xds:\/\/\/echo.echo-grpc.svc.cluster.local:7070\u0022}\u0027 :17171 proto.EchoTestService\/ForwardEcho | jq -r \u0027.output | join(\u0022\u0022)\u0027\n\nHandling connection for 17171\n[0] grpcecho.Echo(\u0026{xds:\/\/\/echo.echo-grpc.svc.cluster.local:7070 map[] 0  5s false })\n[0 body] x-request-id=0\n[0 body] Host=echo.echo-grpc.svc.cluster.local:7070\n[0 body] content-type=application\/grpc\n[0 body] user-agent=grpc-go\/1.39.1\n[0 body] StatusCode=200\n[0 body] ServiceVersion=v1\n[0 body] ServicePort=17070\n[0 body] Cluster=\n[0 body] IP=10.68.1.18\n[0 body] IstioVersion=\n[0 body] Echo=\n[0 body] Hostname=echo-v1-7cf5b76586-z5p8l\n\u0060\u0060\u0060\n\n## 限制条件\n\n最初的版本有几个限制，可能会在未来的版本中修复。\n\n- 不支持自动 mTLS，也不支持许可模式。相反，我们需要在服务器上使用 \u0060STRICT\u0060，在客户端使用 \u0060ISTIO_MUTUAL\u0060 的明确 mTLS 配置。在迁移到 \u0060STRICT\u0060 的过程中，可以使用 Envoy。\n- \u0060grpc.Serve(listener)\u0060 或 \u0060grpc.Dial(\u0022xds:\/\/...\u0022)\u0060 在 bootstrap 被写入或 xDS 代理准备好之前被调用会导致失败。 \u0060holdApplicationUntilProxyStarts\u0060 可以用来解决这个问题，或者应用程序可以对这些失败更加稳健。\n- 如果支持 xDS 的 gRPC 服务器使用 mTLS，那么你将需要确保你的健康检查可以绕过这个问题。要么使用一个单独的端口，要么你的健康检查客户端需要一种方法来获得适当的客户端证书。\n- gRPC 中 xDS 的实现与 Envoy 不一致。某些行为可能不同，某些功能可能缺失。[gRPC 的功能状态](https:\/\/github.com\/grpc\/grpc\/blob\/master\/doc\/grpc_xds_features.md)提供了更多细节。请确保测试任何 Istio 配置是否真正适用于你的无代理的 gRPC 应用程序。\n\n## 性能\n\n### 实验设置\n\n- 使用 Fortio，一个基于 Go 的负载测试应用程序\n  - 稍作修改，以支持 gRPC 的 XDS 功能 (PR)\n- 资源：\n  - GKE 1.20 集群有 3 个 \u0060e2-standard-16\u0060 节点（每个节点有 16 个 CPU\u002b64GB 内存）\n  - Fortio 客户端和服务器应用程序：1.5 vCPU，1000 MiB 内存\n  - Sidecar（istio-agent 和可能的 Envoy 代理）：1 vCPU，512 MiB 内存\n- 测试的工作负载类型：\n  - 基线：常规的 gRPC，没有使用 Envoy 代理或 Proxyless xDS\n  - Envoy：标准的 istio-agent \u002b Envoy proxy sidecar\n  - 无代理：使用 xDS gRPC 服务器实现的 gRPC 和客户端的 \u0060xds:\/\/\/\u0060 解析器。\n  - 通过 \u0060PeerAuthentication\u0060 和 \u0060DestinationRule\u0060 启用 \/ 停用 mTLS\n\n### 延迟\n\n![P50 延迟对比图](008i3skNly1gwp512szlvj31260rgq57.jpg)\n\n![P99 延迟对比图](008i3skNly1gwp51zjxqaj312q0r2jtl.jpg)\n\n在使用无代理的 gRPC 解析器时，延迟会有微小的增加。与 Envoy 相比，这是一个巨大的改进，仍然可以实现先进的流量管理功能和 mTLS。\n\n### istio-proxy 容器的资源使用情况\n\n| 类别        | 客户端 \u0060mCPU\u0060 | 客户端内存 (\u0060MiB\u0060) | 服务端 \u0060mCPU\u0060 | 服务端内存 (\u0060MiB\u0060) |\n| ----------- | ------------- | ------------------ | ------------- | ------------------ |\n| Envoy 明文  | 320.44        | 66.93              | 243.78        | 64.91              |\n| Envoy mTLS  | 340.87        | 66.76              | 309.82        | 64.82              |\n| 无代理明文  | 0.72          | 23.54              | 0.84          | 24.31              |\n| 无代理 mTLS | 0.73          | 25.05              | 0.78          | 25.43              |\n\n尽管我们仍然需要一个代理，但代理使用的内存不到完整 vCPU 的 0.1%，而且只有 25 MiB，这还不到运行 Envoy 所需内存的一半。\n\n这些指标不包括应用容器中 gRPC 的额外资源使用量，但有助于展示 istio-agent 在此模式下运行时的资源使用影响。\n', '\/trans\/grpc-proxyless-service-mesh\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文介绍了 Istio 对 gRPC 的无代理服务网格功能的支持。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/how-ebpf-streamlines-the-service-mesh/">[译] eBPF 如何简化服务网格</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2021/10/27</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://thenewstack.io/how-ebpf-streamlines-the-service-mesh/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('eBPF 如何简化服务网格', '本文探讨一下 eBPF 是如何让我们精简服务网格，使服务网格的数据平面更有效率，更容易部署。', '\n今天有几个服务网格的产品和项目，承诺简化应用微服务之间的连接，同时提供额外的功能，如安全连接、可观测性和流量管理。但正如我们在过去几年中反复看到的那样，对服务网格的兴奋已经被对额外的[复杂性](https:\/\/engineering.hellofresh.com\/everything-we-learned-running-istio-in-production-part-2-ff4c26844bfb)和[开销的](https:\/\/pklinker.medium.com\/performance-impacts-of-an-istio-service-mesh-63957a0000b)实际[担忧所抑制](https:\/\/medium.com\/geekculture\/watch-out-for-this-istio-proxy-sidecar-memory-pitfall-8dbd99ea7e9d)。让我们来探讨一下 [eBPF](https:\/\/ebpf.io\/) 是如何让我们精简[服务网格](https:\/\/thenewstack.io\/category\/service-mesh\/)，使服务网格的数据平面更有效率，更容易部署。\n\n## Sidecar 问题\n\n今天的 Kubernetes 服务网格解决方案要求你在每一个应用 pod 上添加一个代理 sidecar 容器，如 [Envoy](https:\/\/www.envoyproxy.io\/) 或 [Linkerd-proxy](https:\/\/linkerd.io\/)。这是正确的：即使在一个非常小的环境中，比如说有 20 个服务，每个服务运行五个 pod，分布在三个节点上，你也有 100 个代理容器。无论代理的实现多么小和有效，这种纯粹的重复都会耗费资源。\n\n每个代理使用的内存与它需要能够通信的服务数量有关。Pranay Singhal 写了他配置 Istio 的[经验](https:\/\/medium.com\/geekculture\/watch-out-for-this-istio-proxy-sidecar-memory-pitfall-8dbd99ea7e9d)，将每个代理的消耗从 1GB 左右减少到更合理的 60-70MB。但是，即使在我们的小环境中，在三个节点上有 100 个代理，这种优化配置仍然需要每个节点 2GB 左右。\n\n![来自 [redhat.com\/architect\/why-when-service-mesh](https:\/\/redhat.com\/architect\/why-when-service-mesh)——每个微服务都有自己的代理 sidecar](008i3skNly1gvtp69o74jj31w50u0jy8.jpg) \n\n为什么我们需要所有这些 sidecar？这种模式允许代理容器与 pod 中的应用容器共享一个网络命名空间。网络命名空间是 Linux 内核的结构，它允许容器和 pod 拥有自己独立的网络堆栈，将容器化的应用程序相互隔离。这使得应用之间互不相干，这就是为什么你可以让尽可能多的 pod 在 80 端口上运行一个 web 应用 —— 网络命名空间意味着它们各自拥有自己的 80 端口。代理必须共享相同的网络命名空间，这样它就可以拦截和处理进出应用容器的流量。\n\n## 引入 eBPF\n\n[eBPF](http:\/\/ebpf.io\/) 是一种内核技术，允许自定义程序在内核中运行。这些程序在响应事件时运行，有成千上万个可能的事件，eBPF 程序可以被附加到这些事件上。这些事件包括轨迹点、进入或退出任何功能（在内核或用户空间）或对服务网格来说很重要的 —— 抵达的网络数据包。\n\n重要的是，**每个节点只有一个内核**；在一个节点上运行的所有容器（也就是所有的 pod）共享同一个内核。如果你在内核中添加一个 eBPF 程序到一个事件中，它将被触发，无论哪个进程引起该事件，无论它是在应用容器中运行还是直接运行在主机上。\n\n![每台主机一个内核](008i3skNly1gvtp6c8mn9j31ea0u0n0t.jpg) \n\n这就是为什么 eBPF 对于 Kubernetes 中的任何一种 instrumentation 来说都是如此令人兴奋的技术 —— 你只需要在每个节点上添加一次 instrumentation，所有的应用程序 pod 都会被覆盖。无论你是在寻求可观测性、安全性还是网络，由 eBPF 驱动的解决方案都可以在不需要 sidecar 的情况下对应用进行检测。\n\n基于 eBPF 的 [Cilium](http:\/\/cilium.io\/) 项目（最近 [以孵化级别加入云计算基金会](https:\/\/www.cncf.io\/blog\/2021\/10\/13\/cilium-joins-cncf-as-an-incubating-project\/)）将这种“无 sidecar\u0022 模式带到了服务网格的世界。除了传统的 sidecar 模型，Cilium 还支持每个节点使用一个 Envoy 代理实例运行服务网格的数据平面。使用我们前面的例子，这就把代理实例的数量从 100 个减少到只有 3 个。\n\n![用无 sidecar 代理模式减少代理实例](008i3skNly1gvtp67ocjkj31xt0u0jvp.jpg) \n\n## 减少 YAML\n\n在 sidecar 模型中，指定每个应用 pod 的 YAML 需要被修改以添加 sidecar 容器。这通常是自动化的 —— 例如，使用一个 mutating webhook，在每个应用 pod 部署的时候注入 sidecar。\n\n以 Istio 为例，这需要[标记](https:\/\/istio.io\/latest\/docs\/setup\/additional-setup\/sidecar-injection\/#controlling-the-injection-policy) Kubernetes 命名空间和 \/ 或 pod，以定义是否应该注入 sidecar—— 当然也需要为集群启用 mutating webhook。\n\n但如果出了问题怎么办？如果命名空间或 pod 的标签不正确，那么 sidecar 将不会被注入，pod 将不会被连接到服务网格。更糟糕的是，如果攻击者破坏了集群，并能够运行一个恶意的工作负载 —— 例如，一个加密货币矿工，他们将不太可能标记它，以便它加入服务网格。它不会通过服务网格提供的流量观察能力而被发现。\n\n相比之下，在支持 eBPF 的无 sidecar 代理模型中，pod 不需要任何额外的 YAML 就可以被检测。相反，一个 CRD 被用来在集群范围内配置服务网格。即使是已经存在的 pod 也可以成为服务网格的一部分，而不需要重新启动。\n\n如果攻击者试图通过直接在主机上运行工作负载来绕过 Kubernetes 编排，eBPF 程序可以检测并控制这一活动，因为这一切都可以从内核看到。\n\n## eBPF 支持的网络效率\n\n支持 eBPF 的网络允许数据包走捷径，绕过内核的部分网络堆栈，这可以使 Kubernetes 网络的[性能得到显著改善](https:\/\/cilium.io\/blog\/2021\/05\/11\/cni-benchmark)。让我们看看这在服务网格数据平面中是如何应用的。\n\n![在 eBPF 加速、无 sidecar 的服务网格模型中，网络数据包通过的路径要短得多](008i3skNly1gvtp6ao3lqj31q90u0gqw.jpg) \n\n在服务网格的情况下，代理在传统网络中作为 sidecar 运行，数据包到达应用程序的路径相当曲折：入站数据包必须穿越主机 TCP\/IP 栈，通过虚拟以太网连接到达 pod 的网络命名空间。从那里，数据包必须穿过 pod 的网络堆栈到达代理，代理将数据包通过回环接口转发到应用程序。考虑到流量必须在连接的两端流经代理，与非服务网格流量相比，这将导致延迟的[显著增加](https:\/\/linkerd.io\/2021\/05\/27\/linkerd-vs-istio-benchmarks\/#latency-at-20-rps)。\n\n基于 eBPF 的 Kubernetes CNI 实现，如 Cilium，可以使用 eBPF 程序，明智地钩住内核中的特定点，沿着更直接的路线重定向数据包。这是可能的，因为 Cilium 知道所有的 Kubernetes 端点和服务的身份。当数据包到达主机时，Cilium 可以将其直接分配到它所要去的代理或 Pod 端点。\n\n## 网络中的加密\n\n如果一个网络解决方案能够意识到 Kubernetes 服务，并在这些服务的端点之间提供网络连接，那么它能够提供服务网格数据平面的能力就不足为奇。但这些能力可以超越基本的连接。一个例子是透明加密。\n\n通常使用服务网格来确保所有的应用流量都是经过认证和加密的。这是通过双向 TLS（mTLS）实现的；服务网格代理组件作为网络连接的端点，并与其远程对等物协商一个安全的 TLS 连接。这种连接对代理之间的通信进行加密，而不需要对应用程序做任何改变。\n\n但在应用层管理的 TLS 并不是实现组件间认证和加密流量的唯一方法。另一个选择是在网络层加密流量，使用 [IPSec 或 WireGuard](https:\/\/cilium.io\/blog\/2021\/05\/11\/cni-benchmark#the-cost-of-encryption---wireguard-vs-ipsec)。因为它在网络层操作，这种加密不仅对应用程序完全透明，而且对代理也是透明的 —— 它可以在有或没有服务网格时启用。如果你使用服务网格的唯一原因是提供加密，你可能想考虑网络级加密。它不仅更简单，而且还可以用来验证和加密节点上的任何流量 —— 它不只限于那些启用了 sidecar 的工作负载。\n\n## eBPF 是服务网格的数据平面\n\n现在，eBPF 在 Linux 生产发行版使用的内核版本中得到广泛支持，企业可以利用它来获得更有效的网络解决方案，并作为服务网格的更有效的数据平面。\n\n去年，我代表 [CNCF](https:\/\/cncf.io\/?utm_content=inline-mention) 的技术监督委员会，对服务网格领域的整合和清晰化做了一些 [预测](https:\/\/youtu.be\/bESogtuHwX0)。在同一主题演讲中，我谈到 eBPF 有可能成为更多项目和更广泛部署能力的基础。这两个想法现在正结合在一起，因为 eBPF 似乎是服务网格数据平面的自然路径。\n', '\/trans\/how-ebpf-streamlines-the-service-mesh\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文探讨一下 eBPF 是如何让我们精简服务网格，使服务网格的数据平面更有效率，更容易部署。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/can-ztna-replace-vpn/">[译] ZTNA 能取代 VPN 吗？——三种远程访问方法对比</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2021/10/13</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e5%ae%89%e5%85%a8"> 
             安全
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://assets.ctfassets.net/slt3lc6tev37/IcpGyTHplQhOeB60k1Egp/e49211fc4482b67f3bf264c22923ef5c/Can_ZTNA_replace_your_VPN" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('ZTNA 能取代 VPN 吗？——三种远程访问方法对比', '本文对比了 VPN 和 ZTNA 远程访问解决方案，阐明了它们的好处和局限性，同时阐明了迁移项目的最重要考虑因素。同时给出了 Cloudflare 的解决方案及迁移到 ZTNA 的步骤建议。', '\n## 编者按\n\n本文译自 Cloudflare 出品的白皮书 [*Can ZTNA replace your VPN? Compare 3 remote access approaches*](https:\/\/assets.ctfassets.net\/slt3lc6tev37\/IcpGyTHplQhOeB60k1Egp\/e49211fc4482b67f3bf264c22923ef5c\/Can_ZTNA_replace_your_VPN)，本文对比了 VPN 和 ZTNA 远程访问解决方案，阐明了它们的好处和局限性，同时阐明了迁移项目的最重要考虑因素。同时给出了 Cloudflare 的解决方案及迁移到 ZTNA 的步骤建议。\n\n## 简介\n\n安全、无缝的远程访问是一个业务促进因素——提高远程用户的生产力，减少 IT 团队花在入职和维护用户与应用连接的时间，并具有灵活性和弹性。然而，远程访问对许多企业来说仍然是一个挑战。\n\n很久以前，VPN 提供了一种简单的方法，将一些远程用户短暂地连接到企业网络。然而，随着劳动力的分布越来越广——企业需要在更长时间内保持远程用户的安全连接——这种方法的缺陷变得很明显，从性能低下、安全风险增加到扩展性问题。\n\n随着远程访问需求的增长，企业正越来越多地从传统的 VPN 实施方式转向更安全、性能更高的远程访问解决方案。零信任网络访问（Zero Trust Network Access），或称 ZTNA，围绕特定的应用程序、私有 IP 和主机名创建安全边界，用基于身份和背景授予访问权的默认拒绝策略取代默认允许的 VPN 连接。\n\n![](008i3skNly1gvco15q2jsj619a0nead202.jpg) \n\n2020 年，大约 5% 的远程访问使用主要由 ZTNA 提供服务。由于传统 VPN 访问的局限性以及提供更精确的访问和会话控制的需要，预计到 2024 年，这一数字将跃升至 40%。\n\n虽然 ZTNA 为企业提供了比 VPN 更明显的优势和更多的功能，但许多组织发现它并不能完全替代 VPN 基础设施。但是，随着 ZTNA 变得更加强大，VPN 问题变得更加严重，这种情况正在迅速改变。本文对比了 VPN 和 ZTNA 远程访问解决方案，阐明了它们的好处和局限性，同时阐明了迁移项目的最重要考虑因素。它解释了 Cloudflare 如何提供 ZTNA，并推荐了一套行动步骤，将传统的 VPN 基础设施过渡到更快、更安全的远程用户零信任连接。\n\n## 方法 1：传统的 VPN\n\n几十年来，VPN 使组织能够将其远程用户连接到公司网络，并具有一定的隐私和安全性。在公共互联网上访问敏感信息，任何攻击者都可能窥探或窃取数据，而 VPN 允许用户通过加密连接安全访问内部资源。\n\n两种最常见的 VPN 实施模式是基于客户端的 VPN 和无客户端的 SSL-VPN。每种模式都有各自的好处和挑战。\n\n基于客户端的 VPN 通过加密的隧道将远程用户连接到一个私人网络。这种连接是通过一个软件应用程序或客户端建立的，它要求用户用用户名和密码进行一次认证，以获得对该网络内任何资源的持续访问。\n\n**优点**\n\n一旦建立连接，就自由的横向移动使用户很容易通过访问应用程序和连接到内部主机来快速访问多种资源。\n\n**挑战**\n\n- 不是为漫游用户和移动设备设计的。当用户四处漫游时，他们的笔记本电脑和移动设备都会随着无线网络的变化而无缝地重新连接。然而，VPN 客户端不善于流畅地处理这些重新连接，要求用户反复强迫 VPN 客户端重新启动和重新认证——造成生产力的损失，并产生 IT 票据。\n\n- 可见性差。采用这种方法，VPN 基础设施在数据中心的内部防火墙背后终止了来自 VPN 客户端的加密隧道。虽然这些连接被记录下来，但没有特定的应用集中日志来显示用户访问了哪些应用或他们在应用中采取了哪些行动。\n\n无客户端的 SSL-VPN 门户允许少数远程用户连接到私人网络中的一些基于浏览器的应用程序。这种连接是通过运行 VPN 服务的网络设备中内置的 Web 服务器实现的。\n\n**挑战**\n\n- 安全问题。数据中心内的大多数 VPN 设置允许用户完全访问，这给那些不希望非雇员（如承包商）不受限制地访问敏感资源和应用程序的组织带来了问题。\n\n- 不是为支持大量的并发用户而建立的。与现代云服务不同，门户网站的网络服务器不能弹性扩展以满足更高需求。相反，必须安装更多的网络设备并进行负载均衡，以扩大门户的规模，这通常是昂贵、复杂和无效的，因为设备的其他功能可能没有被充分利用。\n\n- 无客户端的 SSL-VPN 门户使防火墙端口和网络服务器暴露在攻击之下。为了让托管门户的网络服务器能够到达内部应用，管理员必须开放入站防火墙端口，使其暴露在外部攻击之下。开放的端口和网络服务器本身都必须屏蔽 DDoS 和网络应用的攻击，这需要更复杂的配置和更高的成本，以确保这种连接方法的安全。\n\nwpsfkrjr5.png) \n\n 虽然 VPN 为远程用户提供了基本的隐私，但在设计时并没有考虑到安全性或可扩展性。传统上，企业使用 VPN 将少数远程用户短期连接到企业网络。然而，随着远程工作变得越来越普遍，VPN 问题开始成倍增加。\n\n- 用户体验到性能低下。如果 VPN 基础设施没有能力处理其员工创造的流量吞吐量和并发连接，用户的互联网连接就会变慢。此外，当 VPN 距离用户和他们试图访问的应用服务器都很远时，就会造成访问延迟。\n\n- 企业网络容易受到攻击。VPN 通常采用城堡和山丘模式，即用户一旦连接到网络，就可以不受限制地访问所有企业资源。由于没有内置的方法来限制对关键基础设施和数据的访问，企业被迫配置昂贵、复杂的安全服务，如下一代防火墙和网络访问控制——或者容易受到恶意的横向移动，导致更大的数据泄露。\n\n**托管 VPN 服务的挑战**\n\n一些供应商已经将运行 VPN 服务的网络设备转移到公有云中，作为虚拟机在一个或多个数据中心运行。VPN 可能与其他安全服务捆绑在一起，也可能不与之捆绑在一起（或与之串联）。\n\n将 VPN 置于云中，似乎可以解决硬件 VPN 设备固有的一些可扩展性问题。然而，这样做也带来了一些重大的安全和可扩展性挑战。\n\n例如有一个组织托管一个完整的 NGFW（下一代防火墙），将 VPN 与防火墙和其他安全功能结合起来。由于 NGFW 是作为一个捆绑服务提供的，因此不可能根据需求独立扩展任何特定功能。扩大一个功能需要扩大整个服务；要做到这一点，必须启动更多的虚拟机，以平衡每个虚拟机中执行的少量计算的负载。这不仅是一个不切实际且不便的解决方案，而且随着组织的远程访问需求不断扩大，很可能会产生高额费用。\n\n## 方法 2：零信任网络访问\n\n零信任安全规避了 VPN 所固有的许多挑战。它所依据的原则是，网络内部或外部的任何用户或设备都不能被默认信任。为了减少数据泄露、内部攻击和其他威胁的风险和影响，零信任方法——\n\n- 对每一次登录和请求进行认证和记录。\n\n- 要求对所有用户和设备进行严格的核查。\n\n- 根据身份和背景，限制每个用户和设备可以访问的信息。\n\n- 并增加了端对端加密，以隔离网络中的应用和数据。\n\n![](008i3skNly1gvcoksofzvj61o80u0q5q02.jpg) \n\n与 VPN 一样，ZTNA 有两种配置方式：\n\n1. 无客户端（或服务发起的）ZTNA 使用现有的浏览器，而不是客户端，来创建一个安全连接并验证用户设备。传统上，无客户端 ZTNA 仅限于具有 HTTP\/HTTPS 协议的应用，但兼容性正在快速发展。 \n\n- 优点：无客户端 ZTNA 使用反向代理连接，防止直接访问应用程序，阻止用户访问他们可能没有权限查看的应用程序和数据，并允许管理员在管理方面有更强的控制和灵活性。\n\n2. 基于客户端（终端启动）的 ZTNA 在控制代理和授权应用之间建立加密连接之前，在用户设备上安装软件。\n\n- 优点：基于客户端的 ZTNA 使管理员能够更深入地了解用户访问应用程序的设备状态、位置和风险背景，因此可以创建和执行更精细的策略。而且，由于这种方法不限于 HTTP\/HTTPS，它可以用来访问更广泛的非 HTTP 应用——例如那些依赖 SSH、RDP、VNC、SMB 和其他 TCP 连接的应用。\n\n**实施 ZTNA 的挑战**\n\n虽然 ZTNA 与传统的 VPN 相比具有明显的优势，但它并不是一个确保远程用户网络访问安全的完美方法。当企业权衡采用零信任的利弊时，他们可能会遇到以下一个或多个挑战。\n\n1. 解决方案并不是真正的云原生。\n\n如果供应商不提供基于云的 ZTNA——意味着他们的客户需要在自己的数据中心部署软件，那么用户就会失去即时可扩展性和无限吞吐量等关键优势。\n\n2. 供应商可能不提供基于客户端和无客户端的 ZTNA 选项。\n\n这限制了那些需要将用户连接到非 HTTP 应用（如远程桌面、SSH 应用或文件共享）的组织的价值。\n\n3. 配置可能是复杂和耗时的。\n\n不提供策略协调和自动化支持的供应商（通过 Terraform 等工具）可能会给管理员带来更多的手动工作——除了在身份提供者中已经发生的配置之外。\n\n## 方法 3：Cloudflare 的远程访问方法\n\n保护和扩展远程访问应该是一个无缝的过程，一个不分层的笨重的安全解决方案，创造性能的权衡，减少不必要的成本。Cloudflare 使团队能够处理所有的远程访问用例，具有以下好处。\n\n- 为用户和管理员提供简单、无风险的入职培训。Cloudflare 很容易与现有的身份供应商和终端保护平台集成，以执行限制访问企业应用程序和资源的零信任政策。\n\n- 基于客户端和无客户端的 ZTNA 部署的灵活性。Cloudflare 为网络、SSH、VNC（以及即将推出的 RDP）应用程序的连接提供无客户端支持，为非 HTTP 应用程序和内部 IP（以及即将推出的主机名）的私有路由提供基于客户端的支持。\n\n![](wpsxPzRG3.png)  \n\n表 1：Cloudflare 如何应对远程访问挑战\n\n| 问题             | 解决方案        | Cloudflare 的实施                                   |\n| -------------------------- | ------------------------- | ------------------------------------------------------------ |\n| 难以扩展                   | 全局边缘网络            | 可扩展性问题困扰着非云原生的 VPN 和 ZTNA 服务，使远程用户难以访问应用程序和数据。Cloudflare 的全球 Anycast 网络不仅使用户的连接速度比 VPN 快，而且还确保任何规模的远程工作者都能根据需要安全、迅速地连接到企业资源，而不需要管理员进行额外的耗时配置。 |\n| 与移动设备的兼容性差       | 轻量级客户端              | 利用 IPSec 和 SSL 协议的 VPN 和 ZTNA 解决方案在移动和漫游设备上的性能往往不佳。Cloudflare 的 WARP 客户端利用更现代的 Wireguard 协议，该协议在用户空间运行，支持更广泛的操作系统选项，与传统选项相比，用户体验更好。Cloudflare 的 WARP 客户端可以在 Windows、MacOS、iOS、Android 和即将到来的 Linux 设备上配置。 |\n| 没有集成的或薄弱的 DDoS 保护 | 内置行业领先的 DDoS 保护    | 如果没有集成的 DDoS 保护，企业往往被迫以 daisy-chain 方式提供额外的安全服务，这可能会造成配置上的麻烦、可扩展性问题和安全挑战。Cloudflare 的 67\u002bTbps 网络为任何 ZTNA 模式提供内置的 DDoS 保护，抵御最大规模的攻击。 |\n| 协议的限制             | 非网络应用程序支持        | 模式兼容性：用于 SSH\/VNC 应用的无客户端 ZTNA；用于所有其他非网络应用的基于客户端的 ZTNA。 |\n| 没有集成的网络防火墙       | 内置网络防火墙            | 随着企业网络的发展，企业必须平衡的安全硬件堆栈也在不断增加——导致成本、性能和安全方面的折衷。Cloudflare 使管理员能够在边缘执行网络防火墙策略，使他们能够精细地控制哪些数据允许进出网络，并提高流量流经网络的可见性。  ✓ 模式兼容性：基于客户端的 ZTNA |\n| 缺乏细粒度的控制           | 内置安全网关（SWG） | 未经批准使用应用程序会给企业带来严重的安全问题；如果没有严格的政策，用户可能会访问和篡改敏感数据和其他企业资源。结合 ZTNA 和 SWG，Cloudflare 允许管理员对应用程序内的用户和设备访问权限进行更精细的控制，因此用户和基于角色的组只能访问他们需要的资源。✓ 模式兼容性：基于客户端的 ZTNA |\n\n## 用零信任网络访问取代传统 VPN\n\n在向无 VPN 安全过渡的漫长而痛苦的过程中，IT 安全领导可能会觉得零信任的承诺很空洞。但是，用零信任网络访问取代 VPN 是可能的，而不需要在协议支持或功能上做出取舍。\n\n推荐的迁移路径根据驱动你的项目的业务专家而有所不同。\n\n- 如果更快连接到应用程序是你的首要任务，请部署基于客户端的 ZTNA，首先用于非网络应用。\n\n- 如果加强你的应用程序访问规则的安全性更为重要，那么就从网络应用开始。替换 VPN 只是整个网络转型的第一步。由于向 SASE 模式的过渡可能是压倒性的，我们根据客户采取的方法，分解了一条通往零信任安全的常见路径。\n\n\n![](008i3skNly1gvcoknm2onj61tx0u0thb02.jpg)  \n', '\/trans\/can-ztna-replace-vpn\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文对比了 VPN 和 ZTNA 远程访问解决方案，阐明了它们的好处和局限性，同时阐明了迁移项目的最重要考虑因素。同时给出了 Cloudflare 的解决方案及迁移到 ZTNA 的步骤建议。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/service-mesh-ultimate-guide-e2/">[译] 服务网格终极指南第二版——下一代微服务开发</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2021/10/11</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://www.infoq.com/articles/service-mesh-ultimate-guide-2e/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('服务网格终极指南第二版——下一代微服务开发', '本文是 InfoQ 自 2020 年 2 月发表的服务网格终极指南后的第二版，发布于 2021 年 9 月。', '\n### 主要收获\n\n- 了解采用服务网格技术的新兴架构趋势，特别是多云、多集群和多租户模式，如何在异构基础设施（裸机、虚拟机和 Kubernetes）中部署服务网格解决方案，以及从边缘计算层到网格的应用 \/ 服务连接。\n- 了解服务网格生态系统中的一些新模式，如多集群服务网格、媒体服务网格（Media Service Mesh）和混沌网格，以及经典的微服务反模式，如“死星（Death Star） “架构。\n- 获取最新的关于在部署领域使用服务网格的创新总结，在 Pod（K8s 集群）和 VM（非 K8s 集群）之间进行快速实验、混乱工程和金丝雀部署。\n- 探索服务网格扩展领域的创新，包括：增强身份管理，以确保微服务连接的安全性，包括自定义证书授权插件，自适应路由功能，以提高服务的可用性和可扩展性，以及增强 sidecar 代理。\n- 了解操作方面即将出现的情况，如配置多集群功能和将 Kubernetes 工作负载连接到托管在虚拟机基础设施上的服务器，以及管理多集群服务网格中所有功能和 API 的开发者门户。\n\n在过去的几年里，服务网格技术有了长足的发展。服务网格在各组织采用云原生技术方面发挥着重要作用。通过提供四种主要能力 —— 连接性、可靠性、可观测性和安全性，服务网格已经成为 IT 组织的技术和基础设施现代化工作的核心组成部分。服务网格使开发和运维团队能够在基础设施层面实现这些能力，因此，当涉及到跨领域的非功能需求时，应用团队不需要重新发明轮子。\n\n自本文[第一版](https:\/\/www.infoq.com\/articles\/service-mesh-ultimate-guide\/)于 2020 年 2 月发表以来，服务网格技术经历了重大创新，在不断发展的服务网格领域出现了一些新的架构趋势、技术能力和服务网格项目。\n\n在过去的一年里，服务网格产品的发展远远超过了原有的 Kubernetes 解决方案，没有托管在 Kubernetes 平台上的应用无法利用服务网格。并非所有的组织都将其所有的业务和 IT 应用程序过渡到 Kubernetes 云平台。因此，自服务网格诞生以来，一直需要这项技术在不同的 IT 基础设施环境中工作。\n\n随着微服务架构的不断采用，应用系统在云供应商、基础设施（Kubernetes、虚拟机、裸机服务器）、地域，甚至在服务网格集成环境中要管理的工作负载类型方面，都已实现解耦和分布式。\n\n让我们从服务网格的历史开始说起，了解服务网格是如何产生的。\n\n2016 年前后，“服务网格 \u0022 这个词出现在微服务、云计算和 DevOps 的领域。Buoyant 团队在 2016 年用[这个](https:\/\/twitter.com\/wm\/status\/1383061764938469377?s=20)词来解释他们的产品 Linkerd。和云计算领域的许多概念一样，相关的模式和技术其实有很长的历史。\n\n服务网格的到来主要是由于 IT 领域内的一场风暴。开发人员开始使用多语言（polyglot）方法构建分布式系统，并需要动态服务发现。运维部门开始使用短暂的基础设施，并希望优雅地处理不可避免的通信故障和执行网络策略。平台团队开始接受像 Kubernetes 这样的容器编排系统，并希望使用现代 API 驱动的网络代理（如 Envoy）在系统中和周围动态地路由流量。\n\n本文旨在回答软件架构师和技术负责人的相关问题，如：什么是服务网格？我是否需要服务网格？如何评估不同的服务网格产品？\n\n## 服务网格模式\n\n服务网格模式专注于管理分布式软件系统中所有服务之间的通信。\n\n### 背景介绍\n\n该模式的背景有两个方面。首先，工程师们已经采用了微服务架构模式，并通过将多个（理想情况下是单一用途且可独立部署的）服务组合在一起构建他们的应用。第二，组织已经接受了云原生平台技术，如容器（如 Docker）、编排器（如 Kubernetes）和网关。\n\n### 意图\n\n服务网格模式试图解决的问题包括：\n\n- 消除了将特定语言的通信库编译到单个服务中的需求，以处理服务发现、路由和应用层（第 7 层）非功能通信要求。\n- 外部化服务通信配置，包括外部服务的网络位置、安全凭证和服务质量目标。\n- 提供对其他服务的被动和主动监测。\n- 在整个分布式系统中分布式地执行策略。\n- 提供可观测性的默认值，并使相关数据的收集标准化。\n  - 启用请求记录\n  - 配置分布式追踪\n  - 收集指标\n\n### 结构\n\n服务网格模式主要侧重于处理传统上被称为“东西向“的基于远程过程调用（RPC）的流量：请求 \/ 响应类型的通信，源自数据中心内部，在服务之间传播。这与 API 网关或边缘代理相反，后者被设计为处理“南北“流量。来自外部的通信，进入数据中心内的一个终端或服务。\n\n## 服务网格的特点\n\n服务网格的实施通常会提供以下一个或多个功能：\n\n- 规范化命名并增加逻辑路由，（例如，将代码级名称“用户服务 \u0022 映射到平台特定位置“AWS-us-east-1a\/prod\/users\/v4”。\n- 提供流量整形和流量转移\n- 保持负载均衡，通常采用可配置的算法\n- 提供服务发布控制（例如，金丝雀释放和流量分割）\n- 提供按请求的路由（例如，影子流量、故障注入和调试重新路由）。\n- 增加基线可靠性，如健康检查、超时 \/ 截止日期、断路和重试（预算）。\n- 通过透明的双向传输级安全（TLS）和访问控制列表（ACL）等策略，提高安全性\n- 提供额外的可观测性和监测，如顶线指标（请求量、成功率和延迟），支持分布式追踪，以及 \u0022挖掘\u0022 和检查实时服务间通信的能力。\n- 使得平台团队能够配置 \u0022 理智的默认值”，以保护系统免受不良通信的影响。\n\n服务网格的能力可分为以下四个方面：\n\n- 连接性\n- 可靠性\n- 安全性\n- 可观测性\n\n让我们看看服务网格技术在这些领域都能提供哪些功能。\n\n**连接性**\n\n- 流量控制（路由，分流）\n- 网关（入口、出口）\n- 服务发现\n- A\/B 测试、金丝雀\n- 服务超时、重试\n\n**可靠性**\n\n- 断路器\n- 故障注入 \/ 混沌测试\n\n**安全性**\n\n- 服务间认证（mTLS）\n- 证书管理\n- 用户认证（JWT）\n- 用户授权（RBAC）\n- 加密\n\n**可观测性**\n\n- 监测\n- 遥测、仪表、计量\n- 分布式追踪\n- 服务图表\n\n## 服务网格架构：内部原理\n\n服务网格由两部分组成：数据平面和控制平面。Matt Klein，[Envoy Proxy](https:\/\/www.envoyproxy.io\/) 的作者，写了一篇关于“ [服务网格数据平面与控制平面 ](https:\/\/blog.envoyproxy.io\/service-mesh-data-plane-vs-control-plane-2774e720f7fc)“的深入探讨。\n\n广义上讲，数据平面“执行工作”，负责“有条件地翻译、转发和观察流向和来自 [网络终端] 的每个网络数据包”。在现代系统中，数据平面通常以代理的形式实现，（如 Envoy、[HAProxy](http:\/\/www.haproxy.org\/) 或 [MOSN](https:\/\/github.com\/mosn\/mosn)），它作为 \u0022sidecar\u0022 与每个服务一起在进程外运行。Linkerd 使用了一种 [微型代理](https:\/\/linkerd.io\/2020\/12\/03\/why-linkerd-doesnt-use-envoy\/)方法，该方法针对服务网格的使用情况进行了优化。\n\n控制平面“监督工作”，并将数据平面的所有单个实例 —— 一组孤立的无状态 sidecar 代理变成一个分布式系统。控制平面不接触系统中的任何数据包 \/ 请求，相反，它允许人类运维人员为网格中所有正在运行的数据平面提供策略和配置。控制平面还能够收集和集中数据平面的遥测数据，供运维人员使用。\n\n控制平面和数据平面的结合提供了两方面的优势，即策略可以集中定义和管理，同时，同样的政策可以以分散的方式，在 Kubernetes 集群的每个 pod 中本地执行。这些策略可以与安全、路由、断路器或监控有关。\n\n下图取自 Istio 架构文档，虽然标注的技术是 Istio 特有的，但这些组件对所有服务网格的实现都是通用的。\n\n![Istio 架构](arch.jpg) \n\nIstio 架构，展示了控制平面和代理数据平面的交互方式（由 [Istio 文档提供](https:\/\/istio.io\/docs\/)）。\n\n## 使用案例\n\n服务网格可以实现或支持多种用例。\n\n### 动态服务发现和路由\n\n服务网格提供动态服务发现和流量管理，包括用于测试的流量影子（复制），以及用于金丝雀发布和 A\/B 实验的流量分割。\n\n服务网格中使用的代理通常是“应用层 \u0022 感知的（在 OSI 网络堆栈的第 7 层运行）。这意味着流量路由决策和指标的标记可以利用 HTTP 头或其他应用层协议元数据。\n\n### 服务间通信可靠性\n\n服务网格支持跨领域的可靠性要求的实施和执行，如请求重试、超时、速率限制和断路。服务网格经常被用来补偿（或封装）处理[分布式计算的八个谬误](https:\/\/en.wikipedia.org\/wiki\/Fallacies_of_distributed_computing)。应该注意的是，服务网格只能提供 wire-level 的可靠性支持（如重试 HTTP 请求），最终服务应该对相关的业务影响负责，如避免多个（非幂等的）HTTP POST 请求。\n\n### 流量的可观测性\n\n由于服务网格处于系统内处理的每个请求的关键路径上，它还可以提供额外的“可观测性”，例如请求的分布式追踪、HTTP 错误代码的频率以及全局和服务间的延迟。虽然在企业领域是一个被过度使用的短语，但服务网格经常被提议作为一种方法来捕获所有必要的数据，以实现整个系统内流量的统一界面视图。\n\n### 通信安全\n\n服务网格还支持跨领域安全要求的实施和执行，如提供服务身份（通过 x509 证书），实现应用级服务 \/ 网络分割（例如，“服务 A\u0022 可以与“服务 B“通信，但不能与“服务 C“通信），确保所有通信都经过加密（通过 TLS），并确保存在有效的用户级身份令牌或“[护照](https:\/\/qconsf.com\/sf2019\/presentation\/user-device-identity-microservices-netflix-scale) \u0022。\n\n## 反模式\n\n当反模式的使用出现时，这往往是一个技术成熟的标志。服务网格也不例外。\n\n### 太多的流量管理层次\n\n当开发人员不与平台或运维团队协商，并在现在通过服务网格实现的代码中重复现有的通信处理逻辑时，就会出现这种反模式。例如，除了服务网格提供的 wire-level 重试策略外，应用程序还在代码中还实现了重试策略。这种反模式会导致重复的事务等问题。\n\n### 服务网格银弹\n\n在 IT 领域没有“银弹“这样的东西，但供应商有时会被诱惑给新技术贴上这个标签。服务网格不会解决微服务、Kubernetes 等容器编排器或云网络的所有通信问题。服务网格的目的只是促进服务件（东西向）的通信，而且部署和运行服务网格有明显的运营成本。\n\n### 企业服务总线（ESB）2.0\n\n在前微服务面向服务架构（SOA）时代，企业服务总线（ESB）实现了软件组件之间的通信系统。有些人担心 ESB 时代的许多错误会随着服务网格的使用而重演。\n\n通过 ESB 提供的集中的通信控制显然有价值。然而，这些技术的发展是由供应商推动的，这导致了多种问题，例如：ESB 之间缺乏互操作性，行业标准的定制扩展（例如，将供应商的特定配置添加到 WS-* 兼容模式中），以及高成本。ESB 供应商也没有做任何事情来阻止业务逻辑与通信总线的集成和紧耦合。\n\n### 大爆炸部署\n\n在整个 IT 界有一种诱惑，认为大爆炸式的部署方法是最容易管理的方法，但正如 [Accelerate](https:\/\/itrevolution.com\/book\/accelerate\/) 和 [DevOps 报告](https:\/\/puppet.com\/resources\/report\/state-of-devops-report\/)的研究，事实并非如此。由于服务网格的全面推广意味着这项技术处于处理所有终端用户请求的关键路径上，大爆炸式的部署是非常危险的。\n\n### 死星建筑\n\n当企业采用微服务架构，开发团队开始创建新的微服务或在应用中利用现有的服务时，服务间的通信成为架构的一个关键部分。如果没有一个良好的治理模式，这可能会导致不同服务之间的紧密耦合。当整个系统在生产中出现问题时，也将很难确定哪个服务出现了问题。\n\n如果缺乏服务沟通战略和治理模式，该架构就会变成所谓的“死星架构”。\n\n关于这种架构反模式的更多信息，请查看关于云原生架构采用的[第一部分](https:\/\/www.infoq.com\/articles\/cloud-native-architecture-adoption-part1\/)、[第二部分](https:\/\/www.infoq.com\/articles\/cloud-native-architecture-adoption-part2\/)和[第三部分的](https:\/\/www.infoq.com\/articles\/cloud-native-architecture-adoption-part3\/)文章。\n\n### 特定领域的服务网格\n\n服务网格的本地实现和过度优化有时会导致服务网格部署范围过窄。开发人员可能更喜欢针对自己的业务领域的服务网格，但这种方法弊大于利。我们不希望实现过于细化的服务网格范围，比如为组织中的每个业务或功能域（如财务、人力资源、会计等）提供专用的服务网格。这就违背了拥有像服务网格这样的通用服务协调解决方案的目的，即企业级服务发现或跨域服务路由等功能。\n\n## 服务网格的实现和产品\n\n以下是一份非详尽的当前服务网格实施清单。\n\n- [Linkerd ](https:\/\/linkerd.io\/)(CNCF 毕业项目)\n- [Istio](https:\/\/istio.io\/)\n- [Consul](https:\/\/www.consul.io\/)\n- [Kuma](https:\/\/kuma.io\/)（CNCF 沙盒项目）\n- [AWS App Mesh](https:\/\/aws.amazon.com\/app-mesh\/)\n- [NGINX Service Mesh](https:\/\/www.nginx.com\/products\/nginx-service-mesh\/)\n- [AspenMesh](https:\/\/aspenmesh.io\/)\n- [Kong](https:\/\/konghq.com\/kong-mesh\/)\n- [Solo Gloo Mesh](https:\/\/www.solo.io\/products\/gloo-mesh\/)\n- [Tetrate Service Bridge](https:\/\/www.tetrate.io\/tetrate-service-bridge\/)\n- [Traefik Mesh](http:\/\/traefik.io\/traefik-mesh)（原名 Maesh）。\n- [Meshery](http:\/\/layer5.io\/meshery)\n- [Open Service MEsh](http:\/\/openservicemesh.io\/)（CNCF 沙盒项目）。\n\n另外，像 [DataDog](https:\/\/www.datadoghq.com\/blog\/tag\/service-mesh\/) 这样的其他产品也开始提供与 [Linkerd](https:\/\/docs.datadoghq.com\/integrations\/linkerd\/?tab=host)、Istio、Consul Connect 和 AWS App Mesh 等服务网格技术的集成。\n\n## 服务网格对比\n\n服务网格领域的发展极为迅速，因此任何试图创建比较的努力都可能很快变得过时。然而，确实存在一些比较。应该注意了解来源的偏见（如果有的话）和进行比较的日期。\n\n- https:\/\/layer5.io\/landscape\n- https:\/\/kubedex.com\/istio-vs-linkerd-vs-linkerd2-vs-consul\/（截至 2021 年 8 月的正确数据）\n- https:\/\/platform9.com\/blog\/kubernetes-service-mesh-a-comparison-of-istio-linkerd-and-consul\/（截至 2019 年 10 月的最新情况）\n- [https:\/\/servicemesh.es\/ ](https:\/\/servicemesh.es\/)(最后发表于 2021 年 8 月)\n\nInfoQ 一直建议服务网格的采用者对每个产品进行自己的尽职调查和试验。\n\n## 服务网格教程\n\n对于希望试验多服务网格的工程师或建筑师来说，可以使用以下教程、游戏场和工具。\n\n- [Layer 5 Meshery](https:\/\/layer5.io\/meshery)—— 多网格管理平面\n- [Solo 的 Gloo Mesh](https:\/\/github.com\/solo-io\/supergloo)—— 服务网格编排平台\n- KataCoda Istio 教程\n- [Consul 服务网格教程](https:\/\/learn.hashicorp.com\/consul)\n- [Linkerd 教程](https:\/\/linkerd.io\/2\/getting-started\/)\n- [NGINX 服务网格教程](https:\/\/docs.nginx.com\/nginx-service-mesh\/tutorials\/)\n- [Istio 基础教程](https:\/\/tetrate-academy.thinkific.com\/courses\/istio-fundamentals-zh)\n\n## 服务网格的历史\n\n自 2013 年底 Airbnb 发布 [SmartStack](https:\/\/medium.com\/airbnb-engineering\/smartstack-service-discovery-in-the-cloud-4b8a080de619)，为新兴的“ [微服务 ](https:\/\/www.infoq.com\/microservices\/)“风格架构提供进程外服务发现机制（使用 [HAProxy](http:\/\/www.haproxy.org\/)）以来，InfoQ 一直在跟踪这个我们现在称之为 [服务网格](https:\/\/www.infoq.com\/servicemesh\/)的话题。许多之前被贴上“独角兽“标签的组织在此之前就在研究类似的技术。从 21 世纪初开始，谷歌就在开发其 [Stubby ](https:\/\/grpc.io\/blog\/principles\/)RPC 框架，该框架演变成了 [gRPC](https:\/\/cloud.google.com\/blog\/products\/gcp\/grpc-a-true-internet-scale-rpc-framework-is-now-1-and-ready-for-production-deployments)，以及 [谷歌前端（GFE）](https:\/\/landing.google.com\/sre\/sre-book\/chapters\/production-environment\/)和全局软件负载均衡器（GSLB），在 [Istio](https:\/\/istio.io\/) 中可以看到它们的特质。在 2010 年代早期，Twitter 开始了 Scala 驱动的 [Finagle](https:\/\/twitter.github.io\/finagle\/) 的工作，[Linkerd](https:\/\/linkerd.io\/) 服务网格由此产生。\n\n2014 年底，Netflix 发布了[一整套基于 JVM 的实用程序](https:\/\/netflix.github.io\/)，包括 [Prana](https:\/\/www.infoq.com\/news\/2014\/12\/netflix-prana\/)，一个“sidecar“程序，允许用任何语言编写的应用服务通过 HTTP 与库的独立实例进行通信。2016 年，NGINX 团队开始谈论“[Fabric 模型](https:\/\/www.nginx.com\/blog\/microservices-reference-architecture-nginx-fabric-model\/) \u0022，这与服务网格非常相似，但需要使用他们的商业 NGINX Plus 产品来实现。另外，Linkerd v0.2 在 2016 年 2 月[发布](https:\/\/linkerd.io\/2016\/02\/18\/linkerd-twitter-style-operability-for-microservices\/)，尽管该团队直到后来才开始称它为服务网格。\n\n服务网格历史上的其他亮点包括 2017 年 5 月的 [Istio](https:\/\/istio.io\/)、2018 年 7 月的 [Linkerd 2.0](https:\/\/linkerd.io\/2018\/09\/18\/announcing-linkerd-2-0\/)、2018 年 11 月的 [Consul Connect](https:\/\/www.hashicorp.com\/products\/consul\/service-mesh) 和 [Gloo Mesh](https:\/\/github.com\/solo-io\/supergloo)、2019 年 5 月的 [服务网格接口（SMI）](https:\/\/smi-spec.io\/)，以及 2019 年 9 月的 Maesh（现在叫 Traefik Mesh）和 Kuma。\n\n即使是在独角兽企业之外出现的服务网格，如 HashiCorp 的 [Consul](https:\/\/www.consul.io\/)，也从上述技术中获得了灵感，通常旨在实现 CoreOS 提出的“[GIFEE ](https:\/\/github.com\/linearregression\/GIFEE)“概念；所有人可用的 Google 基础设施（Google infrastructure for everyone else）。\n\n为了深入了解现代服务网格概念的演变历史，[Phil Calçado](https:\/\/philcalcado.com\/) 写了一篇全面的文章“ [模式：服务网格](https:\/\/philcalcado.com\/2017\/08\/03\/pattern_service_mesh.html) \u0022。\n\n## 服务网格标准\n\n尽管在过去的几年里，服务网格技术年复一年地发生着重大转变，但服务网格的标准还没有跟上创新的步伐。\n\n使用服务网格解决方案的主要标准是[服务网格接口](https:\/\/smi-spec.io\/)（SMI）。服务网格接口是在 [Kubernetes](https:\/\/kubernetes.io\/) 上运行的服务网格的一个规范。它本身并没有实现服务网格，而是定义了一个通用的标准，可以由各种服务网格供应商来实现。\n\nSMI API 的目标是提供一套通用的、可移植的服务网格 API，Kubernetes 用户可以以一种与提供者无关的方式使用。通过这种方式，人们可以定义使用服务网格技术的应用程序，而不需要与任何特定的实现紧密结合。\n\nSMI 基本上是一个 Kubernetes 自定义资源定义（[CRD](https:\/\/kubernetes.io\/docs\/tasks\/extend-kubernetes\/custom-resources\/custom-resource-definitions\/)）和扩展 API 服务器的集合。这些 API 可以安装到任何 Kubernetes 集群，并使用标准工具进行操作。为了激活这些 API，需要在 Kubernetes 集群中运行一个 SMI 提供者。\n\nSMI 规范既允许终端用户的标准化，也允许服务网格技术提供商的创新。SMI 实现了灵活性和互操作性，并涵盖了最常见的服务网格功能。目前的[规范组件](https:\/\/github.com\/servicemeshinterface\/smi-spec\/tree\/main\/apis)集中在服务网格能力的连接方面。API 规范包括以下内容。\n\n- 流量访问控制\n- 流量指标\n- 流量规格\n- 流量分割\n\n目前的 SMI [生态系统](https:\/\/github.com\/servicemeshinterface\/smi-spec)包括广泛的服务网格，包括 Istio、Linkerd、Consul Connect、Gloo Mesh 等。\n\nSMI 规范是在 [Apache License 2.0 版本下](http:\/\/www.apache.org\/licenses\/)[许可的](https:\/\/github.com\/servicemeshinterface\/smi-spec\/blob\/main\/LICENSE)。\n\n如果你想了解更多关于 SMI 规范及其 API 细节，请查看以下链接。\n\n- [核心规范](https:\/\/github.com\/servicemeshinterface\/smi-spec\/blob\/main\/SPEC_LATEST_STABLE.md)（当前版本：0.6.0）\n- [规范 Github 项目](https:\/\/github.com\/servicemeshinterface\/smi-spec)\n- [如何贡献](https:\/\/github.com\/servicemeshinterface\/smi-spec\/blob\/main\/CONTRIBUTING.md)\n\n## 服务网格基准测试\n\n[服务网格性能](https:\/\/smp-spec.io\/)是一个捕捉基础设施容量、服务网配置和工作负载元数据细节的标准。SMP 规范用于捕捉以下细节。\n\n- 环境和基础设施细节\n- 节点的数量和规模，编排器\n- 服务网格和它的配置\n- 工作量 \/ 应用细节\n- 进行统计分析以确定性能特征\n\n来自 Linkerd 团队的 William Morgan [写了](https:\/\/linkerd.io\/2021\/05\/27\/linkerd-vs-istio-benchmarks\/)关于 Linkerd 和 Istio 的性能基准测试。还有一篇来自 2019 年的[文章](https:\/\/istio.io\/latest\/blog\/2019\/performance-best-practices\/)，介绍了 Istio 关于服务网格性能基准测试的最佳实践。\n\n重要的是要记住，就像其他性能基准测试一样，你不应该对任何这些外部出版物投入过多的注意力，特别是产品供应商发表的文章。该在你的服务器环境中设计和执行你自己的性能测试，以验证哪个具体产品适合你的应用程序的业务和非功能要求。\n\n## 探索服务网格的未来\n\n[Kasun Indrasiri](https:\/\/www.infoq.com\/profile\/Kasun-Indrasiri\/) 探讨了“ [为事件驱动的消息传递使用服务网格的潜力](https:\/\/www.infoq.com\/articles\/service-mesh-event-driven-messaging\/) \u0022，他在其中讨论了在服务网格中实现消息传递支持的两种主要的新兴架构模式：协议代理 sidecar 和 HTTP 桥接 sidecar。这是服务网格社区中一个活跃的发展领域，在 [Envoy 中](https:\/\/github.com\/envoyproxy\/envoy\/issues\/2852)支持 [Apache Kafka 的](https:\/\/github.com\/envoyproxy\/envoy\/issues\/2852)工作引起了相当多的关注。\n\nChristian Posta 之前在“[Towards a Unified, Standard API for Consolidating Service Meshes ](https:\/\/www.infoq.com\/articles\/service-mesh-api-federating\/)中写过关于服务网格使用标准化的尝试。这篇文章还讨论了 2019 年微软和合作伙伴在 KubeCon EU 上宣布的[服务网格接口（SMI）](https:\/\/cloudblogs.microsoft.com\/opensource\/2019\/05\/21\/service-mesh-interface-smi-release\/)。SMI 定义了一套通用和可移植的 API，旨在为开发人员提供不同服务网格技术的互操作性，包括 Istio、Linkerd 和 Consul Connect。\n\n将服务网格与平台结构整合的主题可以进一步分为两个子主题。\n\n首先，正在进行的工作是减少由服务网格数据平面引入的网络开销。这包括[数据平面开发工具包（DPDK）](https:\/\/www.dpdk.org\/)，它是一个[用户空间应用程序](https:\/\/www.linuxjournal.com\/content\/userspace-networking-dpdk)，“绕过了 Linux 内核网络堆栈，直接与网络硬件对话”。还有 [Cilium 团队的](https:\/\/www.infoq.com\/news\/2018\/03\/cilium-linux-bpf\/)基于 Linux 的 BPF 解决方案，它利用 Linux 内核中的扩展[伯克利包过滤器（eBPF）功能](https:\/\/cilium.io\/blog\/istio\/)来实现“非常有效的网络、策略执行和负载均衡功能”。另一个团队正在用[网络服务网格（Network Service Mesh）](https:\/\/github.com\/networkservicemesh\/networkservicemesh\/)将服务网格的概念映射到 L2\/L3 有效载荷，试图“以云原生的方式重新想象网络功能虚拟化（NFV）\u0022。\n\n其次，有多项举措将服务网格与公共云平台更紧密地结合在一起，从 [AWS App Mesh](https:\/\/www.infoq.com\/news\/2019\/01\/aws-app-mesh\/)、[GCP Traffic Director](https:\/\/www.infoq.com\/news\/2019\/04\/google-traffic-director\/) 和 [Azure Service Fabric Mesh 的](https:\/\/www.infoq.com\/articles\/azure-service-fabric-mesh\/)发布可见端倪。\n\nBuoyant 团队致力于为服务网格技术开发有效的以人为本的控制平面。他们最近发布了 [Buoyant Cloud](https:\/\/buoyant.io\/cloud\/)，一个基于 SaaS 的“团队控制平面”，用于平台团队操作 Kubernetes。这个产品将在下面的章节中详细讨论。\n\n自去年以来，在服务网格领域也有一些创新。\n\n### 多云、多集群、多租户服务网格\n\n近年来，不同组织对云的采用已经从单一的云解决方案（私有云或公共云）转变为由多个不同供应商（AWS、谷歌、微软 Azure 等）支持的基于多云（私有、公共和混合）的新基础设施。同时，需要支持不同的工作负载（交易、批处理和流媒体），这对实现统一的云架构至关重要。\n\n这些业务和非功能需求反过来又导致需要在异构基础设施（裸机、虚拟机和 Kubernetes）中部署服务网格解决方案。服务网格需要相应转变，以支持这些不同的工作负载和基础设施。\n\n像 [Kuma](https:\/\/konghq.com\/blog\/multi-cluster-multi-cloud-service-meshes-with-cncfs-kuma-and-envoy\/) 和 [Tetrate Service Bridge](https:\/\/www.tetrate.io\/tetrate-service-bridge\/) 这样的技术支持多网格控制平面，以使业务应用在多集群和多云服务网格环境中工作。这些解决方案抽象出跨多个区域的服务网格策略的同步以及跨这些区域的服务连接（和服务发现）。\n\n多集群服务网格技术的另一个新趋势是需要从边缘计算层（物联网设备）到网格层的应用 \/ 服务连接。\n\n### 媒体服务网格\n\n思科系统公司开发的[媒体流网格（Media Streaming Mesh）](https:\/\/www.ciscotechblog.com\/blog\/introducing-media-streaming-mesh\/)或媒体服务网格，用于协调实时应用程序，如多人游戏、多方视频会议或在 Kubernetes 云平台上使用服务网格技术的 CCTV 流。这些应用正越来越多地从单体应用转向微服务架构。服务网格可以通过提供负载均衡、加密和可观测性等功能来帮助应用程序。\n\n### 混沌网格\n\n[Chaos Mesh](https:\/\/chaos-mesh.org\/) 是 [CNCF 托管的项目](https:\/\/community.cncf.io\/chaos-mesh-community\/)，是一个开源的、云原生的混沌工程平台，用于托管在 Kubernetes 上的应用程序。虽然不是直接的服务网格实现，但 Chaos Mesh 通过协调应用程序中的故障注入行为来实现混沌工程实验。故障注入是服务网格技术的一个关键能力。\n\nChaos Mesh 隐藏了底层的实现细节，因此应用开发者可以专注于实际的混沌实验。Chaos Mesh [可以和服务网格一起使用](https:\/\/chaos-mesh.org\/blog\/chaos-mesh-q\u0026a\/)。请看这个[用例](https:\/\/github.com\/sergioarmgpl\/operating-systems-usac-course\/blob\/master\/lang\/en\/projects\/project1v3\/project1.md)，该团队如何使用 Linkerd 和 Chaos Mesh 来为他们的项目进行混沌实验。\n\n### 服务网格作为一种服务\n\n一些服务网格供应商，如 Buoyant，正在提供管理服务网格或“服务网格作为一种服务“的解决方案。今年早些时候，Buoyant [宣布](https:\/\/buoyant.io\/newsroom\/buoyant-cloud-offers-managed-service-mesh\/)公开测试发布一个名为 [Buoyant Cloud 的](http:\/\/buoyant.io\/cloud) SaaS 应用程序，允许客户组织利用 Linkerd 服务网格的按需支持功能来管理服务网格。\n\nBuoyant Cloud 解决方案提供的一些功能包括如下：\n\n- 自动跟踪 Linkerd 数据平面和控制平面的健康状况\n- 在 Kubernetes 平台上管理跨 pod、代理和集群的服务网格生命周期和版本\n- 以 SRE 为重点的工具，包括服务水平目标（SLO）、工作负荷黄金指标跟踪和变更跟踪\n\n### 网络服务网格（NSM）\n\n网络服务网格（[NSM](https:\/\/networkservicemesh.io\/)）是云原生计算基金会的另一个沙盒项目，提供了一个混合的、多云的 IP 服务网格。NSM 实现了网络服务连接、安全和可观测性等功能，这些都是服务网格的核心特征。NSM 与现有的容器网络接口（[CNI](https:\/\/github.com\/containernetworking\/cni)）实现协同工作。\n\n### 服务网格扩展\n\n服务网格扩展是另一个已经看到很多创新的领域。服务网格扩展的一些发展包括：\n\n- 增强的身份管理，以确保微服务连接的安全，包括自定义证书授权插件\n- 自适应路由功能，以提高服务的可用性和可扩展性\n- 加强 sidecar 代理权\n\n### 服务网格业务\n\n采用服务网格的另一个重要领域是服务网格生命周期的运维方面。操作方面 —— 如配置多集群功能和将 Kubernetes 工作负载连接到虚拟机基础设施上托管的服务器，以及管理多集群服务网格中所有功能和 API 的开发者门户 —— 将在生产中服务网格解决方案的整体部署和支持方面发挥重要作用。\n\n## 常见问题\n\n### 什么是服务网格？\n\n服务网格是一种在分布式（可能是基于微服务的）软件系统内管理所有服务对服务（东西向）流量的技术。它既提供以业务为重点的功能操作，如路由，也提供非功能支持，如执行安全策略、服务质量和速率限制。它通常（尽管不是唯一的）使用 sidecar 代理来实现，所有服务都通过 sidecar 代理进行通信。\n\n### 服务网格与 API 网关有什么不同？\n\n关于服务网格的定义，见上文。\n\n另一方面，API 网关管理进入集群的所有入口（南北）流量，并为跨功能的通信要求提供额外支持。它作为进入系统的单一入口点，使多个 API 或服务凝聚在一起，为用户提供统一的体验。\n\n### 如果我正在部署微服务，我是否需要服务网格？\n\n不一定。服务网格增加了技术栈的操作复杂性，因此通常只有在组织在扩展服务与服务之间的通信方面遇到困难，或者有特定的用例需要解决时才会部署。\n\n### 我是否需要服务网格来实现微服务的服务发现？\n\n不，服务网格提供了实现服务发现的一种方式。其他解决方案包括特定语言的库（如 Ribbon 和 [Eureka](https:\/\/www.infoq.com\/news\/2012\/09\/Eureka\/) 或 [Finagle](https:\/\/www.infoq.com\/finagle\/)）。\n\n### 服务网格是否会给我的服务之间的通信增加开销 \/ 延迟？\n\n是的，当一个服务与另一个服务进行通信时，服务网格至少会增加两个额外的网络跳数（第一个是来自处理源的出站连接的代理，第二个是来自处理目的地的入站连接的代理）。然而，这个额外的网络跳转通常发生在 [localhost 或 loopback 网络接口](https:\/\/en.wikipedia.org\/wiki\/Localhost)上，并且只增加了少量的延迟（在毫秒级）。实验和了解这对目标用例是否是一个问题，应该是服务网格分析和评估的一部分。\n\n### 服务网格不应该是 Kubernetes 或应用程序被部署到的 \u0022云原生平台\u0022 的一部分吗？\n\n潜在的。有一种说法是在云原生平台组件内保持关注点的分离（例如，Kubernetes 负责提供容器编排，而服务网格负责服务间的通信）。然而，正在进行的工作是将类似服务网格的功能推向现代平台即服务（PaaS）产品。\n\n### 我如何实施、部署或推广服务网格？\n\n最好的方法是分析各种服务网格产品（见上文），并遵循所选网格特有的实施准则。一般来说，最好是与所有利益相关者合作，逐步将任何新技术部署到生产中。\n\n### 我可以建立自己的服务网格吗？\n\n是的，但更相关的问题是，你应该吗？建立一个服务网格是你组织的核心竞争力吗？你能否以更有效的方式为你的客户提供价值？你是否也致力于维护你自己的网络，为安全问题打补丁，并不断更新它以利用新技术？由于现在有一系列的开源和商业服务网格产品，使用现有的解决方案很可能更有效。\n\n### 在一个软件交付组织内，哪个团队拥有服务网格？\n\n通常，平台或运维团队拥有服务网格，以及 Kubernetes 和持续交付管道基础设施。然而，开发人员将配置服务网格的属性，因此这两个团队应该紧密合作。许多企业正在追随云计算先锋的脚步，如 Netflix、Spotify 和谷歌，并正在创建内部平台团队，为[以产品为重点的全周期开发团队](https:\/\/www.infoq.com\/news\/2018\/06\/netflix-full-cycle-developers\/)提供工具和服务。\n\n### Envoy 是一个服务网格吗？\n\nEnvoy 是一个云原生代理，最初是由 Lyft 团队设计和构建的。Envoy 经常被用作服务网格的数据平面。然而，为了被认为是一个服务网格，Envoy 必须与控制平面一起使用，这样才能使这些技术集合成为一个服务网格。控制平面可以是简单的集中式配置文件库和指标收集器，也可以是全面 \/ 复杂的 Istio。\n\n### Istio 和“服务网格 \u0022 这两个词可以互换使用吗？\n\n不，Istio 是服务网格的一种。由于 Istio 在服务网格类别出现时很受欢迎，一些人将 Istio 和服务网格混为一谈。这个混淆的问题并不是服务网格所独有的，同样的挑战发生在 Docker 和容器技术上。\n\n### 我应该使用哪个服务网格？\n\n这个问题没有唯一的答案。工程师必须了解他们当前的需求，以及他们的实施团队的技能、资源和时间。上面的服务网格比较链接将提供一个良好的探索起点，但我们强烈建议企业至少尝试两个网格，以了解哪些产品、技术和工作流程最适合他们。\n\n### 我可以在 Kubernetes 之外使用服务网吗？\n\n是的。许多服务网格允许在各种基础设施上安装和管理数据平面代理和相关控制平面。[HashiCorp 的 Consul](https:\/\/www.hashicorp.com\/resources\/consul-service-mesh-kubernetes-and-beyond) 是最知名的例子，Istio 也被实验性地用于 Cloud Foundry。\n\n## 其他资源\n\n- [InfoQ 服务网格主页](https:\/\/www.infoq.com\/servicemesh\/)\n- [InfoQ eMag：服务网格的过去、现在和未来](https:\/\/www.infoq.com\/minibooks\/service-mesh\/)\n- [服务网格：每位软件工程师都需要了解的世界上最容易被滥用的技术](https:\/\/servicemesh.io\/)\n- [服务网格的比较](https:\/\/servicemesh.es\/)\n- [服务网格](https:\/\/softwareengineeringdaily.com\/2020\/01\/07\/service-meshes\/)\n- [采用云原生架构，第三部分：服务协调和服务网格](https:\/\/www.infoq.com\/articles\/cloud-native-architecture-adoption-part3\/)\n', '\/trans\/service-mesh-ultimate-guide-e2\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文是 InfoQ 自 2020 年 2 月发表的服务网格终极指南后的第二版，发布于 2021 年 9 月。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/service-mesh-unnecessary-complexity/">[译] 远离复杂性——服务网格需要更加务实</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2021/09/28</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://www.infoq.com/articles/service-mesh-unnecessary-complexity/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('远离复杂性——服务网格需要更加务实', '服务网格是 Kubernetes 世界中的一个热门话题，但许多潜在的采用者已经失去了耐心。', '\n## 主要收获\n\n- 采用服务网格有巨大的价值，但必须以轻便的方式进行，以避免不必要的复杂性。\n- 在实施服务网格时，要采取务实的方法，与技术的核心功能保持一致，并注意分散注意力的问题。\n- 服务网格的一些核心特征包括标准化监控、自动加密和身份识别、智能路由、可靠的重试和网络可扩展性。\n- 服务网格可以提供强大的功能，但这些功能可能会分散对核心利益的注意力，并不被视为实施服务网格的主要原因。\n- 一些值得注意的分心，可能对你的初始实施没有必要，包括复杂的控制平面、多集群支持、Envoy、WASM 和 A\/B 测试。\n\n服务网格是 Kubernetes 世界中的一个热门话题，但许多潜在的采用者已经失去了耐心。服务网格的采用受到了巨大的复杂性和似乎无穷无尽的供应商解决方案的限制。在我自己浏览了这个领域后，我发现采用服务网格有巨大的价值，但必须以轻量级的方式进行，以避免不必要的复杂性。尽管普遍存在幻灭感，但服务网格的前景依然光明。\n\n## 在工作中学习\n\n我进入服务网格的世界，始于我在一家历史悠久的财富 500 强科技公司担任云计算架构师。在我们的服务网格旅程开始时，我身边有许多强大的工程师，但大多数人几乎没有云开发的经验。我们的组织诞生于云计算之前，要完全实现云计算的价值需要时间。我们的传统业务线主要集中在技术堆栈的硬件元素上，而云计算的决策最初是由为运送硬件或为这些硬件提供固件和驱动程序而开发的流程所驱动。 \n\n随着这个组织经历了 \u0022数字化转型\u0022，它越来越依赖于提供高质量的软件服务，并逐渐形成了更好的方法论。但是，作为云计算架构师，我仍然在为优先考虑硬件的业务流程和具有不同技能组合、流程和信念的工程团队而奔波。随着时间的推移，我和我的团队在将.NET 应用程序迁移到 Linux、采用 Docker、迁移到 AWS 以及与之相关的最佳实践（如持续集成、自动部署、不可变基础设施、基础设施即代码、监控等）方面变得熟练和成功，但挑战仍然存在。\n\n在这段时间里，我们开始将我们的应用程序分割成一系列的微服务。起初，这是一个缓慢的转变，但最终这种方法流行起来，开发人员开始喜欢建立新的服务而不是增加现有的服务。我们这些基础设施团队的人把这看作是一种成功。唯一的问题是，与网络有关的问题数量激增，开发人员正在向我们寻求答案，而我们还没有准备应用这种冲击。\n\n## 服务网格拯救了我们\n\n我第一次听说服务网格是在 2015 年，当时我正在研究服务发现工具，并寻找与 Consul 集成的简单方法。我很喜欢把应用责任下沉到 \u0022sidecar\u0022容器的想法，并找到了一些可以做到这一点的工具。大约在这个时候，Docker 有一个叫做 \u0022linking\u0022的功能，让你把两个应用程序放在一个共享的网络空间中，这样它们就可以通过本地主机进行通信。这个功能提供了一个类似于我们现在在 Kubernetes pod 内的体验。两个独立构建的服务可以在部署时进行组合，以实现一些额外的功能。\n\n我总是抓住机会用简单的解决方案来解决大问题，所以这些新功能的力量立即打动了我。虽然这个工具是为了与 Consul 集成，但在实践中，它可以做任何你想要的事情。它是我们拥有的基础设施的一个新的层级，可以用来为每个人解决问题。\n\n这方面的一个具体例子是在我们采用过程的早期。当时，我们正在努力使许多不同服务的日志输出标准化。通过采用服务网格和这种新的设计模式，我们能够把我们的人的问题——让开发人员标准化他们的日志，转变成技术问题——把所有的服务流量通过一个可以为他们做日志记录的代理。这对我们的团队来说是一个重大的进步。\n\n我们对服务网格的实施是非常务实的，并与该技术的核心功能保持一致。然而，许多营销炒作可能集中在不太需要的边缘案例上，在评估服务网格是否适合你时，能够识别这些干扰是很重要的。\n\n## 核心功能\n\n服务网格可以提供的核心功能分为四个关键责任领域：可观测性、安全性、连接性和可靠性。\n\n## 标准化的监控\n\n这是我们最成功的地方之一，也是最简单的采用，就是标准化的监测。它的运营成本很低，而且可以被制作成适合你使用的任何监控系统。它使企业能够捕获他们所有的 HTTP 或 gRPC 指标，并在整个系统中以标准方式存储它们。这就控制了复杂性，减轻了应用团队的负担，他们不再需要实施 Prometheus 指标端点或标准化日志格式。它还使用户能够对其应用程序的[黄金信号](https:\/\/sre.google\/sre-book\/monitoring-distributed-systems\/#xref_monitoring_golden-signals)有一个公正的看法。 \n\n**自动加密和身份识别**\n\n证书管理是很难做好的。如果一个组织还没有在这方面投资，他们应该找一个网格来为他们做这件事。证书管理需要维护复杂的基础设施代码，具有巨大的安全影响。相比之下，网格将能够与编排系统集成，了解工作负载的身份，在需要时可以用来执行策略。这允许一个真正强大的安全态势，相当于或优于那些由 Calico 或 Cilium 等功能丰富的 CNI 提供的安全态势。\n\n## 智能路由\n\n智能路由是另一项功能，使网格在发送请求时能 \u0022做正确的事\u0022。应用如下：\n\n1. 使用延迟加权算法优化流量\n2. 拓扑感知路由，提高性能并降低成本\n3. 根据请求成功的可能性来确定时间\n4. 与编排系统集成以实现 IP 解析，而不是依赖 DNS\n5. 传输升级，如 HTTP 到 HTTP\/2\n\n这些功能可能不会让普通人感到兴奋，但随着时间的推移，它们带来了更多的价值。\n\n## 可靠的重试\n\n在分布式系统中重试请求可能很麻烦，然而，这总是需要实施的。分布式系统通常会将一个客户端请求转换为下游的许多请求，这意味着 \u0022尾巴\u0022情况的可能性大大增加，例如发生异常的失败请求。对此，最简单的缓解措施是重试失败的请求。\n\n困难来自于避免 \u0022重试风暴\u0022或 \u0022重试 DDoS\u0022，即当一个处于退化状态的系统触发重试时，随着重试的增加，负载增加，性能进一步下降。一个天真的实现不会考虑到这种情况，因为它可能需要与缓存或其他通信系统集成，以知道重试是否值得执行。服务网格可以通过提供整个系统允许的重试总数的约束来做到这一点。服务网格还可以在这些重试发生时进行报告，有可能在你的用户注意到之前提醒你系统的退化。\n\n## 网络可扩展性\n\n也许服务网格的最佳属性是其可扩展性。它提供了一个额外的适配层，可以承担 IT 部门接下来的任何工作。Sidecar 代理的设计模式是另一个令人兴奋和强大的功能，即使它有时被过度宣传和过度设计来做用户和技术还没有准备好的事情。当社区在等待哪个服务网格\u0022胜出\u0022时，这反映了之前被过度炒作的编排战争，我们将不可避免地在未来看到更多专门的网格，而且很可能有更多的最终用户建立自己的控制平面和代理来满足他们的使用情况。\n\n## 服务网格分心\n\n平台或基础设施控制层的价值怎么强调都不过分。然而，在服务网格的世界中，我了解到一个主要的挑战是，服务网格所解决的核心问题往往甚至不是大多数服务网格项目的沟通重点。\n\n相反，许多来自服务网格项目的沟通都是围绕着那些听起来很强大或令人兴奋的功能，但最终却让人分心。包括以下内容。\n\n## 强大（复杂）的控制平面\n\n要很好地运行复杂的软件是非常困难的。这就是为什么如此多的组织使用云计算，使用完全托管的服务。那么，为什么服务网格项目会让我们负责运行如此复杂的系统？系统的复杂性不是一种资产，而是一种责任，然而大多数项目都在吹嘘他们的功能集和可配置性。\n\n## 多集群支持\n\n多集群是现在的一个热门话题。大多数团队最终都会运行多个 Kubernetes 集群。但多集群的主要痛点是你的 Kubernetes 管理网络被分割成两半。服务网格帮助解决这个 Kubernetes 的扩展问题，但它最终并没有实现任何新的东西。是的，多集群支持是必要的，但它对服务网格的承诺被过度宣传了。\n\n## Envoy\n\nEnvoy 是一个伟大的工具，但它被当作某种标准来介绍，这是有问题的。Envoy 是许多开箱即用的代理之一，你可以在此基础上建立一个服务网格平台。但是，Envoy 并没有什么内在的特别之处，使它成为正确的选择。采用 Envoy 会给你的组织带来一系列重要的问题，包括：\n\n- 运行时间成本和性能（所有这些过滤器加起来）\n- 计算资源要求以及如何随负载变化而变化\n- 如何调试错误或意外行为\n- 你的网格如何与 Envoy 进行交互，以及配置的生命周期是什么\n- 运作成熟的时间（这可能比你预期的要长）\n\n服务网格中代理的选择应该是一个实施细节，而不是一个产品要求。\n\n## WASM\n\n我是 Web Assembly（WASM）的忠实粉丝，曾成功地用它在[Blazor](https:\/\/dotnet.microsoft.com\/apps\/aspnet\/web-apps\/blazor)中构建前端应用程序。然而，WASM 作为定制服务网格代理行为的工具，使你完全陷入了获得全新的软件生命周期开销的境地，这与你现有的软件生命周期是完全分离的。如果你的组织还没有准备好构建、测试、部署、维护、监控、回滚和版本代码（影响通过其系统运行的每个请求），那么你还没有准备好使用 WASM。\n\n## A\/B 测试\n\n当我意识到 A\/B 测试实际上是一个应用程序级别的问题已经太晚了。在基础设施层提供基元来实现它是可以的，但没有简单的方法来完全自动化大多数组织需要的 A\/B 测试水平。通常情况下，应用程序需要定义独特的指标，以确定测试的积极信号。如果一个组织想在服务网格层实施 A\/B 测试，以下是解决方案需要支持的内容：\n\n1. 对部署和回滚的精细控制，因为很可能有多个不同的 \u0022测试\u0022在同一时间进行\n2. 能够捕获系统知道的自定义指标，并能根据这些指标做出决定\n3. 根据请求的特点暴露出对流量方向的控制，这可能包括解析整个请求主体\n\n这是很难实现的，而且没有一个服务网格能做到开箱即用。最终，我们的组织选择了一个网格之外的功能标记解决方案，它以最小的努力取得了巨大的成功。\n\n## 我们终将走向何方\n\n最终，我们所面临的挑战并不是服务网格所独有的。我们工作的组织有一系列的限制条件，要求我们对解决的问题和解决的方式采取务实的态度。我们面临的问题包括： \n\n- 拥有大量不同技能的开发人员的大型组织\n- 一般来说，云计算和 SaaS 能力不成熟\n- 为非云计算软件优化的流程\n- 分散的软件工程方法和信念\n- 资源有限\n- 咄咄逼人的最后期限 \n\n简而言之，我们人少，问题多，而且需要快速展示价值。我们必须支持那些主要不是网络或云计算的开发者，我们需要扩大规模以支持大型工程组织，这些组织有不同的方法和流程来做云计算的事情。我们需要把大部分精力放在解决成熟度曲线上低的基本问题上。\n\n最后，当我们面临自己的服务网格决定时，我们决定建立在[Linkerd 服务网格](https:\/\/linkerd.io\/)之上，因为它最符合我们的优先事项：低运营成本（包括计算和人力）、低认知开销、支持性社区和透明的管理，同时满足我们的功能要求和预算。在 Linkerd 指导委员会呆了很短的时间（他们喜欢诚实的反馈和社区参与），我了解到它与我自己的工程原则是多么的吻合。Linkerd 最近[在 CNCF](https:\/\/www.cncf.io\/announcements\/2021\/07\/28\/cloud-native-computing-foundation-announces-linkerd-graduation\/)达到了[毕业状态](https:\/\/www.cncf.io\/announcements\/2021\/07\/28\/cloud-native-computing-foundation-announces-linkerd-graduation\/)，这是一个漫长的过程，强调了项目的成熟度以及它的广泛采用。\n\n## 关于作者\n\n**Chris Campbell** 从事软件工程师和架构师工作超过十年，与多个团队和组织合作，采用云原生技术和最佳实践。他的工作时间分为两部分，一部分是与企业领导合作，采用软件交付策略来加速业务发展，另一部分是与工程团队合作，提供可扩展的云基础设施。他最感兴趣的是能提高开发人员生产力和体验的技术。\n', '\/trans\/service-mesh-unnecessary-complexity\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">服务网格是 Kubernetes 世界中的一个热门话题，但许多潜在的采用者已经失去了耐心。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/envoy-oss-5-year/">[译] 网络代理 Envoy 开源五周年，创始人 Matt Klein 亲述开源心路历程及经验教训</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2021/09/15</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/envoy"> 
             Envoy
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://mattklein123.dev/2021/09/14/5-years-envoy-oss/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('网络代理 Envoy 开源五周年，创始人 Matt Klein 亲述开源心路历程及经验教训', '开源网络代理 Envoy 的创始人 Matt Klein，在 Twitter 因为自己的程序 bug 造成重大事故而离职，后加入 Lyft，在开源 Envoy 之前几乎没有贡献和管理开源项目的经验，这篇文章分享了他个人及 Envoy 开源的心路历程，在投身开源 Envoy 还是为雇主 Lyft 效命，该如何抉择？', '\n译者注：本文译自 Envoy 代理的创始人 Matt Klein 于昨晚在个人博客上发布的文章 [5 year of Envoy OSS](https:\/\/mattklein123.dev\/2021\/09\/14\/5-years-envoy-oss\/)。他在 Twitter 因为自己的程序 bug 造成重大事故而离职，后加入 Lyft，在开源 Envoy 之前几乎没有贡献和管理开源项目的经验，这篇文章分享了他个人及 Envoy 开源的心路历程，在投身开源 Envoy 还是为雇主 Lyft 效命，该如何抉择？看完本文，相信对于开源项目的维护者、创业者及投资人都会大有收获。\n\n------\n\n## 前言\n\n今天是 [Envoy Proxy 开源](https:\/\/www.envoyproxy.io\/)的 [5 周年](https:\/\/eng.lyft.com\/announcing-envoy-c-l7-proxy-and-communication-bus-92520b6c8191)。毫不夸张地说，在专业方面，过去的 5 年是一个史诗般的过山车，我的情绪介于兴奋、自豪、焦虑、尴尬、无聊、倦怠之间。我想分享一下这个项目的前传和历史，以及我在发展大型开源软件项目的过程中所学到的一些经验教训。\n\n## 前传和历史\n\n### 前传\n\n除了一些小的弯路，我在技术行业二十年的职业生涯一直专注于底层系统：嵌入式系统，操作系统，虚拟化，文件系统，以及最近的分布式系统网络。我的分布式系统网络之旅始于 2010 年初在亚马逊，我有幸帮助开发了第一批高性能计算（HPC）EC2 实例类型。我学到了大量的底层高性能计算机网络知识，尽管我对分布式系统的概念接触有限。\n\n2012 年，我加入了 Twitter，在经历了几次错误的开始后，我最终加入了边缘网络团队。这是我第一次真正接触到分布式系统应用网络概念。我领导了一个新的 HTTP 边缘代理的开发，称为 Twitter 流式聚合器（TSA），它在 2013 年首次推出，以扩大 Twitter 的“firehose”API（流式所有推文）的交付。在 2014 年世界杯前夕，我们决定将 TSA 作为一个通用的 HTTP\/HTTP2\/TLS 边缘代理，在靠近巴西赛事的存在点（POPs）推出。这样做的主要原因是不可能在 POP 的少量主机托管机架上部署现有的基于 JVM 的资源匮乏的边缘代理。项目周期特别紧张，我的团队成功地完成了一届没有事故的世界杯。（我还清楚地记得有一段时间，当软件崩溃时，不管是什么时候，我都会给自己打上一页，修复错误，然后重新进行金丝雀部署，继续测试）。在 Twitter 工作期间，我还接触到了该公司通过 Finagle 库进行服务间网络通信的方式，并取得了巨大成功。\n\n2015 年元旦前后，我在 Twitter 的日子里，因为我写的一个 bug，TSA 系统故障导致数百万 Twitter 的安卓用户被下线，这将是我在 Twitter 工作的尾声。\n\n![](008i3skNly1guh3vblu9xj60tu0eu76p02.jpg) \n\n### 加入 Lyft 和创建“Lyft 代理”\n\n我在 2015 年春天离开了 Twitter，部分原因是下线事件的影响，部分原因是对没有得到晋升的挫败感，部分原因是想尝试新的东西。我跟着我的老板从 Twitter 到了 Lyft，还有我在 Twitter 的其他同事。\n\n当我加入 Lyft 时，公司规模相对较小（少于 100 名工程师），并且正在努力从单体架构迁移到微服务架构。我已经[多次](https:\/\/mattklein123.dev\/appearances\/)谈到了 Envoy 的这部分历程，所以我不会再重述，在此简短的总结下，Lyft 遇到了所有典型的微服务迁移问题，主要是源于网络和可观测性。此外，Lyft 已经是“多面手”（使用多种语言和框架），所以使用基于库的解决方案来解决这些问题似乎不切实际。因此，根据我以前建立 TSA 的经验和观察服务间通信在 Twitter 的工作方式，由于得到在 Lyft 的前 Twitter 同事们的信任，我提议建立一个新的应用网络系统，称为“Lyft 代理”。\n\n经过一些激烈的讨论，包括新的代理是否应该用 Python 构建（是的，真的），我们就项目的大致轮廓达成一致，并决定使用 C\u002b\u002b 作为实现语言。在当时，C\u002b\u002b 似乎是唯一合理的选择。今天我还会选择 C\u002b\u002b 吗？然而，如今已经不是 2015 年初了。\n\n如果不说“Envoy\u0022 这个名字的由来，这部分的历史就不完整了。我们正在为这个项目建立最初的开发脚手架的时候，一个有远见的同事（Ryan Lane）说，我们不能把这个新项目叫做“Lyft 代理”，我们必须选择一个更好的名字。我总是很实际，就去找辞典，查了一下“代理”，然后决定用 Envoy 作为新名字。\n\n### 在 Lyft 上线\n\n直到 2015 年夏天，我才开始认真地研究 Envoy 的源代码。那几个月是我职业生涯中最有趣的几个月。我们应该珍惜这段初创时期，因为它不会持续很久。我花了很长时间，争取在合理的时间内（根据我的定义，这种类型的项目需要 3-4 个月的时间）做出能给 Lyft 带来价值的东西。俗话说，Lyft 给了我大量的绳子来吊死自己，而我致力于确保这种吊死不会发生。\n\n当然，我的效率主要归功于刚从压缩的开发时间表和许多错误（主要是我自己的）中走出来，在 Twitter 的 TSA。我知道哪些错误是不能犯的，哪些抽象是需要的，哪些测试有效，哪些无效，等等。\n\n2015 年秋天准备投入生产的 Envoy 的最初版本只包含了该项目今天所包含的功能和复杂性的一小部分。它不支持 TLS，只支持 HTTP\/1，并且有极其简单的路由和弹性功能。它所拥有的是你今天所看到的东西的骨架。在这个项目的历史上，很少有重大的重构，主要是因为，正如我之前所说的，我知道将要发生什么，以及为了支持这些功能，需要有哪些抽象。Envoy 从一开始就拥有一流的可观测性输出，以指标和日志的形式。在 2021 年，这种类型的网络可观测性是桌面上的赌注（这在很大程度上要归功于 Envoy 的成功），但在当时却不是这样。\n\nEnvoy 最初是作为边缘代理在 Lyft 上线的，位于提供 TLS 终止的 AWS ELB 后面。到 2015 年秋末，Envoy 为 Lyft 的 100% 流量提供服务，该系统产生的边缘仪表盘立即得到了回报（例如，提供 API 调用百分点延迟直方图，每个终端的成功率和请求率等）。\n\n在最初推出后不久，另一位 Twitter 同事（Bill Gallagher）加入了我的项目，我们迅速增加了一些功能，如 TLS 终止、HTTP\/2 支持、更多路由和负载平衡功能等。\n\n与此同时，Lyft 基于 Envoy 的“服务网格 \u0022 也开始成形了。首先，Envoy 被部署在 PHP 单片机旁边，以取代 HAProxy 及其一些固有的运维问题（例如，当时 HAProxy 仍然是单线程的），以帮助 MongoDB 的代理。可以毫不夸张地说，Envoy 的早期开发有很大一部分是针对 MongoDB 的稳定性（负载均衡、速率限制、可观测性等）。\n\n基于 Envoy 的边缘机群和单体之间的直接观察能力的好处是非常明显的。不久之后，我们在一些高 RPS 分解的微服务旁边部署了 Envoy，以帮助排除网络问题。这方面的价值也得到了证明。随着时间的推移，我们超越了对可观测性的关注，增加了帮助系统可靠性的功能，如直接连接和服务发现（跳过内部 ELB）、异常值检测、健康检查、重试、断路等。Lyft 的基于负载的重大事件的数量从每 1-2 周一次慢慢减少。当然，Envoy 不能将所有此类事件的减少归功于此，但它提供的网络抽象确实有很大的帮助。\n\n2016 年初，我们决定推动一个 100% 覆盖的服务网格。最初，我们认为这将是一个艰难的过程，需要自上而下的授权。在实践中，**团队报名参加了迁移，因为他们将得到的好处是显而易见的**。“胡萝卜 \u0022式的迁移几乎总是成功的。而“大棒\u0022 式的迁移则很少成功，或者即使成功了，也会在组织内留下眼泪和愤怒。\n\n到 2016 年中期，Envoy 被用于 Lyft 的所有网络通信，包括边缘服务、服务间通信、数据库、外部合作伙伴等。无论从哪个角度来看，该项目都取得了巨大的成功，帮助 Lyft 完成了微服务的迁移，提高了整体的可靠性，并对网络进行了抽象，使大多数工程师不需要了解真实的系统拓扑结构。此后，Bill 离开了这个项目，在 Lyft 从事其他工作，接替他的是 Roman Dzhabarov 和 Constance Caramanolis 加入我的团队。我们的小团队为整个 Lyft 开发和运维 Envoy。\n\n### 开放源码\n\n到 2016 年夏天，我们开始认真讨论开源 Envoy 的问题。早期的 Lyft 员工对开源和它为公司所做的事情很欣赏。很明显，Envoy 并不是 Lyft 的主要业务，那么为什么不把它放在那里并给予回报呢？我可以坦率地说，我们都带着不同的目标和期望来对待开放源代码的过程，以及对项目获得巨大成功后会发生什么感到非常天真。\n\n在加入 Envoy 之前，我已经使用了相当多的开源软件，但我几乎没有开源贡献的经验，也没有维护者的经验。（虽然我在 Linux 内核中有过[一次提交](https:\/\/github.com\/torvalds\/linux\/commit\/00370b8f8dd6e3171b8202f9c5187a5f73e99497)！）开源 Envoy 似乎是一个很好的机会，可以扩展我的技能组合，学习新的东西，可能会促进我的职业生涯，坦率地说，我不希望有一个 TSA v3 在第三家公司出现。对于 Lyft 来说，Envoy 是一个重要的工程项目，领导层认为，开放源代码将使 Lyft 作为一个工程组织具有可信度，并有助于招聘工作。正如我之前所说，我们所有人都对创建成功的开源，更重要的是在它获得成功的情况下培育它所需要的东西感到天真。\n\n但是，我们决定给它一个机会。我们在 2016 年夏天花了很大一部分时间来编写文档（Jose Nino 在这个时候加入了团队，他的第一个任务就是阅读并帮助改进所有的文档），清理存储库，使其 \u0022 不那么尴尬”，制作网站，发布博文等等。我真的很感谢这段时间里我在 Lyft 的同事，他们不仅支持我们，还帮助我们完成了无数的任务，包括网站设计、logo 等等。即使在这个早期阶段，我们也觉得第一印象很重要，如果我们要在开源领域有所作为，就必须通过高质量的文档、网站等给人留下良好的第一印象。\n\n在此期间，我们还利用我们的行业关系，与 Lyft 的一些“同行公司”（湾区的“独角兽 \u0022 互联网创业公司）会面，向他们展示我们在 Envoy 方面所做的工作，并获得他们的反馈，我们认为如果我们在正式开源前成功获得一个启动合作伙伴，这将是对项目的一个重大帮助。所有这些会议都非常友好，总的来说，所有与我们会面的公司都对我们所取得的成就印象深刻。但是，事后看来，他们都表示，以他们的小型基础设施团队，不可能马上采用 Envoy。他们祝愿我们在开放源代码方面取得最好的成绩，并说他们以后会回来看看。我们不禁对这些会议的结果感到沮丧，但我们还是向前推进了。\n\n2015 年 8 月，我与谷歌进行了第一次友好的会面。一个 Lyft 的同事（Chris Burnett）在一个 gRPC 聚会上发言，提到了 Envoy，因为它与 Envoy 的 [gRPC 桥接](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/intro\/arch_overview\/other_protocols\/grpc#grpc-bridging)支持有关。我不知道的是，谷歌在发现 Envoy 的时候，正准备在 NGINX 的基础上推出 Istio。一次会议引出了另一次会议，然后是更多的会议，在 Envoy 开源之前，大量的谷歌员工已经看到了源代码和文档。(稍后会有更多关于这方面的内容）。\n\n到 9 月初，我们已经准备好了，并将开源日定为 9 月 14 日。总的来说，我是一个（过度？）自信的人，但在我的生活中，有几次我对自己成功的能力有很大的焦虑。我立即想到的是：开始上高中，开始上大学，以及大学毕业后在微软工作。而开源的 Envoy 就是其中之一。我记得我被公众的反应吓坏了。人们会怎么说？反馈会是积极的还是恶毒的？虽然我们在开源时是一个小团队，但我仍然写了 90% 或更多的代码，并且觉得把它放到公共领域是对我自己和我的能力的一种反映。\n\n如期而至，[Envoy](https:\/\/eng.lyft.com\/announcing-envoy-c-l7-proxy-and-communication-bus-92520b6c8191) 在 2016 年 9 月 14 日 [成为开源产品](https:\/\/eng.lyft.com\/announcing-envoy-c-l7-proxy-and-communication-bus-92520b6c8191)。我记得我和妻子一起庆祝，并说了一些话。“如果我们能让其他公司像 Lyft 一样使用 Envoy，我就会很高兴。”\n\n对开放源码发布的反应几乎是普遍的积极。令我们惊讶的是，几乎是立刻，我们开始听到大公司的声音，而不是小公司。在几周内，我们与苹果、微软进行了交谈，与谷歌的对话也不断加快。大公司在现有的解决方案中存在问题，并且有大量的团队准备投入到解决这些问题的工作中。具有讽刺意味的是（至少在 Twitter 的观点中），C\u002b\u002b 在这里是一种帮助，而不是一种阻碍。这些大公司都已经拥有充足的 C\/C\u002b\u002b 开发资源，以及他们想要整合的现有库，等等。对他们来说，C\u002b\u002b 是一个卖点。\n\n在这段时间里，毫不奇怪，我们与谷歌的人有最多的互动。最初主要是构建 Istio 的团队，但渐渐地，我们与 Anna Berenberg 花了更多时间，她现在是谷歌的杰出工程师，领导各种网络和负载均衡工作。这种关系将产生 \u0022 喷气燃料”，在 2017 年初真正启动该项目。\n\n### 开始起飞\n\n到了 2017 年初，很明显，Envoy 的开发正在加速。谷歌承诺用 Envoy 取代 NGINX，用于 Istio（最终在 2017 年春季推出），对项目的未来来说更重要的是，Anna 的大型团队致力于 GCP 云负载均衡功能，他们开始向使用 Envoy 的各种云负载均衡产品以及内部用例（这在这个时期都是非常秘密的，但现在已经众所周知）。\n\n我将永远记得与谷歌互动的那段时间是我职业生涯中最紧张的时期之一。说实话，那感觉就像一个收购（审讯）过程。我记得长长的会议和电子邮件线程，以证明我们的技术决定，“面试 \u0022中，谷歌试图确定我们是否会成为一个好的开源项目合作伙伴，等等。当时我们很痛苦地发现，这次\u0022 收购 \u0022 将使 Envoy 进入一个我们自己永远无法实现的轨道，所以我们尽一切努力使它获得成功，最终也获得了成功。而且，在过去 4 年多的时间里，我们与谷歌的合作确实是一种杰出的伙伴关系。早期的谷歌云工程师最终成为维护者，Harvey Tuch 和 Alyssa Wilk，为项目带来了大量的人才，包括技术上的，以及对开源和社区的支持。我对他们的感激之情溢于言表，没有他们，项目就不会有今天的成就。多年来为该项目做出贡献的其他谷歌工程师（现在有很多），除了普遍是优秀的社区管理者之外，还为该项目增加了大量的工程力量，否则该项目就不会有。我当然对最初的谷歌合作关系有顾虑（技术和理念上的分歧，等等），但我可以诚实地说，这些顾虑都没有成为现实。\n\n除了确保 Istio 和 GCP 团队与谷歌合作的成功之外，我们还花了大量时间与其他公司和维护者合作并加入他们，其中许多人对项目产生了巨大的影响，至今仍作为维护者、贡献者或用户大量参与。如果没有这些早期的社区成员，这个项目就不会有今天，我也非常感谢他们对项目的信任。\n\n同时，随着项目的不断深入，我开始收到大量投资者对 Envoy 的兴趣。有强烈的愿望让我离开 Lyft，围绕这个项目开一家公司。我[写过这部分的旅程](https:\/\/medium.com\/@mattklein123\/optimizing-impact-why-i-will-not-start-an-envoy-platform-company-8904286658cb)，所以我不会在这里重述，留在 Lyft 我会有大量的时间和精力来处理所有这些互动。正如链接的文章所描述的，我最终决定留在 Lyft，不开公司，以支持 Envoy 的持续成功。\n\n与此同时，我仍然在 Lyft 工作，正如我将在后面进一步讨论的那样，我越来越多地从事两份工作。我的第一份工作是在内部领导网络团队，并在运营上支持 Lyft 的 Envoy。我的第二份工作是作为 Envoy 的公众形象，包括 OSS 领导，代码审查，修复错误，编写可以促进项目的功能，在会议上发言，帮助其他公司采用和部署 Envoy，等等。我开始变得过于分散，并出现了倦怠的迹象。然而，到了 2017 年年中，不可否认的事实是，Envoy 的发展轨迹是大大的“向上和向右”。各大公司、“同行公司”、垂直产品和服务等的采用率继续攀升。\n\n### 捐赠给 CNCF 且感到倦怠\n\n到 2017 年秋天，有两件事是清楚的。\n\n1. Envoy 已经超出了 Lyft OSS 设备所能提供的范围。该项目需要法律、公共关系、营销、活动组织等方面的帮助。\n2. 我很快就完全倦怠了，需要找出一条可持续发展的道路。\n\n为了解决第一点，我们最终同意考虑将 Envoy 转交到 CNCF。数月来，CNCF 一直在追求该项目，但似乎从来没有任何令人信服的理由来加入。到 2017 年底，很明显，CNCF 的资源即使不是净收益，也至少对项目是中性的。我们开始了提交程序，并最终在我们最初开放项目资源的几乎整整一年后[加入了该基金会](https:\/\/eng.lyft.com\/envoy-joins-the-cncf-dc18baefbc22)。我很感谢 Alexis Richardson 和 Chris Aniszczyk 在这个过程中对项目的指导。\n\n第二点则要复杂得多。从根本上说，我的工作时间超过了我的工作能力，有效地跨越了两个不同的工作。此外，我正在期待我的第一个孩子，预产期在 2018 年初，随着到来的日期越来越近，这让我越来越焦虑。到这个时候，我已经很清楚，我在设定期望和界限方面做得不够好，不知道自己能够为 Lyft 提供什么，同时也没有从行业的角度关注 Envoy 的持续增长。在 Lyft，我越来越放任自流，陷入人际关系的争吵，在为更多的初级团队成员提供指导和领导方面，没有达到我这个级别的期望。\n\n简而言之，我当时正处于崩溃的边缘，最终我选择了 Envoy 而不是 Lyft，这对我的 Lyft 同事造成了伤害。我想，如果我在 2017 年初至年中对我的工作量与 Lyft 的领导层更加透明，我可能会避免一些最糟糕的结果，但不幸的现实是，**为开源软件行业的工作提供资源，而这些工作对雇主没有立即明显的作用，这是一个复杂的努力**。它可能会更顺利，也可能不会。在任何情况下，虽然我对一些我本可以处理得更好的人际关系问题感到遗憾，但无论好坏，**我都不后悔把精力放在 Envoy 上。我优先考虑的是 Envoy，而不是 Lyft，我做了我认为当时必须做的事情，以使它成功**。\n\n### 可持续发展道路\n\n我的第一个孩子在 2018 年 2 月出生，Lyft 极其慷慨的陪产假政策为我提供了休息和放空自己的时间。我从 Lyft 获得了一些空间，并开始更深入地思考我想要什么以及什么对我来说是可持续的。\n\n当我休完陪产假回来后，我与 Lyft 领导层明确表示，我不能再参与 Lyft 的 Envoy 的 \u0022日常\u0022 运维。相反，由于 2017 年底的一些后果，基础设施团队也希望与我分开一些。由于这个原因，**我大幅后退，实际上完全停止了在 Lyft 的基础设施工作**，在 2018 年年中至年末的 Lyft Bikes 和 Scooters 初始版本中编写固件网络代码。这是一个了不起的团队努力，在压缩的时间范围内得到了一些东西，我真的很喜欢在几个月内做一些完全不同的事情。\n\n2018 年也是我积极开始琢磨在 Envoy OSS 社区中 \u0022取代自己\u0022 的那一年。我花了大量的时间（并将继续花大量的时间）来培养维护者、新的贡献者，组织第一次专门的 EnvoyCon，等等。任何领导者都应该有一个目标，那就是确保该组织在有一天该领导者退位时能够继续良好地运作。\n\n到 2018 年底，我的主要职业倦怠风险已经得到解决，我又开始了合理的工作时间，并花了很多时间与我的妻子和儿子在一起，我的时间大致在 Envoy OSS 工作和 Lyft 的一般基础设施领导之间各占一半。明确地说，Envoy 的成功带来的特权使我能够在 Lyft 的工作生活中取得这种平衡。随着时间的推移，随着我的行业地位的提高，我的影响力也在同步增加，这使得我更容易按照自己的意愿设定就业条款。没有多少人有这样的运气，我明白我是多么幸运，能够“突破“倦怠墙的另一边而不必离开我的工作。\n\n### Envoy 长大了\n\n自 2019 年以来，因为新冠疫情，我在 Lyft 的基础设施领导和 OSS 领导之间继续保持着我上面描述的五五开的比例。当然也有单调和渴望不同的时候（从历史上看，我是一个习惯性换工作的人，6.5 年是迄今为止我在一件事情上工作的最长时间），但总的来说，我很高兴看到 Envoy 从一个“新秀 \u0022 变成更多的“少年”。我不再专注于做我所能想到的一切，使 Envoy 获得巨大的成功，因为坦率地说，Envoy 是一个巨大的成功，已经席卷了市场，并改变了用户对应用负载均衡工具的期望。相反，我更关注项目的可持续性。我们是在做长期的工作，这些天我觉得自己更像一个 CEO，看减员人数、优先级、预算编制、安全问题等等。这并不是说这不是有用的工作；它显然是有用的，它只是与早期的工作不同，早期的工作技术性更强，节奏更快。\n\n截止到 2021 年末，我对 Envoy 最引以为豪的事情是，在我看来，这个社区已经可以自我维持了。我们有一群令人难以置信的维护者、贡献者和用户，他们对项目的成功充满热情，并在使 Envoy 成为今天的样子中发挥了作用。这确实是一个团队的努力。\n\n## 经验教训\n\n过去的 5 年是一个史诗般的旅程。虽然我觉得我在技术上学到的东西相对较少，但我在领导力、社区建设和所有其他非技术性的东西方面都得到了成长和学习，这些都是建立一个成功的企业，无论是企业还是一个主要的开源成功故事。以下是我对一些主要学习内容的简短总结。\n\n### 成功的开源软件就像创办一个企业\n\n也许有争议的是，**我认为如果一个人有目标要创建一个非常成功的开源软件项目，他们需要把它想成一个企业**。除了核心技术之外，创业还涉及很多因素：\n\n- 招聘（在开源软件中，这意味着招聘贡献者和维护者）\n- 获取客户（在开源软件中，这被转化为用户）\n- 文档和技术写作\n- 公共关系\n- 市场营销\n- 法律（商标、许可等）\n- 人力资源（在开源软件中，这将转化为解决社区纠纷和制定文化）\n- 资金（在开源软件中，这转化为辅助费用，如 CI、为维护者找到允许他们在项目中部分或全部时间工作的工作，等等）\n- 总的说来，就是领导和方向的确定。资源有限，有很多事情可以做。企业 \/ 项目需要专注于最重要的事情，以实现产品的市场适应性。\n\n直观地说，我知道这一点，在最初为 Envoy 进行开源努力时，我积极地追求上述所有的领域，努力使项目从开始发展到今天的规模。上述列表中的每一项都很关键，如果没有所有这些，一个项目是不可能成功的，尤其是在技术领域有很多资金雄厚的公司竞争对手的情况下。\n\n我强烈鼓励那些考虑进行大规模开源工作的人提前在上述领域进行投资，以便在第一天就给人留下最佳印象。此外，新的开源项目应该准备在项目成长并开始看到采用时，在上述领域进行更多的投资。\n\n毫不奇怪，这些天我在 Envoy 上做的编码工作相对较少。我在项目上的时间主要是管理项目的所有非技术方面（上述列表中的所有内容，甚至更多！），并确保事情按计划进行。我所做的大多数编码项目都是“清洁 \u0022 的幕后项目，对项目有好处，但没有什么乐趣，也不可能激励其他贡献者（当然，我对他们每天的工作没有发言权，我有动力让他们尽可能的开心，这样他们就不会离开）。\n\n### 终端用户驱动的开源软件是一种结构性优势\n\n这些天来，很多“大的开源软件”，特别是在基础设施领域，是由大公司和风险投资支持的初创公司资助的。我不会绕到关于开源软件的困难经济的讨论，因为我[已经写过了](https:\/\/medium.com\/@mattklein123\/the-broken-economics-of-oss-5a1b31fc0182)。我想说的是，**我坚信终端用户的开源软件比企业和风险投资支持的开源软件有很大的优势**：最初的客户几乎肯定会从软件中获得价值，否则软件就不会得到资助。这种与客户一起建立东西的良性循环是非常强大的。它几乎普遍导致了更好的结果：软件更可靠、更专注、功能更少。有很多由最终用户驱动的开源软件的例子，然后取得了巨大的商业成功。鉴于坚实的基础和内在的产品市场适应性，这对我来说并不奇怪。我希望看到比今天更多的最终用户驱动的开源软件，尽管我认识到经济上是困难的。对于那些有机会的人来说，请向这种类型的软件所具有的结构性优势靠拢！\n\n### 不要跟风，要跟随客户\n\n这也许是 \u0022成功的开源软件就像创业\u0022 和 \u0022最终用户驱动的开源软件是一种结构性优势\u0022 的必然结果，但我无法强调坚持不懈地关注客户的实际需求而不是炒作周期所认为的客户需求是多么关键。例如，**多年来，人们一直在嘲笑 Envoy 是用 C\u002b\u002b 编写的，这引起了无数的笑话**。我喜欢 C\u002b\u002b 吗？不，不是很喜欢。它是否在 2015 年完成了工作，并吸引了最初的一批主要用户？肯定是的。这是一个关注客户和市场的例子，而不是屈服于没有实际“商业 \u0022 影响的炒作。如果一个人把开源软件当做一个企业，就会立刻明白，**以客户和市场为中心是取得巨大成功的唯一途径**。在 Envoy，我花了大量的时间为终端用户争论，以确保我们建立的东西能让所有人受益，而不仅仅是一小部分小众用户。\n\n### 可扩展性是至关重要的\n\n跟着客户走往往会导致客户的要求不能很好地融入项目的架构中。从开源软件的角度来看，失去对项目主要目标的关注会导致功能蔓延、软件无法维护和维护人员负担过重。同时，说“不 \u0022 也是失去潜在用户的一个保证。\n\n对于 Envoy，我想确保我们至少可以说“是的，但是……\u0022，即提供一个强大的可扩展性模型，让用户可以满足他们的需求，而不需要将每一个改动和功能都推到上游。这种策略已经多次得到回报，它减轻了维护者的负担，让用户能够解决他们自己的问题，更重要的是，将 Envoy 推向了我在最初设计该软件时从未想象过的用例。\n\n可扩展性，特别是对于开源软件的构建模块，是至关重要的。\n\n### 质量问题\n\n跟随客户的另一个推论是，质量确实很重要。用户希望软件易于操作，相对来说没有错误，关心安全，等等。曾几何时很多人会觉得因为开源软件是 \u0022 免费的”，所以质量就得不到保证。这在理论上也许是正确的，但实际上，在一个项目对软件质量认真对待之前，用户不会大量地聚集在一个软件上。因为获得用户是一个飞轮，可以获得更多的用户（特别是当从早期采用者转向晚期采用者时），所以确保为整个软件质量编列时间预算就更加关键了。\n\n关于 Envoy，我一直有一个 \u0022零碰撞\u0022 的理念。任何崩溃都会被调查和修复，无论多么不频繁的错误。这种对稳定性和质量的关注不会被忽视。\n\n### 社区是扩大规模的唯一途径\n\n这很明显，但我还是要说：社区是扩展开源软件的唯一途径。这是一个由维护者、贡献者和用户组成的社区。此外，社区的**基调**在项目开始时就已经确定，而且极难改变。人类倾向于遵循规范。一旦规范被确定下来，无论规范是什么，与这些规范不一致的人都会被避开。因此，**项目最初的公共基调对于设定其长期的社区轨迹极为关键**。\n\n当我们把 Envoy 做成开源软件时，我在 GitHub 上投入了大量的精力与人们一起工作，使用建设性和欢迎性的语言。总的来说，我尽我所能让 Envoy 成为一个受欢迎的地方，让人们愿意来贡献自己的力量，无论是维护、偶尔的贡献，还是用户帮助其他用户。\n\n在 Envoy 所取得的所有不同类型的成功中，到目前为止，给我带来最多个人满足感的部分是，有相当多的人告诉我，他们已经发誓不再使用开源软件，尤其是基础设施开源软件，因为他们觉得大多数项目中的人对彼此感觉都很糟糕。相反的，他们喜欢为 Envoy 做贡献，因为这个社区是如此的尊重和欢迎彼此。这需要大量的努力和纪律，尤其是在项目的早期，才能达到这样的结果，而这已经得到了众多的回报。\n\n不要低估从一开始就确定项目的文化和基调的复合效应。\n\n### 混合商业和开源软件的利益是非常困难的\n\n已经有很多关于开源软件的困难经济学的文章（[包括我自己的文章](https:\/\/medium.com\/@mattklein123\/the-broken-economics-of-oss-5a1b31fc0182)，我在上面提到的）。我只想说，**试图将商业上的成功和开放源码的成功结合起来是非常困难的，主要是因为这些成功往往是相互矛盾的**。\n\n我相信，Envoy 通过其强大的 API 和可扩展性系统穿透了这个矛盾。从本质上讲，Envoy 已经成为一个工具，现在被大量的垂直产品和服务所使用。这就产生了一个社区，该社区充满了选择在一个共同的基底上合作的公司，即使是通过在扩展 \/ API \/ 控制平面 \/ UI\/UX 层上的创新，推出相互竞争的上层产品。\n\n任何成功的开源项目都会看到大量的商业 \/ 投资人的兴趣。如果一个项目的目标是保持一个充满活力的社区，同时又能取得商业上的成功（我认为这对整个项目的成功是必要的，因为钱必须来自某处），**那么预先考虑如何将核心层和商业层分开是极其重要的**。这样做的实用性和策略会因项目和技术的不同而不同，但我相信专注于强大的 API \/ 扩展性的分割是一个富有成效的策略。\n\n### 基金会是很棘手的\n\n在现代的开源讨论中，有很多关于基金会的作用的讨论。我不打算对这一话题做大量的评论，**但我的主要建议是不要被基金会和它们可能提供的理论利益所干扰**。相反，要积极地关注产品的市场适应性，生产高质量的软件，并为用户提供价值。如果这些事情得以实现，其余的事情就会自然而然地发生。\n\n对于非常成功的项目来说，基金会，更确切地说，中立的商标持有地，是非常有用的，所以我肯定会在那个时候考虑加入一个。随着项目的成熟，Envoy 从成为 CNCF 的一部分所获得的价值也在不断增加。CNCF 雇佣了开源软件律师、营销人员、公共关系人员、一流的活动人员等等。这些额外的资源在“经营业务 \u0022 方面是非常宝贵的。\n\n### 提前考虑治理问题\n\n![](008i3skNly1guh3vqvywcj60tw0h8go702.jpg)开源治理是**非常**困难的。就其本质而言，开放源代码是无政府的，没有明确的领导结构。没有一个适合所有项目的治理方法，每个项目都必须找到自己的前进方向，可以通过“BDFL”\/CEO 类型的模式、指导委员会、类似 Apache PMC 的程序等。所有的治理模式都有优点和缺点，并且有不同的失败模式。\n\n最重要的是，在项目变得庞大和成功之前，先认真思考治理问题。写下一套规则和规范，特别是花时间记录项目的冲突解决过程。\n\n同时也要意识到，根据我在上面关于社区规范如何在早期设定的评论，早期的项目维护者将对整个对话和冲突解决的风格产生巨大的影响，就像公司的早期员工对公司的文化产生巨大的影响一样。\n\n在我的印象中，我们在 Envoy 内部非常幸运，没有发生过任何重大分歧，出现的问题也可以迅速友好地解决。在项目的历史上，我们从来没有需要援引[维护者投票程序来解决冲突](https:\/\/github.com\/envoyproxy\/envoy\/blob\/main\/GOVERNANCE.md#conflict-resolution-and-voting)。在我看来，这是一个巨大的成就，也是对所有维护者的素质和专业性的证明，尤其是考虑到该项目已经变得如此受欢迎，以及围绕它的所有商业利益。\n\n### 对开源贡献的期望是至关重要的\n\n我在上面提到过这个问题，但我自己的职业倦怠很大程度上是由于我没有很好地与我的雇主就我需要花多少时间来管理 Envoy 的开源增长设定合理的期望。我不会撒谎说，进行这样的对话就能神奇地使雇主为某人腾出大量时间来从事开源工作，特别是那些可能不直接适用于其日常工作的项目。话虽如此，我确信对所有参与的人来说，对开源过程有公开和诚实的期望是非常重要的。以下是在开源项目之前或开始以开源身份工作之前要问的合理问题：\n\n- 雇员应该问他们的雇主，为什么他们要开放源代码？\n- 雇主应该问他们的员工，为什么他们要开放源代码？(这个问题的答案和前一个问题的答案不同是完全合理的，但应该在公开场合讨论)。\n- 雇员应该问他们的雇主，如果项目成功了，会发生什么？该项目将有哪些资源可用？员工将有多少时间可以在通用的开源软件问题上工作，目的是直接推动项目的发展？\n\n**雇主和雇员之间不匹配的期望是未来怨恨和倦怠的根本原因。**\n\n### 代理容易，API 难\n\n对一些人来说，Envoy 提供的底层网络代理机制似乎是这个项目的复杂部分。事实证明，与为 Envoy 发展一个稳定的 API 生态系统所做的工作相比，代理部分（在我看来）相对简单。平衡人类和计算机消费的 API 人体工程学，保持不同版本的稳定性，发展 API 以支持其他客户端，如 gRPC，指定协议语义以使 Envoy 能够与数百（可能是数千）个不同的管理服务器对话，等等，都是非常复杂的。我为团队在这一领域取得的成就感到骄傲（特别要感谢推动这一工作的 Harvey），即使在这一过程中出现了一些错误（比如从 API 的 V2 版本强制迁移到 V3 版本）。\n\n如果一个软件提供了一个 API，而且更重要的是希望这个 API 成为其他系统的关键组件，那么不要低估提供一个稳定和符合人体工程学的 API 的成本和复杂性。反过来说，**强大的 API 是一个生态系统飞轮的重要组成部分**，会以此产生更多的产品和用户，所以在我看来，这些努力是非常值得的。\n\n### 不要忽视职业倦怠\n\n**如果一个人想成就大事业，我不相信他可以 100% 实现良好的工作生活平衡**。现实情况是，任何成功都是由现有的特权 \/ 机会、一个好的想法、良好的执行力和大量的运气（包括在正确的时间出现在正确的地点）组成的。所有这些东西都在 Envoy 中发挥作用，我不会假装我没有把自己搞得很累，特别是在 2017 年。我也会重新做一遍 2017 年的工作，因为从我的角度来看，我做了我必须做的事情，使项目获得成功。(有时我想，如果我已经有了孩子，Envoy 是否还会诞生。我不确定它是否会发生，但这是一个更长的谈话主题！)\n\n综上所述，我在 2017 年描述的那种史诗般的推动力只能持续这么久，直到一个人崩溃。我鼓励大家不断反思自己的工作生活平衡，并为自己找出一条可持续发展的道路。每个人的情况都不同，我不能提供任何一个避免职业倦怠的建议，但我认为反思是一个好的开始，也是我自己不得不努力的事情。\n\n## 感谢\n\n在过去 6 年半的时间里，在 Envoy 上工作，其中 5 年是作为开源软件，这是我职业生涯中的亮点。这个项目的成功确实是一个团队的努力，我一个人是不可能完成的，我为我们所有人（维护者、贡献者和用户）共同完成的事情感到非常自豪。在这个项目上工作的维护者和贡献者是我所共事过的最好的工程师群体，他们才华横溢，他们就职在不同公司，位于不同的地理位置，这真是开源的理论潜力在实践中的体现。作为一个团队，我们已经产生了世界性的影响，改变了用户对软件负载均衡系统的期望，同时也建立了一个充满活力和热情的社区。在我最疯狂的梦想中，我从未想过这个项目会成为今天的样子。\n\n对我来说，未来会发生什么就不那么清楚了。正如我上面所说的，我的重点已经转移到了可持续性上。我想确保，如果有一天我离开了，这个项目将保持健康。尽管如此，这一天还没有到来，我期待着在可预见的未来帮助领导项目前进，希望能取得更大的成功和采用。向前迈进！\n', '\/trans\/envoy-oss-5-year\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">开源网络代理 Envoy 的创始人 Matt Klein，在 Twitter 因为自己的程序 bug 造成重大事故而离职，后加入 Lyft，在开源 Envoy 之前几乎没有贡献和管理开源项目的经验，这篇文章分享了他个人及 Envoy 开源的心路历程，在投身开源 Envoy 还是为雇主 Lyft 效命，该如何抉择？</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
          <div class="col-12">
 
 
 
 
 
 
 
 
 
 
 
 <nav aria-label="Page navigation">
   <ul class="pagination justify-content-center">
     
     
     <li class="page-item">
       <a class="page-link" href="/blog/">
         ««
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a href="/blog/page/18/" class="page-link">
         «
       </a>
     </li>
     
     
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item">
           <a href="/blog/page/17/" class="page-link">
             17
           </a>
         </li>
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item">
           <a href="/blog/page/18/" class="page-link">
             18
           </a>
         </li>
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item page-item active ">
           <a href="/blog/page/19/" class="page-link">
             19
           </a>
         </li>
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item">
           <a href="/blog/page/20/" class="page-link">
             20
           </a>
         </li>
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item">
           <a href="/blog/page/21/" class="page-link">
             21
           </a>
         </li>
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
     
     
     <li class="page-item">
       <a href="/blog/page/20/" class="page-link">
         »
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a class="page-link" href="/blog/page/27/">
         »»
       </a>
     </li>
     
   </ul>
 </nav>
 
</div>

        </div>
      </div>
      <!-- sidebar -->
      <aside class="col-lg-4 order-1 order-lg-2 d-none d-sm-block">
          <div class="sidebar">
          <!-- categories -->
<div class="blog-categories mb-4">
  <p class="sidebar-title">
      专栏
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/istio" class="sidebar-item">
            <span>Istio</span>
            <span>(74)</span>
        </a>
      
        <a href="/categories/service-mesh" class="sidebar-item">
            <span>Service Mesh</span>
            <span>(42)</span>
        </a>
      
        <a href="/categories/kubernetes" class="sidebar-item">
            <span>Kubernetes</span>
            <span>(25)</span>
        </a>
      
        <a href="/categories/%e9%9a%8f%e7%ac%94" class="sidebar-item">
            <span>随笔</span>
            <span>(22)</span>
        </a>
      
        <a href="/categories/%e5%85%b6%e4%bb%96" class="sidebar-item">
            <span>其他</span>
            <span>(18)</span>
        </a>
      
        <a href="/categories/envoy" class="sidebar-item">
            <span>Envoy</span>
            <span>(17)</span>
        </a>
      
        <a href="/categories/%e4%b8%9a%e6%80%81" class="sidebar-item">
            <span>业态</span>
            <span>(17)</span>
        </a>
      
        <a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f" class="sidebar-item">
            <span>云原生</span>
            <span>(14)</span>
        </a>
      
        <a href="/categories/ai" class="sidebar-item">
            <span>AI</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%ae%89%e5%85%a8" class="sidebar-item">
            <span>安全</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%bc%80%e6%ba%90" class="sidebar-item">
            <span>开源</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e6%97%85%e8%a1%8c" class="sidebar-item">
            <span>旅行</span>
            <span>(7)</span>
        </a>
      
        <a href="/categories/%e5%8f%af%e8%a7%82%e6%b5%8b%e6%80%a7" class="sidebar-item">
            <span>可观测性</span>
            <span>(5)</span>
        </a>
  </div>
</div>

<div class="blog-categories mb-4">
  <p class="sidebar-title">
      资料
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/%e5%87%ba%e7%89%88%e7%89%a9" class="sidebar-item">
            <span>出版物</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e7%94%b5%e5%ad%90%e4%b9%a6" class="sidebar-item">
            <span>翻译电子书</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e6%96%87%e6%a1%a3" class="sidebar-item">
            <span>翻译文档</span>
            <span>(7)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>翻译图书</span>
            <span>(6)</span>
        </a>
      
        <a href="/categories/%e5%8e%9f%e5%88%9b%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>原创图书</span>
            <span>(2)</span>
        </a>
      
        <a href="/categories/%e6%95%99%e7%a8%8b%e6%89%8b%e5%86%8c" class="sidebar-item">
            <span>教程手册</span>
            <span>(2)</span>
        </a>
  </div>
</div>





          </div>
      </aside>
      <!-- /sidebar -->
    </div>
  </div>
</section>




<footer>
  
  <div class="footer bg-footer section-sm border-bottom overlay ">
    <div class="container-xl">
      <div class="row">
        <div class="col col-xl-4 d-sm-none mb-2 mb-lg-0 d-xl-block d-none">
          
          <p class="h3 text-white mb-4 text-uppercase">联系</p>
          
          <ul class="list-unstyled">
            
            
            <li class="mb-4 text-color">微信公众号</li>
            
            
            <li class="mb-4"><img src="/images/servicemesher-wechat.webp" width="118px" height="118px" alt="footer image"></li>
            
            
            
          
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">博客</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/blog/shanxi-trip/">地上文物看山西：宝藏文物大省不该被埋没</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/multi-cluster-pki-istio-recipe/">多集群 PKI 与 Istio 实践：为服务网格构建可信且可扩展的 PKI</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/envoy-tracing/">Envoy 代理如何处理用户请求以实现追踪</a></li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">链接</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://istio.io/latest/zh/" target="_blank" rel="noopener noreferrer">
                  Istio 服务网格
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://tetrate.io/?jimmysong" target="_blank" rel="noopener noreferrer">
                  Tetrate 公司
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener noreferrer">
                  云原生学院|Bilibili
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/awesome-cloud-native/" target="_blank" rel="noopener noreferrer">
                  云原生开源项目大全
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://cloudnative.to" target="_blank" rel="noopener noreferrer">
                  云原生社区（中国）
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">教程</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/envoy-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Envoy 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/istio-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Istio 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/kubernetes-handbook/" >
                  Kubernetes 基础教程
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/envoy-made-simple/" >
                  简明 Envoy 教程
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">通知</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/notice/nist-sp-800-233-service-mesh-proxy-models/">资料分享：云原生应用服务网格代理模型的威胁分析指南</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/kubecon-china-2024-panel/">KubeCon China 2024（香港）</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/website-revamp-notice/">网站改版通知</a></li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>

  
  <div class="copyright py-4 bg-footer overlay">
    <div class="container-xl">
      <div class="row">
        <div class="col-sm-6 text-sm-left text-center">
          <p class="mb-0 text-color">© 2017-2024 Jimmy Song 保留所有权利</p>
        </div>
        <div class="col-sm-6 text-sm-right text-center">
          <ul class="list-inline">
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://twitter.com/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-x-twitter text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/contact/" >
                    <i class="fa-brands fa-weixin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://github.com/rootsongjc" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-github text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://linkedin.com/in/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-linkedin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="mailto:rootsongjc@gmail.com" >
                    <i class="fa-solid fa-envelope text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/blog/index.xml" >
                    <i class="fa-solid fa-rss text-white"></i>
              </a>
            </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>


<!-- JS Plugins -->

<script src="/plugins/popper/popper.min.js"></script>

<script src="/plugins/bootstrap/bootstrap.min.js"></script>

<script src="/plugins/slick/slick.min.js"></script>

<script src="/plugins/filterizr/jquery.filterizr.min.js"></script>

<script src="/plugins/search/fuse.min.js"></script>

<script src="/plugins/search/mark.js"></script>

<script src="/plugins/hex_md5/hex_md5.js"></script>

<script src="/plugins/anchor/anchor.min.js"></script>

<script src="/plugins/tocbot/tocbot.min.js"></script>

<script src="/plugins/bigger-picture/bigger-picture.min.js"></script>


<!-- Main Script -->

<script src="/js/script.min.f94c22b1d478bfc9e2e0a7d954429e47b7e6d36edd423758482e04154ae1842e.js"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-ESY906ZWZ0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ESY906ZWZ0');
</script>


<!-- Baidu analysis -->
<meta name="baidu-site-verification" content="g8IYR9SNLF" />





<script>
    anchors.add();
</script>






<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>










<script src="/js/wowchemy-search.min.7a37268e7bbe4a9160c2e4c33b749816.js" type="module"></script>
<script id="search-hit-fuse-template" type="text/x-template">
  <div class="search-hit" id="summary-{{key}}">
    <div class="search-hit-content border-bottom">
      <div class="search-hit-name">
        <div class='search-hit-link'><a href="{{relpermalink}}">{{title}}</a></div>
        <div class="search-hit-metadata d-flex">
            <span class="mr-1"><i class="fa-regular fa-calendar mr-1"></i>{{date}}</span>
            <span class="mr-1"><i class="fa-regular fa-folder-open mr-1"></i>{{section}}</span>
            <span class="d-sm-block d-none"><i class="fa-solid fa-link mr-1"></i>{{relpermalink}}</span>
        </div>
        <div class="search-hit-description">{{snippet}}</div>
      </div>
    </div>
  </div>
</script>



    </body>
</html>
