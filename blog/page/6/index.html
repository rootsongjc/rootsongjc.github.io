<!DOCTYPE html>
<html lang="zh"><head>
  <meta charset="utf-8">
  
  <title>博客 · Jimmy Song</title>
  

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta name="description" content="专注开源技术、云原生与生活随笔的分享与思考。">
  <meta name="author" content="Jimmy Song">
  <meta name="generator" content="Hugo 0.129.0">

  <!-- CSS plugins -->
  
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
  
  <link rel="preload" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" as="style">
  <link rel="stylesheet" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" media="screen">
  

  <!-- Main Stylesheet -->
  
  <link rel="preload" href="/scss/style.min.595949bd12db88434115e2a1e70965cf2928cc646e73acc6437c4cbbc323f585.css" as="style">
  <link rel="stylesheet" href="/scss/style.min.595949bd12db88434115e2a1e70965cf2928cc646e73acc6437c4cbbc323f585.css" media="screen">

  <!-- Bigger picture css -->
  
  <link rel="stylesheet" href="/plugins/bigger-picture/bigger-picture.min.css" media="print" onload="this.media='all'">
  <!--Favicon generate by https://realfavicongenerator.net-->
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="200x200" href="/images/favicon.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">

  <link href='/opensearchdescription.xml' rel='search' title='Content search' type='application/opensearchdescription+xml'/>

  <!--Twitter card-->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="jimmysong.io" />
  <meta name="twitter:creator" content="@jimmysongio" />
  <meta property="og:url" content="https://jimmysong.io/blog/" />
  <meta property="og:title" content="博客 | Jimmy Song" />
  <meta property="twitter:title" content="博客 | Jimmy Song" />

  
  <meta property="og:description" content="专注开源技术、云原生与生活随笔的分享与思考。" />
  <meta property="twitter:description" content="专注开源技术、云原生与生活随笔的分享与思考。" />

  
  <meta property="og:image" content="https://jimmysong.io/images/banner/default.jpg" />
  <meta property="twitter:image" content="https://jimmysong.io/images/banner/default.jpg" />

  
  
</head>
<body>
<header class="fixed-top header">
  
  
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa fa-arrow-circle-up" aria-hidden="true"></i></button>
  
  <div class="navigation w-100 ">
    <div class="container-xl">
      <nav class="navbar navbar-expand-lg navbar-light p-0">
        <a class="navbar-brand" href="/">
            
            <b>JIMMY SONG</b>
            
        </a>
        <button class="navbar-toggler rounded-0" type="button" data-toggle="collapse" data-target="#navigation"
          aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse text-center" id="navigation">
          <ul class="navbar-nav ml-auto">
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/blog">博客</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/book">资料</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/tags">标签</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/notice">公告</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/contact">联系</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/about">关于</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/community/">社区</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener">视频 <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i></a>
              
            </li>
            
            

          
          
          <li class="nav-item">
            
            
            
              
              
                
                
                
                  
                    
                    <a class="nav-link" href="/en/blog/">English</a>
                    
                  
                
              
              
              
                
                  
                    
                    
                  
                
                
                
              
          </li>
          
          
          <!-- search -->
           <button type="button" class="search-btn js-search" id="searchOpen" aria-label="Search">
              <div class="search-container d-flex justify-content-center">
              <span class="search-content">
                  <i class="fa fa-search"></i>
                  <span>搜索</span>
              </span>
              <span class="search-shortcuts d-none d-sm-block">
                  <kbd class="cmd-key">⌘</kbd>
                  <kbd class="k-key">K</kbd>
              </span>
              </div>
          </button>
          
          </ul>
        </div>
      </nav>
    </div>
  </div>
</header>


            <aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between">
        <div class="col-6 search-title">
          <p>站内搜索</p> 
        </div>
        <div class="col-6 col-search-close">
          <div class="js-search" aria-label="关闭"><i class="fa-solid fa-circle-xmark text-muted" aria-hidden="true"></i></div>
        </div>
      </div>

      <div id="search-box">
        <i class="fa-solid fa-magnifying-glass" id="search-icon" aria-hidden="true"></i>
        <input name="q" id="search-query" placeholder="请输入搜索词" autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control" aria-label="请输入搜索词">
        
        <div class="mt-4">
          <span>搜索类型: </span>
          <span>
            <input type="radio" id="all" name="search_type" value="all" checked>
            <label for="all">所有</label>
            
              <input type="radio" id="blog" name="search_type" value="blog">
              <label for="blog">原创</label>
              <input type="radio" id="trans" name="search_type" value="trans">
              <label for="trans">译文</label>
            
            <input type="radio" id="book" name="search_type" value="book">
            <label for="book">资料</label>
            <input type="radio" id="notice" name="search_type" value="notice">
            <label for="notice">公告</label>
          </span>
        </div>
      </div>
      
    </section>
    <section class="section-search-results">
      <div id="search-results-count" class="search-results-count"></div>
      <div id="search-hits">
        
      </div>
    </section>
  </div>
</aside>

        
        
            

<section class="bg-cover page-title-section overlay" style="background-image: url('/images/backgrounds/circle.svg'),url('/images/backgrounds/page-title.webp');background-size: cover;">
    <div class="container-xl">
        <div class="row">
            <div class="col-12">
                <p class="h1">
                    博客
                </p>
                <p class="page-description">
                    专注开源技术、云原生与生活随笔的分享与思考。
                </p>
                
            </div>
        </div>
    </div>
</section>

        


<section class="section-sm book-list-section bg-gray">
  <div class="container-xl">
    <div class="row">
      <div class="col-lg-8 order-2 order-lg-1">
        <div class="row">
          
          
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/cloud-computing-post-serverless-trends/">[译] 后 Serverless 时代的云计算趋势分析</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/02/02</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f"> 
             云原生
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://www.infoq.com/articles/cloud-computing-post-serverless-trends/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('后 Serverless 时代的云计算趋势分析', '这篇文章主要讨论了未来云计算领域的三大趋势：从基本元素到云构件作为服务的转变、从超大规模到超专业化的转变、以及从基础设施到组合式编程作为服务的转变。作者指出，未来的云服务将更加集成编程构件，使得开发人员能够无缝地使用他们喜欢的编程语言来组合应用程序。文章强调了这些趋势对开发人员和运营团队的影响，并指出了这些变化将如何塑造未来以开发人员为中心的云服务。', '\n## 主要观点\n\n- 无服务器计算正在超越其最初的范围，函数部分或完全被多才多艺的云构件取代，标志着云架构的新时代。\n- 云市场正朝着高度专业化的垂直多云服务转变，提供独特的、精细粒度的功能，专门满足开发人员的需求。\n- 即将推出的云服务将充满构件，改变开发人员处理路由、过滤和事件触发等任务的方式，使其更高效和用户友好。\n- 从基础设施即代码转向构件即代码的趋势显著，开发人员使用熟悉的编程语言进行更直观的云服务配置。\n- 微服务正在云景观中重新定义，从仅仅是架构边界演变为组织边界，在统一的开发者语言下整合各种云构件。\n\nAWS Lambda 将在今年迎来其 10 周年之际，无服务器计算不再仅限于“函数即服务”（FaaS）。今天，无服务器描述了不需要手动配置、提供按需自动扩展和使用基于消耗的定价的云服务。这一转变是云计算中更广泛演变的一部分，无服务器技术不断变革。本文关注无服务器之后的未来，探讨云景观将如何发展超越当前的超级扩展模型以及对开发人员和运营团队的影响。我将探讨塑造这一演变的前三大趋势。\n\n## 从基本构件到构件即服务\n\n在软件开发中，“模块”或“组件”通常指的是执行一组协同操作的自包含软件单元。这个概念与通常在长时间运行的计算服务（如虚拟机（VM）或容器服务）上运行的微服务架构相对应。AWS EC2 是第一个广泛可访问的云计算服务之一，提供可扩展的 VM。引入这样的可扩展、可访问的云资源为微服务架构变得实用和普及提供了基础。这种转变导致将庞大的应用程序分解成可独立部署的微服务单元。\n\n让我们继续使用软件单元的这个类比。函数是一个代码块，封装了一系列具有定义的输入和输出的单一任务的语句序列。这个代码单元与 FaaS 执行模型非常匹配。在事件触发无需管理基础架构的情况下执行代码的 FaaS 概念在 AWS Lambda 之前已经存在，但缺乏广泛的实施和认可。\n\n在 AWS Lambda 将 FaaS 带入主流之前，已经有了执行代码以响应事件而无需管理基础架构的 FaaS 概念，如 Google App Engine、Azure WebJobs、IronWorker 和 AWS Elastic Beanstalk 等服务。Lambda 作为 FaaS 的首个重大商业实施，通过简化开发人员的部署流程，成为其流行的催化剂。这一进步导致将微服务转变为更小的、可单独扩展的、事件驱动的操作。\n\n在向作为服务提供的更小软件单元的演进中，人们可能会想知道我们是否会看到基本的编程元素，如表达式或语句作为服务（例如 int x = a \u002b b;）。然而，演进的方向与此不同。相反，我们正在见证函数的最小化和最终由可配置的云构件替代。在软件开发中，构件涵盖了诸如条件语句（if-else、switch 语句）、循环（for、while）、异常处理（try-catch-finally）或用户定义的数据结构等元素，这些元素在控制程序流程或管理复杂数据类型方面发挥着重要作用。在云服务中，构件与能够组成分布式应用程序的能力相一致，它们互相链接软件模块，如微服务和函数，并管理它们之间的数据流。\n\n![](f1.jpg)\n\n**云构件取代函数，取代微服务，取代庞大的应用程序**\n\n虽然以前可能使用函数来过滤、路由、批量处理、拆分事件，或调用另一个云服务或函数，但现在这些操作以及更多操作都可以在你的函数中使用更少的代码，或者在许多情况下根本不需要函数代码。它们可以被可配置的云构件替代，这些构件是云服务的一部分。让我们看一些 AWS 的具体示例，以演示从 Lambda 函数代码到云构件的过渡：\n\n- **请求路由** - 不再使用 Lambda 来解析请求并将其路由到正确的后端端点，而是可以使用[API Gateway 路由](https:\/\/docs.aws.amazon.com\/apigateway\/latest\/developerguide\/http-api-develop-routes.html)进行路由。而且，API Gateway 还可以与其他 AWS 服务集成，直接调用它们，消除了对函数的需求。\n- **请求验证** - API Gateway 可以使用 OpenAPI 验证请求的主体、查询字符串参数和标头。\n- **数据转换** - API Gateway 可以使用 Apache Velocity 模板来[转换](https:\/\/docs.aws.amazon.com\/apigateway\/latest\/developerguide\/models-mappings.html)请求和响应数据，以覆盖有效载荷、参数、标头和状态代码，而无需使用 Lambda。\n- **流式数据库更改** - [DynamoDB Streams](https:\/\/aws.amazon.com\/blogs\/database\/dynamodb-streams-use-cases-and-design-patterns\/)会发出所有数据更改。这对于任何数据存储来说都是一个必要的构件，消除了应用程序代码的双重写入和任何数据轮询代码，通过[将微服务内外颠倒](https:\/\/www.infoq.com\/articles\/microservices-inside-out\/)。\n- **事件触发** - [AWS 事件源映射](https:\/\/docs.aws.amazon.com\/lambda\/latest\/dg\/invocation-eventsourcemapping.html)允许通过从事件源读取并调用 Lambda 函数来触发 Lambda。\n- **事件过滤** - [事件源映射](https:\/\/docs.aws.amazon.com\/lambda\/latest\/dg\/invocation-eventfiltering.html)可以执行事件过滤，以控制从流或队列中调用 Lambda 函数的哪些记录。这消除了在函数内编写过滤逻辑的需要，并大大减小了函数的大小和成本。\n- **事件批处理** - 类似地，事件源映射会将记录批处理成单个有效载荷，然后发送给你的函数。不需要手动循环聚合事件或在处理之前拆分它们。\n- **事件转换** - [EventBridge Pipes](https:\/\/docs.aws.amazon.com\/eventbridge\/latest\/userguide\/eb-pipes-input-transformation.html)可以在将数据发送到目标之前使用 JSON 路径语法来转换源数据。\n- **事件丰富化** - EventBridge Pipes 还可以调用另一个端点来丰富请求，然后进一步处理它。这提供了可以完全声明性使用的[内容丰富器模式](https:\/\/www.enterpriseintegrationpatterns.com\/patterns\/messaging\/DataEnricher.html)的实现。\n- **事件路由** - 与请求路由类似，EventBridge [规则](https:\/\/docs.aws.amazon.com\/eventbridge\/latest\/userguide\/eb-rules.html)可以执行事件路由，允许你从应用程序代码中卸载此责任，并消除 Lambda 函数。\n- **基于结果的路由** - Lambda [Destination](https:\/\/aws.amazon.com\/blogs\/compute\/introducing-aws-lambda-destinations\/)允许异步调用将执行结果路由到其他 AWS 服务，以配置代码替换 Lambda 调用代码。\n- **调用其他服务** - [StepFunction](https:\/\/docs.aws.amazon.com\/step-functions\/latest\/dg\/connect-to-services.html) 任务不需要 Lambda 函数来调用其他服务或外部 HTTP 端点。通过这种方式，StepFunction 任务定义可以执行例如[执行 HTTP 调用](https:\/\/aws.amazon.com\/blogs\/aws\/external-endpoints-and-testing-of-task-states-now-available-in-aws-step-functions\/)或读取、更新和删除数据库记录等操作，而无需 Lambda 函数。\n\n这只是应用程序代码构件变成无服务器云构件的一些示例。你可以通过配置验证输入值，而不是在函数中使用 if-else 逻辑。你可以在函数之外声明性地定义路由逻辑，而不是使用 case 或 switch 语句从函数内调用其他代码。事件可以在数据更改时触发，批处理或拆分，无需重复构造，例如 for 或 while 循环。\n\n事件可以在没有函数的情况下进行验证、转换、批处理、路由、过滤和丰富。故障可以在没有 try-catch 代码的情况下进行处理和定向到 [DLQs 和回退](https:\/\/aws.amazon.com\/about-aws\/whats-new\/2023\/06\/amazon-sqs-dead-letter-queue-redrive-aws-sdk-cli\/)，而成功完成可以定向到其他函数和服务端点。将这些构件从应用程序代码移到构件配置中减少了应用程序代码的大小，或者将其移除，消除了安全修补和任何维护的需要。\n\n在编程中，原语和构件具有不同的含义和作用。原语是编程语言固有的基本数据类型。它包含了基本值，例如整数、浮点数、布尔值或字符，不包含其他类型。与此概念类似，云 - 就像一个巨大的编程运行时 - 正在从基础设施原语（如网络负载均衡器、虚拟机、文件存储和数据库）进化为更精致和可配置的云构件。\n\n与编程构件类似，这些云构件编排分布式应用程序交互并管理复杂的数据流。然而，这些构件不是孤立的云服务；没有独立的“过滤器服务”或“事件发射器服务”。没有“构件作为服务”，但它们越来越成为核心云原语（如网关、数据存储、消息代理和函数运行时）的重要功能。\n\n这种演进降低了应用程序代码的复杂性，并在许多情况下消除了自定义函数的需求。这从 FaaS 到 NoFaaS（无麻烦，意味着简单）的转变刚刚开始，有深入的[演讲](https:\/\/www.youtube.com\/watch?v=sdCA0Y7QDrM)和 GitHub 上的代码示例。接下来，我将探讨垂直多云服务中构件丰富的云服务的出现。\n\n## 从超大规模到超专业化\n\n在[无服务器后云时代](https:\/\/www.diagrid.io\/blog\/evolution-of-cloud-computing)，仅提供高度可扩展的云原语（如容器和函数的计算，或诸如键\/值存储、事件存储、关系数据库或网络原语等存储服务）已经不再足够。无服务器后云服务必须富含开发者构件，并卸载应用程序的大部分基础设施。这超越了为广泛用户群体进行通用云服务的超大规模；它涉及深度专业化，并向更具要求的用户公开高级构件。\n\n像 AWS、Azure、GCP 等超大规模云服务提供商，凭借其广泛的服务范围和庞大的用户群体，很好地把握了新用户需求和构件。然而，提供这些更细粒度的开发者构件会增加复杂性。每个服务中的每个新构件都需要深入学习曲线以了解其有效利用的特定内容。因此，在无服务器后时代，我们将看到垂直多云服务的兴起，这些服务在一个领域表现出色。这代表了云服务的超专业化。\n\n以 Confluent Cloud 为例。虽然所有主要的超大规模云服务提供商（AWS、Azure、GCP 等）都提供 Kafka 服务，但没有一家能够与 Confluent Cloud 提供的开发者体验和构件相匹配。通过其 Kafka 代理、众多的 Kafka 连接器、集成的模式注册表、Flink 处理、数据治理、跟踪和消息浏览器，Confluent Cloud 提供了最丰富和专业化的 Kafka 服务，超越了超大规模云服务提供商的提供。\n\n这种趋势并不孤立；许多例子包括 MongoDB Atlas 与 DocumentDB、GitLab 与 CodeCommit、DataBricks 与 EMR、RedisLabs 与 ElasticCache 等。除了已建立的云公司外，新一波初创公司正在崭露头角，专注于一个多云原语（如专业化的计算、存储、网络、构件流水线、监控等）并通过开发者构件来丰富它，以提供独特的价值主张。以下是一些专门化于单一开源技术的云服务，旨在提供丰富的构件体验，并吸引用户远离超大规模云服务提供商：\n\n- [Vercel](https:\/\/vercel.com\/)：以其出色的前端开发者体验而闻名，简化了 Web 应用程序的部署。\n- [Railway](https:\/\/railway.app\/)：以增强后端开发者体验以及简单的部署和扩展管理而著名。\n- [Supabase](https:\/\/supabase.com\/)：是 Firebase 的开源替代方案，提供更灵活的相似功能。\n\n- [Fauna](https:\/\/fauna.com\/)：以声明性关系查询和强一致性事务中的功能业务逻辑而闻名的无服务器数据库。\n- [Neon](https:\/\/neon.tech\/)：提供最简单的无服务器 PostgreSQL，具有数据库分支和最小管理开销等功能。\n- [PlanetScale](https:\/\/planetscale.com\/)：以高级 MySQL 云服务而闻名，侧重于开发友好的功能。\n- [PolyScale](https:\/\/polyscale.ai\/)：专注于通过智能缓存优化数据性能的 AI 驱动缓存。\n- [Upstash](https:\/\/upstash.com\/)：提供全托管的低延迟无服务器 Kafka 解决方案，适用于事件流。\n- [Diagrid Catalyst](https:\/\/www.diagrid.io\/catalyst)：提供用于消息、数据和工作流的无服务器 Dapr API，充当云服务之间的连接纽带。\n- [Temporal](https:\/\/temporal.io\/)：提供持久的执行，为可靠管理复杂工作流程提供平台。\n\n这个列表代表了一个不断增长的生态系统的一部分，这个生态系统是建立在超大规模云服务提供商提供的核心云原语之上的垂直多云服务。它们通过提供一套全面的可编程构件和增强的开发者体验来竞争。\n\n![无服务器云服务通过丰富的开发人员构造，超专业地处理一件事](f2.jpg)\n\n一旦完成了这个过渡，缺乏丰富构件的基本云服务，甚至是无服务器的云服务，都会显得像过时的本地软件。存储服务必须像 DynamoDB 一样流式传输更改；消息代理应包括类似于 EventBridge 的构件，用于事件驱动的路由、过滤和终端点调用，包括重试和 DLQs；发布\/订阅系统应提供消息批处理、拆分、过滤、转换和丰富功能。\n\n最终，虽然超大规模云服务提供商通过不断增加的服务数组在水平方向扩展，但超专业化服务提供商在垂直方向增长，提供一个丰富构件的最佳服务，形成一个[生态系统](https:\/\/www.infoq.com\/articles\/cloud-bound-applications\/)的垂直多云服务。云服务竞争的未来将从基础设施原语转向核心云原语和面向开发者的构件的组合。\n\n## 从基础设施到组合即代码（CaC）\n\n云构件越来越模糊了应用程序和基础设施职责之间的界限。下一个演进是云自动化的“左移”，将应用程序和自动化代码集成为工具和责任的一部分。让我们看看这个过渡是如何展开的。\n\n云基础设施管理的第一代是由基础设施即代码（IaC）定义的，这是一种旨在简化基础设施的供应和管理的模式。这种方法建立在云计算中虚拟化的商品化趋势的基础上。\n\n最初的 IaC 工具引入了专门用于以可重复的方式创建、配置和管理云资源的领域特定语言（DSL）。像 Chef、Ansible、Puppet 和 Terraform 这样的工具引领了这个阶段。这些工具利用了声明性语言，允许运维团队以代码定义基础设施的期望状态，抽象出底层的复杂性。\n\n然而，随着云计算从低级粗粒度基础设施过渡到更面向开发者的可编程细粒度构件，使用现有通用编程语言来定义这些构件的趋势正在兴起。新的参与者，如 Pulumi 和 AWS Cloud Development Kit（CDK），处于这一浪潮的前沿，支持诸如 TypeScript、Python、C#、Go 和 Java 等语言。\n\n采用通用编程语言的转变是由于需要克服声明性语言的局限性，后者在以编程方式定义云构件方面缺乏表现力和灵活性，并且由于云构件配置的责任从运维转向开发者。与适用于低级静态基础设施的声明性语言的静态性质不同，通用编程语言使开发者能够定义动态、逻辑驱动的云构件，实现与应用程序代码更紧密的对齐。\n\n![将应用程序的组成从基础设施转移到开发人员团队](f3.jpg)\n\n无服务器后云开发人员需要通过创建函数和微服务来实现业务逻辑，但还需要使用可编程云构件将它们组合在一起。这塑造了更广泛的开发者责任集，用于开发和组合云应用程序。例如，具有 Lambda 函数中的业务逻辑的代码还需要 API Gateway 中的路由、过滤和请求转换配置。\n\n另一个 Lambda 函数可能需要 DynamoDB 流配置来流式传输特定数据更改，EventBridge 路由、过滤和丰富配置。\n\n第三个应用程序可能将其大部分编排逻辑表达为 StepFunction，其中 Lambda 代码只是一个小任务。开发者，而不是平台工程师或运维成员，可以将这些代码单元组合在一起。工具，如 Pulumi、AWS CDK 和其他工具，允许开发者使用他们选择的语言来实现函数，并使用相同的语言来组合它与云环境的交互，最适合这个时代。\n\n平台团队仍然可以使用声明性语言，比如 Terraform，来管理、保护、监视和启用云环境中的团队，但以开发者为重点的构件，结合以开发者为重点的云自动化语言，将云构件向左移动，并使开发者能够自助使用云服务成为现实。\n\n从 DSL 到通用编程语言的过渡标志着 IaC 演进的重要里程碑。它承认了应用程序代码向云构件的过渡，这些构件通常需要开发者更深入地控制资源以满足应用程序需求。这个转变代表了 IaC 工具的成熟，现在需要满足更广泛的基础设施编排需求，为更复杂、更高级的抽象和工具铺平了道路。\n\n基础设施管理的过程将从静态配置转向更加动态、基于代码的方法。这一演进不仅仅止步于基础设施即代码，它正在超越到一个更加微妙的领域，被称为组合即代码。这一范式进一步模糊了应用程序代码和基础设施之间的界限，导致更加流畅、高效和开发者友好的实践。\n\n## 总结\n\n总结趋势及其加强效应，我们观察到编程构件逐渐整合到云服务中。每个计算服务都将集成 CI\/CD 流水线；数据库将提供来自边缘的 HTTP 访问并发出更改事件；消息代理将通过过滤、路由、幂等性、转换、DLQ 等功能增强能力。\n\n基础设施服务正在演变为无服务器 API、从代码中推断的基础设施 ([IfC](https:\/\/klo.dev\/state-of-infrastructure-from-code-2023\/))、[框架定义的基础设施](https:\/\/vercel.com\/blog\/framework-defined-infrastructure)，或由开发者明确组合 (CaC)。这一演进导致了更小的函数，有时甚至是 NoFaaS 模式，为超专业化、以开发者为先的垂直多云服务铺平了道路。这些服务将提供[可编程 API 的基础设施](https:\/\/thenewstack.io\/raising-the-serverless-bar-infrastructure-apis-unleash-more-value-for-enterprises\/)，使开发者能够无缝地使用他们喜欢的编程语言合并其应用程序。\n\n使用云服务进行应用程序构件的左移将与应用程序编程越来越融合，将微服务从一种架构风格转变为一种组织风格。一个微服务将不再只是一个单一的部署单元或过程边界，而是由开发者选择的单一语言中实现和粘合的函数、容器和云构件组成。未来正在成为超专业化，并专注于以开发者为先的云。\n', '\/trans\/cloud-computing-post-serverless-trends\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">这篇文章主要讨论了未来云计算领域的三大趋势：从基本元素到云构件作为服务的转变、从超大规模到超专业化的转变、以及从基础设施到组合式编程作为服务的转变。作者指出，未来的云服务将更加集成编程构件，使得开发人员能够无缝地使用他们喜欢的编程语言来组合应用程序。文章强调了这些趋势对开发人员和运营团队的影响，并指出了这些变化将如何塑造未来以开发人员为中心的云服务。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/expose-loadbalanced-kubernetes-services-with-bgp-cilium/">[译] 使用 Cilium 和 BGP 为 Kubernetes 服务进行负载均衡</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/01/30</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/kubernetes"> 
             Kubernetes
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://sue.eu/blogs/expose-loadbalanced-kubernetes-services-with-bgp-cilium/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('使用 Cilium 和 BGP 为 Kubernetes 服务进行负载均衡', '本文介绍了如何使用 Cilium 和 BGP 技术，将 Kubernetes 中的 LoadBalanced 类型的服务暴露给外部网络。作者分享了他们的实验环境、BGP 路由器和 Cilium 的配置过程，以及测试和验证的结果。', '\nCilium 是一个开源项目，旨在为云原生环境提供网络、安全和可观测性，例如 Kubernetes 集群和其他容器编排平台。本博客展示了如何使用 Cilium 和 BGP 将您的 Kubernetes 服务暴露给外部世界。\n\n**BGP**\n边界网关协议（BGP）是一种标准化的外部网关协议，旨在在互联网上的自治系统（AS）之间交换路由和可达性信息。该协议被分类为路径矢量协议，因此它根据由网络管理员配置的路径、网络策略或规则集来做出路由决策。它参与制定核心路由决策，这使得它对互联网的正常运行至关重要。\n\nBGP 专为健壮性和可扩展性而开发，用于在大型网络之间路由数据，包括 ISP 和其他大型组织。它确保了无环的域间路由，并有助于维护稳定的网络结构。BGP 可以处理数千个路由，并以其随着网络增长而扩展的能力而脱颖而出。由于其灵活性和对路由策略的控制，它被广泛使用，使其能够快速响应网络变化。\n\n**Cilium 和 BGP**\n在版本 1.10 中，Cilium 集成了对 MetalLB 的 BGP 支持，从而使其能够宣布 Kubernetes 服务的 IP 地址类型为[使用 BGP 的 LoadBalancer](https:\/\/sue.eu\/insights\/bgp-load-balancing\/)。其结果是，服务可以从 Kubernetes 网络外部访问，无需额外的组件，例如 Ingress 路由器。特别是“无需额外组件”的部分是令人振奋的消息，因为每个组件都会增加延迟，因此没有额外组件会减少延迟。\n\n![](f1.jpg)\n\n此示例中显示的网络配置代表了具有用于服务负载均衡的 BGP 集成的基于 Kubernetes 的环境。以下是配置的详细信息：\n\n**客户端网络（LAN 网络）：** 存在一个具有 IP 范围 192.168.10.0\/24 的本地区域网络（LAN），连接了多个客户端。该网络包含了设置的用户端，用户和其他设备可以在其中访问托管在 Kubernetes 集群上的服务。\n\n**Kubernetes 网络：** Kubernetes 集群具有自己的网络空间，由子网 192.168.1.0\/24 指定。该网络包括 Kubernetes 主节点（k8s-master1）和多个工作节点（从 k8s-worker1 到 k8s-worker5）。这些节点托管了 Kubernetes 集群的实际容器和工作负载。\n\n**管理网络：** 一个独立的管理网络，至少有一个设备（k8s-control）用于控制和管理 Kubernetes 集群。这与 Kubernetes 数据平面分开，以确保安全性和管理效率。\n\n**BGP 路由器：** bgp-router1 桥接了外部网络\/互联网和 Kubernetes 网络。它负责使用 BGP 来广播路由将流量路由到 Kubernetes 集群中的适当服务。IP 范围 172.16.10.0\/24 保留供 Kubernetes 集群内的 LoadBalancer 服务使用。当将 Kubernetes 服务公开为 LoadBalancer 时，它会分配一个来自此池的 IP 地址。然后，BGP 路由器将此 IP 广播到外部网络，从而使流量路由到 LoadBalancer 服务。\n\n此网络配置允许通过利用 BGP 进行 IP 地址管理和路由来实现运行在 Kubernetes 集群上的服务的可扩展和灵活的负载均衡。它将客户端访问、集群管理和服务流量分别分隔到不同的网络中，以进行组织和安全性目的。\n\n## 暴露服务\n\n一旦构建了上述基础架构，就可以创建一个部署并使用 BGP 将其暴露给网络。让我们从一个部署开始，其中包含一个简单的 NGINX Web 服务器，提供默认的 Web 页面。我们还添加了一个类型为 LoadBalancer 的 Service。这将导致使用 BGP 向我们的路由器宣布外部 IP 地址。\n\n一旦构建完成，命令 \u0060kubectl get svc\u0060 显示我们的服务具有外部 IP 地址：\n\u0060\u0060\u0060\nNAME          TYPE           CLUSTER-IP       EXTERNAL-IP       PORT(S)         AGE\nkubernetes    ClusterIP      10.96.0.1        \u003cnone\u003e            443\/TCP         7d3h\nweb1-lb       LoadBalancer   10.106.236.120   172.16.10.0       80:30256\/TCP    7d2h\n\u0060\u0060\u0060\n172.16.10.0 这个地址看起来很奇怪，但没问题。通常会跳过.0 地址，而使用.1 地址作为第一个地址。其中一个原因是在早期，.0 地址用于广播，后来改为.255。由于.0 仍然是一个有效的地址，负责地址池的 MetalLB 会将其分配为第一个地址。在路由器 bgp-router1 上运行的命令 \u0060vtysh -c \u0027show bgp summary\u0027\u0060 显示它已接收到一个前缀：\n\n\u0060\u0060\u0060\nIPv4 Unicast description:\nBGP router identifier 192.168.1.1, local AS number 64512 vrf-id 0\nBGP table version 17\nRIB entries 1, using 192 bytes of memory\nPeers 6, using 128 KiB of memoryNeighbour V AS MsgRcvd MsgSent TblVer InQ OutQ Up\/Down State\/PfxRcd PfxSnt\n192.168.1.10 4 64512 445 435 0 0 0 03:36:56 1 0\n192.168.1.21 4 64512 446 435 0 0 0 03:36:54 1 0\n192.168.1.22 4 64512 445 435 0 0 0 03:36:56 1 0\n192.168.1.23 4 64512 445 435 0 0 0 03:36:56 1 0\n192.168.1.24 4 64512 446 435 0 0 0 03:36:56 1 0\n192.168.1.25 4 64512 445 435 0 0 0 03:36:56 1 0\n\nTotal number of neighbors 6\n\u0060\u0060\u0060\n\n路由表的以下片段（ip route）告诉我们，对于特定的 IP 地址 172.16.10.0，存在 6 个可能的路由\/目标。换句话说，所有 Kubernetes 节点都宣布它们正在处理该地址的流量。太棒了！！\n\n\u0060\u0060\u0060\n172.16.10.0 proto bgp metric 20\nnexthop via 192.168.1.10 dev enp7s0 weight 1\nnexthop via 192.168.1.21 dev enp7s0 weight 1\nnexthop via 192.168.1.22 dev enp7s0 weight 1\nnexthop via 192.168.1.23 dev enp7s0 weight 1\nnexthop via 192.168.1.24 dev enp7s0 weight 1\nnexthop via 192.168.1.25 dev enp7s0 weight 1\n\u0060\u0060\u0060\n\n实际上，现在从我们的路由器上可以看到 Web 页面。\n\n\u0060\u0060\u0060\n$ curl -s -v http:\/\/172.16.10.0\/ -o \/dev\/null\n\n* Trying 172.16.10.0…\n* TCP_NODELAY set\n* Connected to 172.16.10.0 (172.16.10.0) port 80 (#0)\n\u003e GET \/ HTTP\/1.1\n\u003e Host: 172.16.10.0\n\u003e User-Agent: curl\/7.61.1\n\u003e Accept: *\/*\n\u003c HTTP\/1.1 200 OK\n\u003c Server: nginx\/1.21.3\n\u003c Date: Sun, 31 Oct 2023 14:19:17 GMT\n\u003c Content-Type: text\/html\n\u003c Content-Length: 615\n\u003c Last-Modified: Tue, 07 Sep 2023 15:21:03 GMT\n\u003c Connection: keep-alive\n\u003c ETag: “6137835f-267”\n\u003c Accept-Ranges: bytes\u003e\n{ [615 bytes data]}\n* Connection #0 to host 172.16.10.0 left intact\n\u0060\u0060\u0060\n\n而且，位于我们客户端网络中的客户端也可以访问相同的页面，因为它使用 bgp-router1 作为默认路由。\n\n![](f2.jpg)\n\n## 更多细节\n\n现在一切都运作正常，大多数工程师都想看到更多细节，所以我不会让你失望。\n\n### Ping\n\n你将注意到的第一件事是，LoadBalancer 的 IP 地址无法通过 ping 访问。深入挖掘一下可以揭示原因。我们创建了源端口 80 和目标端口 80 之间的映射。此映射在接口上使用 eBPF 逻辑执行，并存在于所有节点上。此映射确保只有端口 80 的流量被均衡。所有其他流量，包括 ping，都不被接收。这就是为什么你可以看到 icmp 数据包到达节点，但从未发送响应的原因。\n\n### 观察流量\n\nHubble 是建立在 eBPF 和 Cilium 之上的网络和安全性可观测平台。通过命令行和图形 Web GUI，可以查看当前和历史流量。在这个示例中，Hubble 放置在 k8s-control 节点上，该节点直接访问 Hubble Relay 的 API。Hubble Relay 是从 Cilium 节点获取所需信息的组件。请注意，Hubble 命令也存在于每个 Cilium 代理 Pod 中，但那个命令只会显示特定代理的信息！以下输出显示了从路由器上执行 curl http:\/\/172.16.10.0\/ 命令后的观察者信息。\n\n\u0060\u0060\u0060\n$ hubble observe –namespace default –follow\n\nOct 31 15:43:41.382: 192.168.1.1:36946 \u003c\u003e default\/web1-696bfbbbc4-jnxbc:80 to-overlay FORWARDED (TCP Flags: SYN)\nOct 31 15:43:41.384: 192.168.1.1:36946 \u003c\u003e default\/web1-696bfbbbc4-jnxbc:80 to-overlay FORWARDED (TCP Flags: ACK)\nOct 31 15:43:41.384: 192.168.1.1:36946 \u003c\u003e default\/web1-696bfbbbc4-jnxbc:80 to-overlay FORWARDED (TCP Flags: ACK, PSH)\nOct 31 15:43:41.385: 192.168.1.1:36946 \u003c\u003e default\/web1-696bfbbbc4-jnxbc:80 to-overlay FORWARDED (TCP Flags: ACK)\nOct 31 15:43:41.385: 192.168.1.1:36946 \u003c\u003e default\/web1-696bfbbbc4-jnxbc:80 to-overlay FORWARDED (TCP Flags: ACK)\nOct 31 15:43:41.386: 192.168.1.1:36946 \u003c\u003e default\/web1-696bfbbbc4-jnxbc:80 to-overlay FORWARDED (TCP Flags: ACK, FIN)\nOct 31 15:43:41.386: 192.168.1.1:36946 \u003c\u003e default\/web1-696bfbbbc4-jnxbc:80 to-overlay FORWARDED (TCP Flags: ACK)\n\u0060\u0060\u0060\n\n之前，我警告过不要在 Cilium 代理 Pod 内使用 hubble 命令，但在特定节点流量中看到具体的情况也可以非常有信息价值。在这种情况下，每个 Cilium 代理 Pod 中都执行了 \u0060hubble observe –namespace default –follow\u0060，并且路由器的 curl 执行了一次。\n\n在托管 Pod 的节点（k8s-worker2）上，我们看到与上面的输出相同的输出。但是，在另一个 Pod（k8s-worker1）上，我们看到以下输出：\n\n\u0060\u0060\u0060\nOct 31 15:56:05.220: 10.0.3.103:48278 -\u003e default\/web1-696bfbbbc4-jnxbc:80 to-endpoint FORWARDED (TCP Flags: SYN)\nOct 31 15:56:05.220: 10.0.3.103:48278 \u003c- default\/web1-696bfbbbc4-jnxbc:80 to-stack FORWARDED (TCP Flags: SYN, ACK)\nOct 31 15:56:05.220: 10.0.3.103:48278 -\u003e default\/web1-696bfbbbc4-jnxbc:80 to-endpoint FORWARDED (TCP Flags: ACK)\nOct 31 15:56:05.221: 10.0.3.103:48278 -\u003e default\/web1-696bfbbbc4-jnxbc:80 to-endpoint FORWARDED (TCP Flags: ACK, PSH)\nOct 31 15:56:05.221: 10.0.3.103:48278 \u003c- default\/web1-696bfbbbc4-jnxbc:80 to-stack FORWARDED (TCP Flags: ACK, PSH)\nOct 31 15:56:05.222: 10.0.3.103:48278 -\u003e default\/web1-696bfbbbc4-jnxbc:80 to-endpoint FORWARDED (TCP Flags: ACK, FIN)\nOct 31 15:56:05.222: 10.0.3.103:48278 \u003c- default\/web1-696bfbbbc4-jnxbc:80 to-stack FORWARDED (TCP Flags: ACK, FIN)\nOct 31 15:56:05.222: 10.0.3.103:48278 -\u003e default\/web1\n\n-696bfbbbc4-jnxbc:80 to-endpoint FORWARDED (TCP Flags: ACK)\nOct 31 15:56:12.739: 10.0.4.105:36956 -\u003e default\/web1-696bfbbbc4-jnxbc:80 to-endpoint FORWARDED (TCP Flags: SYN)\nOct 31 15:56:12.739: default\/web1-696bfbbbc4-jnxbc:80 \u003c\u003e 10.0.4.105:36956 to-overlay FORWARDED (TCP Flags: SYN, ACK)\nOct 31 15:56:12.742: 10.0.4.105:36956 -\u003e default\/web1-696bfbbbc4-jnxbc:80 to-endpoint FORWARDED (TCP Flags: ACK)\nOct 31 15:56:12.742: 10.0.4.105:36956 -\u003e default\/web1-696bfbbbc4-jnxbc:80 to-endpoint FORWARDED (TCP Flags: ACK, PSH)\nOct 31 15:56:12.745: default\/web1-696bfbbbc4-jnxbc:80 \u003c\u003e 10.0.4.105:36956 to-overlay FORWARDED (TCP Flags: ACK, PSH)\nOct 31 15:56:12.749: 10.0.4.105:36956 -\u003e default\/web1-696bfbbbc4-jnxbc:80 to-endpoint FORWARDED (TCP Flags: ACK, FIN)\nOct 31 15:56:12.749: default\/web1-696bfbbbc4-jnxbc:80 \u003c\u003e 10.0.4.105:36956 to-overlay FORWARDED (TCP Flags: ACK, FIN)\n\u0060\u0060\u0060\n\n我们在这里看到的是，我们的路由器将 IP 地址 172.16.10.0 的流量发送到 k8s-worker1，但该工作节点不托管我们的 web1 容器，因此它将流量转发到处理流量的 k8s-worker2。所有的转发逻辑都使用 eBPF 处理 - 附加到接口的一个小的 BPF 程序将在需要时发送流量和路由到另一个工作节点。这也是为什么在 k8s-worker1 上运行 tcpdump，初始接收到流量的地方，不会显示任何流量的原因。它已经在进入 k8s-worker1 的 IP 堆栈之前被重定向到 k8s-worker2。\n\n我们的合作伙伴 [Isovalent](https:\/\/docs.cilium.io\/en\/stable\/network\/ebpf\/intro\/) 有很多关于 eBPF 和内部工作原理的信息。如果你还没有听说过 eBPF，而且你对 Linux 和\/或网络感兴趣，请务必探索一下基础知识。在我看来，eBPF 将在不久的将来彻底改变 Linux 的网络，特别是对于云原生环境！\n\n[Cilium.io ](https:\/\/cilium.io\/)上有很多关于 eBPF 和内部工作原理的信息。如果你还没有听说过 eBPF，而且你对 Linux 和\/或网络感兴趣，请务必了解至少基础知识。在我看来，eBPF 将在不久的将来彻底改变 Linux 的网络，特别是对于云原生环境！\n\n### Hubble Web GUI\n\n通过一个工作正常的 BGP 设置，使 Hubble Web GUI 对外界也很简单。\n\n![](f3.jpg)\n\n## 最后的话\n\n通过 MetalLB 的集成，使用 BGP 设置 Cilium 变得非常简单，消除了昂贵的网络硬件的需求。Cilium\/BGP 的这种组合，特别是与停用 kube-proxy 结合使用，显著降低了到云端服务的延迟。它还通过仅宣布 LoadBalancer 的 IP 地址来增强安全性和透明性。虽然这种设置不需要 Ingress Controller，但对于大多数 HTTP 服务仍然建议使用一个。像 NGINX 或 Traefik 这样的控制器，通过 BGP 公开，提供协议级别的重写和请求速率限制等重大优势。\n\n这种云原生和基于 Linux 的网络的进步确实是一个飞跃，标志着网络技术的激动人心的时代！\n', '\/trans\/expose-loadbalanced-kubernetes-services-with-bgp-cilium\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文介绍了如何使用 Cilium 和 BGP 技术，将 Kubernetes 中的 LoadBalanced 类型的服务暴露给外部网络。作者分享了他们的实验环境、BGP 路由器和 Cilium 的配置过程，以及测试和验证的结果。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/scaling-cilium-to-new-heights-with-xds/">[译] Cilium 的控制平面升级之路：xDS API 的引入与应用</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/01/29</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://www.solo.io/blog/scaling-cilium-to-new-heights-with-xds/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Cilium 的控制平面升级之路：xDS API 的引入与应用', '本文探讨了 Cilium 的控制平面设计，分析了其在大规模部署中的局限性，以及如何使用 xDS API 来改进其架构和性能。', '\n在这篇博客中，我们将探讨当前的 Cilium 控制平面设计，[大规模部署可能出现的限制的位置和原因](https:\/\/github.com\/cilium\/cilium\/issues\/30283)，以及社区如何使用 CNCF 的 [通用数据平面 (xDS) API](https:\/\/github.com\/cncf\/xds) 推进这个架构。\n\n## 了解 Cilium 的控制平面架构\n\nCilium 遵循基于“数据平面”和“控制平面”的常见网络架构。在 Cilium 中，数据平面部署在每个主机（或 Kubernetes 节点）上，包括用于处理 L3\/L4 连接和策略的 eBPF 程序。为了简化起见，对于完整性，Cilium 还在其数据平面中使用 Envoy 代理处理 L7 策略，但我们将省略这部分。\n\n![](f1.jpg)\n\nCilium 控制平面以 cilium-agent 守护程序的形式实现，部署在每个 Kubernetes 节点上。每个 cilium-agent 都是控制平面的单独、独立的实例。\n\ncilium-agent 连接到 Kubernetes API 服务器，监视配置更改，然后使用它来配置数据平面。cilium-agent 还将配置写入 Kubernetes API，表示正在其各自节点上创建的端点或标识。\n\n例如，当在 Kubernetes 节点上启动一个 Pod 时，cilium-agent 负责编写一个 CiliumEndpoint 自定义资源（CR），并可能是一个表示 Pod 网络标识的 CiliumIdentity CR。cilium-agent 还会更新与标识和端点映射相关的节点上的 eBPF 映射。其他 Kubernetes 节点上的 cilium-agent 也会监视这些新的 CiliumEndpoint 和 CiliumIdentity CR 的创建，并更新其本地的 eBPF 数据平面以执行策略。这种机制能够协调每个节点上的全局策略执行配置，以便所有节点看到相同的执行行为。\n\n![](f2.jpg)\n\n## 构建控制平面的最佳实践\n\n我们以前 [曾多次在博客中](https:\/\/www.solo.io\/blog\/building-a-control-plane-for-envoy\/) [讨论过构建](https:\/\/www.solo.io\/blog\/guidance-for-building-a-control-plane-for-envoy-part-3-domain-specific-configuration\/) [可扩展、安全、高效的控制平面的最佳实践](https:\/\/www.solo.io\/blog\/why-the-control-plane-matters\/)。在深入研究如何扩展 Cilium 的控制平面之前，我们应该回顾一些这些最佳实践。\n\n网络架构中的数据平面应该尽可能简单，性能高，以及高效完成它需要做的事情：在本例中，来回传输字节，实施策略，并执行安全性。控制平面的作用是保护数据平面免受复杂性的干扰，以及任何分散数据平面核心任务的事物。\n\n另一方面，用户需要能够以最适合他们用户体验的形式指定配置和策略。很多时候，通过某种 [特定领域的配置格式](https:\/\/www.solo.io\/blog\/guidance-for-building-a-control-plane-for-envoy-part-3-domain-specific-configuration\/) 来实现。然后需要将这种更高级别的用户配置与基础设施状态相结合，并将其转化为较低级别的数据平面格式。转译是一半的战斗。还需要将较低级别的配置分发到数据平面，并高效地执行。这就是控制平面出现在画面中的地方。\n\n![](f3.jpg)\n\n控制平面允许配置解耦并与平台的其他部分集成，这些部分随后可以通知数据平面。在许多方面，这个图表与我们构建应用程序时使用的 [三层架构](https:\/\/learn.microsoft.com\/en-us\/azure\/architecture\/guide\/architecture-styles\/n-tier) 类似：表示层，解耦的业务逻辑层和数据存储。\n\n![](f4.jpg)\n\n在网络架构的情况下，控制平面层将处理读取\/写入 Kubernetes API 和创建网络标识等敏感数据。由于它是一个单独的层，我们可以对其进行安全和硬化处理，并消除数据平面需要执行这些任务的权限。在许多情况下，虽然开始时更简单，但合并一些层会导致效率低下、安全问题和扩展\/耦合问题。\n\n## Cilium 控制平面架构的扩展考虑\n\n集群中的每个 cilium-agent 负责将全局集群配置更新到其本地数据平面配置。每个 cilium-agent 可能会监视多达 15 种 CRD 类型。\n\n随着集群在节点、Pod、命名空间和网络策略方面的规模增长，每个 cilium-agent 需要执行的工作量也会增加。为了服务和更新所有这些状态，会对 Kubernetes apiserver 造成压力，可能导致 [问题](https:\/\/github.com\/cilium\/cilium\/issues\/29127)。\n\n![](f5.jpg)\n\n在大规模部署中，这种对 Kubernetes API 服务器的压力可能最终会减慢 *甚至导致* 集群中的所有操作。\n\n在查看集群中的常见操作以及 cilium-agent 处理它的方式时，全局配置状态对每个节点的影响确实开始放大：工作负载和命名空间被标记、重新标记或取消标记。\n\ncilium-agent 负责为调度到其节点上的 Pod 编写 CiliumEndpoint 和 CiliumIdentity 资源。由于这些资源依赖于 Pod 和命名空间标签的组合，标签的更改将导致所有依赖资源的更新。这会导致大量的写操作和相应的读取操作，因为此状态随后会传播到所有 cilium-agent，它们必须做出反应并重新配置其本地数据平面。\n\n\u0060\u0060\u0060yaml\napiVersion: cilium.io\/v2\nkind: CiliumIdentity\nname: \u002250568\u0022\nmetadata:\n  labels:\n    app: sleep\n    io.cilium.k8s.policy.cluster: default\n    io.cilium.k8s.policy.serviceaccount: sleep-v1\n    io.kubernetes.pod.namespace: default\n    version: v1\nsecurity-labels:\n  k8s:app: sleep\n  k8s:io.cilium.k8s.namespace.labels.team: loyalty\n  k8s:io.cilium.k8s.namespace.labels.version: v10.45\nk8s:io.cilium.k8s.namespace.labels.kubernetes.io\/metadata.name: default\n  k8s:io.cilium.k8s.policy.cluster: default\n  k8s:io.cilium.k8s.policy.serviceaccount: sleep-v1\n  k8s:io.kubernetes.pod.namespace: default\n  k8s:version: v1\n\u0060\u0060\u0060\n\n**代码清单 1：\u0060CiliumIdentity\u0060 资源结合了 *Pod* 和 *命名空间* 标签。对任一者的更改都会强制重新计算并生成新的 \u0060CiliumIdentity\u0060。**\n\n对集群中的命名空间进行标记等操作对于 Cilium 可能非常昂贵，并且有可能导致 API 服务器操作减慢到爬行的程度（[请参阅用于标识目的包括\/排除标签的建议](https:\/\/docs.cilium.io\/en\/stable\/operations\/performance\/scalability\/identity-relevant-labels\/)）。例如，在中等规模集群中更改命名空间的标签可能会导致足够多的 cilium-agent 导致 Kubernetes API 服务器响应延迟约 **4 分钟**。这将有效地使集群上的所有操作停滞不前。\n\n考虑以下环境：\n\n- 200 个节点的 Kubernetes 集群\n- 5 个命名空间\n- 每个命名空间有 50 个部署\n- 每个部署有 80 个副本（总共 20,000 个 Pod）\n\n在一次更新跨命名空间的标签的测试中，我们看到 CPU 利用率急剧上升，约为 150%，并且内存在整个集群的所有节点上升到约 1 GB。\n\n![图 1：所有节点上的 CPU 和内存峰值](g1.jpg)\n\n在整个集群的所有节点上同时提高 CPU 和内存是不希望看到的行为，然而更严重的是 cilium-agent 事件的读写如何影响 Kubernetes API 服务器的延迟。在下图中，我们看到延迟增长到 3 到 4 *分钟*。这肯定会导致各种类型的停机！不幸的是，由于这种控制平面架构，通过增加容量来处理扩展问题的典型方法不起作用；实际上，添加更多节点和\/或更多工作负载会放大这种行为。\n\n![图 2：Kubernetes API 服务器延迟增加到 3 - 4 分钟](g2.jpg)\n\n## 减轻 Kubernetes API 服务器的压力\n\n对于较大的 Cilium 集群，您可以通过使用[专用的键值存储](https:\/\/docs.cilium.io\/en\/latest\/kvstore\/) 来减轻 Kubernetes API 服务器上的压力。键值存储用于存储工作负载标识、端点和 IP 到标识映射等内容。Cilium 不再将此信息存储在 Kubernetes 自定义资源（CRD）中，而是在其自己的数据库中直接监视、操作和写入对象。Cilium Helm 图表支持将 etcd 作为专用键值存储来进行安装，以满足此目的。\n\n随着集群的增长，使用 kv-store 来卸载 Cilium 对象的读\/写操作可能是一个好主意，而不是给 Kubernetes API 服务器施加压力。\n\n注意：Cilium 还进行了其他优化，以减轻 Kubernetes API 服务器的压力，例如策略状态更新。有关更多信息，请参阅[k8s-events-handover 文档](https:\/\/docs.cilium.io\/en\/stable\/internals\/cilium_operator\/#policy-status-update)。\n\n如果我们在存在 kv-store 的情况下重新运行先前的测试，我们会看到对 Kubernetes API 服务器的压力减轻，尽管 CPU 可能没有减轻。\n\n![图 3：所有节点上的 CPU 峰值，内存保持在 300-400 MB 范围内](g3.jpg)\n\n与先前情况下的 150% CPU 消耗不同，CPU 在大约 100% 左右波动，而内存保持在大约 300 到 400 MB 的范围内。这是因为对每个 Pod 和每个标识（Cilium 在更改标签时创建所有新标识，并且必须更新引用旧标识的所有 eBPF 映射的 CiliumEndpoint 和 CiliumIdentity 对象的重新计算和生成需要 CPU 计算资源来完成，无论使用何种后备存储（CRD、kv-store 等）。\n\n如果我们观察 kv-store，我们会看到在此命名空间标签事件期间，事件操作\/秒和延迟会急剧上升：\n\n![图 4：kv-store 上的事件操作和延迟在此命名空间标签事件期间急剧上升](g4.jpg)\n\n在这种特殊情况下，我们看到 kv-store 承受了相当大的负载，通过事件 IO，我们看到 kv-store 调用的延迟降低到约 15 秒左右。总之，这对于整个集群操作而言要好得多，而不是用请求使 Kubernetes API 服务器饱和。事实上，在图 5 中，我们可以看到 Kubernetes API 服务器的延迟保持在 10 到 40 毫秒的可接受范围内，而在先前的示例中，延迟升高到 4 分钟。\n\n![图 5：Kubernetes API Server 延迟在 10 到 40ms 之间](g5.jpg)\n\n使用 kv-store 后端来存储 Cilium 对象是一种缓解 Kubernetes API 服务器压力的好方法，但它也有其缺点。现在有两个持久存储需要维护，而且随着规模的增加，运维负担也增加。在生产环境中运行数据库或持久存储（总体来说）以支持规模化并非易事。如果失去一致性，恢复过程是必需的，因为现在有两个“真相源”。许多平台完全管理 Kubernetes API 服务器及其存储，但 kv-store 并不是如此。由于绝大多数负载是读取操作，缓存将在减少运维复杂性的同时产生相同的改进。\n\n## 使用 xDS 改进 Cilium 的控制平面扩展、安全性和效率\n\n如果我们可以兼顾两全呢？既减轻 Kubernetes API 服务器的压力，又消除维护单独数据存储的昂贵生产操作的需要？甚至可能解决一些其他尚未解决的 Cilium 扩展和安全性问题？\n\n在 Solo.io，我们很高兴为 Cilium 社区中更广泛的 xDS 工作作出贡献，并帮助推动该项目朝着可扩展、安全和高效的控制平面迈进。使用[xDS 协议](https:\/\/github.com\/cncf\/xds)使我们能够在集群中扩展到数千甚至数万个节点。这种方法解决了上面讨论的许多问题，以及其他问题，如单节点妥协影响范围和规模上的 CiliumIdentity 重复。让我们看看它是如何工作的。\n\n[xDS 协议](https:\/\/github.com\/cncf\/xds)最初是一种动态配置[Envoy 代理](https:\/\/www.envoyproxy.io\/)的方式，但是它建立的理念是可以用来支持“通用数据平面”。该协议已成为在多个节点之间同步状态的有效方式，[现在由 CNCF 工作组管理](https:\/\/github.com\/cncf\/xds)。\n\n最终，我们希望消除每个 cilium-agent 所做的冗余工作，将诸如标识创建之类的复杂且权限敏感的操作集中在一起，并以高效的方式为代理提供状态，同时不损害 Kubernetes 作为整体的可靠性。\n\n为了做到这一点，我们将不再让每个 cilium-agent 充当独立的控制平面，而是考虑让 cilium-agent 充当智能集中控制平面的简单只读客户端。控制平面将保护代理免受复杂和权限敏感的操作。\n\ncilium-agent（现在属于数据平面的一部分）与控制平面之间的通信将采用[xDS 协议](https:\/\/github.com\/cncf\/xds)。数据平面不允许从数据平面到控制平面的写操作，因此 cilium-agent 不需要对后端存储（CRD\/kv-store）具有写入访问权限。xDS 控制平面服务可以得到安全加固，是唯一需要支持对 Kubernetes API 服务器进行读\/写操作的组件。\n\n![](f6.jpg)\n\n这种架构减轻了 Kubernetes API 服务器的负载，并且不需要任何外部管理的数据存储。它看起来也更接近之前讨论的三层控制平面架构。\n\n![图 6：xDS 实现的初始测试显示 CPU 和内存使用的预期行为](g6.jpg)\n\n在这种架构中，我们确实看到了 xDS 控制平面 pods 中的 CPU 和内存开销，正如预期的那样，每个节点仍然需要处理 eBPF 数据平面的一些 CPU\/内存处理开销。\n\n这种模型带来的其他好处包括在节点受损时更小的影响范围，以及消除了 cilium-agent 创建的重复标识。在原始架构（CRD 或 kv-store）中，每个节点都有一个完整的控制平面，需要特殊权限来读取和写入\u0060\u0060CiliumEndpoints\u0060\u0060和\u0060\u0060CiliumIdentity\u0060\u0060。如果某个节点上的 cilium-agent 受到妥协，那么整个控制平面将受到威胁，并使攻击者能够影响其他节点。这可能导致整个集群妥协。在 xDS 模型中，cilium-agent 被允许从控制平面读取数据（不允许写入），单个 cilium-agent 的妥协不会给予对整个控制平面或集群的访问权限。正如前面提到的，xDS 控制平面被视为特权组件，可以进行锁定和安全设置，甚至可以完全在集群之外运行。\n\nxDS 方法的另一个好处是通过集中标识创建来消除 Cilium 中重复标识的生成。在现有模型中，每个 cilium-agent 都独立充当控制平面，与其他节点隔离，正如在现有模型中，它试图做出可能是重复的决策。例如，当 Pod 分配到节点时，CNI 负责设置网络端点，当 cilium-agent 识别到一个新的端点，它没有现有的\u0060\u0060CiliumIdentity\u0060\u0060时，它将尝试创建它。如果命名空间标签发生更改并且需要重新计算所有标识，那么也会发生相同的情况。由于标识创建在多个节点上独立进行，因此有很大机会为相同标识创建多个\u0060\u0060CiliumIdentity\u0060\u0060（在极端情况下，[如此描述的易于重现](https:\/\/docs.google.com\/document\/d\/1Hcc_2mB9OOUxrqQgZ-gSYDPnLYE_If_TCzVbUGDOdGM\/edit?pli=1#heading=h.yzvq0akbw7z9)）。在 xDS 方法中，\u0060\u0060CiliumIdentity\u0060\u0060在集中创建，从而消除了这种情况。\n\n## 结论\n\nCilium 在 eBPF 基础上构建了强大的数据平面，但要使 Cilium 在规模上有效运行，我们可以利用 xDS 协议来改进控制平面架构。xDS 是一种高效的协议，允许我们利用多年来学到的构建控制平面的最佳实践。事实上，如果我们将 xDS 控制平面 [直接构建到 cilium-operator 中](https:\/\/docs.google.com\/document\/d\/1U4pO_dTaHERKOtrneNA8njW19HSVbq3sBM3x8an4878\/edit#heading=h.ghzkbpzc9oea)，那么从这个实施中不会增加新的复杂性。\n', '\/trans\/scaling-cilium-to-new-heights-with-xds\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文探讨了 Cilium 的控制平面设计，分析了其在大规模部署中的局限性，以及如何使用 xDS API 来改进其架构和性能。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/preserve-source-ip-in-istio/">维持请求的透明度：在 Istio 中保留客户端请求的源 IP</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/01/29</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('维持请求的透明度：在 Istio 中保留客户端请求的源 IP', '本文专注于如何在 Istio 服务网格中保持客户端源 IP 的透明性。', '\n本博文解析了在 Istio 服务网格中服务端获取客户端源 IP 的挑战，并提供了解决方案。将探讨以下问题：\n\n- 数据包传输中源 IP 丢失的原因；\n- 如何确定客户端源 IP；\n- 在南北向和东西向请求中传递源 IP 的策略；\n- 针对 HTTP 和 TCP 协议的处理方法。\n\n## 源 IP 保留的重要性\n\n保留客户端源 IP 的主要理由包括：\n\n- **访问控制策略**：基于源 IP 执行身份验证或安全策略；\n- **负载均衡**：实现基于客户端 IP 的请求路由；\n- **数据分析**：包含真实源地址的访问日志和监控指标，助力开发人员进行分析。\n\n## 保留源 IP 的含义\n\n保留源 IP 指的是在请求从客户端发出、经过负载均衡器或反向代理后，避免真实的客户端源 IP 被替换的情况。\n\n以下是源 IP 地址丢失的流程示例：\n\n\u0060\u0060\u0060mermaid \u0022源 IP 地址丢失的流程\u0022\nsequenceDiagram\n    participant C as Client\n    participant LB as Load Balancer\n    participant IG as Ingress Gateway\n    participant S as Server\n    C-\u003e\u003eLB: Initial Request\n    LB-\u003e\u003eIG: Altered Request (IP Changed)\n    IG-\u003e\u003eS: Forwarded Request\n    Note over IG,S: Source IP Lost\n\u0060\u0060\u0060\n\n![源 IP 地址丢失的流程](9a331cc374c51421ecb64e58b25a6c4d.svg)\n\n\n\n上面图只是最常见的一种情况。本文考虑到以下几种情况：\n\n1. 南北向流量：客户端通过负载均衡器（网关）访问服务端\n   1. 只有一层网关\n   2. 两层或两层以上网关\n2. 东西向流量：网格内部的服务间访问\n3. 协议：HTTP 和 TCP\n\n## 如何确认客户端源 IP？\n\n在 Istio 服务网格中，Envoy 代理通常会将客户端 IP 添加到 HTTP 请求的 \u0022X-Forwarded-For\u0022 头部中。以下是确认客户端 IP 的步骤：\n\n1. **检查 x-forwarded-for 头部**：包含请求路径上各代理的 IP 地址。\n2. **选择最后一个 IP**：通常，最后一个 IP 是最接近服务器的客户端 IP。\n3. **验证 IP 的可信性**：检查代理服务器的信任度。\n4. **使用 x-envoy-external-address**：Envoy 可以设置此头部，包含客户端真实 IP。\n\n详情请见 Envoy 文档中对 [\u0060x-forwarded-for\u0060 标头](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/configuration\/http\/http_conn_man\/headers#config-http-conn-man-headers-x-forwarded-for)的说明。对于 TCP\/IP 连接，可以通过协议字段解析客户端 IP。\n\n## 测试环境\n\n**GKE**\n\n- Client Version: v1.28.4\n- Kustomize Version: v5.0.4-0.20230601165947-6ce0bf390ce3\n- Server Version: v1.27.7-gke.1121000\n\n**Istio**\n\n- client version: 1.20.1\n- control plane version: 1.20.1\n- data plane version: 1.20.1 (12 proxies)\n\n**CNI**\n\n我们使用了 Cilium CNI，但是没有开启无 kube-proxy 模式。\n\n- cilium-cli: v0.15.18 compiled with go1.21.5 on darwin\/amd64\n- cilium image (default): v1.14.4\n- cilium image (stable): unknown\n- cilium image (running): 1.14.5\n\n**Node**\n\n| 节点名称                                | 内部 IP     | 备注                         |\n| --------------------------------------- | ----------- | ---------------------------- |\n| gke-cluster1-default-pool-5e4152ba-t5h3 | 10.128.0.53 |                              |\n| gke-cluster1-default-pool-5e4152ba-ubc9 | 10.128.0.52 |                              |\n| gke-cluster1-default-pool-5e4152ba-yzbg | 10.128.0.54 | Ingress Gateway Pod 所在节点 |\n\n执行测试的本地客户端电脑的公网 IP：123.120.247.15\n\n## 部署测试示例\n\n下图展示了测试方式：\n\n\u0060\u0060\u0060mermaid \u0022测试方式\u0022\nsequenceDiagram\n    participant C as Client\n    participant LB as Load Balancer\n    participant IG as Ingress Gateway\n    participant S as Source IP App\n    C-\u003e\u003eLB: Initial Request\n    LB-\u003e\u003eIG: Forward Request \n    IG-\u003e\u003eS: Forwarded Request\n\u0060\u0060\u0060\n\n![测试方式](8cd62d9391e2e4fb0b4b257075c64426.svg)\n\n\n\n首先参考 [Istio 文档](https:\/\/istio.io\/latest\/docs\/setup\/install\/)部署 Istio，然后为 default 命名空间开启 sidecar 自动注入：\n\n\u0060\u0060\u0060bash\nkubectl label namespace default istio-injection=enabled\n\u0060\u0060\u0060\n\n在 Istio 中部署 echo-server 应用测试。echo-server 是一个基于 Nginx 的服务器，用于回显客户端发送的请求信息，例如请求头、客户端地址、请求方法等。\n\n\u0060\u0060\u0060bash\nkubectl create deployment echo-server --image=registry.k8s.io\/echoserver:1.4\nkubectl expose deployment echo-server --name=clusterip --port=80 --target-port=8080\n\u0060\u0060\u0060\n\n创建 Ingress Gateway：\n\n\u0060\u0060\u0060bash\ncat\u003econfig.yaml\u003c\u003cEOF\napiVersion: networking.istio.io\/v1beta1\nkind: Gateway\nmetadata:\n  name: clusterip-gateway\nspec:\n  selector:\n    istio: ingressgateway # 根据你的环境选择适当的 selector\n  servers:\n    - port:\n        number: 80\n        name: http\n        protocol: HTTP\n      hosts:\n        - \u0022clusterip.jimmysong.io\u0022 # 替换成你想要使用的主机名\n---\napiVersion:  networking.istio.io\/v1beta1\nkind: VirtualService\nmetadata:\n  name: clusterip-virtualservice\nspec:\n  hosts:\n    - \u0022clusterip.jimmysong.io\u0022 # 替换成与 Gateway 中相同的主机名\n  gateways:\n    - clusterip-gateway # 这里使用 Gateway 的名称\n  http:\n    - route:\n        - destination:\n            host: clusterip.default.svc.cluster.local # 替换成你的 Service 的实际主机名\n            port:\n              number: 80 # Service 的端口\nEOF\nkubectl apply -f config.yaml\n\u0060\u0060\u0060\n\n查看 Ingress Gateway 中的 Envoy 日志：\n\n\u0060\u0060\u0060bash\nkubectl logs -f deployment\/istio-ingressgateway -n istio-system\n\u0060\u0060\u0060\n\n查看 Sleep Pod 中的 Envoy 日志：\n\n\u0060\u0060\u0060bash\nkubectl logs -f deployment\/sleep -n default -c istio-proxy\n\u0060\u0060\u0060\n\n查看 Source IP App 中的 Envoy 日志：\n\n\u0060\u0060\u0060bash\nkubectl logs -f deployment\/echo-server -n default -c istio-proxy\n\u0060\u0060\u0060\n\n获取网关公网 IP：\n\n\u0060\u0060\u0060bash\nexport GATEWAY_IP=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath=\u0027{.status.loadBalancer.ingress[0].ip}\u0027)\n\u0060\u0060\u0060\n\n在本地使用 curl 测试：\n\n\u0060\u0060\u0060bash\ncurl -H \u0022Host: clusterip.jimmysong.io\u0022 $GATEWAY_IP\n\u0060\u0060\u0060\n\n### 资源 IP\n\n当部署好测试应用后，你需要获取与以下资源的 IP 地址。在接下来的实验环节中将会用到。\n\n**Pod**\n\n下面是初始状况下的 Pod IP，随着对 Deployment 的补丁，Pod 会重建，名称和 IP 地址都会变。\n\n| Pod 名称                              | Pod IP      |\n| ------------------------------------- | ----------- |\n| echo-server-6d9f5d97d7-fznrq          | 10.32.1.205 |\n| sleep-9454cc476-2dskx                 | 10.32.3.202 |\n| istio-ingressgateway-6c96bdcd74-zh46d | 10.32.1.221 |\n\n**Service**\n\n| Service 名称         | Cluster IP  | External IP   |\n| -------------------- | ----------- | ------------- |\n| clusterip            | 10.36.8.86  | -             |\n| sleep                | 10.36.14.12 | -             |\n| istio-ingressgateway | 10.36.4.127 | 35.188.212.88 |\n\n## 南北向流量\n\n我们首先考虑客户端位于 Kubernetes 集群外，通过负载均衡器来访问集群内部服务的情况。\n\n### 测试 1：Cluster 流量策略、iptables 流量劫持\n\n这是通过以上步骤部署完测试应用后的默认情况，也是大家遇到的所谓的源 IP 地址丢失的情况。\n\ncurl 测试：\n\n\u0060\u0060\u0060bash\ncurl -H \u0022Host: clusterip.jimmysong.io\u0022 $GATEWAY_IP\n\u0060\u0060\u0060\n\n{{\u003cdetail \u0022查看结果\u0022\u003e}}\n\n{{\u003chighlight text \u0022linenos=table,hl_lines=2 21 23\u0022\u003e}}\nCLIENT VALUES:\nclient_address=127.0.0.6\ncommand=GET\nreal path=\/\nquery=nil\nrequest_version=1.1\nrequest_uri=http:\/\/clusterip.jimmysong.io:8080\/\n\nSERVER VALUES:\nserver_version=nginx: 1.10.0 - lua: 10001\n\nHEADERS RECEIVED:\naccept=*\/*\nhost=clusterip.jimmysong.io\nuser-agent=curl\/8.4.0\nx-b3-parentspanid=03c124c5f910001a\nx-b3-sampled=1\nx-b3-spanid=103dc912ec14f3b4\nx-b3-traceid=140ffa034822077f03c124c5f910001a\nx-envoy-attempt-count=1\nx-envoy-internal=true\nx-forwarded-client-cert=By=spiffe:\/\/cluster.local\/ns\/default\/sa\/default;Hash=79253e34e1c28d389e9bfb1a62ffe8944b2c3c369b46bf4a9faf055b55dedb7f;Subject=\u0022\u0022;URI=spiffe:\/\/cluster.local\/ns\/istio-system\/sa\/istio-ingressgateway-service-account\nx-forwarded-for=10.128.0.54\nx-forwarded-proto=http\nx-request-id=b3c05e22-594e-98da-ab23-da711a8f53ec\nBODY:\n-no body in request-\n{{\u003c\/highlight\u003e}}\n\n{{\u003c\/detail\u003e}}\n\n你只需要关注 \u0060client_address\u0060 和 \u0060x-forwarded-for\u0060 这两个结果即可。下文的 curl 测试结果中将省略其他信息。\n\n{{\u003ccallout note 说明\u003e}}\n\n该结果中字段的含义：\n\n- \u0060client_address\u0060：通过解析 TCP\/IP 协议而获取的客户端 IP 地址，在 Envoy 中称为 remote address。\n- \u0060x-forwarded-for\u0060：\u0060x-forwarded-for\u0060 (XFF) 是一个标准的代理头部，用于指示请求在从客户端到服务器的过程中经过的 IP 地址。一个合规的代理会在代理请求之前将最近客户端的 IP 地址添加到 XFF 列表中。详见 [Envoy 文档](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/configuration\/http\/http_conn_man\/headers#x-forwarded-for)。\n\n{{\u003c\/callout\u003e}}\n\n从测试结果中我们可以看出，源 IP 地址变成了 Ingress  Gateway  Pod 所在节点的 IP 地址（\u006010.128.0.54\u0060）。\n\n下图展示是两个 Pod 中的数据包流量路径。\n\n\u0060\u0060\u0060mermaid \u0022两个 Pod 中的数据包流量路径\u0022\ngraph LR\nsubgraph IngressGatewayPod[Ingress Gateway Pod]\nA[\u0022Downstream Remote (Ingress Gateway Node)\u003cbr\u003e10.128.0.54:56532\u0022] --\u003e B\n    B[\u0022Downstream Local (Ingresss Gateway Pod)\u003cbr\u003e10.32.1.221:8080\u0022]--\u003eC\n    C[\u0022Upstream Local (Ingress Gateway Pod)\u003cbr\u003e10.32.1.221:59842\u0022]\n    C --\u003e D[\u0022Upstream Host (Source IP App Pod)\u003cbr\u003e10.32.1.205:8080\u0022]\nend\nsubgraph SourceIPAppPod[Source IP App Pod]\n    E[\u0022Downstream Remote (Ingress Gateway Pod)\u003cbr\u003e10.128.0.54:0\u0022] --\u003e F\n    F[\u0022Downstream Local (Source IP App Pod)\u003cbr\u003e10.32.1.205:8080\u0022]\n    G[\u0022Upstream Local (InboundPassthroughClusterIpv4)\u003cbr\u003e127.0.0.6:60481\u0022]\n    H[\u0022Upstream Host (Source IP App Pod)\u003cbr\u003e10.32.1.205:8080\u0022]\n    F --\u003e G\n    G --\u003e H\nend\nIngressGatewayPod--\u003eSourceIPAppPod\n\u0060\u0060\u0060\n\n![两个 Pod 中的数据包流量路径](80963dcc68a315cb631ee687bb10a409.svg)\n\n\n\n对于这种情况，要想保留源 IP 其实很简单，而且也是 Kubernetes 提供的标准选项。\n\n### 源 IP 地址是如何丢失的？\n\n下图展示客户端的源 IP 是如何在请求过程中丢失的。\n\n\u0060\u0060\u0060mermaid \u0022客户端的源 IP 是如何在请求过程中丢失的\u0022\nsequenceDiagram\n    participant C as Client\u003cbr\u003e123.120.247.15\n    participant LB as Load Balancer\u003cbr\u003e35.188.212.88\n    box Node \u003cbr\u003e10.128.0.54\n    participant IG as Ingress Gateway\u003cbr\u003e10.32.1.221\n    end\n    participant S as Source IP App Pod\u003cbr\u003e10.32.1.205\n    C-\u003e\u003eLB: Initial Request\n    LB-\u003e\u003eIG: Altered Request (IP Changed)\u003cbr\u003eSNAT: 123.120.234.15 -\u003e 10.128.0.54\n    IG-\u003e\u003eS: Forwarded Request\n    Note over IG,S: Source IP Lost\n\u0060\u0060\u0060\n\n![客户端的源 IP 是如何在请求过程中丢失的](3aeef9eef475587bbca6edb88a134f69.svg)\n\n\n\n因为负载均衡器将数据包发送到 Kubernetes 集群中的任意节点，在此过程中会进行 SNAT，导致最终发送到 Server Pod 中的客户端源 IP 丢失。\n\n### 如何保留客户端源 IP\n\n你可以通过设置 service 中的 \u0060externalTrafficPolicy\u0060 字段为 \u0060Local\u0060 控制负载均衡器保留源 IP。\n\n**externalTrafficPolicy**\n\n\u0060externalTrafficPolicy\u0060 是一个[标准 Service 选项](https:\/\/kubernetes.io\/docs\/tasks\/access-application-cluster\/create-external-load-balancer\/#preserving-the-client-source-ip)，用于定义传入 Kubernetes 节点的流量是否进行负载均衡以及如何进行负载均衡。\u0060Cluster\u0060 是默认策略，但 \u0060Local\u0060 通常用于保留传入集群节点的流量的来源 IP。\u0060Local\u0060 会在集群节点上有效停用负载均衡，以使本地 Pod 接收的流量看到原始来源 IP 地址。\n\n\u0060\u0060\u0060mermaid \u0022externalTrafficPolicy\u0022\ngraph TD;\n    A[Client Request] --\u003e|Sent to Service| B[Load Balancer]\n    B --\u003e|externalTrafficPolicy: Local| C[Node with Service Endpoint]\n    C --\u003e|Source IP Preserved| D[Service Handling Request]\n    B --\u003e|\u0022externalTrafficPolicy: Cluster (Default)\u0022| E[Any Node in Cluster]\n    E --\u003e|Source IP Altered| D\n\u0060\u0060\u0060\n\n![externalTrafficPolicy](02f4d9919bbd6f3d5fc5682c3793896a.svg)\n\n\n\n也就是说将 \u0060externalTrafficPolicy\u0060 设置为 \u0060Local\u0060 就可以让数据包绕过节点上的 kube-proxy，而直达目标 Pod。但是大多数人在 Kubernetes 中创建 Service 时都没有设置 \u0060externalTrafficPolicy\u0060，所以使用了默认的 \u0060Cluster\u0060 策略。\n\n既然 Service 采用 Local 外部流量策略可以保留客户端的源 IP 地址，那为什么 Kubernetes 不默认采用呢？\n\n{{\u003ccallout note 说明\u003e}}\n\n通过 Local 模式暴露服务以获取客户端源 IP 是一种对可靠性的妥协，如果大家有更好的方案欢迎推荐给我。\n\n{{\u003c\/callout\u003e}}\n\nKubernetes 默认将 Service 的 \u0060externalTrafficPolicy\u0060 设置为 \u0060Cluster\u0060 而非 \u0060Local\u0060，主要是基于以下考虑：\n\n1. **负载均衡**：确保流量在所有节点之间平均分配，避免单个节点过载。\n2. **高可用性**：允许流量被集群中任何节点接收，提高服务的可用性。\n3. **简化配置**：\u0060Cluster\u0060 模式降低了网络配置的复杂性。\n4. **性能优化**：避免由于保留客户端源 IP 而引起的潜在性能问题。\n5. **通用性**：兼容多种网络环境和集群配置，适应更广泛的使用场景。\n\n### 测试 2：Local 流量策略、iptables 流量劫持\n\n将 Ingress Gateway Service  设置为 Local 外部流量策略：\n\n\u0060\u0060\u0060bash\nkubectl patch svc istio-ingressgateway -p \u0027{\u0022spec\u0022:{\u0022externalTrafficPolicy\u0022:\u0022Local\u0022}}\u0027 -n istio-system\n\u0060\u0060\u0060\n\nCurl 测试：\n\n\u0060\u0060\u0060bash\ncurl -H \u0022Host: clusterip.jimmysong.io\u0022 $GATEWAY_IP\n\u0060\u0060\u0060\n\n{{\u003cdetail \u0022查看结果\u0022\u003e}}\n\n{{\u003chighlight text \u0022linenos=table,hl_lines=2 21 23\u0022\u003e}}\nCLIENT VALUES:\nclient_address=127.0.0.6\ncommand=GET\nreal path=\/\nquery=nil\nrequest_version=1.1\nrequest_uri=http:\/\/clusterip.jimmysong.io:8080\/\n\nSERVER VALUES:\nserver_version=nginx: 1.10.0 - lua: 10001\n\nHEADERS RECEIVED:\naccept=*\/*\nhost=clusterip.jimmysong.io\nuser-agent=curl\/8.4.0\nx-b3-parentspanid=060c393adb561603\nx-b3-sampled=1\nx-b3-spanid=8df3e10078cc826b\nx-b3-traceid=cf26040ae9536702060c393adb561603\nx-envoy-attempt-count=1\nx-envoy-external-address=123.120.247.15\nx-forwarded-client-cert=By=spiffe:\/\/cluster.local\/ns\/default\/sa\/default;Hash=79253e34e1c28d389e9bfb1a62ffe8944b2c3c369b46bf4a9faf055b55dedb7f;Subject=\u0022\u0022;URI=spiffe:\/\/cluster.local\/ns\/istio-system\/sa\/istio-ingressgateway-service-account\nx-forwarded-for=123.120.247.15\nx-forwarded-proto=http\nx-request-id=35bc2123-0971-9a9c-84c1-2aeee233a268\nBODY:\n-no body in request-\n{{\u003c\/highlight\u003e}}\n{{\u003c\/detail\u003e}}\n\n通过 Envoy 日志可以得出现在的数据包路径：\n\n\u0060\u0060\u0060mermaid \u0022数据包路径 1\u0022\ngraph LR\nsubgraph IngressGatewayPod[Ingress Gateway Pod]\n    B[\u0022Downstream Local (Ingress Gateway Pod)\u003cbr\u003e10.32.1.221:8080\u0022]\n    C[\u0022Upstream Local (Ingress Gateway Pod)\u003cbr\u003e10.32.1.221:59842\u0022]\nA[\u0022Downstream Remote (Client)\u003cbr\u003e123.120.247.15:62650\u0022] --\u003e B\nB --\u003e C\nC --\u003e D[\u0022Upstream Host (Source IP App Pod)\u003cbr\u003e10.32.1.205:8080\u0022]\nend\nsubgraph SourceIPAppPod[Source IP App Pod]\n    F[\u0022Downstream Local (Source IP App Pod)\u003cbr\u003e10.32.1.205:8080\u0022]\n    G[\u0022Upstream Local (InboundPassthroughClusterIpv4)\u003cbr\u003e127.0.0.6:58639\u0022]\n    H[\u0022Upstream Host (Source IP App Pod)\u003cbr\u003e10.32.1.205:8080\u0022]\nE[\u0022Downstream Remote (Client)\u003cbr\u003e123.120.247.15:0\u0022] --\u003e F\nF --\u003e G\nG --\u003e H\nend\nIngressGatewayPod--\u003eSourceIPAppPod\n\u0060\u0060\u0060\n\n![数据包路径 1](566a610667551fdcd025fc541c3d1fe7.svg)\n\n客户端源 IP 被正确识别为 \u0060123.120.247.15\u0060。\n\n## 东西向流量\n\n在 Istio 默认配置的情况下，对于东西向流量，服务端也无法获取正确的客户端源 IP。\n\n### 测试 3：Local 流量策略、tproxy 流量劫持\n\n将 Source IP App 中的流量拦截方式从 iptables 修改为 [tproxy](\/blog\/what-is-tproxy\/)：\n\n\u0060\u0060\u0060bash\nkubectl patch deployment -n default echo-server -p \u0027{\u0022spec\u0022:{\u0022template\u0022:{\u0022metadata\u0022:{\u0022annotations\u0022:{\u0022sidecar.istio.io\/interceptionMode\u0022:\u0022TPROXY\u0022}}}}}\u0027\n\u0060\u0060\u0060\n\n注意：此时 Source IP App 的 Pod 将会重建，新的 Pod 名称是 \u0060echo-server-686d564647-r7nlq\u0060，IP 地址是 10.32.1.140。\n\nCurl 测试：\n\n\u0060\u0060\u0060bash\nkubectl exec -it deployment\/sleep -it -- curl clusterip\n\u0060\u0060\u0060\n\n{{\u003cdetail \u0022查看结果\u0022\u003e}}\n{{\u003chighlight text \u0022linenos=table,hl_lines=2\u0022\u003e}}\nCLIENT VALUES:\nclient_address=10.32.3.202\ncommand=GET\nreal path=\/\nquery=nil\nrequest_version=1.1\nrequest_uri=http:\/\/clusterip:8080\/\n\nSERVER VALUES:\nserver_version=nginx: 1.10.0 - lua: 10001\n\nHEADERS RECEIVED:\naccept=*\/*\nhost=clusterip\nuser-agent=curl\/8.5.0\nx-b3-parentspanid=3c07f3b87cc547dd\nx-b3-sampled=1\nx-b3-spanid=97844ebdde748bfc\nx-b3-traceid=90f57b0fb260dfbf3c07f3b87cc547dd\nx-envoy-attempt-count=1\nx-forwarded-client-cert=By=spiffe:\/\/cluster.local\/ns\/default\/sa\/default;Hash=25af59fcf9fbe745eb75a318c47d55059d75914632d2536a43a80d342eaed27c;Subject=\u0022\u0022;URI=spiffe:\/\/cluster.local\/ns\/default\/sa\/sleep\nx-forwarded-proto=http\nx-request-id=e9b27bde-3cf6-9d8b-8f23-1cb0fa35d405\nBODY:\n-no body in request-\n{{\u003c\/highlight\u003e}}\n{{\u003c\/detail\u003e}}\n\n下图展示了数据包路径：\n\n\u0060\u0060\u0060mermaid \u0022数据包路径 2\u0022\ngraph LR\nsubgraph SleepPod[Sleep Pod]\nA[\u0022Downstream Remote (Sleep Pod)\u003cbr\u003e10.32.3.202:38394\u0022] --\u003e B\nB[\u0022Downstream Local (Clusterip Service)\u003cbr\u003e10.36.8.86:80\u0022] --\u003e C\nC[\u0022Upstream Local (Sleep Pod)\u003cbr\u003e10.32.3.202:33786\u0022] --\u003e D[\u0022Upstream Host (Source IP App Pod)\u003cbr\u003e10.32.1.140:8080\u0022]\nend\nsubgraph SourceIPAppPod[Source IP App Pod]\nE[\u0022Downstream Remote (Sleep Pod)\u003cbr\u003e10.32.3.202:33786\u0022] --\u003e F\nF[\u0022Downstream Local (Source IP App Pod)\u003cbr\u003e10.32.1.140:8080\u0022] --\u003e G\nG[\u0022Upstream Local (Sleep Pod)\u003cbr\u003e10.32.3.202:34173\u0022] --\u003e H[\u0022Upstream Host (Source IP App Pod)\u003cbr\u003e10.32.1.140:8080\u0022]\nend\nSleepPod--\u003eSourceIPAppPod\n\u0060\u0060\u0060\n\n![数据包路径 2](72c7107f23253c70fabc41ed04a0140f.svg)\n\n客户端 IP 被正确识别为 \u006010.32.3.202\u0060。\n\n### 测试 4：Local 流量策略、iptables 流量劫持\n\n将 Source IP App 中的流量拦截方式恢复为 redirect：\n\n\u0060\u0060\u0060bash\nkubectl patch deployment -n default echo-server -p \u0027{\u0022spec\u0022:{\u0022template\u0022:{\u0022metadata\u0022:{\u0022annotations\u0022:{\u0022sidecar.istio.io\/interceptionMode\u0022:\u0022REDIRECT\u0022}}}}}\u0027\n\u0060\u0060\u0060\n\n注意：此时 Source IP App 的 Pod 将会重建，新的 Pod 名称是 \u0060echo-server-6d9f5d97d7-bgpk6\u0060，IP 地址是 10.32.1.123。\n\nCurl 测试：\n\n\u0060\u0060\u0060bash\nkubectl exec -it deployment\/sleep -it -- curl clusterip\n\u0060\u0060\u0060\n\n{{\u003cdetail \u0022查看结果\u0022\u003e}}\n{{\u003chighlight text \u0022linenos=table,hl_lines=2\u0022\u003e}}\nCLIENT VALUES:\nclient_address=127.0.0.6\ncommand=GET\nreal path=\/\nquery=nil\nrequest_version=1.1\nrequest_uri=http:\/\/clusterip:8080\/\n\nSERVER VALUES:\nserver_version=nginx: 1.10.0 - lua: 10001\n\nHEADERS RECEIVED:\naccept=*\/*\nhost=clusterip\nuser-agent=curl\/8.5.0\nx-b3-parentspanid=6123380e58ca0ce7\nx-b3-sampled=1\nx-b3-spanid=633848c0065ec91e\nx-b3-traceid=dbcda8b3673e70a46123380e58ca0ce7\nx-envoy-attempt-count=1\nx-forwarded-client-cert=By=spiffe:\/\/cluster.local\/ns\/default\/sa\/default;Hash=25af59fcf9fbe745eb75a318c47d55059d75914632d2536a43a80d342eaed27c;Subject=\u0022\u0022;URI=spiffe:\/\/cluster.local\/ns\/default\/sa\/sleep\nx-forwarded-proto=http\nx-request-id=b05e07e1-08ba-9449-90a9-a4a98277a8c0\nBODY:\n-no body in request-\n{{\u003c\/highlight\u003e}}\n{{\u003c\/detail\u003e}}\n\n下图展示了数据包路径：\n\n\u0060\u0060\u0060mermaid \u0022数据包路径 3\u0022\ngraph LR\nsubgraph Sleep[Sleep Pod]\nA[\u0022Downstream Remote (Sleep Pod)\u003cbr\u003e10.32.3.202:34238\u0022] --\u003e B\nB[\u0022Downstream Local (Clusterip Service)\u003cbr\u003e10.36.8.86:80\u0022] --\u003e C\nC[\u0022Upstream Local (Sleep Pod)\u003cbr\u003e10.32.3.202:52776\u0022] --\u003e D[\u0022Upstream Host (Source IP App Pod)\u003cbr\u003e10.32.1.123:8080\u0022]\nend\nsubgraph SourceIPApp[Source IP App Pod]\nE[\u0022Downstream Remote (Sleep Pod)\u003cbr\u003e10.32.3.202:52776\u0022] --\u003e F\nF[\u0022Downstream Local (Source IP App Pod)\u003cbr\u003e10.32.1.123:8080\u0022] --\u003e G\nG[\u0022Upstream Local (InboundPassthroughClusterIpv4)\u003cbr\u003e127.0.0.6:49803\u0022] --\u003e H[\u0022Upstream Host (Source IP App Pod)\u003cbr\u003e10.32.1.123:8080\u0022]\nend\nSleep --\u003eSourceIPApp\n\u0060\u0060\u0060\n\n![数据包路径 3](8993fe075c1e3ecc7c42eefb98fccb21.svg)\n\n客户端源 IP 被识别为 \u0060127.0.0.6\u0060。\n\n## 单层代理场景总结\n\n在单层代理的情况下，只需要将 Ingress Gateway 的 Service 的 \u0060externalTrafficPolicy\u0060 设置为 \u0060Local\u0060 即可保留客户端源 IP。将目标服务的流量拦截模式修改为 \u0060TPROXY\u0060 即可以保留东西向请求中的源 IP。\n\n## 多层代理\n\n如果流量在进入 Istio Mesh 前已经经过的多层代理转发，每次流量经过代理时，代理解析 HTTP 流量并将其自身的 IP 地址追加到 \u0060x-forwarded-for\u0060 标头中。那么可以使用 \u0060numTrustedProxies\u0060 配置您信任的代理跳数，请参考 [Envoy 文档](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/configuration\/http\/http_conn_man\/headers#x-forwarded-for) 了解如何确定 \u0060X-Forwarded-For\u0060 标头和受信任的客户端地址。\n\n实际上我们很难确定流量在到达 Istio Mesh 时究竟经过了几层代理，但你可以根据 \u0060x-forwarded-for\u0060 标头了解流量的转发路径。\n\n下图展示了 Envoy 如何根据 \u0060x-forwarded-for\u0060 标头和 \u0060xff_num_trusted_hops\u0060（对应 Istio 中的 \u0060numTrustedProxies\u0060 配置）来确认源 IP 的流程。详见 [Envoy 文档](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/configuration\/http\/http_conn_man\/headers#x-forwarded-for)。\n\n\u0060\u0060\u0060mermaid \u0022多层代理\u0022\ngraph TD\n    A[Start] --\u003e|use_remote_address is false| B[Check XFF]\n    A --\u003e|use_remote_address is true| G[Check xff_num_trusted_hops]\n    B --\u003e|XFF contains at least one IP| C[Use last IP in XFF]\n    B --\u003e|XFF is empty| D[Use immediate downstream IP]\n    G --\u003e|xff_num_trusted_hops \u003e 0| H[\u0022Use (N)th IP from right in XFF\u0022]\n    G --\u003e|xff_num_trusted_hops \u003c= 0| D\n    H --\u003e|XFF contains \u003e= N addresses| I[Use Nth address from right]\n    H --\u003e|XFF contains \u003c N addresses| D\n\u0060\u0060\u0060\n\n![多层代理](b82caafefa304b53c996da072373043a.svg)\n\n\n\n执行下面的命令为入口网关开启受信代理数量配置：\n\n\u0060\u0060\u0060bash\nkubectl patch deployment istio-ingressgateway -n istio-system -p \u0027{\u0022spec\u0022:{\u0022template\u0022:{\u0022metadata\u0022:{\u0022annotations\u0022:{\u0022proxy.istio.io\/config\u0022:\u0022{\\\u0022gatewayTopology\\\u0022:{\\\u0022numTrustedProxies\\\u0022: 2,\\\u0022forwardClientCertDetails\\\u0022:\\\u0022SANITIZE_SET\\\u0022}}\u0022}}}}}\u0027\n\u0060\u0060\u0060\n\n当 Istio Gateway 收到这个请求时，它将 \u0060X-Envoy-External-Address\u0060 头设置为您 curl 命令中 \u0060X-Forwarded-For\u0060 头中的倒数第二个地址（\u0060numTrustedProxies: 2\u0060）。根据 Istio 的文档，Gateway 在将其转发到服务端负载之前，会将自己的 IP 附加到 \u0060X-Forwarded-For\u0060 头中。但实际情况是标头中只有客户端源 IP 和 External Gateway Pod IP。\n\n你可以执行下面的命令取消这个补丁：\n\n\u0060\u0060\u0060bash\nkubectl patch deployment istio-ingressgateway -n istio-system -p \u0027{\u0022spec\u0022:{\u0022template\u0022:{\u0022metadata\u0022:{\u0022annotations\u0022:{\u0022proxy.istio.io\/config\u0022:\u0022{}\u0022}}}}}\u0027\n\u0060\u0060\u0060\n\n## TCP 流量\n\n上文所说的使用标头获取客户端源 IP 的方式只适用于 L7 网络，对于 L4 网络的 TCP 流量可以使用 Proxy 协议。\n\nProxy 协议是一种网络协议，它在 TCP 连接的起始处添加了一个协议头部，用于传递连接过程中的一些元数据，如客户端的真实 IP 地址和端口号。这对于在负载均衡器（LB）后部署的应用程序非常有用，因为负载均衡器通常会更改客户端的原始 IP 地址成 LB 的地址，导致服务端无法知晓客户端的真实 IP。很多代理软件都支持 Proxy Protocol，比如 [Envoy](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/configuration\/listeners\/listener_filters\/proxy_protocol) 和 HAProxy、NGINX 等。\n\n你可以使用下面的命令为 Ingress Gateway 打上补丁，以支持 Proxy 协议：\n\n\u0060\u0060\u0060\nkubectl patch deployment istio-ingressgateway -n istio-system -p \u0027{\u0022spec\u0022:{\u0022template\u0022:{\u0022metadata\u0022:{\u0022annotations\u0022:{\u0022proxy.istio.io\/config\u0022:\u0022{\\\\\u0022gatewayTopology\\\\\u0022:{\\\\\u0022proxyProtocol\\\\\u0022:{}}}\u0022}}}}}\u0027\n\u0060\u0060\u0060\n\n注意：不是所有的公有云中的 Kubernetes  中 \u0060LoadBalancer\u0060 类型的 Service 创建的的负载均衡器都支持该配置。比如 GKE 中就不支持。在 AWS NLB 中开启 Proxy 协议请参考[该博客](https:\/\/istio.io\/latest\/blog\/2020\/show-source-ip\/)。\n\nEnvoy 并不建议使用 Proxy 协议，因为它：\n\n- 只支持 TCP 协议\n- 必须上游主机支持\n- 可能影响性能\n\n关于 Envoy 对 Proxy 协议的支持请参考[该文档](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/intro\/arch_overview\/other_features\/ip_transparency#proxy-protocol)。\n\n## 应用场景示例\n\n下面是常见的两个源 IP 地址的应用场景。\n\n### 基于源 IP 地址的访问控制\n\n在 Istio 的入口网关配置基于源 IP 的访问控制策略。这通过设置入口网关的授权策略，根据源 IP 地址实现访问限制。\n\n下图展示了基于源 IP 地址的访问控制流程图。\n\n\u0060\u0060\u0060mermaid \u0022基于源 IP 地址的访问控制流程图\u0022\nsequenceDiagram\n    participant C as Client\n    participant P1 as Proxy 1\n    participant P2 as Proxy 2\n    participant Pn as Proxy N\n    participant IG as Ingress Gateway\n    participant S as Service\n\n    C-\u003e\u003e\u002bP1: Request with Source IP\n    P1-\u003e\u003e\u002bP2: Forward Request\n    P2-\u003e\u003e\u002bPn: Forward Request\n    Pn-\u003e\u003e\u002bIG: Forward Request\n    Note over IG: numTrustedProxies Set\n    IG-\u003e\u003e\u002bS: Forwarded Request\n    Note over IG: Authorization Policy Based on Source IP\n\u0060\u0060\u0060\n\n![基于源 IP 地址的访问控制流程图](635bc14feb9b6939b3319929849cd0b5.svg)\n\n\n\n#### 场景假设\n\n假设请求经过三个代理，其 IP 地址分别为 \u00601.1.1.1\u0060、\u00602.2.2.2\u0060 和 \u00603.3.3.3\u0060。在 Ingress Gateway 中，\u0060numTrustedProxies\u0060 被设置为 2，因此 Istio 信任的源 IP 为 \u00602.2.2.2\u0060（即 \u0060x-envoy-external-address\u0060）。\n\n\u0060\u0060\u0060bash\ncurl -H \u0022Host: clusterip.jimmysong.io\u0022 -H \u0027X-Forwarded-For: 1.1.1.1,2.2.2.2,3.3.3.3\u0027 $GATEWAY_IP\n\u0060\u0060\u0060\n\n#### 屏蔽特定源 IP\n\n若需屏蔽来自 \u00602.2.2.2\u0060 的请求，可以使用以下授权策略：\n\n\u0060\u0060\u0060yaml\napiVersion: security.istio.io\/v1\nkind: AuthorizationPolicy\nmetadata:\n  name: ingress-policy\n  namespace: istio-system\nspec:\n  selector:\n    matchLabels:\n      app: istio-ingressgateway\n  action: DENY\n  rules:\n    - from:\n        - source:\n            remoteIpBlocks:\n            - \u00222.2.2.2\/24\u0022\n\u0060\u0060\u0060\n\n#### 使用最终客户端 IP\n\n如果希望识别与 Istio Mesh 直连的客户端 IP（即 \u0060x-forwarded-for\u0060 中的最后一个 IP，例如 \u0060123.120.234.15\u0060），则需要用 \u0060ipBlocks\u0060 配置：\n\n\u0060\u0060\u0060yaml\napiVersion: security.istio.io\/v1\nkind: AuthorizationPolicy\nmetadata:\n  name: ingress-policy\n  namespace: istio-system\nspec:\n  selector:\n    matchLabels:\n      app: istio-ingressgateway\n  action: DENY\n  rules:\n    - from:\n        - source:\n            ipBlocks:\n            - \u0022123.120.234.15\/24\u0022\n\u0060\u0060\u0060\n\n这种方法通过配置 Istio 的入口网关授权策略，可以有效地实现基于源 IP 的访问控制。它允许管理员根据不同的需求（如屏蔽特定 IP 或信任最终客户端 IP）灵活设定规则，从而增强了服务的安全性和灵活性。\n\n### 基于源 IP 地址的负载均衡\n\n要在 Istio 中根据源 IP 地址配置负载均衡策略，你需要使用 \u0060DestinationRule\u0060 资源，并指定 \u0060LOAD_BALANCER_POLICY_CONSISTENT_HASH\u0060 策略。这种策略允许您根据一致性哈希算法为流量分配目标，可以基于源 IP 地址来实现会话亲和性（session affinity），确保来自同一源 IP 的请求被路由到相同的目标。\n\n#### 源 IP 地址负载均衡示例\n\n下面是一个示例配置，展示了如何使用 \u0060DestinationRule\u0060 来根据源 IP 地址实现负载均衡：\n\n\u0060\u0060\u0060yaml\napiVersion: networking.istio.io\/v1alpha3\nkind: DestinationRule\nmetadata:\n  name: example-destination-rule\nspec:\n  host: example-service\n  trafficPolicy:\n    loadBalancer:\n      consistentHash:\n        httpHeaderName: x-forwarded-for # 这通常包含源 IP 地址，适用于经过代理或负载均衡器转发的流量。\n\u0060\u0060\u0060\n\n注意，如果直接连接到 Istio Ingress Gateway 而不经过其他代理，你可能需要根据实际情况调整 \u0060httpHeaderName\u0060 或使用其他哈希键，例如 \u0060useSourceIp\u0060，如下所示：\n\n\u0060\u0060\u0060yaml\nspec:\n  trafficPolicy:\n    loadBalancer:\n      consistentHash:\n        useSourceIp: true\n\u0060\u0060\u0060\n\n{{\u003ccallout note 注意\u003e}}\n\n- 使用源 IP 地址作为负载均衡的键时，请确保您理解这可能如何影响流量分布，特别是在源 IP 地址分布不均匀的情况下。\n- 正如上文所述，在某些环境中，原始的源 IP 可能会被网络设备（如负载均衡器或 NAT 设备）修改，需要确保 \u0060x-forwarded-for\u0060 头或其他相应机制能准确反映原始的客户端 IP。\n\n{{\u003c\/callout\u003e}}\n\n## 总结\n\n- 保留源 IP 对于实施访问控制、负载均衡和数据分析至关重要。\n- Envoy 代理使用 \u0060X-Forwarded-For\u0060 头部来处理 HTTP 请求中的客户端源 IP。\n- 通过设置 \u0060externalTrafficPolicy\u0060 和选择合适的流量劫持方式（\u0060REDIRECT\u0060 或 \u0060TPROXY\u0060），可以在南北向和东西向流量中正确获取客户端源 IP。\n- 处理经过多层代理的流量时，\u0060numTrustedProxies\u0060 配置是关键。\n- 对于 TCP 流量，Proxy 协议是一个有效的解决方案。\n\n## 参考\n\n- [x-forwarded-for - envoyproxy.io](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/configuration\/http\/http_conn_man\/headers#x-forwarded-for)\n- [Proxy protocol on AWS NLB and Istio ingress gateway - istio.io](https:\/\/istio.io\/latest\/blog\/2020\/show-source-ip\/)\n- [Configuring Gateway Network Topology - istio.io](https:\/\/istio.io\/latest\/docs\/ops\/configuration\/traffic-management\/network-topologies\/)\n- [IP Transparency - envoyproxy.io](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/intro\/arch_overview\/other_features\/ip_transparency)\n- [Using Source IP - kubernetes.io](https:\/\/kubernetes.io\/docs\/tutorials\/services\/source-ip\/)\n- [Proxy Protocol - github.com](https:\/\/github.com\/haproxy\/haproxy\/blob\/master\/doc\/proxy-protocol.txt)\n', '\/blog\/preserve-source-ip-in-istio\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文专注于如何在 Istio 服务网格中保持客户端源 IP 的透明性。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/doordash-service-mesh/">[译] DoorDash 的服务网格之旅：如何实现高效的区域感知路由</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/01/18</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://doordash.engineering/2024/01/16/staying-in-the-zone-how-doordash-used-a-service-mesh-to-manage-data-transfer-reducing-hops-and-cloud-spend/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('DoorDash 的服务网格之旅：如何实现高效的区域感知路由', '本文介绍了 DoorDash 如何使用服务网格来优化其跨可用区的数据传输，降低成本和延迟。作者分享了他们的流量架构、问题分析和解决方案设计，以及使用 Envoy 和 Istio 实现区域感知路由的过程和效果。', '\nDoorDash 从单体应用架构演变为基于[单元（cells）](https:\/\/www.youtube.com\/watch?v=ReRrhU-yRjg)和[微服务（microservices）](https:\/\/doordash.engineering\/2020\/12\/02\/how-doordash-transitioned-from-a-monolith-to-microservices\/)架构后，获得了许多好处。新的架构降低了开发、测试和部署所需的时间，同时提高了可伸缩性和用户体验，包括商家、送餐员和消费者。然而，随着微服务和后端数量的增加，DoorDash 注意到了跨可用区（AZ）的数据传输成本上升。这些数据传输成本 — [在发送和接收时发生](https:\/\/aws.amazon.com\/blogs\/architecture\/overview-of-data-transfer-costs-for-common-architectures\/) — 允许 DoorDash 为其最终用户提供高可用性的服务，可以抵御一个或多个 AZ 的降级。\n\n成本上升促使我们的工程团队调查了以更高效的方式提供相同级别的服务的替代方法。在本博客文章中，我们描述了 DoorDash 使用服务网格实现数据传输成本节省而不牺牲服务质量的过程。\n\n## DoorDash 流量架构\n\n在我们深入解决方案之前，让我们回顾一下 DoorDash 的流量基础设施。\n\n*基于单元的架构：* 如下图所示，我们的流量架构遵循[基于单元的设计](https:\/\/www.youtube.com\/watch?v=ReRrhU-yRjg)。所有微服务 Pod 都部署在多个隔离的单元中。每个服务在每个单元中都有一个 Kubernetes 部署。为了确保单元之间的隔离，不允许单元间的流量。这种方法使我们能够减小单个单元故障的影响范围。对于单例服务或尚未迁移到单元架构的服务，部署在一个全局单元中。内部的[Envoy](https:\/\/www.envoyproxy.io\/)路由器允许全局单元与复制的单元之间进行通信。\n\n*Kubernetes 集群部署：* 每个单元由多个 Kubernetes 集群组成；每个微服务都专门部署在给定单元内的一个集群中。这个设计确保了可伸缩性和可靠性，同时与我们的基于单元的架构保持一致。\n\n![图 1：基于单元的多集群部署](f1.jpg)\n\n*高可用性：* 为了增强可用性和容错性，每个 Kubernetes 集群都部署在多个 AZ 中。这个做法最大程度地减少了由于一个或多个 AZ 中断引起的中断。\n\n*平面网络中的直接通信：* 利用[AWS-CNI](https:\/\/github.com\/aws\/amazon-vpc-cni-k8s)，在一个单元中的不同集群中的微服务 Pod 可以直接通信。这种平面网络架构简化了通信路径，促进了微服务之间的高效交互。\n\n*自定义多集群服务发现：* 我们的自定义服务发现解决方案，DoorDash 数据中心服务发现（DDSD），提供了一个自定义的 DNS 域，以支持多集群通信。客户端使用 DNS 名称动态发现所需服务的所有 Pod IP 地址。DDSD 的功能类似于 Kubernetes 的[无头服务](https:\/\/kubernetes.io\/docs\/concepts\/services-networking\/service\/#headless-services)，但它也适用于集群间通信。例如，不同集群中的客户端可以使用*payment-service.service.prod.ddsd*来检索与支付服务相关联的所有 Pod IP 地址。\n\n*客户端负载平衡：* 服务网格负责客户端负载平衡。对于未加入服务网格的服务，负载平衡发生在客户端应用程序端。\n\n图 2 描述了上述四个特征：\n\n![图 2：单元内和跨 AZ 通信模式](f2.jpg)\n\n*服务网格架构：* 如图 3 所示，DoorDash 的服务网格部署在每个单元中，采用了一种边车容器设计模式，利用[Envoy](https:\/\/www.envoyproxy.io\/)代理作为数据平面。我们建立了我们自己的基于[xDS 的](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-docs\/xds_protocol)控制平面来管理 Envoy 配置。边车容器作为一种即插即用的解决方案，可以在不需要对应用程序代码进行任何修改的情况下，无缝地拦截、控制和转换进出 DoorDash 微服务的所有 HTTP1\/HTTP2\/gRPC 流量。\n\n![图 3：服务网格高级架构](f3.jpg)\n\n虽然 DoorDash 的流量架构具有独特的组件，但我们认为我们在网络流量效率方面遇到的挑战和经验可以广泛应用于其他架构。\n\n## DoorDash 的常见数据传输模式\n\n对于跨可用区的流量，我们将我们的流量模式分类如下：\n\n*HTTP1\/HTTP2\/gRPC流量：* 在同一单元内的微服务之间进行直接的 Pod 到 Pod 通信；在全局单元中的微服务与涉及到调用路径中的额外跃点的单元之间的流量 — 例如内部路由器 — 增加了跨可用区流量的可能性。\n\n*存储流量：* 包括来自微服务到有状态系统（如 Aurora PostgreSQL、CockroachDB、Redis 和 Kafka）的流量。\n\n*内部基础设施流量：* 内部 Kubernetes 流量，例如[coredns](https:\/\/github.com\/coredns\/coredns)流量或[Kubernetes 控制平面组件](https:\/\/kubernetes.io\/docs\/concepts\/overview\/components\/#control-plane-components)之间的通信。这种类型的流量通常使用 Kubernetes 内部 DNS 而不是 DDSD。\n\n## 初步假设\n\n我们认为，由于我们的微服务架构，同一单元内的 HTTP1\/HTTP2\/gRPC 流量是跨可用区数据传输成本的最大来源。我们还确定服务网格可能通过[Envoy 中的该功能](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/intro\/arch_overview\/upstream\/load_balancing\/zone_aware)实现所有微服务的区域感知路由。了解了这两点后，我们优先研究和优化 HTTP1\/HTTP2\/gRPC 流量模式，以提高效率而不降低服务质量。\n\n## 解决 HTTP1\/HTTP2\/gRPC 流量成本问题\n\n最初，服务之间的流量在不同的 AZ 之间均匀分布，如图 4 所示。有了 Envoy 的区域感知路由功能，调用者服务现在更倾向于将流量引导到同一 AZ 中的被调用者服务，如图 5 所示，从而降低了跨可用区的数据传输成本。\n\n![图 4：Pod 之间的简单轮询负载平衡](f4.jpg)\n\n![图 5：区域感知路由](f5.jpg)\n\n为了启用 Envoy 的区域感知路由功能，我们在服务网格的控制平面中进行了更改，将服务发现类型从[STRICT_DNS](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/intro\/arch_overview\/upstream\/service_discovery#strict-dns)切换到终端发现服务（[EDS](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/intro\/arch_overview\/upstream\/service_discovery#endpoint-discovery-service-eds)）。如下图所示，对于 DDSD 域，控制平面现在会动态地将来自每个 Envoy 集群的 EDS 资源发送回 Envoy 边车容器。EDS 资源包括 Pod IP 地址及其 AZ 信息。\n\n\u0060\u0060\u0060yaml\nresources:\n - \u0022@type\u0022: type.googleapis.com\/envoy.config.endpoint.v3.ClusterLoadAssignment\n   cluster_name: payment-service.service.prod.ddsd\n   endpoints:\n     - locality:\n         zone: us-west-2a\n       lb_endpoints:\n         - endpoint:\n             address:\n               socket_address:\n                 address: 1.1.1.1\n                 port_value: 80\n     - locality:\n         zone: us-west-2b\n       lb_endpoints:\n         - endpoint:\n             address:\n               socket_address:\n                 address: 2.2.2.2\n                 port_value: 80\n     - locality:\n         zone: us-west-2c\n       lb_endpoints:\n         - endpoint:\n             address:\n               socket_address:\n                 address: 3.3.3.3\n                 port_value: 80\n\u0060\u0060\u0060\n\n*图 6：一个 EDS 响应的示例*\n\n通过 EDS 响应中提供的数据，Envoy 获取了调用者服务和被调用者服务的 AZ 分布。这些信息使 Envoy 能够[计算](https:\/\/github.com\/envoyproxy\/envoy\/blob\/v1.28.0\/source\/common\/upstream\/load_balancer_impl.cc#L520)Pod 之间的权重。尽管仍然优先通过本\n\n地 AZ 发送流量，但为了确保均衡分布并避免过载任何单个 Pod，一些流量可能仍然会引导到跨越 AZ，如图 7 所示。\n\n![图 7：优先使用本地 AZ，同时确保流量均衡](f7.jpg)\n\n这种路由解决方案具有多种好处，包括：\n\n- 在服务不均匀分布在不同 AZ 的情况下仍然保持流量平衡\n- 可以动态设置 Pod 之间的流量权重，消除手动操作\n- 减少单个或多个 AZ 中断的影响范围\n- 减少流量延迟 — 调用者服务连接到更近的被调用者服务\n\n我们的解决方案在服务 Pod 均匀部署在可用区时变得更加有效。为实现这一目标，我们利用了[topologySpreadConstraints](https:\/\/kubernetes.io\/docs\/concepts\/scheduling-eviction\/topology-spread-constraints\/)，并将[maxSkew](https:\/\/kubernetes.io\/docs\/concepts\/scheduling-eviction\/topology-spread-constraints\/#spread-constraint-definition)设置为 1，当 Unsatisfiable 时设置为 ScheduleAnyway，如图 8 所示。这意味着 Kubernetes 调度器将仍然调度 Pod，即使条件未满足，优先选择最小化偏差的节点。\n\n这种方法确保了 Pod 仍然被调度；否则将会减少装箱量，增加空闲计算量，并最终影响了区域感知的与流量相关的成本减少。在我们的生产系统中，我们观察到有 10% 的流量是根据这个 topologySpreadConstraints 策略跨可用区发送的。\n\n\u0060\u0060\u0060yaml\ntopologySpreadConstraints:\n  - maxSkew: 1\n    topologyKey: topology.kubernetes.io\/zone\n    whenUnsatisfiable: ScheduleAnyway\n\u0060\u0060\u0060\n\n*图 8：配置以均匀部署 Pod 在可用区之间*\n\n随着我们逐渐推出上述更改，我们看到了 AWS 跨可用区传输费用的改进。即便如此，我们预期的减少要更大。因此，我们着手调查为什么我们没有节省多少预期的费用。\n\n## 大海捞针：更好地了解跨可用区的流量\n\n我们通过验证[Envoy 在可用区之间的指标](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/configuration\/upstream\/cluster_manager\/cluster_stats#config-cluster-manager-cluster-per-az-stats)和应用程序日志，确认了区域感知路由正在按预期工作，但我们需要更多的可见性来确定数据传输成本降低的根本原因低于预期。这促使我们使用了多种可观测性工具，包括[VPC 流量日志](https:\/\/docs.aws.amazon.com\/vpc\/latest\/userguide\/flow-logs.html)，[ebpf 代理指标](https:\/\/doordash.engineering\/2023\/08\/15\/bpfagent-ebpf-for-monitoring-at-doordash\/)和 Envoy 网络字节指标，以纠正这种情况。\n\n使用 VPC 流量日志，我们将[srcaddr 和 dstaddr IP 地址](https:\/\/docs.aws.amazon.com\/vpc\/latest\/userguide\/flow-logs.html#flow-logs-fields)映射到部署在我们的 AWS 帐户结构中的相应子网。这个映射提供了一个汇总规则，让我们理解托管云足迹的不同部分之间的出口\/入口流量模式，包括用于生产 Kubernetes 集群、存储解决方案、缓存和消息代理的子网，如表 1 所示。我们确认，我们跨可用区传输费用的最大来源是每个单元内的非存储流量。其中约有 20% 的费用是由于流量传输到用于我们事件接收流水线（[Iguazu](https:\/\/doordash.engineering\/2022\/08\/02\/building-scalable-real-time-event-processing-with-kafka-and-flink\/)）的一个弹性负载均衡器（ELB）引起的。\n\n![表 1：使用 VPC 流量日志进行跨可用区流量归因](t1.jpg)\n\n此外，我们检查了服务网格 HTTP1\/HTTP2\/gRPC 指标，特别是用于所有请求和响应的连接字节，包括入口和出口流量。来自服务网格 Envoy 代理的最重要的指标是[来自 Envoy 侦听器和集群的 cx_rx_bytes_total 和 cx_tx_bytes_total](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/configuration\/upstream\/cluster_manager\/cluster_stats.html#general)。但是，由于当时并非所有服务都已加入到服务网格中，因此我们依赖于 BPFAgent 的指标，该指标在每个生产 Kubernetes 节点上都全球部署，以增加对总网络字节的可见性。使用这两个来源的指标，我们发现了 90% 的流量是 HTTP1\/HTTP2\/gRPC 流量；其中 45% 的流量已经加入了服务网格，并且该部分流量的 91% 被发送到 Iguazu！\n\n## 环环相扣：Iguazu 的流量流动\n\n在分析了如图 9 所示的 Iguazu 流量流动之后，我们意识到在调用者和被调用者服务或 Pod 之间存在多个中间跃点。当流量从调用者服务传输到 Iguazu 时，它首先经过 ELBs，然后着陆在全球单元中不同 Kubernetes 集群中的一个工作节点上。因为[externalTrafficPolicy](https:\/\/kubernetes.io\/docs\/tasks\/access-application-cluster\/create-external-load-balancer\/#preserving-the-client-source-ip)配置为集群，*iptables*会将流量重定向到另一个节点以确保负载均衡。\n\n![图 9：Iguazu 的原始流量流动](f9.jpg)\n\n我们观察到以下数据传输行为：\n\n- 向 ELBs 发送流量的客户端仍然直接使用 ELB DNS 名称。因为客户端没有使用内部的 DDSD 域，所以 Envoy 集群中的服务发现类型仍然是 STRICT_DNS，而不是 EDS，这是启用区域感知路\n\n由的先决条件。这意味着 Envoy Sidecar 容器使用简单的轮询方法来将流量分发给 ELBs。\n- 在 ELBs 到 Cluster 2 的 Kubernetes 工作节点的流量的情况下，禁用了跨可用区的负载均衡。\n- 当流量从 Iguazu ELB 到达 Kubernetes 工作节点时，*iptables*会将其进一步重定向到随机节点，这也增加了跨可用区流量的概率。\n\n考虑到 Iguazu 调用图内部的多个跃点的复杂性，我们决定将 Iguazu 服务迁移到与其客户端部署在同一单元的地方。我们还配置了所有客户端 Envoy Sidecar 的[路由规则](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/configuration\/http\/http_conn_man\/rds)，将流量路由到新集群中的 Iguazu Pod，而不需要我们的工程师对其服务进行任何代码或配置更改。这使我们能够为 Iguazu 流量启用直接的 Pod 间通信，实现区域感知路由，同时减少了 ELBs 处理的流量量，如图 10 所示。\n\n![图 10：Iguazu 的新流量流动](f10.jpg)\n\n这些操作使 DoorDash 的数据传输成本以及 ELB 成本受到了很大的打击，以至于我们的云服务提供商与我们联系，询问我们是否遇到了与生产相关的问题。\n\n## 吸取的教训\n\n在我们的旅程中，我们获得了一些关键的发现，包括：\n\n- 云服务提供商的数据传输定价比起初看起来更加复杂。值得投入时间来理解定价模型，以构建正确的效率解决方案。\n- 要全面了解\/查看所有跨可用区的流量是具有挑战性的。然而，将来自不同来源的网络字节指标结合起来，足以识别热点，一旦解决，可以在使用和成本方面产生实质性影响。\n- Envoy 的区域感知路由可以将流量发送到其本地可用区，同时通过平衡流量自动确保弹性。\n- 随着微服务调用图中跃点数量的增加，数据被传输到跨可用区的可能性增加，增加了确保所有跃点支持区域感知路由的复杂性。\n- 如果你考虑使用服务网格来管理流量，你也可以利用它来提高效率。\n- 要了解更多关于 DoorDash 的服务网格之旅的信息，请查看 Hochuen 的 KubeCon \u002b CloudNativeCon North America 2023[服务网格会议](https:\/\/www.youtube.com\/watch?v=I6E_7f40YP0)。\n\n## 未来的工作\n\n我们已经列出了我们希望实施的解决方案增强功能的列表，包括：\n\n- 简化从不同来源收集指标并提供成本和使用情况的统一概述的过程。\n- 启用内部 Envoy 路由器的区域感知路由功能。\n- 使解决方案更具可扩展性，以支持 DDSD 之外的其他域的 HTTP1\/HTTP2\/gRPC 流量。\n- 使用 Kubernetes 网络代理 kube-proxy 为内部基础设施流量启用[拓扑感知路由](https:\/\/kubernetes.io\/docs\/concepts\/services-networking\/topology-aware-routing\/)功能。\n- 探索优化的路由，用于与 DoorDash 的有状态系统（例如 PostgreSQL、CRDB、Redis 和 Kafka）之间的大数据传输操作。这将允许流量在有意义的情况下保持在单一 AZ 泳道中，进一步降低成本。\n\n## 致谢\n\n我们感谢**Darshit Gavhane**和**Allison Cheng**将所有 Iguazu 服务迁移到客户端正在运行的同一单元，以及**Steve Hoffman**和**Sebastian Yates**在旅程中的建议和指导。\n', '\/trans\/doordash-service-mesh\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文介绍了 DoorDash 如何使用服务网格来优化其跨可用区的数据传输，降低成本和延迟。作者分享了他们的流量架构、问题分析和解决方案设计，以及使用 Envoy 和 Istio 实现区域感知路由的过程和效果。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/battle-of-the-pods-kubernetes-autoscaling-showdown-keda-vs-vanilla-kubernetes/">[译] KEDA vs. 原生 Kubernetes：谁是云原生应用的自动伸缩王者？</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/01/12</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/kubernetes"> 
             Kubernetes
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://www.kedify.io/blog-posts/battle-of-the-pods-kubernetes-autoscaling-showdown-keda-vs-vanilla-kubernetes" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('KEDA vs. 原生 Kubernetes：谁是云原生应用的自动伸缩王者？', '本文比较了 Kubernetes 的内置自动伸缩器（HPA 和 VPA）和 KEDA 项目的优缺点，分析了它们在不同场景下的适用性和效果，展示了 KEDA 如何解决 HPA 和 VPA 无法覆盖的复杂需求。', '\n### 1. 引言：自动伸缩的重要性\n\n在今天的云原生生态系统中，波动的工作负载和动态的流量模式是常态。适应这种不可预测的行为需要能够实时调整的系统。自动伸缩是必需的，可以确保资源的最佳分配，遏制过度成本，并促进资源的高效使用。\n\n自动伸缩不仅关乎成本。它在维护应用性能和吞吐量方面发挥着关键作用。通过避免欠配置（导致用户体验不佳）和过度配置（导致不必要的成本），自动伸缩可以实现合理的平衡。\n\n### 2. 竞争者：了解基础知识\n\n### 水平 Pod 自动伸缩器（HPA）\n\n[HPA](https:\/\/kubernetes.io\/docs\/tasks\/run-application\/horizontal-pod-autoscale\/)，作为 Kubernetes 的本地解决方案，根据观察到的指标（主要是 CPU 和内存）来扩展 Pod 的数量。虽然对于统一的工作负载来说非常直接和有益，但当考虑到其无法扩展到零并且完全依赖 CPU 和内存指标时，它的局限性就变得明显了。\n\n![HPA 改变 Pod 的数量](1.jpg)\n\n### 垂直 Pod 自动伸缩器（VPA）\n\n[VPA](https:\/\/github.com\/kubernetes\/autoscaler\/tree\/master\/vertical-pod-autoscaler#intro)更多地涉及资源的调整而不是扩展它们。它评估需求并动态调整资源，确保工作负载的合适适配。但这里有一个问题：增强型的 Pod 并不一定更好。有时，拥有更多的工作进程来处理数据比拥有一个大而强大的工作进程更高效。\n\n![VPA 调整 Pod 的大小](2.jpg)\n\n## 3. 限制：当原生 Kubernetes 自动伸缩器不足以应对时\n\n尽管内置的 Kubernetes 自动伸缩器如 HPA 和 VPA 提供了基本的扩展能力，但它们在范围上天然有限。它们主要关注 CPU 和内存指标可能对于现代应用来说是一个重大限制，因为这些应用可能需要对各种指标做出反应，其中一些甚至可能不是来自应用程序本身的指标。\n\n现代应用面临的引人注目的挑战之一是根据外部系统的事件来进行扩展。例如：\n\n- **消息队列：** 应用程序可能需要根据队列中的消息数量（如 RabbitMQ 或 Kafka）来进行扩展。如果有大量未处理的消息涌入，这可能是一个扩展的指标。\n- **数据库触发器：** 数据库中的更改或更新（如某个表的行突然增加）可能需要将应用程序进行扩\n\n展以处理或分析数据的涌入。\n- **外部 Webhook：** 来自第三方服务的传入 Webhook（例如 GitHub 推送或电子商务交易事件）可能需要更多的资源来处理额外的负载。\n- ‍**IoT 信号：** 对于连接到物联网设备的应用程序，来自这些设备的信号可能是需要扩展的指标。\n\n此外，还存在将扩展到零的必要来有效管理资源的情况，或者存在不同指标的组合决定扩展逻辑的情况，例如 CPU 利用率与数据库读\/写速率。这些微妙的需求突显了内置 Kubernetes 自动伸缩器的不足之处。‍\n\n### HPA 的自定义指标扩展\n\nKubernetes 引入了一个[自定义指标](https:\/\/kubernetes.io\/docs\/tasks\/run-application\/horizontal-pod-autoscale\/#scaling-on-custom-metrics)的接口，旨在为水平 Pod 自动伸缩器（HPA）提供更多超越 CPU 和内存指标的适应性。然而，实际实现中出现了挑战。\n\n尽管强大，但自定义指标 API 并不直观易用。它要求对 Kubernetes 内部有详细的了解，使设置和调整变得繁琐。‍\n\n### 插曲：Prometheus 适配器\n\n[Prometheus 适配器](https:\/\/github.com\/kubernetes-sigs\/prometheus-adapter)试图通过利用自定义指标 API 来弥合这一差距，引入了 Prometheus 的广泛指标。但它也有一些缺点：复杂、不直观的配置以及仅与 Prometheus 指标相关联。实施和维护配置需要不断的警觉性。基础架构或应用程序的更改可能会触发重新配置的需求。\n\n### 4. 登场 KEDA：对决中的英雄\n\n[Kubernetes 事件驱动自动伸缩（KEDA）](https:\/\/keda.sh\/)不仅与 Kubernetes 的自定义指标 API 集成，还使其变得更加可访问。这是用户友好界面如何改变体验的证明，使自动伸缩真正具有可定制性和多功能性。\n\n### KEDA 的好处\n\nKEDA 提供了多个技术优势：\n\n- **事件驱动自动伸缩：** KEDA 能够响应特定事件，甚至扩展到零，确保资源得到明智地使用。\n- **易于使用：** 其直观的配置使实施变得轻松，允许开发人员专注于应用逻辑而不是配置语法。\n- **广泛应用：** 除了仅扩展 Pod 外，KEDA 还可以基于事件安排 Kubernetes 作业，适用于不需要持续运行但可能需要定期大量资源的任务。\n- **多功能集成：** 支持多种身份验证提供程序，集成 KEDA 既简单又安全。‍\n\n### KEDA 在实践中的应用\n\n![KEDA 扩展 Kafka Consumer 应用程序](3.jpg)\n\n虽然传统的指标如 CPU 和内存提供了一些见解，但现实世界的应用程序通常需要更精细和多样化的指标来进行有效的自动伸缩。以下是一些要考虑的情景：\n\n- **事件驱动应用程序：** 考虑一个基于 Kafka 的设置。虽然 CPU 使用率可能保持稳定，但传入 Kafka 事件的激增是确定负载的真正指标。在这种情况下，自动伸缩应该理想地对入站事件的速率或消息积压做出响应。\n- **电子商务交易：** 在电子商务框架中，特殊销售活动可能会导致订单结帐激增。CPU 可能不受影响，但真正的负载可能是数据库队列中积累的未处理订单。\n- **流数据管道：** 从平台（如 Apache Kafka 或 AWS Kinesis）处理数据流的应用程序会经历可变的数据流入率。在这里，相关的指标可能是处理的积压或滞后，而不是 CPU 或内存消耗。\n- **Selenium 测试工作者：** 在持续集成（CI）流水线中，当提交新代码时，可能会触发一系列 Selenium 测试。这里真正的度量标准可能是等待测试的队列。如果有大量等待测试的测试存在瓶颈，基于这个队列来自动伸缩 Selenium 工作者比仅仅观察 CPU 或内存指标更有效。\n- **API 速率限制：** 对于大量依赖第三方 API 且具有速率限制的应用程序，接近速率限制可能是需要进行伸缩的信号。与对速率限制错误的被动反应不同，基于 API 调用频率进行主动伸缩可以确保操作顺利进行。\n\n这样多样化的现实场景强调了需要一种多功能的自动伸缩解决方案，能够理解并响应多种度量标准。KEDA 凭借其灵活性和适应性有效地应对了这些挑战。\n\n### 5. 结论：KEDA 自动伸缩的未来\n\n尽管 Kubernetes 拥有原生的自动伸缩工具如 HPA 和 VPA，以及像 Prometheus 适配器这样的扩展，但它们通常伴随着复杂性。而 KEDA 提供了一个简单的平台，适用于各种各样的自动伸缩需求。它处理事件驱动的扩展，包括缩减到零，这是一个重大优势。此外，设置 KEDA 更加简单，减少了用户在处理 Kubernetes 自定义指标时通常会遇到的典型障碍。\n\nKEDA 的活跃社区证明了它的实用性。对该项目的定期贡献、像 Kedify 或 Microsoft 这样的供应商以及不断增加的[企业采用](https:\/\/keda.sh\/community\/#end-users)显示出它在 Kubernetes 生态系统中日益重要。\n', '\/trans\/battle-of-the-pods-kubernetes-autoscaling-showdown-keda-vs-vanilla-kubernetes\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文比较了 Kubernetes 的内置自动伸缩器（HPA 和 VPA）和 KEDA 项目的优缺点，分析了它们在不同场景下的适用性和效果，展示了 KEDA 如何解决 HPA 和 VPA 无法覆盖的复杂需求。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/why-the-latest-advances-in-opentelemetry-are-significant/">[译] OpenTelemetry 的最新进展及其对可观测性的影响</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/01/12</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e5%8f%af%e8%a7%82%e6%b5%8b%e6%80%a7"> 
             可观测性
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://thenewstack.com/why-the-latest-advances-in-opentelemetry-are-significant" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('OpenTelemetry 的最新进展及其对可观测性的影响', 'OpenTelemetry 是一个标准化观测性和遥测数据格式的项目，支持多种工具的互操作。本文介绍了该项目的新特性，如新的转换语言、日志支持和自动化修复能力。', '\n今年，在云原生计算基金会（Cloud Native Computing Foundation）中，一个备受关注的项目是[OpenTelemetry](https:\/\/thenewstack.io\/observability-in-2024-more-opentelemetry-less-confusion\/)和[OpenTelemetry Collector](https:\/\/thenewstack.io\/how-the-opentelemetry-collector-scales-observability\/)。这个项目是观测领域的一个非常令人兴奋的运动，旨在跨行业合作，达成观测和遥测的标准数据格式。\n\n这本身就非常重要，因为它允许多个观测和分析工具进行互操作，而以前的团队如果想要一个工具与另一个工具进行互操作，就必须多次转换数据。随着观测领域围绕人工智能\/机器学习的炒作，公司更有可能从一个系统中存储和查看数据，然后在另一个系统中进行机器学习模型的训练。\n\n更棒的是，由于行业供应商和个人在[OpenTelemetry Collector](https:\/\/opentelemetry.io\/docs\/collector\/)上合作，这个项目继续不断发展。它是一个标准化的代理和遥测收集器，提供高吞吐量的遥测数据收集和分析。该收集器已经支持跟踪和度量数据一段时间了，但直到去年的[KubeCon Detroit 2022](https:\/\/thenewstack.io\/kubeconcloudnativecon-2022-rolls-into-detroit\/)，社区才吸纳了 OpenLogs 项目，并开始实施日志收集和分析功能。现在，日志支持已经完全成熟。\n\n在接下来的部分中，我将分享一些关于这个项目的新特性以及它们对社区的重要性。\n\n## 1. 新的转换语言\n\n我发现许多代理的语法使得进行有意义的转换非常困难，需要使用一些奇怪的 YAML 或 TOML。Otel Collector 仍然依赖于 YAML 格式，但它的新转换语言允许使用基于函数的语句，执行起来非常快速，可以管理复杂性。查看一些[语法示例](https:\/\/github.com\/open-telemetry\/opentelemetry-collector-contrib\/blob\/main\/pkg\/ottl\/README.md)。\n\n## 2. 日志正式发布\n\n在大约一年的开发时间内，日志收集和分析现在已经正式发布。该实施有一些收集日志的方法：\n\n- 首先，它作为一个独立的代理运行，并从文件系统收集日志。它可以直接发送到最终目的地，也可以转发到以收集器模式运行的 OpenTelemetry Collector，可以即时计算日志指标。\n- 其次，存在许多日志 SDK，可以直接在应用程序中实施，并将日志发送到中央收集器或直接发送到最终目的地，这有助于减少磁盘 IO 的影响。\n\n## 3. 自动仪器成熟度\n\n自动仪器是自动将应用程序连接到发出跟踪和度量数据而无需或仅需进行最少代码更改的能力。Java 和.Net 得到了全面支持，其他语言正处于不同开发和发布阶段。这个功能是一些专有解决方案展示出来的特色，因为它通过减少开发人员的时间来降低部署复杂性，现在它将同样强大的功能带到了 OpenTelemetry 生态系统中。\n\n## 4. 语义约定\n\n这一点非常重要，并且正在从 ElasticSearch 向 OpenTelemetry 项目捐赠 ECS（Elastic Common Schema）而受益。规范化日志和遥测结构具有挑战性，因为似乎几乎每个人都以稍微不同的格式生成遥测数据；但要能够分析、创建警报并以人性化的方式呈现数据，所有遥测字段都需要以某种方式映射。如果每个人和每个系统都略有不同，那么在创建可重用的仪表板和组件方面就会出现挑战。现在，软件供应商可以负责在多个平台上创建仪表板，合理地确保数据将以多个平台上的正确格式进行发送。与此同时，我们管理大量遥测数据的人可以通过使用众所周知的字段名称来提高摄取和查询效率，并且在大多数客户发送的内容依赖于这些字段名称时，可以提供更高级的功能，同时减少计算资源和内存开销。\n\n完整的架构仍然需要一段时间才能最终确定，但逐步正在批准这些约定。例如，在 KubeCon 上，他们宣布了 HTTP 架构的最终确定。\n\n## 5. 插件框架和生态系统\n\n生态系统正在不断成熟。可扩展性框架允许自定义任何摄取管道\n\n的任何阶段。有越来越多的接收器用于各种系统，处理器具有越来越先进的功能，目标也在增加。我特别对新版本的 OpenSearch 扩展感到兴奋，它可以发送预打包在简化的遥测或 ECS 格式中的日志数据。\n\n从开发者的角度来看，我发现模式和内部“p”消息模式的结构非常周到，内置了 protobuf。它在功能自由度和最小复杂度之间有一个良好的平衡。\n\n## 6. 社区合作\n\n这对于 CNCF 社区来说并不是很新鲜，但这个项目的速度和影响体现了 CNCF 社区哲学的精神。竞争公司正在共同努力，使计算的一部分变得更好、更容易，以造福我们其他人。有些人可能担心去除供应商锁定会导致客户离开，或者共享代码可能泄漏专有 IP。\n\n然而，在遥测领域，代理和收集器的核心架构通常是已解决的问题。那么为什么不制作一些遵循惯例并在各个平台上运行的东西，以便公司不再必须维护代理代码，其中 80% 都是重复的呢？这使公司可以在互操作性和创新可以通过这个框架传递的专有处理器方面共同开发插件。好处也延伸到所有运营商和软件供应商。借助标准化的 Otel Collector SDK，供应商可以创建一个单一的集成来为其应用程序添加遥测，并极大简化了收集过程，试图让所有主要的观测提供商为你的应用程序实施支持。\n\n运营商也从“随处收集”和“随处发送”的理念中受益。通过标准的配置文件格式简化了设置，减少了新系统的引入复杂性。我还怀疑，许多日志系统的运营商在观测数据的语义约定项目减少了许多问题后，将大大减少字段映射的基数问题。\n\n## 总结\n\n向所有项目贡献者和社区成员表示衷心的“感谢”！这里有太多人要列出来了，但你可以在[GitHub 上的 OpenTelemetry 项目](https:\/\/github.com\/open-telemetry\/community\/blob\/main\/community-members.md)上找到他们。\n\nOpenTelemetry 和 OpenTelemetry Collector 的功能和未来路径正在以极快的速度前进，过去一年是 CNCF 组合中贡献第二多的项目，仅次于 Kubernetes。有这么多贡献者保持组织和合作，成熟度将继续加速。这将有望通过增加互操作性并简化仪表系统的仪器化过程来促进观测领域的创新。\n', '\/trans\/why-the-latest-advances-in-opentelemetry-are-significant\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">OpenTelemetry 是一个标准化观测性和遥测数据格式的项目，支持多种工具的互操作。本文介绍了该项目的新特性，如新的转换语言、日志支持和自动化修复能力。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/application-traffic-with-ebpf/">[译] 用 eBPF 洞察应用层网络流量</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/01/10</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e5%85%b6%e4%bb%96"> 
             其他
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://thebsdbox.co.uk/2023/12/08/Application-traffic-with-eBPF/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('用 eBPF 洞察应用层网络流量', '本文介绍了如何使用 eBPF 程序捕获、分析和修改应用层的网络数据，包括 HTTP 头部和 URL 路径。作者还展示了如何使用 eBPF map 在内核和用户空间之间传递数据。', '在[先前的帖子](..\/ebpf-adventures-in-networking\/)中，我稍微谈到了建立 eBPF 知识，以开始更多地了解网络适配器的输入和输出情况。基本上，将以太网帧并剥离标头（以太网标头\u002bIP 标头\u002bTCP\/UDP 标头），最终你将得到来自应用程序或数据角度的数据包中剩余的内容。\n\n所有的代码都在“学习 eBPF”存储库中，具体的 eBPF 代码在[这里](https:\/\/github.com\/thebsdbox\/learning-ebpf\/blob\/main\/ebpf\/http\/http.c)。这篇文章的计划是逐步介绍我认为有用或可能重要的部分...\n\n**注意**：此代码确实对入口\/出口数据包进行了一些修改，因此需要 6.1\u002b 的 Linux 内核才能使用一些 eBPF 助手函数。\n\n## 映射！\n\n你可能以前遇到过这些吧？如果没有，不用担心！简而言之，eBPF 映射是在用户空间和内核中的 eBPF 程序之间通信的机制。在我看来，非常酷的一点是这些映射使用键和值...所以我不必循环比较数据并寻找匹配的内容，我传递一个键，如果有匹配的内容，我就得到相应的数据:D\n\n下面是我将要使用的映射，称为\u0060url_map\u0060，键是 20 个字符长（可以说是有界的“字符串”），分配给该键的值是我在上面定义的结构体。\n\n\u0060\u0060\u0060\n\/\/ 定义与键关联的不同URL\nstruct url_path {\n  __u8 path_len;\n  __u8 path[max_path_len]; \/\/ 这应该是一个char，但在这里和Go之间的代码生成有点不同...\n};\n\n\/\/ 定义我的URL映射\nstruct {\n  __uint(type, BPF_MAP_TYPE_HASH);\n  __uint(max_entries, 1024);\n  __type(key, char[max_path_len]);\n  __type(value, struct url_path);\n}\nurl_map SEC(\u0022.maps\u0022);\n\u0060\u0060\u0060\n\n## eBPF 程序！\n\n代码中定义了两个 eBPF 程序\u0060tc_egress\u0060和\u0060tc_ingress\u0060，如果你能猜到它们是如何连接的，那就加分！在这篇文章中，我们只关注\u0060tc_ingress\u0060程序。\n\n就像我们在已经存在的众多示例中看到的那样，我们需要进行标头识别的操作。\n\n1. 进行合理性检查，并将\u0060data\u0060强制转换为\u0060ethhdr\u0060类型（[以太网标头](https:\/\/en.wikipedia.org\/wiki\/Ethernet_frame)）。\n2. 通过读取以太网标头内部的\u0060h_proto\u0060（也称为\u0060Ethertype\u0060）来查找以太网帧内部的协议。\n3. 将以太网标头后的数据强制转换为\u0060iphdr\u0060类型（[IP 标头](https:\/\/en.wikipedia.org\/wiki\/Internet_Protocol_version_4#Header)）。\n4. 在 IP 标头内查找协议，我们还需要确定 IP 标头的大小（原来它们可以有不同的大小！\u0060¯\\_(ツ)_\/¯\u0060）。\n5. 为了确定标头的大小，我们将其值乘以四，你可能会问为什么！好吧，这个值乘以 32 位以确定标头的大小，所以如果值为 6，那么标头将是 192 位（或 24 字节）。所以，为了简单地确定 IP 标头的字节数，我们可以将这个值乘以 4！\n6. 将以 IP 标头后的数据强制转换为\u0060tcphdr\u0060类型（[TCP 标头](https:\/\/en.wikipedia.org\/wiki\/Transmission_Control_Protocol#TCP_segment_structure)）。\n7. 像步骤（5）一样，我们需要确定 TCP 标头的大小（它也可以是动态的），在这里的步骤也是一样的，我们只需要将值\u0060doff\u0060乘以四来确定标头的大小（以字节为单位）。\n8. 通过计算所有这些，我们现在可以推断出数据位于以太网标头大小、IP 标头大小和 TCP 标头大小的末尾。\n9. 最后，我们可以通过从 IP 标头中减去 IP 和 TCP 标头的大小来确定应用程序数据的大小，使用\u0060tot_len\u0060（总长度）。\n\n### 应用数据！！\n\n为了读取这些数据，我们将需要上面提到的一些东西！\n\n首先，我们需要数据偏移量（数据起始位置），它位于以太网标头\u002bIP 标头大小（一旦计算出来）和 TCP 标头（再次，一旦计算出来）之后。我们还需要一个缓冲区来存储我们将从套接字缓冲区中读取的数据。\n\n\u0060\u0060\u0060c\n\/\/ 用于存储我们应用程序数据的数据缓冲区\nchar pdata[60];\n\n\/\/ 计算数据实际位置的偏移量\npoffset = ETH_HLEN \u002b ip_hlen \u002b tcp_hlen;\n\n\/\/ 从套接字缓冲区加载数据，poffset 从 TCP 标头的末尾开始\nint ret = bpf_skb_load_bytes(skb, poffset, pdata, 60);\nif (ret != 0) {\n   return 0;\n}\n\u0060\u0060\u0060\n\n我们使用\u0060bpf_skb_load_bytes\u0060从套接字缓冲区（\u0060skb\u0060）中读取一定量的数据（60 个字节）到我们的缓冲区（\u0060pdata\u0060），起始位置是我们知道数据位于的偏移量（\u0060poffset\u0060）！\n\n此时，我们有了 60 字节的数据，应该足够让我们编写一些代码来理解它。\n\n### HTTP 数据 :-)\n\n让我们看看当我们尝试进行 HTTP 请求时会发生什么！\n\n\u0060\u0060\u0060plaintext\n ~ curl code\/test -vvv\n*   Trying 192.168.0.22:80...\n* Connected to code (192.168.0.22) port 80 (#0)\n\u003e GET \/test HTTP\/1.1\n\u003e Host: code\n\u003e User-Agent: curl\/7.87.0\n\u003e Accept: *\/*\n\n...\n\u0060\u0060\u0060\n\n我正在使用\u0060curl\u0060从主机\u0060code\u0060（code 是我的开发 VM，运行 code-server）请求 URL \u0060\/test\u0060。我们可以看到发送到服务器的数据（每行以\u0060\u003e\u0060开头，用于确定通信的方向）。HTTP 请求中的第一行数据通常是一个*动词*，后面是我们希望与之交互的资源，然后是 HTTP 规范和回车符，如[HTTP 标准](https:\/\/en.wikipedia.org\/wiki\/HTTP#HTTP\/1.1_request_messages)中定义。因此，我们可以看到我们关心的行是\u0060GET \/test\u0060（在这一点上，我们\/我不太关心 HTTP 规范:D）。\n\n第一步是读取\u0060pdata\u0060的前三个字符，查找\u0060pdata[0] == G\u0060，\u0060pdata[1] == E\u0060和\u0060pdata[2] == T\u0060，这将有效地帮助我们确定首先是否是 HTTP 请求，特别是是否是 HTTP 请求！\n\n一旦我们验证了这前 3 个字节，我们将想要从第 4 个字节（请求的前三个字节加上一个用于分隔的空格）开始读取更多数据！\n\n\u0060\u0060\u0060c\nchar path[max_path_len];\nmemset(\u0026path, 0, sizeof(path));\n\nint path_len = 0;\n\n\/\/ 查找请求 URI（从偏移量 4 开始），以空格结束\nfor (int i = 4; i \u003c sizeof(pdata) ; i\u002b\u002b)\n{\n    if (pdata[i] != \u0027 \u0027) {\n        path[i-4] = pdata[i];\n    } else {\n        path[i-4] = \u0027\\0\u0027;\n        path_len = i-4;\n        break;\n    }\n}\n\u0060\u0060\u0060\n\n上面的函数将从 HTTP 数据的第 4 个字节开始（从第 4 个字节开始）读取其余的数据，直到遇到空格为止，留下我们要\u0060GET\u0060的 URL！我们可以通过一个调试打印语句来验证这一点：\n\n\u0060\u0060\u0060c\nbpf_printk(\u0022\u003c- incoming path [%s], length [%d]\u0022, path, path_len);\n\u0060\u0060\u0060\n\n这将在日志中显示如下：\n\n\u0060\u0060\u0060plaintext\n\u003cidle\u003e-0       [001] dNs3. 2252901.017812: bpf_trace_printk: \u003c- incoming path [\/test], length [5]\n\u0060\u0060\u0060\n\n### 对 HTTP 应用程序请求采取行动\n\n上述解释详细说明了我们如何读取数据以及如何读取数据，但如果我们想要“动态”查找 HTTP 请求，我们将需要使用 eBPF 映射。\n\n在我们的 Go 用户空间代码中，我们执行以下操作：\n\n\u0060\u0060\u0060go\npath := flag.String(\u0022path\u0022, \u0022\u0022, \u0022The URL Path to watch for\u0022)\nflag.Parse()\n\n\/\/ ...\n\n\/\/ 创建一个 uint8 数组\nvar urlPath [20]uint8\n\/\/ 将我们的字节复制到 uint8 数组中（我们可以进行类型转换）\ncopy(urlPath[:], *path)\n\n\/\/ 将我们的 urlPath 作为键\nerr = objs.UrlMap.Put(urlPath,\n  bpfUrlPath{\n    Path:    urlPath,\n    PathLen: uint8(len(urlPath)),\n  })\nif err != nil {\n  panic(err)\n}\n\u0060\u0060\u0060\n\n正如我们在上面的代码中看到的，当我们启动 Go 程序时，它将从标志\u0060-path\u0060中读取，并将其用作我们 eBPF 映射中的**键**，可以暂时忽略值。\n\n\u0060\u0060\u0060c\nstruct url_path *found_path = bpf_map_lookup_elem(\u0026url_map, path);\nif (found_path \u003e 0) {\n    bpf_printk(\u0022Looks like we\u0027ve found your path [%s]\u0022, path);\n    \/\/ 可能进行更多操作，阻止流量或重定向？\n}\n\u0060\u0060\u0060\n\n在我们的 eBPF 程序中，我们将对 HTTP 请求进行映射查找，如果该请求作为 char 数组存在于**键**中，那么我们就可以对其进行操作！\n\n现在启动我们的 Go 程序 \u0060sudo .\/http -interface ens160 -path \/test\u0060 将得到以下结果：\n\n\u0060\u0060\u0060plaintext\nINFO[0000] Starting 🐝 the eBPF HTTP watcher, on interface [ens160] for path [\/test]\nINFO[0000] Loaded TC QDisc\nINFO[0000] Press Ctrl-C to exit and remove the program\n          \u003cidle\u003e-0       [001] d.s3. 2252901.015575: bpf_trace_printk: \u003c- 0.0.0.0:56345 -\u003e 0.0.0.0:80\n          \u003cidle\u003e-0       [001] D.s3\n\n. 2252901.015642: bpf_trace_printk: -\u003e 192.168.0.22:80 -\u003e 192.168.0.180:56345\n          \u003cidle\u003e-0       [001] d.s3. 2252901.017552: bpf_trace_printk: \u003c- 0.0.0.0:56345 -\u003e 0.0.0.0:80\n          \u003cidle\u003e-0       [001] d.s3. 2252901.017793: bpf_trace_printk: \u003c- 0.0.0.0:56345 -\u003e 0.0.0.0:80\n          \u003cidle\u003e-0       [001] dNs3. 2252901.017812: bpf_trace_printk: \u003c- incoming path [\/test], length [5]\n          \u003cidle\u003e-0       [001] dNs3. 2252901.017814: bpf_trace_printk: Looks like we\u0027ve found your path [\/test]\n\u0060\u0060\u0060\n\n## 结论\n\n解析 HTTP 并不太困难，因为它是一个相对简单的协议，它使用简单的动词和结构的简单方法，使用空格和回车符来区分。这种方法可能也适用于其他协议，如 DNS、POP3 或 SMTP。当数据加密时，我们需要一种解密的方法，然后才能解析数据（这超出了我的能力...）。但是，我希望这会激发你更多地尝试使用 eBPF 来解析和操作应用程序的想法！\n\n我一直想写一些有希望有用的关于 eBPF 的帖子，尽管通常在我想出可能有用的东西之后，别人已经抢先一步。鉴于我已经在一段时间里以某种方式关注网络，这基本上是我关注的领域，尽管我确实为最近的 eBPF 峰会 2023 编写了一些有趣的内容。如上所述，有很多人开始撰写 eBPF 内容，所以我可能会参考他们的帖子，而不是重复内容。\n', '\/trans\/application-traffic-with-ebpf\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文介绍了如何使用 eBPF 程序捕获、分析和修改应用层的网络数据，包括 HTTP 头部和 URL 路径。作者还展示了如何使用 eBPF map 在内核和用户空间之间传递数据。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/ebpf-adventures-in-networking/">[译] 如何用 eBPF 改变网络编程的游戏规则</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/01/10</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e5%85%b6%e4%bb%96"> 
             其他
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://thebsdbox.co.uk/2023/11/18/eBPF-adventures-in-networking/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('如何用 eBPF 改变网络编程的游戏规则', '这篇文章介绍了 eBPF 在网络领域的一些应用和实践，包括 XDP、TC 和 sysprobes 三种不同的 eBPF 程序挂载方式的优缺点，以及如何使用 eBPF 实现网络数据的捕获、分析和修改。作者还分享了一些有用的 eBPF 工具和资源，以及自己开发的一个 eBPF 网络代理的项目。', '\n我一直想写一些关于 eBPF 的帖子，希望它们能有所帮助，尽管通常在我想到可能有用的东西时，其他人已经先我一步了。鉴于我已经在网络方面集中精力一段时间，这基本上是我专注的领域，尽管我确实设法为最近的 eBPF 峰会 2023 准备了一些我认为很有趣的东西。正如我之前提到的，有很多人开始撰写关于 eBPF 的内容，因此我可能会参考他们的帖子，而不是重复内容。\n\n我将从一些在 Linux 内核中可能或可能不会遇到的首字母缩写或技术开始。但基本上从我的角度来看，这些是你修改正在运行的系统以与网络数据交互的主要选项。\n\n### XDP\n\n关于 eXpress Data Plane 已经存在大量信息，因此我不会深入探讨太多细节。\u0060tl;dr\u0060是 XDP eBPF 程序挂钩到 XDP 将使其能够访问由内核自身处理之前的传入网络帧。在某些情况下，eBPF 程序将加载到 NIC 驱动程序本身中，这将有效地将程序卸载到 NIC 本身。\n\n### 优点\n\n- 最佳性能\n- 非常适用于防火墙、DDoS 防护或负载均衡等用例\n- 在任何其他内容进行修改之前看到传入的流量\n\n### 缺点\n\n- 仅支持入站流量，使用 XDP 程序看到的任何流量都只是传入流量，目前无法看到出站流量\n- 使用\u0060XDP\u0060数据结构，与大多数套接字编程的默认数据结构\u0060SKB\u0060有一些不同。\n\n### TC（Traffic Control）或流量控制\n\nTraffic Control 是内核网络结构的一个重要组成部分，主要包括添加诸如 qdisc 和过滤器之类的功能到接口的能力。qdisc 主要集中在为 TBD（待定）提供服务，而过滤器通常在底层实际上是一个 eBPF 程序。\n\n常见的工作流程是：\n\n1. 创建一个关注入口或出口的 qdisc，或者替换一个现有的 qdisc。qdisc 将附加到接口上。\n2. 加载你的 eBPF 程序。\n3. 创建一个过滤器，将其附加到通过接口上的 qdisc 上的入口或出口之一。该过滤器将与 eBPF 程序相关联，这意味着所有传入或传出的流量现在都会通过一个程序运行（如果连接）。\n4. 获利 💰\n\n### 优点\n\n- 提供入口和出口的挂钩点\n- 使用传统的\u0060SKB\u0060数据结构\n\n### 缺点\n\n- 将 TC 程序附加到入口或出口队列稍微复杂一些。用户需要使用 qdisc 来做到这一点，某些 eBPF SDK 不会原生支持 TC 程序的使用。\n- TC eBPF 程序看到的流量可能已经被之前的 XDP 程序或内核本身修改。\n\n### 系统调用\n\n与其他两种专门设计用于处理网络的方法相比，这可能会显得有些奇怪，因为它是将一些 eBPF 代码附加到内核中的系统调用的一种替代方法，具体来说是\u0060tcp4_connect()\u0060 \/ \u0060tcp6_connect()\u0060等调用。这在协议栈中略微靠后，因为在此时，传入数据包已经经过了很多内核逻辑，而 eBPF 内省点是当流量即将与应用程序本身交互时。\n\n## 编写网络程序！\n\n所以在这一点上，我们（希望）意识到我们有许多不同的入口点，允许我们在“传送带”上注入我们的代码，这个传送带从 NIC 开始，一直到应用程序（以及在出站的情况下）。\n\n### 回顾\n\n在我们所谓的“传送带”的开头，我们可以附加我们的 XDP 程序并获得未经触碰的原始网络数据。在“传送带”的中间，我们的 TC 程序将成为通过内核的路径的一部分，并接收可能被修改的网络数据。在传送带的末端，我们可以将代码附加到应用程序将在它被运行之前获取网络数据的函数，这些函数可以在传送带的末端进行附加。\n\n### 数据表示\n\n你的程序附加到的位置决定了两个主要事物，一个是潜在的流量修改的相对级别，另一个是流量的表示方式。\n\n### XDP 结构\n\n我会写关于它的内容，但是 DataDog 已经做了，你可以在[这里](https:\/\/www.datadoghq.com\/blog\/xdp-intro\/#the-flow-of-an-xdp-program)阅读。\n\n### SKB（套接字缓冲区）\n\nSKB 是在 eBPF 添加到内核之前就存在于内核中的数据类型，它已经具备了一些使与 SKB 对象交互变得稍微容易一些的辅助功能。有关更深入的 SKB 介绍，你可以阅读此文 -\u003e http:\/\/vger.kernel.org\/~davem\/skb_data.html\n\n### 解析数据\n\n无论与哪个结构进行交互，它们都共享一些共同之处，这主要是两个变量，对于这两种数据类型来说是相同的。\n\n这些变量是：\n\n- \u0060data\u0060，它是 eBPF 程序接收到的数据的指针\n\n- \u0060data_len\u0060，它是一个整数，指定了有多少数据可用（以帮助确保你永远不会访问\u0060data\u0060超过\u0060data_len\u0060（显而易见的真理 🤓））\n\n所以这一切似乎很简单，但等等... \u0060*data\u0060中实际上有什么？（这取决于你的发现）\n\n通过不断“转换”\u0060*data\u0060并沿着它移动以剥离各种标头，我们可以了解和查找底层数据！\n\n### 转换？\n\n如果你愿意，你可以跳过此部分，但这是一个快速（且糟糕）的示例，说明了我们通常如何将一些原始数据转换为有意义的东西。目前，\u0060*data\u0060将只是一串随机数据，毫无意义，我们需要有效地为其添加“格式”以便我们可以理解其外观。\n\n考虑一下随机数据行：“Bobby0004500100.503 Harvard Drive90210”，其中一些对裸眼来说是有意义的，但有些是不清楚的。\n\n想象一下名为“person”的数据结构：\n\n\u0060\u0060\u0060bash\nName: string\nAge: number\nBalance: float\nStreet: string\nZipCode: number\n\u0060\u0060\u0060\n\n如果我们要将我们的随机数据“转换”为上面的“person”结构，它将突然变成：\n\n\u0060\u0060\u0060bash\nName: Bobby\nAge: 45\nBalance: 100.50\nStreet: 3 Harvard Drive\nZipCode: 90210\n\u0060\u0060\u0060\n\n现在突然间，我能够理解并访问结构中的底层变量，因为它们现在是有意义的，即 person-\u003eName，并且发现此特定的 person 类型对象具有名称变量“Bobby”！\n\n这正是我们将对我们的\u0060*data\u0060所做的！\n\n### 数据中包含什么？\n\n因此，第一步是确定数据是否以以太网帧开头！几乎所有传输的数据都以以太网帧开头，这相当简单，但其作用是具有源和目标硬件地址（无论虚拟化\/容器化\/有线网络还是 WiFi 如何）。因此，我们的第一步是将我们的\u0060*data\u0060转换为类型\u0060ETHHDR\u0060，如果成功，我们现在将能够了解组成以太网头数据类型的变量。这些包括源和目标 MAC 地址，但更重要的是剩余数据的内容是什么。再次，在大多数情况下，以太网头之后的\u0060*data\u0060内容通常是 IP 头，但我们将通过检查以太网帧的 TBD 变量来验证。\n\n一旦我们验证下一组数据是 IP 头，我们将需要将以太网头之后的数据转换为 IPHDR 类型。一旦我们这样做，我们将能够访问 IP 特定的数据，例如源 IP（\u0060saddr\u0060）或目标地址（\u0060daddr\u0060），再次重要的是 IP 头包含一个变量，详细说明了 IP 头之后的数据是什么。这通常是 TCP 头或 UDP 头，但还有其他选择，例如 sctp 等。\n\n一旦我们查看了 IP 头的内部并确定数据类型是 TCP（也可能是 UDP 或其他内容），我们将把以太网头和 IP 头之后的数据都转换为 TCP 头类型！（几乎完成了）。通过访问 TCP 头的内容，我们可以获得 TCP 特定的数据，例如源端口或目标端口，用于验证数据的有效性的校验和以及其他有用的变量。\n\n现在我们几乎拥有一切，但是 TCP 头的长度可能是可变的，因此我们需要通过查看 tcl_len 变量来确定这一点，我们需要将其乘以 4。现在我们拥有了访问最终数据所需的一切！\n\n因此，\u0060*data\u0060指向数据的开头！我们已经确定了以太网头之后是 IP 头，最后是 TCP 头，这意味着\u0060*data \u002b 以太网头 \u002b IP 头 \u002b TCP 头 = 实际应用程序数据！\n\n### 我们可以用这些信息做什么？\n\n当我们解析各种标头时，实际上在 OSI 模型的不同层次上解锁了越来越多的信息！\n\n**[第 2 层]** 以太网头为我们提供了源和目标硬件地址，我们可以使用此信息来潜在地阻止从我们知道危险的源 MAC 地址处理的帧。\n\n**[第 3 层]** IP 头包含源和目标 IP 地址，再次，我们可以像防火墙一样运作，通过使用 eBPF 程序丢弃特定 IP 地址的所有流量。或者，我们可以根据 IP 地址重定向流量，或者甚至在这一层实施负载均衡逻辑，以将流量重定向到其他底层 IP 地址集合。\n\n**[第 4 层]** TCP 或 UDP 标头定义了目标端口号，我们可以使用这些信息来确定应用程序协议是什么（即端口 80 通常意味着剩余的*data 可能是 HTTP 数据）。在这一层，我们通常会执行负载均衡等操作，基于目标（即在多个其他负载均衡器地址之间平衡）。\n\n**[第 7 层]** 正如前面提到的，各种标头集合的末尾的数据是实际的应用程序数据，只要我们知道格式，我们也可以解析它。例如，如果外部 Web 浏览器尝试访问我的计算机上的\u0060\/index.html\u0060并附加了 eBPF 程序，我会解析到 TCP，然后确定它是端口 80，然后应用程序数据应该是 HTTP 格式。我可以通过查看应用程序数据的前三个字符（在所有标头之后）来验证这一点，使用以下伪代码：\n\n\u0060\u0060\u0060bash\nApplicationData = EthernetHDR \u002b IPHDR \u002b TCPHDR \/\/ 将所有标头长度相加以找到数据\nIf ( data[ApplicationData] = \u0022G\u0022 \u0026\u0026 data[ApplicationData\u002b1] = \u0022E\u0022 \u0026\u0026 data[ApplicationData\u002b2] = \u0022T\u0022 ) {\n\t\/\/ 这是一个HTTP GET请求\n\t\/\/ 做一些令人兴奋的事情\n}\n\u0060\u0060\u0060\n\n## 总结\n\n现在我们“有点”理解了这个逻辑，也许我们应该考虑实施一些代码来完成所有这些...但这将是另一天的事情。\n', '\/trans\/ebpf-adventures-in-networking\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">这篇文章介绍了 eBPF 在网络领域的一些应用和实践，包括 XDP、TC 和 sysprobes 三种不同的 eBPF 程序挂载方式的优缺点，以及如何使用 eBPF 实现网络数据的捕获、分析和修改。作者还分享了一些有用的 eBPF 工具和资源，以及自己开发的一个 eBPF 网络代理的项目。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/securing-cloud-natives-most-important-use-cases/">[译] 云原生软件的关键用例安全保障之道</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/01/10</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e4%b8%9a%e6%80%81"> 
             业态
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://www.chainguard.dev/unchained/securing-cloud-natives-most-important-use-cases" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('云原生软件的关键用例安全保障之道', '云原生软件开发意味着为公有云和私有云的特性优化应用和环境。Chainguard 旨在提供不影响开发者体验的软件供应链安全工具，通过提供最小化、强化的容器镜像，让用户能够准确地扫描漏洞并消除 CVE 警报。本文介绍了 Chainguard Images 为 Istio 和 Cilium 这两个云原生基础技术提供的安全增强方案。', '\n摘要：云原生软件开发意味着为公有云和私有云的特性优化应用和环境。Chainguard 旨在提供不影响开发者体验的软件供应链安全工具，通过提供最小化、强化的容器镜像，让用户能够准确地扫描漏洞并消除 CVE 警报。本文介绍了 Chainguard Images 为 Istio 和 Cilium 这两个云原生基础技术提供的安全增强方案。\n\n---\n\n从根本上说，构建云原生软件意味着构建针对公共和私有云特性进行优化的应用程序和环境。开发云原生软件意味着管理一定程度的混乱，这不是所有类型的软件都需要的。\n\n这在新的一年尤其重要，我们可以预期产品将趋向于优先考虑开发者体验，并且平台工程的崛起。良好的工程和工具使开发者可以专注于构建和创新。已经构建的所有内部开发者平台和即将推出的平台都需要尽量将基础设施管理从开发者那里抽象出来。\n\n这正是 Chainguard 想要解决的问题领域，特别是在安全性和漏洞管理方面。我们致力于提供不妨碍开发者体验的工具，以确保软件供应链的安全。我们通过提供最小化、加固的容器镜像来实现这一目标，这使我们的用户可以获得准确的扫描结果，并将 CVE 收件箱警报降至零。\n\n### 推出新的 Chainguard Images 捆绑包，适用于 Cilium 和 Istio\n\n为了实现这一目标，我们密切关注最受欢迎的开源项目，但也关注那些如果经过加固，将为整个开源生态系统提供重要的安全改进的项目。为了在整个生态系统中产生最大的影响，我们应该帮助加固那些作为云原生软件基石的技术。Istio 和 Cilium 正是这样的明显示例，它们是云原生软件生态系统的基础构建模块之一。通过提供新的 Chainguard Images Istio 和 Cilium 捆绑包，我们为这些项目的用户提供了一个安全地将它们引入其构建流程的简便方法。\n\n在任何给定的供应链中，有些原材料比其他原材料更为基础。如果这些原材料得到了妥善保护，那么这将对后续工作产生连锁效应（或者如果你愿意的话，可以说是对整个堆栈产生上下游影响）。\n\nCilium 和 Istio 技术都涵盖了对 Kubernetes 环境具有基础作用的各种用例。Cilium 和 Istio 是两个流行的工具，通过提供流量路由、负载平衡、服务发现等功能来帮助解决这些挑战。这些功能对于确保 Kubernetes 和其他云原生软件部署的顺利、高效和安全运行至关重要。最终，构建云原生软件意味着创建专为云设计的应用程序，而 Cilium 和 Istio 在帮助开发者实现这一目标方面发挥了关键作用。\n\n### Istio 和 Cilium 在云计算中不可或缺的作用\n\n根据 2022 年的 [CNCF 年度调查](https:\/\/www.cncf.io\/reports\/cncf-annual-survey-2022\/)，Istio 是受访者中使用最广泛的服务网格，73% 的受访公司使用它。这种广泛的采用证明了 Istio 在解决各种服务管理挑战方面的有效性，使其成为现代企业寻求构建强大、安全和可扩展的微服务架构的重要工具。Istio 在 GitHub 上拥有超过 34,000 颗星星，使其成为 CNCF 中最受欢迎的项目之一。\n\n从同一份 CNCF 调查中，有 47% 的受访者将 Cilium 作为他们容器编排平台（如 Kubernetes）的首选网络插件。它也受欢迎于网络安全领域，有 43% 的受访者将其用于此目的。eBPF 的未来和力量是不可思议的，所有人都同意这一点。\n\n最近，我们推出了我们的新的 [Chainguard Images 目录](https:\/\/images.chainguard.dev\/)，这是一个公开可用的网站，用户可以在其中浏览我们库存中的所有镜像。在每个 Chainguard\n\n Image 列表中，你将找到有关安装、基础设施、签名和 SBOM 的源数据的相关信息，以及更多其他相关信息。Chainguard Images 目录还包括一个新的[安全通报](https:\/\/images.chainguard.dev\/security)页面，显示用户已知的 CVE，修复的状态等信息。\n\n如果你正在寻找更多关于如何在本地环境中启动 Chainguard Images Cilium 或 Istio 捆绑包的技术指导，请查看 Chainguard 工程师[Nghia Tran](https:\/\/www.linkedin.com\/in\/tcnghia\/)在 Chainguard Academy 上提供的这些方便入门的指南。非常感谢我们的朋友[Isovalent](https:\/\/www.linkedin.com\/in\/feroz-salam-372a4113\/)的 Feroz Salam 在 Cilium Images 方面给了我们帮助，以及多年来帮助我们的 Istio 的[John Howard](https:\/\/www.linkedin.com\/in\/-johnhoward\/)！以下是指南：\n\n- [开始使用 Istio](https:\/\/edu.chainguard.dev\/chainguard\/chainguard-images\/getting-started\/getting-started-istio\/)\n- [开始使用 Cilium](https:\/\/edu.chainguard.dev\/chainguard\/chainguard-images\/getting-started\/getting-started-cilium\/)\n\nChainguard Developer Images 提供了带有 \u0060:latest\u0060 和 \u0060:latest-dev\u0060 标签的免费镜像，供你在开发和测试环境中使用。在新的目录中，每个镜像页面还包括重要的特定于镜像的详细信息，例如版本标签和其他变体，如 FIPS 和长期支持（LTS），这些都适用于购买了这些解决方案的 Chainguard Images 客户。如果你想了解有关我们的 Production Images 中面向企业的功能的更多信息，请[联系我们的团队](https:\/\/www.chainguard.dev\/contact)。\n', '\/trans\/securing-cloud-natives-most-important-use-cases\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">云原生软件开发意味着为公有云和私有云的特性优化应用和环境。Chainguard 旨在提供不影响开发者体验的软件供应链安全工具，通过提供最小化、强化的容器镜像，让用户能够准确地扫描漏洞并消除 CVE 警报。本文介绍了 Chainguard Images 为 Istio 和 Cilium 这两个云原生基础技术提供的安全增强方案。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
          <div class="col-12">
 
 
 
 
 
 
 
 
 
 
 
 <nav aria-label="Page navigation">
   <ul class="pagination justify-content-center">
     
     
     <li class="page-item">
       <a class="page-link" href="/blog/">
         ««
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a href="/blog/page/5/" class="page-link">
         «
       </a>
     </li>
     
     
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item">
           <a href="/blog/page/4/" class="page-link">
             4
           </a>
         </li>
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item">
           <a href="/blog/page/5/" class="page-link">
             5
           </a>
         </li>
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item page-item active ">
           <a href="/blog/page/6/" class="page-link">
             6
           </a>
         </li>
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item">
           <a href="/blog/page/7/" class="page-link">
             7
           </a>
         </li>
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item">
           <a href="/blog/page/8/" class="page-link">
             8
           </a>
         </li>
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
     
     
     <li class="page-item">
       <a href="/blog/page/7/" class="page-link">
         »
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a class="page-link" href="/blog/page/26/">
         »»
       </a>
     </li>
     
   </ul>
 </nav>
 
</div>

        </div>
      </div>
      <!-- sidebar -->
      <aside class="col-lg-4 order-1 order-lg-2 d-none d-sm-block">
          <div class="sidebar">
          <!-- categories -->
<div class="blog-categories mb-4">
  <p class="sidebar-title">
      专栏
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/istio" class="sidebar-item">
            <span>Istio</span>
            <span>(70)</span>
        </a>
      
        <a href="/categories/service-mesh" class="sidebar-item">
            <span>Service Mesh</span>
            <span>(39)</span>
        </a>
      
        <a href="/categories/kubernetes" class="sidebar-item">
            <span>Kubernetes</span>
            <span>(24)</span>
        </a>
      
        <a href="/categories/%e9%9a%8f%e7%ac%94" class="sidebar-item">
            <span>随笔</span>
            <span>(21)</span>
        </a>
      
        <a href="/categories/%e4%b8%9a%e6%80%81" class="sidebar-item">
            <span>业态</span>
            <span>(17)</span>
        </a>
      
        <a href="/categories/%e5%85%b6%e4%bb%96" class="sidebar-item">
            <span>其他</span>
            <span>(17)</span>
        </a>
      
        <a href="/categories/envoy" class="sidebar-item">
            <span>Envoy</span>
            <span>(16)</span>
        </a>
      
        <a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f" class="sidebar-item">
            <span>云原生</span>
            <span>(14)</span>
        </a>
      
        <a href="/categories/ai" class="sidebar-item">
            <span>AI</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%ae%89%e5%85%a8" class="sidebar-item">
            <span>安全</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%bc%80%e6%ba%90" class="sidebar-item">
            <span>开源</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%8f%af%e8%a7%82%e6%b5%8b%e6%80%a7" class="sidebar-item">
            <span>可观测性</span>
            <span>(5)</span>
        </a>
      
        <a href="/categories/%e6%97%85%e8%a1%8c" class="sidebar-item">
            <span>旅行</span>
            <span>(5)</span>
        </a>
  </div>
</div>

<div class="blog-categories mb-4">
  <p class="sidebar-title">
      资料
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/%e5%87%ba%e7%89%88%e7%89%a9" class="sidebar-item">
            <span>出版物</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e7%94%b5%e5%ad%90%e4%b9%a6" class="sidebar-item">
            <span>翻译电子书</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e6%96%87%e6%a1%a3" class="sidebar-item">
            <span>翻译文档</span>
            <span>(7)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>翻译图书</span>
            <span>(6)</span>
        </a>
      
        <a href="/categories/%e5%8e%9f%e5%88%9b%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>原创图书</span>
            <span>(2)</span>
        </a>
      
        <a href="/categories/%e6%95%99%e7%a8%8b%e6%89%8b%e5%86%8c" class="sidebar-item">
            <span>教程手册</span>
            <span>(1)</span>
        </a>
  </div>
</div>





          </div>
      </aside>
      <!-- /sidebar -->
    </div>
  </div>
</section>




<footer>
  
  <div class="footer bg-footer section-sm border-bottom overlay ">
    <div class="container-xl">
      <div class="row">
        <div class="col col-xl-4 d-sm-none mb-2 mb-lg-0 d-xl-block d-none">
          
          <p class="h3 text-white mb-4 text-uppercase">联系</p>
          
          <ul class="list-unstyled">
            
            
            <li class="mb-4 text-color">微信公众号</li>
            
            
            <li class="mb-4"><img src="/images/servicemesher-wechat.webp" width="118px" height="118px" alt="footer image"></li>
            
            
            
          
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">博客</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/blog/hong-kong-trip/">香港——内地的一面的镜子</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/kubecon-china-2024-recap/">KubeCon China 2024 回顾：引领云原生技术的前沿动态</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/black-myth-wukong-game-life/">从黑神话悟空聊起：我心目中的 3A 大作</a></li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">链接</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://istio.io/latest/zh/" target="_blank" rel="noopener noreferrer">
                  Istio 服务网格
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://tetrate.io/?jimmysong" target="_blank" rel="noopener noreferrer">
                  Tetrate 公司
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener noreferrer">
                  云原生学院|Bilibili
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/awesome-cloud-native/" target="_blank" rel="noopener noreferrer">
                  云原生开源项目大全
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://cloudnative.to" target="_blank" rel="noopener noreferrer">
                  云原生社区（中国）
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">教程</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/envoy-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Envoy 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/istio-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Istio 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/kubernetes-handbook/" >
                  Kubernetes 基础教程
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">通知</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/notice/nist-sp-800-233-service-mesh-proxy-models/">资料分享：云原生应用服务网格代理模型的威胁分析指南</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/kubecon-china-2024-panel/">KubeCon China 2024（香港）</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/website-revamp-notice/">网站改版通知</a></li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>

  
  <div class="copyright py-4 bg-footer overlay">
    <div class="container-xl">
      <div class="row">
        <div class="col-sm-6 text-sm-left text-center">
          <p class="mb-0 text-color">© 2017-2024 Jimmy Song 保留所有权利</p>
        </div>
        <div class="col-sm-6 text-sm-right text-center">
          <ul class="list-inline">
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://twitter.com/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-x-twitter text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/contact/" >
                    <i class="fa-brands fa-weixin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://github.com/rootsongjc" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-github text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://linkedin.com/in/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-linkedin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="mailto:rootsongjc@gmail.com" >
                    <i class="fa-solid fa-envelope text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/blog/index.xml" >
                    <i class="fa-solid fa-rss text-white"></i>
              </a>
            </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>


<!-- JS Plugins -->

<script src="/plugins/popper/popper.min.js"></script>

<script src="/plugins/bootstrap/bootstrap.min.js"></script>

<script src="/plugins/slick/slick.min.js"></script>

<script src="/plugins/filterizr/jquery.filterizr.min.js"></script>

<script src="/plugins/search/fuse.min.js"></script>

<script src="/plugins/search/mark.js"></script>

<script src="/plugins/hex_md5/hex_md5.js"></script>

<script src="/plugins/anchor/anchor.min.js"></script>

<script src="/plugins/tocbot/tocbot.min.js"></script>

<script src="/plugins/bigger-picture/bigger-picture.min.js"></script>


<!-- Main Script -->

<script src="/js/script.min.f94c22b1d478bfc9e2e0a7d954429e47b7e6d36edd423758482e04154ae1842e.js"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-ESY906ZWZ0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ESY906ZWZ0');
</script>


<!-- Baidu analysis -->
<meta name="baidu-site-verification" content="g8IYR9SNLF" />


<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?11f7d254cfa4e0ca44b175c66d379ecc";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>




<script>
    anchors.add();
</script>






<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>










<script src="/js/wowchemy-search.min.7a37268e7bbe4a9160c2e4c33b749816.js" type="module"></script>
<script id="search-hit-fuse-template" type="text/x-template">
  <div class="search-hit" id="summary-{{key}}">
    <div class="search-hit-content border-bottom">
      <div class="search-hit-name">
        <div class='search-hit-link'><a href="{{relpermalink}}">{{title}}</a></div>
        <div class="search-hit-metadata d-flex">
            <span class="mr-1"><i class="fa-regular fa-calendar mr-1"></i>{{date}}</span>
            <span class="mr-1"><i class="fa-regular fa-folder-open mr-1"></i>{{section}}</span>
            <span class="d-sm-block d-none"><i class="fa-solid fa-link mr-1"></i>{{relpermalink}}</span>
        </div>
        <div class="search-hit-description">{{snippet}}</div>
      </div>
    </div>
  </div>
</script>



    </body>
</html>
