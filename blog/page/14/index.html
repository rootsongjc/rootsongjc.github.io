<!DOCTYPE html>
<html lang="zh"><head>
  <meta charset="utf-8">
  
  <title>博客 · Jimmy Song</title>
  

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta name="description" content="专注开源技术、云原生与生活随笔的分享与思考。">
  <meta name="author" content="Jimmy Song">
  <meta name="generator" content="Hugo 0.129.0">

  <!-- CSS plugins -->
  
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
  
  <link rel="preload" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" as="style">
  <link rel="stylesheet" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" media="screen">
  

  <!-- Main Stylesheet -->
  
  <link rel="preload" href="/scss/style.min.595949bd12db88434115e2a1e70965cf2928cc646e73acc6437c4cbbc323f585.css" as="style">
  <link rel="stylesheet" href="/scss/style.min.595949bd12db88434115e2a1e70965cf2928cc646e73acc6437c4cbbc323f585.css" media="screen">

  <!-- Bigger picture css -->
  
  <link rel="stylesheet" href="/plugins/bigger-picture/bigger-picture.min.css" media="print" onload="this.media='all'">
  <!--Favicon generate by https://realfavicongenerator.net-->
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="200x200" href="/images/favicon.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">

  <link href='/opensearchdescription.xml' rel='search' title='Content search' type='application/opensearchdescription+xml'/>

  <!--Twitter card-->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="jimmysong.io" />
  <meta name="twitter:creator" content="@jimmysongio" />
  <meta property="og:url" content="https://jimmysong.io/blog/" />
  <meta property="og:title" content="博客 | Jimmy Song" />
  <meta property="twitter:title" content="博客 | Jimmy Song" />

  
  <meta property="og:description" content="专注开源技术、云原生与生活随笔的分享与思考。" />
  <meta property="twitter:description" content="专注开源技术、云原生与生活随笔的分享与思考。" />

  
  <meta property="og:image" content="https://jimmysong.io/images/banner/default.jpg" />
  <meta property="twitter:image" content="https://jimmysong.io/images/banner/default.jpg" />

  
  
</head>
<body>
<header class="fixed-top header">
  
  
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa fa-arrow-circle-up" aria-hidden="true"></i></button>
  
  <div class="navigation w-100 ">
    <div class="container-xl">
      <nav class="navbar navbar-expand-lg navbar-light p-0">
        <a class="navbar-brand" href="/">
            
            <b>JIMMY SONG</b>
            
        </a>
        <button class="navbar-toggler rounded-0" type="button" data-toggle="collapse" data-target="#navigation"
          aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse text-center" id="navigation">
          <ul class="navbar-nav ml-auto">
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/blog">博客</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/book">资料</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/tags">标签</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/notice">公告</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/contact">联系</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/about">关于</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/community/">社区</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener">视频 <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i></a>
              
            </li>
            
            

          
          
          <li class="nav-item">
            
            
            
              
              
                
                
                
                  
                    
                    <a class="nav-link" href="/en/blog/">English</a>
                    
                  
                
              
              
              
                
                  
                    
                    
                  
                
                
                
              
          </li>
          
          
          <!-- search -->
           <button type="button" class="search-btn js-search" id="searchOpen" aria-label="Search">
              <div class="search-container d-flex justify-content-center">
              <span class="search-content">
                  <i class="fa fa-search"></i>
                  <span>搜索</span>
              </span>
              <span class="search-shortcuts d-none d-sm-block">
                  <kbd class="cmd-key">⌘</kbd>
                  <kbd class="k-key">K</kbd>
              </span>
              </div>
          </button>
          
          </ul>
        </div>
      </nav>
    </div>
  </div>
</header>


            <aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between">
        <div class="col-6 search-title">
          <p>站内搜索</p> 
        </div>
        <div class="col-6 col-search-close">
          <div class="js-search" aria-label="关闭"><i class="fa-solid fa-circle-xmark text-muted" aria-hidden="true"></i></div>
        </div>
      </div>

      <div id="search-box">
        <i class="fa-solid fa-magnifying-glass" id="search-icon" aria-hidden="true"></i>
        <input name="q" id="search-query" placeholder="请输入搜索词" autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control" aria-label="请输入搜索词">
        
        <div class="mt-4">
          <span>搜索类型: </span>
          <span>
            <input type="radio" id="all" name="search_type" value="all" checked>
            <label for="all">所有</label>
            
              <input type="radio" id="blog" name="search_type" value="blog">
              <label for="blog">原创</label>
              <input type="radio" id="trans" name="search_type" value="trans">
              <label for="trans">译文</label>
            
            <input type="radio" id="book" name="search_type" value="book">
            <label for="book">资料</label>
            <input type="radio" id="notice" name="search_type" value="notice">
            <label for="notice">公告</label>
          </span>
        </div>
      </div>
      
    </section>
    <section class="section-search-results">
      <div id="search-results-count" class="search-results-count"></div>
      <div id="search-hits">
        
      </div>
    </section>
  </div>
</aside>

        
        
            

<section class="bg-cover page-title-section overlay" style="background-image: url('/images/backgrounds/circle.svg'),url('/images/backgrounds/page-title.webp');background-size: cover;">
    <div class="container-xl">
        <div class="row">
            <div class="col-12">
                <p class="h1">
                    博客
                </p>
                <p class="page-description">
                    专注开源技术、云原生与生活随笔的分享与思考。
                </p>
                
            </div>
        </div>
    </div>
</section>

        


<section class="section-sm book-list-section bg-gray">
  <div class="container-xl">
    <div class="row">
      <div class="col-lg-8 order-2 order-lg-1">
        <div class="row">
          
          
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/container-insights-2022/">[译] 2022 年容器生态系统的 9 大趋势洞察</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/11/07</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e4%b8%9a%e6%80%81"> 
             业态
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://www.datadoghq.com/container-report/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('2022 年容器生态系统的 9 大趋势洞察', 'Datadog 发布最新的容器生态系统趋势洞察。', '\n这项研究建立在 Datadog 以前版本的[容器使用报告](https:\/\/www.datadoghq.com\/container-report-2021\/)、[容器编排报告](https:\/\/www.datadoghq.com\/container-orchestration-2018\/)和[Docker 研究报告](https:\/\/www.datadoghq.com\/docker-adoption\/)的基础上。\n\n现代工程团队继续扩展他们对容器的使用，如今基于容器的微服务应用程序无处不在。不断增长的容器使用正在推动组织采用互补技术来简化他们操作集群的方式，而这种不断扩展的容器环境给组织带来了安全挑战。\n\n**在本报告中，我们检查了数万 Datadog 客户**运行的超过**15 亿个容器**，以了解容器生态系统的状态。继续阅读，了解从最新的实际使用数据中收集的更多见解和趋势。\n\n\u003e “这项调查表明，容器和 Kubernetes 革命正在不断发展壮大。结果揭示了使用容器和 Kubernetes 的云原生组织不仅发展得更快，而且获得了更大的信心——在比以往任何时候都更关键的生产环境中构建和部署更大型的应用程序和工作负载。\n\u003e\n\u003e 得益于云原生生态系统中超过 175,000 名贡献者所推动的创新，云原生组织已为前进的道路做好了准备。他们正在创造可以让各种规模的工程团队都可以构建和运行应用程序的技术，以满足当今应用程序的需求。”\n\u003e\n\u003e — Priyanka Sharma，云原生计算基金会执行董事\n\n## 趋势 1：Kubernetes 继续成为最受欢迎的容器管理系统\n\nKubernetes 比以往任何时候都更受欢迎。如今，近一半的容器组织运行 Kubernetes 来在不断发展的生态系统中部署和管理容器。Amazon Elastic Kubernetes Services (Amazon EKS) Blueprints 和 Amazon EKS Anywhere 等工具以及其他托管 Kubernetes 服务使团队可以轻松地在云中和本地运行 Kubernetes 集群。\n\n![](008vxvgGgy1h7wbyje5nkj30ku0ce757.jpg)\n\n\u003e “在 AWS，我们致力于为客户提供简化的 Kubernetes 体验，以便他们可以轻松管理和扩展集群，同时受益于完全托管的 AWS 服务的安全性和弹性。Amazon EKS Blueprints 和 Amazon EKS Anywhere 等新功能使客户能够更快、更轻松地跨 AWS 和本地环境配置和部署 Kubernetes 集群，因此他们可以在任何需要的地方获得相同、一致的 Amazon EKS 体验，以最好地支持他们的应用程序和最终用户。”\n\u003e\n\u003e — Barry Cooks，Amazon Web Services Kubernetes 副总裁\n\n## 趋势 2：无服务器容器技术在所有主要公共云中继续流行\n\n所有主要云提供商（包括 AWS App Runner、AWS Fargate、Azure Container Apps、Azure Container Instances (ACI) 和 Google Cloud Run）对无服务器容器技术的使用率从 2020 年的 21% 增加到 2022 年的 36%（年初至今）。这与我们在之前的研究中看到的增长相呼应，其中包括 Amazon ECS 用户转向 AWS Fargate。\n\n客户将减少配置和管理底层基础设施的需求列为容器采用无服务器技术的主要原因之一。那些不使用无服务器技术的客户更喜欢从管理自己的基础架构中获得的控制力和灵活性。\n\n![](008vxvgGgy1h7wc0jp6mjj30ku0cewff.jpg)\n\n## 趋势 3：多个云提供商的使用随着组织规模的增加而增加\n\n我们的数据显示，超过 30% 的使用 1,000 台或更多主机的容器组织在多个云中工作，并且组织运行的容器越少，多云使用率最低。此外，我们发现多云组织平均拥有比单云组织更多的容器。\n\n![](008vxvgGgy1h7wc690cy0j30ku0ce750.jpg)\n\n## 趋势 4：Kubernetes Ingress 使用率正在上升\n\n为了大规模管理来自集群外部的请求，管理员经常使用 Ingress 来配置到集群中多个服务的路由。如今，超过 35% 的组织使用 Ingress，自 2020 年 8 月 Kubernetes 1.19 版本发布以来，Ingress 已经普遍可用。\n\n随着我们的客户操作更多的集群和 Pod，他们在路由和网络管理方面面临着越来越复杂的问题。许多 Kubernetes 的早期采用者使用云提供的负载均衡器将流量路由到他们的服务。但 Ingress 通常更具成本效益，并且自发布以来其采用率稳步提高。\n\n[Kubernetes Gateway API](https:\/\/gateway-api.sigs.k8s.io\/)（于 2022 年 7 月完成测试版）是容器网络管理发展的下一步。Gateway API 提供高级网络功能，包括使用自定义资源和使用 API 资源对组织角色建模的面向角色的设计。我们期待看到 Gateway API 是否会取代 Ingress，或者这两种技术是否并排使用。\n\n![](008vxvgGgy1h7wc8i70cdj30ku0cemxs.jpg)\n\n## 趋势 5：服务网格仍处于早期阶段，Istio 主导使用\n\n服务网格提供服务发现、负载均衡、超时和重试，并允许管理员管理集群的安全性并监控其性能。我们之前的研究说明了服务网格的早期采用，我们看到的初始模式基本上没有变化。在我们的客户中，我们主要看到 Istio 和 Linkerd，其中 Istio 的受欢迎程度是 Linkerd 的三倍多。\n\n![](008vxvgGgy1h7wc9fn7llj30ku0cewf3.jpg)\n\n\u003e  “服务网格已经证明了为企业中的流量提供一致的安全性、可观测性和控制的价值。Istio 已明确将自己确立为领先的网格解决方案，我为社区为实现这一目标所做的工作感到自豪。最近完成的对 CNCF 的 Istio 捐赠将在这一成功的基础上发展壮大我们的社区。”\n\u003e\n\u003e ——Louis Ryan，Istio 的联合创始人兼谷歌首席工程师\n\n## 趋势 6：大多数主机使用超过 18 个月的 Kubernetes 版本\n\nKubernetes 每年发布三个新版本，为用户提供新功能、安全改进和错误修复。我们在之前的研究中看到，用户通常更愿意等待一年多才能采用这些新版本。我们从轶事中了解到，一些客户延迟的原因是为了确保他们的集群的稳定性和与 API 版本的兼容性。如今，使用最多的版本是 v1.21，它于 2021 年 4 月发布，并于今年早些时候正式过了生命周期终结日。\n\n![](008vxvgGgy1h7wcb5u0w5j30ku0cemy5.jpg)\n\n## 趋势 7：超过 30% 的运行 containerd 的主机使用不受支持的版本\n\n先前的研究表明 containerd 的使用有所增加，这是组织可以采用的符合 CRI 的运行时之一，因为 Dockershim 正在被弃用。我们发现只有大约 69% 的 containerd 主机使用的是 1.5 或 1.6 版本，这是积极支持的版本。值得注意的是，大约 31% 的 containerd 主机正在使用 1.4 或更早的版本，这些版本已经过了生命周期的终结日。\n\n运行较旧的软件版本会带来有关安全性和合规性的问题，并且在容器运行时的情况下，会带来容器逃逸等漏洞的风险。许多主机使用不受支持的容器运行时版本这一事实凸显了组织在运行适当的工具以维护容器安全性和合规性方面面临的挑战。无服务器容器技术降低了过时运行时的风险和手动更新的负担，这可能是我们看到所有云都转向无服务器容器的原因之一。\n\n![](008vxvgGgy1h7wcc9pjexj30ku0ce74y.jpg)\n\n## 趋势 8：访问管理正在改进，但仍然是一个挑战\n\nKubernetes 管理员使用基于角色的访问控制 (RBAC) 来允许主体（用户、组或服务账户）访问或修改集群中的资源。根据安全最佳实践，主体应该只有必要的权限，并且管理员在授予与升级风险相关的 RBAC 权限时必须谨慎。其中包括允许主体列出所有机密或创建工作负载、证书或令牌请求的权限，这些请求可以允许他们修改自己的权限。\n\n好消息是，随着组织部署更多集群，这些集群中使用过度宽松特权的百分比正在下降。我们怀疑随着组织采用权限审计等安全实践和自动化 RBAC 扫描仪等工具，这一数字正在下降。但是，我们发现大约 40% 的集群仍然使用宽松的权限，这会带来安全风险。\n\n![](008vxvgGgy1h7wcdev59yj30ku0cet9l.jpg)\n\n## 趋势 9：NGINX、Redis 和 Postgres 再次成为最受欢迎的容器镜像\n\n截至 2022 年 9 月，最流行的现成容器镜像是：\n\n1. NGINX：这又是最流行的容器镜像。NGINX 为近 50% 的使用容器的组织提供缓存、负载平衡和代理功能。\n2. Redis：组织可以在容器中部署 Redis，用作键值数据存储、缓存或消息代理。\n3. Postgres：这个关系数据库的使用比去年略有增长。\n4. Elasticsearch：这个高性能的文档存储和搜索引擎仍然是最流行的镜像之一。\n5. Kafka：组织可以通过在容器中部署 Kafka 轻松地将事件流功能添加到应用程序中。\n6. RabbitMQ：RabbitMQ 在基于微服务的应用程序中支持解耦架构。\n7. MongoDB：MongoDB 仍然是最流行的 NoSQL 数据库之一。\n8. MySQL：这个开源数据库的排名比以前低。但是 MySQL 的性能和可扩展性使其在最流行的容器镜像列表中持续占有一席之地。\n9. Calico：Calico 是一个网络提供商，让管理员可以管理其 Kubernetes 集群内网络的安全性。\n10. GitLab：为了帮助团队采用和维护 DevOps 实践，GitLab 提供了存储库管理、问题跟踪和 CI\/CD 管道。\n11. Vault：团队可以使用 Vault 来简化机密管理并帮助维护安全的应用程序。\n\n![](008vxvgGgy1h7wcim7nrxj30ku0cedgh.jpg)\n\n在 Kubernetes StatefulSets 中，我们发现 Redis、Postgres、Elasticsearch、RabbitMQ 和 Kafka 是最常部署的镜像。\n\n![](008vxvgGgy1h7wciyjri3j30ku0cet9d.jpg)\n', '\/trans\/container-insights-2022\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">Datadog 发布最新的容器生态系统趋势洞察。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/why-gateway-api-is-the-future-of-ingress-and-mesh/">Gateway API：Kubernetes 和服务网格入口中网关的未来</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/11/02</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/kubernetes"> 
             Kubernetes
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Gateway API：Kubernetes 和服务网格入口中网关的未来', '本文介绍 Kubernetes 中的入口网关及 Gateway API，入口网关与服务网格融合的新趋势。', '\n本文将以 Kubernetes Ingress、Istio 和 Envoy Gateway 为例，向你介绍 Kubernetes 中的入口网关和 Gateway API，同时介绍 Gateway API 使得 Kubernetes 和服务网格入口网关融合的新趋势。\n\n## 本文观点\n\n- Ingress 作为 Kubernetes 的初代入口网关，它的资源模型过于简单以致于无法适应当今的可编程网络；\n- Gateway API 作为 Kubernetes 入口网关的最新成果，它通过角色划分将关注点分离，并提供跨 namespace 支持使其更适应多云环境，已获得大多数 API 网关的支持；\n- 入口网关（南北向）与服务网格（东西向，集群内路由）存在部分功能重叠，Gateway API 为两者的融合提供了新的参考模型；\n\n## Kubernetes 入口网关的历史\n\n2014 年 6 月 Kubernetes 开源，起初只能使用 NodePort 和 LoadBalancer 类型的 Service 对象来暴露集群内服务，后来才诞生了 [Ingress](https:\/\/kubernetes.io\/zh-cn\/docs\/concepts\/services-networking\/ingress\/)，两年后（Kubernetes 1.2）Ingress API 进入 Beta 版本，随后为了保持其轻量和可移植的特性，Ingress API 相较于 Kubernetes 其他 API 发展得比较缓慢，直到 Kubernetes 1.19 它才升级到 GA。\n\nIngress 的主要目标是用简单的、声明性的语法来暴露 HTTP 应用。你可以在 Kubernetes 中部署多种 Ingress Controller，并在创建 Ingress 的时候通过 IngressClass 指定该网关使用的控制器，或者在 Kubernetes 中设置默认的默认的 IngressClass。Kubernetes 默认只支持 AWS、GCE 和 Nginx Ingress Controller，同时还支持大量的[第三方 Ingress Controller](https:\/\/kubernetes.io\/docs\/concepts\/services-networking\/ingress-controllers\/#additional-controllers)。\n\n下图展示了 Kubernetes Ingress 的工作流程。\n\n![Kubernetes Ingress 工作流程](ingress-flow.svg)\n\n详细流程如下：\n\n1. Kubernetes 集群管理员在 Kubernetes 中部署 Ingress Controller；\n2. Ingress Controller 会持续监视 Kubernetes  API Server 中的 IngressClass 和 Ingress 对象的变动；\n3. 管理员应用 IngressClass 和 Ingress 来部署网关；\n4. Ingress Controller 会根据管理员的配置来创建对应的入口网关并配置路由规则；\n5. 如果在云中，客户端会访问该入口网关的负载均衡器；\n6. 网关将根据 HTTP 请求中的 host 和 path 将流量路由到对应的后端服务；\n\nIstio 同时支持 Ingress 和 Gateway API，下面是一个使用 Istio 入口网关的配置示例，在后文中会使用 Gateway API 创建该配置。\n\n\u0060\u0060\u0060yaml\napiVersion: networking.k8s.io\/v1\nkind: IngressClass\nmetadata:\n  name: istio\nspec:\n  controller: istio.io\/ingress-controller\n---\napiVersion: networking.k8s.io\/v1\nkind: Ingress\nmetadata:\n  name: ingress\nspec:\n  ingressClassName: istio\n  rules:\n  - host: httpbin.example.com\n    http:\n      paths:\n      - path: \/\n        pathType: Prefix\n        backend:\n          service:\n            name: httpbin\n            port: 8000\n\u0060\u0060\u0060\n\n注意：Ingress 的 spec 中必须在 \u0060ingressClassName\u0060 字段中指定使用的 \u0060IngressClass\u0060，否则将无法创建对应的入口网关。\n\n## Kubernetes Ingress 的局限性\n\n虽然 \u0060IngressClass\u0060 实现了入口网关与后台实现的解耦，但是它仍然有着巨大的局限性：\n\n- Ingress 的配置过于简单，仅支持 HTTP 协议路由；\n- HTTP 路由仅支持 host 和 path 匹配，对于高级路由功能没有通用配置，只能通过 annotation 来实现，比如[使用 Nginx Ingress Controller 实现 URL 重定向](https:\/\/help.aliyun.com\/document_detail\/86533.html#section-xsg-g5g-1uy)，需要配置 \u0060nginx.ingress.kubernetes.io\/rewrite-target\u0060 annotation，已经无法适应可编程路由的需求；\n- 不同命名空间中的服务要绑定到同一个网关中的情况在实际情况下经常出现，而入口网关无法在多个命名空间中共享；\n- 入口网关的创建和管理的职责没有划分界限，导致开发者不仅要配置网关路由，还需要自己创建和管理网关；\n\n## Kubernetes Gateway API\n\nGateway API 是一个 API 资源的集合 —— \u0060GatewayClass\u0060、\u0060Gateway\u0060、\u0060HTTPRoute\u0060、\u0060TCPRoute\u0060、\u0060ReferenceGrant\u0060 等。Gateway API 暴露了一个更通用的代理 API，可以用于更多的协议，而不仅仅是 HTTP，并为更多的基础设施组件建模，为集群运营提供更好的部署和管理选项。\n\n另外 Gateway API 通过将资源对象分离，实现配置上的解耦，可以由不同的角色的人员来管理，其中的 API 对象如下图所示。\n\n![Gateway API 及角色](gateway-api-roles.svg)\n\n下面是在 Istio 中使用 Gateway API 的示例。\n\n\u0060\u0060\u0060yaml\napiVersion: gateway.networking.k8s.io\/v1alpha2\nkind: Gateway\nmetadata:\n  name: gateway\n  namespace: istio-ingress\nspec:\n  gatewayClassName: istio\n  listeners:\n  - name: default\n    hostname: \u0022*.example.com\u0022\n    port: 80\n    protocol: HTTP\n    allowedRoutes:\n      namespaces:\n        from: All\n---\napiVersion: gateway.networking.k8s.io\/v1alpha2\nkind: HTTPRoute\nmetadata:\n  name: http\n  namespace: default\nspec:\n  parentRefs:\n  - name: gateway\n    namespace: istio-ingress\n  hostnames: [\u0022httpbin.example.com\u0022]\n  rules:\n  - matches:\n    - path:\n        type: PathPrefix\n        value: \/\n    backendRefs:\n    - name: httpbin\n      port: 8000\n\u0060\u0060\u0060\n\n与 Ingress 类似，Gateway 使用 \u0060gatewayClassName\u0060 声明其使用的控制器，该控制器需要平台管理员创建，并允许客户端对 \u0060*.example.com\u0060 域名的请求。应用开发者可以在其服务所在的命名空间中，在此示例中是 \u0060default\u0060 创建路由规则，并通过 \u0060parentRefs\u0060 绑定到 Gateway 上，当然这必须是在 Gateway 明确允许其绑定的情况下（通过 \u0060allowRoutes\u0060 字段中的规则设置）。\n\n当你应用上面的配置后，Istio 会自动为你创建一个负载均衡网关，下图展示了 Gateway API 的工作流程。\n\n![Gateway API 工作流程](gateway-api-flow.svg)\n\n详细流程如下：\n\n1. 基础设施供应商提供了 \u0060GatewayClass\u0060 和 Gateway 控制器；\n2. 平台运维部署 Gateway（可以部署多个，或使用不同的 \u0060GatewayClass\u0060）；\n3. Gateway Controller 会持续监视 Kubernetes  API Server 中的 \u0060GatewayClass\u0060 和 \u0060Gateway\u0060 对象的变动；\n4. Gateway Controller 会根据集群运维的配置来创建对应的网关；\n5. 应用开发者应用 xRoute 并绑定服务上；\n6. 如果在云中，客户端会访问该入口网关的负载均衡器；\n7. 网关将根据流量请求中的匹配条件将路由到对应的后端服务；\n\n从以上步骤中我们可以看出 Gateway API 相比 Ingress 有了明确的角色划分，而且路由规则可以与网关配置解耦，这大大增加了管理的灵活性。\n\n下图展示了流量接入网关后经过处理的流程。\n\n![网关处理流程图](traffic-flow.svg)\n\n从图中我们可以看出路由是与网关绑定的，路由一般与其后端服务部署在同一个命名空间中，如果在不同的命名空间中时，需要在 [\u0060ReferenceGrant\u0060](https:\/\/gateway-api.sigs.k8s.io\/api-types\/referencegrant\/) 中明确赋予该路由跨命名空间的引用权限，例如下面的 \u0060foo\u0060 命名空间中的 HTTPRoute \u0060foo\u0060 可以引用 \u0060bar\u0060 命名空间中的 \u0060bar\u0060 服务。\n\n\u0060\u0060\u0060yaml\nkind: HTTPRoute\nmetadata:\n  name: foo\n  namespace: foo\nspec:\n  rules:\n  - matches:\n    - path: \/bar\n    forwardTo:\n      backend:\n      - name: bar\n        namespace: bar\n---\nkind: ReferenceGrant\nmetadata:\n  name: bar\n  namespace: bar\nspec:\n  from:\n  - group: networking.gateway.k8s.io\n    kind: HTTPRoute\n    namespace: foo\n  to:\n  - group: \u0022\u0022\n    kind: Service\n\u0060\u0060\u0060\n\n目前，Gateway API 仅支持 \u0060HTTPRoute\u0060，\u0060TCPRoute\u0060、\u0060UDPRoute\u0060、\u0060TLSRoute\u0060 和 \u0060GRCPRoute\u0060 还在实验阶段。Gateway API 已经得到了大量的网关和服务网格项目的支持，请[在 Gateway 官方文档中查看支持状况](https:\/\/gateway-api.sigs.k8s.io\/implementations\/)。\n\n## 入口网关与服务网格\n\n服务网格主要关注的是东西向流量，即 Kubernetes 集群内部的流量，但是大部分服务网格同样提供了入口网关功能，例如 Istio。但是 Istio 的功能和 API 过于复杂，在本文中我们就以 SMI 为例来说明入口网关和服务网格的关系。\n\n[SMI](https:\/\/smi-spec.io\/)（Service Mesh Interface）是 CNCF 的孵化项目，开源与 2019 年，它定义了独立于供应商的在 Kubernetes 中运行的服务网格通用标准。\n\n下图说明 Gateway API 与服务网格 API 的重叠点。\n\n![Gateway API 与 SMI 有部分重合](gateway-smi-overlay.svg)\n\n从图中我们可以看到 Gateway API 与 SMI 在流量规范部分有明显的重叠。这些重叠导致同样的功能，需要在 Gateway API 和服务网格中重复实现。\n\n### Istio 服务网格\n\n当然，并不是所有的服务网格是完全符合 SMI 标准，Istio 是目前最流行的服务网格实现，它提供了丰富的流量管理功能，但是没有对这些功能制定单独的策略 API，而是耦合在 \u0060VirtualService\u0060 和 \u0060DestinationRule\u0060 中，如下所示。\n\n**VirtualService**\n\n- 路由：金丝雀发布、基于用户身、URI、Header 等匹配路由等；\n- 错误注入：HTTP 错误代码注入、HTTP 延时注入；\n- 流量切分：基于百分比的流量切分路由；\n- 流量镜像：将一定百分比的流量镜像发送到其他集群；\n- 超时：设置超时时间，超过设置的时间请求将失败；\n- 重试：设置重试策略，如触发条件、重试次数、间隔时间等；\n\n**DestinationRule**\n\n- 负载均衡：设置负载均衡策略，如简单负载均衡、区域感知负载均衡、区域权重负载均衡；\n- 熔断（Circuit Breaking）：通过异常点检测（Outlier Detection）和连接池设置将异常节点从负载均衡池中剔除；\n\n\u0060VirtualService\u0060 主要处理路由相关功能，而 \u0060DestinationRule\u0060 负责集群节点的开合和负载均衡。\n\n### Gateway API 融合 Kubernetes 和服务网格的入口网关\n\n正如上文所述，Gateway API 与服务网格之间有部分功能交集，为了减少重复开发，促成对 Gateway API 与服务网格之间共同关注点的建模，Gateway API 工作组提出了 [GAMMA](https:\/\/gateway-api.sigs.k8s.io\/contributing\/gamma\/)（Gateway API Mesh Management and Administration）倡议。\n\n在该倡议的倡导下，那些在不同网关实现中的细节各不相同的高级流量管理功能，例如超时、重试、健康检查等，全部通过[策略附件](https:\/\/gateway-api.sigs.k8s.io\/references\/policy-attachment\/)（Policy Attachment）的方式将由各个提供商来实现。你可以通过通过 \u0060targetRef\u0060 字段指定策略附件所附加到的资源对象，例如下所示：\n\n\u0060\u0060\u0060yaml\napiVersion: networking.acme.io\/v1alpha1\nkind: RetryPolicy\nmetadata:\n  name: foo\nspec:\n  override:\n    maxRetries: 10\n  default:\n    maxRetries: 5\n  targetRef:\n    group: gateway.networking.k8s.io\/v1alpha2\n    kind: HTTPRoute\n    name: foo\n\u0060\u0060\u0060\n\n在这里例子中重试策略被附加到了名为 \u0060foo\u0060 和 \u0060HTTPRoute\u0060 上。策略附件附加到不同的资源对象上，其生效的优先级也不同，例如 GatewayClass 是集群级的资源，如果策略附件覆盖在它上面的话，将优先生效。\n\n你可以给附加策略指定 \u0060override\u0060 和 \u0060default\u0060 值，其在入口和网格内不同资源上的层次结构的优先级是如下图所示。\n\n![Kubernetes 入口与网格中的覆盖和默认值的优先级](policy-attachment-priority.svg)\n\n目前，Gateway API 正在探索用来处理网格流量，并提出了一些[设计方案](https:\/\/docs.google.com\/document\/d\/1T_DtMQoq2tccLAtJTpo3c0ohjm25vRS35MsestSL9QU\/edit#heading=h.6ks49gf06yii)。\n\n## Envoy Gateway\n\n2022 年 10 月 Envoy Gateway 首个开源版本 [v0.2 发布](\/blog\/envoy-gateway-release\/)，这是一个基于 Envoy 代理的遵循 Gateway API 而创建的网关，[Tetrate](https:\/\/tetrate.io) 是该项目的核心发起者之一。Envoy Gateway 的目标是降低用户采用 Envoy 作为 API 网关的障碍，以吸引更多用户采用 Envoy。它通过入口和 L4\/L7 流量路由，表达式、可扩展、面向角色的 API 设计，使其成为供应商建立 API 网关增值产品的基础。\n\n早在 Envoy Gateway 发布之前，Envoy 作为最流行了云原生代理之一，已被大规模采用，有多款 Gateway 软件基于 Envoy 构建，Istio 服务网格使用它作为默认的 sidecar 代理，并通过 xDS 协议来配置这些分布式代理。在 Envoy Gateway 中，它同样使用 xDS 来配置 Envoy 集群，下图展示了 Envoy Gateway 的架构。\n\n![Envoy Gateway 架构图](envoy-gateway-arch.svg)\n\n基础设施供应商会为你提供 \u0060GatewayGlass\u0060，你可以通过创建一个 Gateway 声明来创建一个 Envoy Gateway，你在 Gateway 中的路由和策略附件会通过 xDS 协议发送给 Envoy 集群。\n\n关于 Envoy Gateway 的进一步介绍，请阅读：\n\n- [使用 Envoy Gateway 0.2 体验新的 Kubernetes Gateway API](https:\/\/cloudnative.to\/blog\/hands-on-with-envoy-gateway\/)\n- [面向未来的网关：新的 Kubernetes Gateway API 和 Envoy Gateway 0.2 介绍](https:\/\/cloudnative.to\/blog\/envoy-gateway-to-the-future\/)\n\n## 总结\n\nGateway API 作为下一代 Kubernetes Ingress API，为 Kubernetes 网关供应商提供一定程度上的 API 规范，在保证其可移植性的前提下丰富了入口网关的功能，同时通过关注点分离方便不同角色的人员对网关进行管理。最后 GAMMA 倡议正在促进服务网格的入口网关与 Gateway API 的融合，策略附件可能将 Gateway API 的功能进一步扩展到东西向网关，我们拭目以待。\n\n## 参考\n\n- [Gateway API - jimmysong.io](\/book\/kubernetes-handbook\/service-discovery\/gateway\/)\n- [一文搞懂 Kubernetes Gateway API 的 Policy Attachment - atbug.com](https:\/\/atbug.com\/explore-k8s-gateway-api-policy-attachment\/)\n- [SMI 与 Gateway API 的 GAMMA 倡议意味着什么？- atbug.com](https:\/\/atbug.com\/why-smi-collaborating-in-gateway-api-gamma\/)\n- [Evolving the Kubernetes Ingress APIs to GA and Beyond - Christopher M Luciano, IBM \u0026 Bowei Du, Google](https:\/\/kccncna19.sched.com\/#)\n', '\/blog\/why-gateway-api-is-the-future-of-ingress-and-mesh\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文介绍 Kubernetes 中的入口网关及 Gateway API，入口网关与服务网格融合的新趋势。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/envoy-gateway-release/">Envoy Gateway 首个正式开源版本介绍</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/10/21</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/envoy"> 
             Envoy
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Envoy Gateway 首个正式开源版本介绍', '今天 Envoy Gateway v0.2 发布，本文将为你介绍什么是 Envoy Gateway，它的架构、快速入门和使用指南。', '\n今年五月 Envoy 社区宣布成立一个新的项目 [Envoy Gateway](https:\/\/github.com\/envoyproxy\/gateway)，经过五个月时间的开发，今天它的首个开源版本 v0.2 发布，本文将为你介绍什么是 Envoy Gateway，它的架构、快速入门和使用指南。\n\n## 什么是 Envoy Gateway？{#what-is-envoy-gateway}\n\nEnvoy Gateway 是一个用于管理 Envoy Proxy 的开源项目，可单独使用或作为 Kubernetes 中应用的网关。它通过了 Gateway API 核心一致性测试，使用 [Gateway API](https:\/\/gateway-api.sigs.k8s.io\/) 作为其唯一的配置语言来管理 Envoy 代理，支持 \u0060GatewayClass\u0060、Gateway、\u0060HTTPRoute\u0060 和 \u0060TLSRoute\u0060 资源。\n\nEnvoy Gateway 的目标是降低用户采用 Envoy 作为 API 网关的障碍，以吸引更多用户采用 Envoy。它通过入口和 L4\/L7 流量路由，表达式、可扩展、面向角色的 API 设计，使其成为供应商建立 API 网关增值产品的基础。\n\nEnvoy Gateway 的核心优势是轻量级、开放、可动态编程，尤其是为后端增加了安全功能，这些优势使得它很适合作为后端 API 网关。\n\n## 架构 {#architecture}\n\n下图展示的是 Envoy Gateway 的架构，图中的阴影部分表示是 Envoy Gateway。你可以通过静态和动态两种方式来配置它，其中的 Provider 是针对不同的供应商开发的。\n\n![Envoy Gateway 架构图](envoy-gateway-arch.svg)\n\n该架构图参考了 [Envoy Gateway 文档](https:\/\/gateway.envoyproxy.io\/contributions\/design\/system-design\/#architecture)。\n\n## 配置流程\n\n下面是配置 Envoy Gateway 的流程：\n\n1. 你可以通过配置文件为其 Provider 提供静态配置（目前仅支持 Kubernetes 和文件方式，将来有可能支持更多不同平台供应商），在 Envoy Gateway 启动后，你还可以通过 Kubernetes 动态配置 Provider；\n2. 这些配置会被 Provider 中的资源监视器看到后应用到 Envoy Gateway 的资源转义器上；\n3. 资源转义器将配置分别转义为针对不同 Provider 开发的基础设施管理器的中间表示（Infra IR）和 xDS 中间表示（xDS IR）；\n4. 两种中间表示（IR）分别应用到其对应的基础设施管理器和 xDS 转义上；\n5. 基础设施通过增删改查（CRDU）Kubernetes Deployment、Service 等资源来运行 Envoy，xDS 管理器通过将 xDS 协议配置 xDS Server 的方式配置 Envoy 代理；\n6. 对于 Envoy 代理的流量请求将应用以上配置并转发到对应的后端；\n\n以上就是对 Envoy Gateway 配置的流程，关于 Envoy 代理设计的更多细节请参考 [Envoy Gateway 文档](https:\/\/gateway.envoyproxy.io\/contributions\/design\/system-design\/)。\n\n## 快速开始 {#quick-start}\n\n下面我们将在 Kubernetes 集群中安装 Envoy Gateway 并部署一个测试网站来看看它是否可以正常运行。\n\n### 前提 {#prerequisites}\n\n在使用 Envoy Gateway 前，请注意它的兼容性问题，参考兼容性矩阵。\n\n| Envoy Gateway 版本 | Envoy 代理版本   | Gateway API 版本 | Kubernetes 最低版本 |\n| ------------------ | ---------------- | ---------------- | ------------------- |\n| v0.2.0             | **v1.23 - 最新** | **v0.5.1**       | v1.24               |\n\n### 安装 {#setup}\n\n因为在 Kubernetes 集群中 Gateway API 不是默认安装的，因此你需要手动安装 Gateway CRD。执行下面的命令安装 Gateway CRD 和 Envoy Gateway：\n\n\u0060\u0060\u0060bash\nkubectl apply -f https:\/\/github.com\/envoyproxy\/gateway\/releases\/download\/v0.2.0\/install.yaml\n\u0060\u0060\u0060\n\n该命令将为你创建 \u0060envoy-gateway-system\u0060、\u0060gateway-system\u0060 两个命令空间，同时创了一系列 CRD。还有一些 Envoy Gateway 运行所需要的 ConfigMap、服务账户、RBAC、角色等。\n\n### 测试 {#test}\n\n执行下面的命令安装 GatewayClass、Gateway、HTTPRoute 和示例应用程序：\n\n\u0060\u0060\u0060 bash\nkubectl apply -f https:\/\/github.com\/envoyproxy\/gateway\/releases\/download\/v0.2.0\/quickstart.yaml\n\u0060\u0060\u0060\n\n端口转发到 Envoy 服务：\n\n\u0060\u0060\u0060bash\nkubectl -n envoy-gateway-system port-forward service\/${ENVOY_SERVICE} 8888:8080 \u0026\n\u0060\u0060\u0060\n\n通过 Envoy 代理 curl 示例应用程序：\n\n\u0060\u0060\u0060bash\ncurl --verbose --header \u0022Host: www.example.com\u0022 http:\/\/localhost:8888\/get\n\u0060\u0060\u0060\n\n你将看到如下输出：\n\n\u0060\u0060\u0060\n*   Trying 127.0.0.1:8888...\n* Connected to localhost (127.0.0.1) port 8888 (#0)\n\u003e GET \/get HTTP\/1.1\n\u003e Host: www.example.com\n\u003e User-Agent: curl\/7.79.1\n\u003e Accept: *\/*\n\u003e\n* Mark bundle as not supporting multiuse\n\u003c HTTP\/1.1 200 OK\n\u003c content-type: application\/json\n\u003c x-content-type-options: nosniff\n\u003c date: Sat, 22 Oct 2022 07:10:34 GMT\n\u003c content-length: 513\n\u003c x-envoy-upstream-service-time: 22\n\u003c server: envoy\n\u003c x-envoy-decorator-operation: backend.default.svc.cluster.local:3000\/*\n\u003c\n{\n \u0022path\u0022: \u0022\/get\u0022,\n \u0022host\u0022: \u0022www.example.com\u0022,\n \u0022method\u0022: \u0022GET\u0022,\n \u0022proto\u0022: \u0022HTTP\/1.1\u0022,\n \u0022headers\u0022: {\n  \u0022Accept\u0022: [\n   \u0022*\/*\u0022\n  ],\n  \u0022User-Agent\u0022: [\n   \u0022curl\/7.79.1\u0022\n  \/\/内容省略...\n },\n \u0022namespace\u0022: \u0022default\u0022,\n \u0022ingress\u0022: \u0022\u0022,\n \u0022service\u0022: \u0022\u0022,\n \u0022pod\u0022: \u0022backend-764c65b4dd-lp6jw\u0022\n* Connection #0 to host localhost left intact\n}\n\u0060\u0060\u0060\n\n如果你看到以上输出就证明你的 Envoy Gateway 安装成功并可正常运行。\n\n如果你的 Kubernetes 集群部署在云上，可以使用云负载均衡器的 IP 地址来访问测试：\n\n\u0060\u0060\u0060bash\nexport GATEWAY_HOST=$(kubectl get svc\/${ENVOY_SERVICE} -n envoy-gateway-system -o jsonpath=\u0027{.status.loadBalancer.ingress[0].ip}\u0027)\ncurl --verbose --header \u0022Host: www.example.com\u0022 http:\/\/$GATEWAY_HOST:8080\/get\n\u0060\u0060\u0060\n\n笔者使用的 GKE，运行上面的命令，\u0060GATEWAY_HOST\u0060 环境变量的值几位负载均衡器的 IP 地址，最后同样可以类似上文的 \u0060curl\u0060 输出。\n\n## Envoy Gateway 中使用的 CRD 简介 {#isito-gateway-crd}\n\n上文说到安装 Envoy Gateway 的时候创建了一系列 CRD，在此我们将简要介绍一下这些 CRD：\n\n- \u0060envoyproxies.config.gateway.envoyproxy.io\u0060：Envoy Proxy API 的 Schema。\n- \u0060gatewayclasses.gateway.networking.k8s.io\u0060：GatewayClass 描述了用户可用于创建 Gateway 资源的一类 Gateways。建议将该资源作为 Gateway 的模板。这意味着一个 Gateway 是基于创建时 GatewayClass 的状态，对 GatewayClass 或相关参数的改变不会向下传播到现有的 Gateway。这项建议的目的是限制 GatewayClass 或相关参数的变化的爆炸半径。如果实现者选择将 GatewayClass 的变化传播给现有 Gateway，实现者必须清楚地记录这一点。每当一个或多个 Gateway 使用一个 GatewayClass 时，实现必须在相关的 GatewayClass 上添加 \u0060gateway-exists-finalizer.gateway.networking.k8s.io\u0060 finalizer。这可以确保与 Gateway 相关的 GatewayClass 在使用中不会被删除。GatewayClass 是一个集群级的资源。\n- \u0060gateways.gateway.networking.k8s.io\u0060：Gateway 通过将 Listener 与一组 IP 地址绑定，代表了一个服务流量处理基础设施的实例。\n- \u0060httproutes.gateway.networking.k8s.io\u0060：HTTPRoute 提供了一种路由 HTTP 请求的方法。这包括通过主机名、路径、标头或查询参数来匹配请求的能力。过滤器可以用来指定额外的处理步骤。后端指定匹配的请求应该被路由到哪里。\n- \u0060referencegrants.gateway.networking.k8s.io\u0060：\u0060ReferenceGrant\u0060 标识了其他命名空间中的资源种类，这些资源被信任为引用与策略相同的名称空间中的指定资源种类。每个 \u0060ReferenceGrant\u0060 都可以用来代表一个独特的信任关系。额外的引用授权可以用来添加到它们所定义的命名空间的入站引用的信任源集合中。Gateway API 中的所有跨命名空间引用（除了跨命名空间的 Gateway-route 附件）都需要一个 \u0060ReferenceGrant\u0060。\n- \u0060referencepolicies.gateway.networking.k8s.io\u0060：该资源已被重新命名为 ReferenceGrant，且将在 Gateway API v0.6.0 中被删除，而采用相同的 ReferenceGrant 资源。\n- \u0060tcproutes.gateway.networking.k8s.io\u0060：TCPRoute 提供了一种路由 TCP 请求的方法。当与 Gateway 监听器结合使用时，它可以用来将监听器指定的端口上的连接转发到 TCPRoute 指定的一组后端。\n- \u0060tlsroutes.gateway.networking.k8s.io\u0060：TLSRoute 资源与 TCPRoute 类似，但可以配置为与 TLS 特定的元数据相匹配。这使得为特定的 TLS 监听器匹配数据流时有更大的灵活性。如果你需要将流量转发到一个 TLS 监听器的单一目标，你可以选择同时使用 TCPRoute 和 TLS 监听器。\n- \u0060udproutes.gateway.networking.k8s.io\u0060：UDPRoute 提供了一种路由 UDP 流量的方法。当与网关监听器结合使用时，它可以用来将监听器指定的端口上的流量转发到 UDPRoute 指定的一组后端。\n\n关于这些 CRD 的具体用法以及 Envoy Gateway 的用户指南，将在以后的文章中分享。\n\n下面两篇我同事写的关于 Envoy Gateway 的文章推荐给大家阅读：\n\n- [使用 Envoy Gateway 0.2 体验新的 Kubernetes Gateway API](https:\/\/cloudnative.to\/blog\/hands-on-with-envoy-gateway\/)\n- [面向未来的网关：新的 Kubernetes Gateway API 和 Envoy Gateway 0.2 介绍](https:\/\/cloudnative.to\/blog\/envoy-gateway-to-the-future\/)\n\n## 参考 {#reference}\n\n- [开源项目 Envoy Gateway 简介 - cloudnative.to](https:\/\/cloudnative.to\/blog\/introducing-envoy-gateway\/)\n- [Envoy API Gateway—— 推动网关的进一步发展 - cloudnative.to](https:\/\/cloudnative.to\/blog\/the-gateway-to-a-new-frontier\/)\n- [Envoy Gateway 官方网站 - gateway.envoyproxy.io](https:\/\/gateway.envoyproxy.io\/)\n', '\/blog\/envoy-gateway-release\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">今天 Envoy Gateway v0.2 发布，本文将为你介绍什么是 Envoy Gateway，它的架构、快速入门和使用指南。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/understand-istio-vs-and-dr/">如何理解 Istio 中的 VirtualService 和 DestinationRule？</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/10/14</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('如何理解 Istio 中的 VirtualService 和 DestinationRule？', '本文将 Istio 中的流量治理与现实世界中的交通管理类比，可以帮助你快速理解 VirtualService 和 DestinationRule 设置的功能。', '\nIstio 在刚开源的时候就定义了几十个 CRD，其中用于流量治理的有 \u0060RouteRule\u0060、\u0060DestinationPolicy\u0060、\u0060EgressRule\u0060 等，后来推出了 [v1alpha3 API](https:\/\/istio.io\/v1.13\/blog\/2018\/v1alpha3-routing\/) 使用 \u0060VirtualService\u0060 和 \u0060DestinationRule\u0060 等取代了之前的 API。但是这些资源对象的定义，并不像 Kubernetes 中那么直观，反而会有些难以理解，比如 \u0060VirtualService\u0060，只看名字你可能认为只是第一个了一个“虚拟的服务”，但实际并非如此。\n\n本文将为你通过与实际的交通做类比，直观简要的介绍 Istio 中的两个核心的用于流量治理的对象——\u0060VirtualService\u0060 和 \u0060DestinationRule\u0060。\n\n## 流量 vs 交通\n\n很多刚接触 Istio 的人可能对 \u0060VirtualService\u0060 和 \u0060DestinationRule\u0060 和两个资源对象不是很理解，如果我们将环境仅限定于 Kubernetes 集群，我们可以将路由比喻成现实世界中的交通，有很多车辆在道路上行驶，这就是流量。\u0060DestinationRule\u0060 相当于开辟了道路\/路径\/车道，确保了两点之间可达并控制车道的数量、宽度等。而 \u0060VirtualService\u0060 就像是红绿灯和道路标线，指挥车辆向哪行驶和如何行驶。也就是说如果你只定义了 DR 将不会对流量产生任何影响，因为你没有指挥流量怎么走，所以你必须定义 VirtualService 才可以控制流量的走向。\n\n一句话来概括：DestinationRule 打通了两地之间的通路，犹如修路架桥通隧道，同时控制车道设路障；VirtualService 做车辆指挥调度。\n\n请看下面这张将流量与交通的对比图，可以帮助你更直观的理解这种比喻。\n\n![流量与交通对比图](traffic.jpg)\n\n## 流量治理\n\n下面列举了你分别可以在这两个资源对象上做的流量治理行为。\n\n**VirtualService**\n\n- 路由：金丝雀发布、基于用户身、URI、Header 等匹配路由等；\n- 错误注入：HTTP 错误代码注入、HTTP 延时注入；\n- 流量切分：基于百分比的流量切分路由；\n- 流量镜像：将一定百分比的流量镜像发送到其他集群；\n- 超时：设置超时时间，超过设置的时间请求将失败；\n- 重试：设置重试策略，如触发条件、重试次数、间隔时间等；\n\n**DestinationRule**\n\n- 负载均衡：设置负载均衡策略，如简单负载均衡、区域感知负载均衡、区域权重负载均衡；\n- 熔断（Circuit Breaking）：通过异常点检测（Outlier Detection）和连接池设置将异常节点从负载均衡池中剔除；\n\n## 总结\n\n本文将抽象的流量治理与现实中的交通管理相类比，帮助你更直观的理解 Istio 中的流量管理对象 \u0060VirtualService\u0060 和 \u0060DestinationRule\u0060。同时介绍了基于它们可以进行的流量治理功能。\u0060VirtualService\u0060 主要用于设置路由规则，而服务弹性（超时、重试、熔断等）需要靠它和 DestinationRule 来共同维持。\n\n## 参考\n\n- [Introducing the Istio v1alpha3 routing API - istio.io](https:\/\/istio.io\/v1.13\/blog\/2018\/v1alpha3-routing\/)\n- [Traffic Management - istio.io](https:\/\/istio.io\/latest\/docs\/tasks\/traffic-management\/)\n', '\/blog\/understand-istio-vs-and-dr\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文将 Istio 中的流量治理与现实世界中的交通管理类比，可以帮助你快速理解 VirtualService 和 DestinationRule 设置的功能。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-canary-upgrade/">如何不停机升级 Istio？</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/10/14</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('如何不停机升级 Istio？', '本文详述了使用金丝雀升级 Istio 的步骤及升级后的注意事项。', '\n## 开始之前\n\n截止到撰写本文时 Istio 的最高版本为 1.15.2，1.13 版本的官方支持已经结束。请对照 [Istio 文档中的发布状态描述](https:\/\/istio.io\/latest\/docs\/releases\/supported-releases\/#support-status-of-istio-releases)确定是否需要对 Istio 进行升级。\n\nIstio 官网上给出了升级 Istio 的[几种方式](https:\/\/istio.io\/latest\/docs\/setup\/upgrade\/)：\n\n- 金丝雀升级\n- 原地升级\n- 使用 Helm 升级\n\n但实际上，为了减少在升级时对网格内业务的影响，建议在升级 Istio 的时候，使用 [canary upgrade](https:\/\/istio.io\/latest\/docs\/setup\/upgrade\/canary\/)，它比 [in-place upgrade](https:\/\/istio.io\/latest\/docs\/setup\/upgrade\/in-place\/) 更加安全，而且支持回滚。使用 canary upgrade 支持跨越两个小版本，而 in-place upgrade 必须一个一个小版本的升级。不论使用哪种方式，其中 Ingress Gateway 都是 in-place upgrade 的。\n\n[Istio 官方文档](https:\/\/istio.io\/latest\/docs\/setup\/upgrade\/canary\/)对升级的步骤描述的不是很详细，本文是对官方文档的一个补充，在升级完成后有两个注意事项：\n\n- 为需要自动 sidecar 注入的 namespace 打上对应的 label；\n- 删除原有的 \u0060validatingwebhookconfiguration\u0060 并添加新的；\n\n下面是详细的升级步骤。\n\n## 升级步骤\n\n使用的是以下命令安装的 canary 版本：\n\n\u0060\u0060\u0060bash\n# 将新版本的 revision 命名为 canary\nistioctl install --set revision=canary\n\n# 取消原先自动注入 sidecar 的 namespace 中的 label 并设置新的 label，这样该 namespace 就可以注入 canary 版本对应的 sidecar\nkubectl label namespace test-ns istio-injection- istio.io\/rev=canary\n\n# 重启数据平面中的工作负载，将完成新版本的 sidecar 自动注入\nkubectl rollout restart deployment -n test-ns\n\u0060\u0060\u0060\n\n注意在升级完成后，为新的 namespace 开启 sidecar 自动注入时，需要给 namespace 打上安装 canary Istio 时候设置的 label，执行下面的命令：\n\n\u0060\u0060\u0060bash\nkubectl label namespace new-ns istio-injection- istio.io\/rev=canary\n\u0060\u0060\u0060\n\n## Istio 升级完成后的注意事项\n\n在升级完成后，还有一些注意事项。例如如果你已经为其他 namespace 打上了 sidecar 自动注入的 label，请一定要将它删掉，并将 label 设置为 \u0060istio.io\/rev=canary\u0060，因为可以保证在 pod 中注入新版被 sidecar，并且连接到新版的 Istiod。\n\n另外，你需要把最早安装 Istio 时设置的 \u0060ValidatingWebhookConfiguration\u0060 删掉，执行下面的命令：\n\n\u0060\u0060\u0060bash\nkubectl delete validatingwebhookconfiguration istiod-default-validator\n\u0060\u0060\u0060\n\n{{\u003ccallout note \u0022关于 ValidatingWebhookConfiguration\u0022\u003e}}\n\n在你安装新版本的 Istio 的时候，会自动创建一个名为 \u0060istio-validator-canary-istio-system\u0060 的 ValidatingWebhookConfiguration，该配置的目的是在创建和更新 Istio CR 的时候，先检测所有连接的 Istiod 是否有效。关于动态准入控制的详细描述请见 [Kubernetes 文档](https:\/\/kubernetes.io\/zh-cn\/docs\/reference\/access-authn-authz\/extensible-admission-controllers\/)。\n\n{{\u003c\/callout\u003e}}\n\n因为在安装新版本 Istio 的时候，安装了新的 \u0060istio-validator-canary-istio-system\u0060。如果你不将旧的删除话，你在创建 Istio CR 的时候将会看到如下错误。\n\n\u0060\u0060\u0060\nError from server (InternalError): error when creating \u0022samples\/bookinfo\/networking\/bookinfo-gateway.yaml\u0022: Internal error occurred: failed calling webhook \u0022validation.istio.io\u0022: failed to call webhook: Post \u0022https:\/\/istiod.istio-system.svc:443\/validate?timeout=10s\u0022: service \u0022istiod\u0022 not found\n\u0060\u0060\u0060\n\n以上内容在 Istio 的官方文档中里并没有说明，但是在 [Istio Issue-36526](https:\/\/github.com\/istio\/istio\/issues\/36526) 中有提及。\n\n## 参考\n\n- [动态准入控制 - kubernetes.io](https:\/\/kubernetes.io\/zh-cn\/docs\/reference\/access-authn-authz\/extensible-admission-controllers\/)\n- [Istio Supported Releases - istio.io](https:\/\/istio.io\/latest\/docs\/releases\/supported-releases\/)\n- [Canary Upgrades - istio.io](https:\/\/istio.io\/latest\/docs\/setup\/upgrade\/canary\/)\n', '\/blog\/istio-canary-upgrade\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文详述了使用金丝雀升级 Istio 的步骤及升级后的注意事项。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-ambient-mode/">关于 Istio 推出 ambient 数据平面模式的看法</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/09/08</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('关于 Istio 推出 ambient 数据平面模式的看法', '本文介绍了 Ambient 模式并阐述了笔者对于 Istio 新推出的 ambient mesh（环境网格）的看法。', '\n今天 [Istio 社区推出了 Ambient Mesh](https:\/\/cloudnative.to\/blog\/introducing-ambient-mesh\/)，这是一种新的 Istio 数据平面模式，旨在简化操作、扩大应用兼容性并降低基础设施成本。用户可以选择将 Ambient Mesh 集成到其基础设施的网格数据平面，放弃 sidecar 代理，同时保持 Istio 的零信任安全、遥测和流量管理等核心功能。该模式目前还是预览版，Istio 社区准备在未来几个月内将其推向生产就绪。\n\nAmbient Mesh 推出的消息对于社区来说可能显得有些突然，但其实关于 sidecar 模式对于资源的消耗过大，以及简化服务网格的呼声在社区里已经存在很久了，Google 从多年前就在寻求 HBONE（HTTP-Based Overlay Network Environment，基于 HTTP 的重叠网络环境）解决方案，还有社区提出的[多种 sidecar 部署模式](\/blog\/beyond-istio-oss\/#sidecar-management)、[proxyless 模式](\/blog\/beyond-istio-oss\/#proxyless-pattern) 等都是为了解决这个问题。\n\n## 什么是 Ambient 模式？{#what-is-ambient-mode}\n\nAmbient 模式是 Istio 社区在 2022 年 9 月推出的一种无 sidecar 的 Istio 数据平面部署模式，下图展示了 Ambient 模式的架构。\n\n![Ambient 模式架构](ambient-mesh-arch.svg)\n\n从图中我们可以看到 Ambient 模式对应用程序本身没有任何侵入，而是在应用程序外围：\n\n1. 同 node 上部署 ztunnel：使用 Envoy 实现的共享代理，多租户模式，负责 L4 网络，主要是安全性方面；\n2. 以服务账户为单位部署 Waypoint proxy：同样使用 Envoy 实现，单租户模式，使用 Gateway API 部署的 Gateway 资源，负责 L7 网络，当服务需要 L7 网络功能的时候才部署；\n\n下面是 Ambient 模式的功能分层。\n\n![Ambient 模式的功能分层](ambient-mesh-layers.svg)\n\n关于 Ambient 模式的更多介绍请阅读：\n\n- [Istio 无 sidecar 代理数据平面 ambient 模式简介](https:\/\/cloudnative.to\/blog\/introducing-ambient-mesh\/)\n- [Istio 服务网格 ambient 模式安全详解](https:\/\/cloudnative.to\/blog\/ambient-security\/)\n- [什么是 Ambient Mesh，它与 sidecar 模式有什么区别？](https:\/\/cloudnative.to\/blog\/what-is-ambient-mesh\/)\n\n## Ambient 模式的核心技术 {#ambient-core}\n\nAmbient 模式中的 ztunnel 和 Waypoint proxy 目前还是使用 Envoy 来实现的，未来不排除使用其他语言（非 C\u002b\u002b，如 Rust）来实现一个轻量级的 ztunnel。该模式的核心是所谓的 HBONE（HTTP Based Overlay Network Environment，基于 HTTP 的覆盖网络环境）。\n\nHBONE 基于 HTTP\/2 CONNECT，将工作负载之间的请求以流的形式进行隧道传输，尽可能地复用 HTTP\/2 连接。HBONE 对工作负载来说是透明的，支持更好的传输机制：\n\n- 支持多协议，包括 Server First 协议，如 MySQL。Istio 可以自动检测出 HTTP 和 HTTP\/2 流量。如果未自动检测出协议，流量将会视为普通 TCP 流量。对于 Server First 协议必须明确声明，否则将作为 TCP 流量处理；\n- 对于使用自己 TLS 证书的应用程序可以逐步采用 Istio；\n- 支持绕过 Istio mTLS 封装直接调用 Pod IP；\n\n## Sidecar 模式的限制 {#sidecar-limitations}\n\n其实 ambient 模式的出现，主要是因为 sidecar 模式有以下限制：\n\n- Sidecar 容器不是 pod 中的一等公民，它的生命周期不受控制，有可能在 sidecar 就没准备好的情况下，pod 就开始接收连接，让 sidecar 的生命周期与应用程序 pod 绑定，这本身就是对应用程序的一种侵入\n- Sidecar 无法解释不规范的七层系列，如 HTTP 和 gRPC；\n- 如果仅需服务网格的安全功能，那么引入 sidecar 是一次过大的投资，因为它增加了很多七层网络功能，这些是用不到的，客户无法做到渐进式采用服务网格；\n- Sidecar 升级时，应用程序需要重新部署或者启动，这需要对应用程序进行协调；\n\n## 关于 Ambient 模式的看法 {#ambient-insight}\n\n本文我将谈谈对 ambient 模式的几点看法：\n\n1. **关于 Ambient Mesh 的命名**：我觉得叫做 **Ambient Mode** 会更好，有些接触 Istio 的初学者可能会觉得它是一种全新的不同于 Istio 的 service mesh；另外关于这个模式的中文翻译，如果直接翻译成“环境网格”似乎让人很难理解，我还想到了其他词汇，如“外围”、“氛围”、“周围”、“环绕”、”情景”等，没有一个汉语词汇可以准确表达这个 ambient 的含义，因为相对于 sidecar 模式，ambient 模式对应用程序 pod 没有侵入性，暂且将其称之为**外围模式**。\n2. **Ambient Mode 的本质**：它的本质是分离 sidecar proxy（Envoy）中的 L4 和 L7 功能，让一部分仅需要安全功能的用户可以最小阻力（低资源消耗、运维成本）地使用 Istio service mesh。\n3. **Ambient Mode 的意义**：因为它 sidecar 模式兼容，用户在采纳 Ambient Mode 获得了 mTLS 和有限的可观测性及 TPC 路由等 L4 功能，之后可以更方便的过度到 sidecar mode 以获得完全的 L7 功能。这给用户采纳 Istio 提供了更多模式选择，优化了 Istio 采纳路径。\n4. **Ambient Mode 的坏处**：Proxyless、sidecar、ambient 模式，使得 Istio 越来越复杂，用户理解起来更加费力；控制平面为了支持多种数据平面部署模式，其实现将更加复杂。\n5. **与其他服务网格的关系**：有的 service mesh 从原先的 per-proxy per-node 模式转变为 sidecar mode，如 Linkerd；还有的从 CNI 做到 service mesh，如 Cilium 使用 per-proxy per-node 模式；如今 Istio 在 sidecar mode 的基础上增加了 ambient mode，这也是目前唯一同时支持这两种部署模式的服务网格，为用户提供了多样的选择。\n6. **安全问题**：虽然 [Istio 服务网格 ambient 模式安全详解](https:\/\/cloudnative.to\/blog\/ambient-security\/) 说明了 ambient 模式的设计主旨是为了将应用程序与数据平面分离，让安全覆盖层的组件（ztunnel）处于类似于 CNI 的网格底层，考虑到 ztunnel 有限的 L4 攻击面，该模式的安全风险是可以接受的；但是，ztunnel 作为 DaemonSet 部署在每个节点上，需要处理和分发调度到该节点上的所有 pod 的证书来建立 mTLS 连接，一旦 一个 ztunnel 被攻破，它的爆炸半径确实是大于一个 sidecar，安全详解的博客中说 Envoy 的 CVE 问题会影响所有 sidecar，升级 sidecar 也会带来很大的运营成本，所以权衡之下选择 ambient 模式，安全问题再次给用户造成了困惑，不过最终选择的权利还是在用户自己。\n\n## 安装试用 {#setup}\n\n参考 [Istio 官网中的步骤](https:\/\/istio.io\/latest\/blog\/2022\/get-started-ambient\/)安装：\n\n1. [下载 Ambient Mesh 预览版](https:\/\/gcsweb.istio.io\/gcs\/istio-build\/dev\/0.0.0-ambient.191fe680b52c1754ee72a06b3e0d3f9d116f2e82)；\n\n2. 检查 Kubernetes 版本，建议的大于等于 1.21；\n\n3. 安装 Ambient profile：\n\n   \u0060\u0060\u0060bash\n   istioctl install --set profile=ambient\n   \u0060\u0060\u0060\n\n4. 部署示例应用：\n\n   \u0060\u0060\u0060bash\n   kubectl apply -f samples\/bookinfo\/platform\/kube\/bookinfo.yaml\n   kubectl apply -f https:\/\/raw.githubusercontent.com\/linsun\/sample-apps\/main\/sleep\/sleep.yaml\n   kubectl apply -f https:\/\/raw.githubusercontent.com\/linsun\/sample-apps\/main\/sleep\/notsleep.yaml\n   kubectl apply -f samples\/bookinfo\/networking\/bookinfo-gateway.yaml\n   \u0060\u0060\u0060\n\n5. 将应用添加到 Ambient Mesh：\n\n   \u0060\u0060\u0060bash\n   kubectl label namespace default istio.io\/dataplane-mode=ambient\n   \u0060\u0060\u0060\n\n6. 发送测试流量：\n\n   \u0060\u0060\u0060bash\n   kubectl exec deploy\/sleep -- curl -s http:\/\/istio-ingressgateway.istio-system\/productpage | head -n1\n   kubectl exec deploy\/sleep -- curl -s http:\/\/productpage:9080\/ | head -n1\n   kubectl exec deploy\/notsleep -- curl -s http:\/\/productpage:9080\/ | head -n1\n   \u0060\u0060\u0060\n\n7. 在将 Pod 加入到 Ambient Mesh 中之后，就可以给这些 Pod 应用 L4 的授权策略：\n\n   \u0060\u0060\u0060bash\n   kubectl apply -f - \u003c\u003cEOF\n   apiVersion: security.istio.io\/v1beta1\n   kind: AuthorizationPolicy\n   metadata:\n    name: productpage-viewer\n    namespace: default\n   spec:\n    selector:\n      matchLabels:\n        app: productpage\n    action: ALLOW\n    rules:\n    - from:\n      - source:\n          principals: [\u0022cluster.local\/ns\/default\/sa\/sleep\u0022, \u0022cluster.local\/ns\/istio-system\/sa\/istio-ingressgateway-service-account\u0022]\n   EOF\n   \u0060\u0060\u0060\n\n   上面这个策略只允许 sleep 服务和 istio ingress gateway 访问 productpage。\n\n8. 应用 L7 策略：\n\n   \u0060\u0060\u0060bash\n   kubectl apply -f - \u003c\u003cEOF\n   apiVersion: gateway.networking.k8s.io\/v1alpha2\n   kind: Gateway\n   metadata:\n    name: productpage\n    annotations:\n      istio.io\/service-account: bookinfo-productpage\n   spec:\n    gatewayClassName: istio-mesh\n   EOF\n   \u0060\u0060\u0060\n\n   使用 Gateway API 创建了一个 Gateway，这里实际是在 \u0060default\u0060 命名空间下创建了一个 waypoint proxy，专门用于处理 L7 流量。\n\n   在给它应用授权策略：\n\n   \u0060\u0060\u0060yaml\n   kubectl apply -f - \u003c\u003cEOF\n   apiVersion: security.istio.io\/v1beta1\n   kind: AuthorizationPolicy\n   metadata:\n    name: productpage-viewer\n    namespace: default\n   spec:\n    selector:\n      matchLabels:\n        app: productpage\n    action: ALLOW\n    rules:\n    - from:\n      - source:\n          principals: [\u0022cluster.local\/ns\/default\/sa\/sleep\u0022, \u0022cluster.local\/ns\/istio-system\/sa\/istio-ingressgateway-service-account\u0022]\n      to:\n      - operation:\n          methods: [\u0022GET\u0022]\n   EOF\n   \u0060\u0060\u0060\n\n   这个策略跟之前有所不同的是最后的 \u0060to\u0060 字段定义了 HTTP 方法，现在你在 sleep pod 中对 productpage 服务执行除 GET 以外的其他请求都将失败。从 notsleep pod 中对 productpage 服务的 GET 请求将成功。\n\n   现在你可以从前面创建的这个 productpage Gateway 中获取到 HTTP 请求的 Prometheus 指标信息。\n\n   \u0060\u0060\u0060bash\n   kubectl exec deploy\/bookinfo-productpage-waypoint-proxy -- curl -s http:\/\/localhost:15020\/stats\/prometheus | grep istio_requests_total\n   \u0060\u0060\u0060\n\n9. **给 Reviews 服务创建 Gateway（Waypoint proxy），所有访问 Reviews 服务的 L7 流量都会经过它。**\n\n   \u0060\u0060\u0060yaml\n   kubectl apply -f - \u003c\u003cEOF\n   apiVersion: gateway.networking.k8s.io\/v1alpha2\n   kind: Gateway\n   metadata:\n    name: reviews\n    annotations:\n      istio.io\/service-account: bookinfo-reviews\n   spec:\n    gatewayClassName: istio-mesh\n   EOF\n   \u0060\u0060\u0060\n\n   再给它应用流量划分：\n\n   \u0060\u0060\u0060bash\n   kubectl apply -f samples\/bookinfo\/networking\/virtual-service-reviews-90-10.yaml\n   kubectl apply -f samples\/bookinfo\/networking\/destination-rule-reviews.yaml\n   \u0060\u0060\u0060\n\n   发送 100 次请求测试流量切分结果。\n\n   \u0060\u0060\u0060bash\n   kubectl exec -it deploy\/sleep -- sh -c \u0027for i in $(seq 1 100); do curl -s http:\/\/istio-ingressgateway.istio-system\/productpage | grep reviews-v.-; done\u0027\n   \u0060\u0060\u0060\n\n   你将获得请求结果，说明一切运行正常。\n\n10. 清理环境和删除 Istio。\n\n    \u0060\u0060\u0060bash\n    kubectl delete -f samples\/bookinfo\/networking\/virtual-service-reviews-90-10.yaml\n    kubectl delete -f samples\/bookinfo\/networking\/destination-rule-reviews.yaml\n    kubectl delete -f samples\/bookinfo\/platform\/kube\/bookinfo.yaml\n    kubectl delete -f https:\/\/raw.githubusercontent.com\/linsun\/sample-apps\/main\/sleep\/sleep.yaml\n    kubectl delete -f https:\/\/raw.githubusercontent.com\/linsun\/sample-apps\/main\/sleep\/notsleep.yaml\n    kubectl delete namespace istio-system\n    kubectl label namespace default istio.io\/dataplane-mode-   \n    \u0060\u0060\u0060\n\n## 如何开启 Ambient Mesh？{#enable-ambient}\n\n在安装有 Istio 的 Kubernetes 中部署了你的应用之后，如果想要给命名空间 \u0060ns-a\u0060 启用 Ambient Mode，只需要运行：\n\n\u0060\u0060\u0060bash\nkubectl label namespace ns-a istio.io\/dataplane-mode=ambient\n\u0060\u0060\u0060\n\nAmbient Mesh 默认启用 L4 安全。\n\n## 如何启用 L7 网络功能？{#enable-l7}\n\nAmbient 模式的 L7 网络功能是按需启用的：假如你想给服务 A 访问服务 B 的路径开启 L7 网络功能，那么你需要给服务 B 创建 Gateway。\n\n另外，L7 网络功能是与服务账户绑定的，假如服务 \u0060svc-a\u0060 的服务账户是 \u0060sa-svc-a\u0060，那么给它部署一个 Gateway：\n\n\u0060\u0060\u0060yaml\napiVersion: gateway.networking.k8s.io\/v1alpha2\nkind: Gateway\nmetadata:\n name: svc-a\n annotations:\n   istio.io\/service-account: sa-svc-a\nspec:\n gatewayClassName: istio-mesh\n\u0060\u0060\u0060\n\n然后你就可以创建 \u0060VirtualService\u0060、\u0060DestinationRule\u0060 等资源管理服务 \u0060svc-a\u0060。\n\n该 Gateway 实际上是一个 Deployment，它可以部署在与应用程序不同的命名空间中，你可以对这个 Deployment 单独管理和扩缩容。\n\n## Ambient 模式的限制 {#limitation}\n\n目前 ambient 模式的代码位于 Istio 代码库的 [\u0060experimental-ambient\u0060 分支](https:\/\/github.com\/istio\/istio\/tree\/experimental-ambient)，[根据 Matt Klein 和 Louis Ryan 的说法](https:\/\/twitter.com\/mattklein123\/status\/1567870635568955392?ref_src=twsrc%5Etfw)，ztunnel 和 Waypoint proxy 是用 Envoy 实现的，其中 ztunnel 是精简后的 Envoy，只负责 L4 功能且继续使用 xDS 协议来控制。但是 ambient 模式依然有很多[限制](https:\/\/github.com\/istio\/istio\/tree\/experimental-ambient#limitations)，例如：\n\n- 对 Kubernetes 版本的要求不低于 1.21\n- 不支持 \u0060EnvoyFilter\u0060；\n- 不支持 IPv6；\n- 直接对 Pod IP 而不是 service 的请求在某些情况下将无效；\n- Ambient 模式下的服务无法通过 \u0060LoadBalancer\u0060 和 \u0060NodePort\u0060 方式访问，不过你可以部署一个入口网关（未启用 ambient 模式）以从外部访问服务；\n- 不支持 Calico CNI 和 Dataplane V2 CNI，因为 Ambient 模式会使用 Istio CNI，与其他 CNI 冲突；\n\n[这里](https:\/\/github.com\/istio\/istio\/tree\/experimental-ambient#supported-environments)有安装 ambient 模式的详细环境要求。\n\n## 更多 {#more}\n\n以上就是笔者对 ambient 模式（外围模式）的看法，该模式还处于试验阶段，但绝不是玩具，据信已在某些场景试验过。笔者也将继续追踪该模式的最新进展，请保持关注。也欢迎更多关注 Istio 的朋友[加入云原生社区 Istio 讨论群](https:\/\/cloudnative.to\/community\/join\/)，与社区大咖一起探讨，或者在本文下面评论聊聊你的看法。\n', '\/blog\/istio-ambient-mode\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文介绍了 Ambient 模式并阐述了笔者对于 Istio 新推出的 ambient mesh（环境网格）的看法。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/coss-vc-funding-since-2020/">自 2020 年以来全球的开源商业化软件融资情况</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/09/02</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e5%bc%80%e6%ba%90"> 
             开源
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('自 2020 年以来全球的开源商业化软件融资情况', '近日 COSS 社区发布了自 2020 年 1 月以来的全球风险投资报告，全球共有超过 240 亿美元开源商业化软件公司融资。', '\n昨天 COSS（Commercial Open Source）公司的创始人也是投资者 Joseph（JJ）Jacks 给我发消息，让我看下他们新发布的这个报告。\n\n![JJ 给我发的报告](jj.jpg)\n\n我早就知道 JJ 创业搞了一个 COSS 投资公司并创立了一个基金，这次他整理的这个全球 COSS 公司融资数据还是比较全面的。\n\n{{\u003ccallout note \u0022什么是 COSS 公司？\u0022\u003e}}\n\nCOSS 是英文 Commercial Open Source Software（商业化开源软件）的简称，COSS 公司指的依靠这些 COSS 而生存的公司，即如果没有这些软件，这家公司就不会存在，例如：\n\n- 如果没有 Kafka 就没有 Confluent；\n- 如果没有 Hadoop 就没有 Cloudera；\n- 如果没有 Spark，就没有 Databricks；\n- 如果没有 Git，就没有 GitLab；\n- 如果没有 Linux，就没有 Red Hat、SUSE 等；\n\n{{\u003c\/callout\u003e}}\n\nCOSS 与 SaaS 类公司的区别见下图。\n\n![COSS 与 SaaS 类公司对比](coss-vs-sass.jpg)\n\n## 关于 COSS 公司融资的一些数据\n\n自 2020 年一月至 2022 年 8 月（32 个月）这段时间内全球公开的 COSS 公司融资数据如下：\n\n- 500\u002b 次融资\n- 360\u002b 家 COSS 初创公司\n- 340\u002b 个开源项目\n- 230\u002b 家风投公司参与\n- 总融资 240\u002b 亿美元\n- 平均每月融资 7.5 亿美元\n- 2021 年 2 月和 2021 年 9 月单月融资规模最大\n\n更多详细数据请阅读博客 [Global VC Funding In COSS: $24B\u002b Raised From Jan 2020 to August 2022](https:\/\/www.coss.community\/cossc\/global-vc-funding-into-coss-24b-raised-from-jan-2020-to-august-2022-3pc6) 和[原始数据表格](https:\/\/docs.google.com\/spreadsheets\/d\/1Bz0lxWzwW8q9AUSO5HgRrUyfR47em6YQW4h8PF_vRmE\/edit#gid=666389338)。\n\n## 中国的开源商业化公司\n\n近两年中国也涌现了一系列的开源商业化（COSS）公司，例如：\n\n{{\u003ctable \u0022表：中国的 COSS 公司\u0022\u003e}}\n\n| 开源软件                | 公司名称                                 |\n| ----------------------- | ---------------------------------------- |\n| Apache ShardingSphere   | [SphereEx](https:\/\/sphere-ex.cn)         |\n| TDengine                | [涛思数据](https:\/\/www.taosdata.com\/)    |\n| OceanBase               | [OceanBase](https:\/\/www.oceanbase.com\/)  |\n| Apache APISIX           | [API7](https:\/\/www.apiseven.com\/)        |\n| Apache Pulsar           | [StreamNative](https:\/\/streamnative.io\/) |\n| Apache DolphinScheduler | 未知                                     |\n| Nebula Graph            | [悦数科技](https:\/\/www.vesoft.com\/cn\/)   |\n| Milvus                  | [Zilliz](https:\/\/zilliz.com\/)            |\n\n{{\u003c\/table\u003e}}\n\n以上仅列举了部分笔者观察到的 COSS 公司，如有遗漏，欢迎补充。\n\n## 总结\n\n在 2020 年之前国内也有不少开源商业化公司，比如 PingCAP、Kylingence、EasyStack 等，2020 年后似乎在全球都有一种 COSS 创业的趋势，国内的开源商业化相对于国外还处于比较早期的阶段，一是有影响力的开源项目太少，二是国内用户尚未对商业化开源软件的付费的习惯，还有一些其他政策和法规问题。\n\n', '\/blog\/coss-vc-funding-since-2020\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">近日 COSS 社区发布了自 2020 年 1 月以来的全球风险投资报告，全球共有超过 240 亿美元开源商业化软件公司融资。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-arm64-support/">Istio 1.15 新增对 arm64 架构处理器的支持</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/08/31</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio 1.15 新增对 arm64 架构处理器的支持', '随着 Istio 1.15 的发布，你可以很方便得在 arm64 架构上部署 Istio。', '\nIstio 是基于容器的云原生技术栈的三大核心技术之一，另外两个是 Kubernetes 和 Knative。其中 Kubernetes 和 Knative 早已支持了 arm64 架构，甚至连 Istio 的数据平面 Envoy 早在 [1.16 版本](https:\/\/www.envoyproxy.io\/docs\/envoy\/v1.16.0\/install\/building#arm-binaries)就已支持 arm64 架构（2020 年 10 月）。随着 [Istio 1.15 的发布](https:\/\/istio.io\/latest\/news\/releases\/1.15.x\/announcing-1.15\/)，你可以开箱即用得在 arm64 架构上部署 Istio，不需要自己来编译 arm 架构的镜像。\n\n## 在 Istio 1.15 之前如何在 arm 架构上安装 Istio？\n\nIstio 默认使用 Docker Hub 作为生产镜像仓库，Google Container Registry 作为生产和测试仓库。对于 1.14 及以前的版本，Istio 官方的镜像仓库中只有 amd64 架构的镜像，如果你的 Kubernetes 集群是运行在 arm 架构下，在安装 Istio 时会出现出现如下错误：\n\n\u0060\u0060\u0060\nexec user process caused: exec format error\n\u0060\u0060\u0060\n\n这时你需要为 Istio 安装重新指定一个包含 arm64 架构镜像的仓库，在安装 Istio 时执行下面的命令指定该镜像仓库：\n\n\u0060\u0060\u0060bash\n$ istioctl install --set profile=demo --set hub=docker.io\/mydockerhub -y\n\u0060\u0060\u0060\n\n此时要想在 arm64 架构上使用 Istio，你可以使用 Istio 社区中有人为 Istio 单独构建了 arm64 架构的[镜像](https:\/\/github.com\/resf\/istio)，或者自己构建镜像。\n\n## Istio 为了支持 arm 做了哪些工作？\n\n为了让 Istio 支持 arm，需要将以下二进制文件或者镜像基于 arm 架构编译：\n\n- \u0060istioctl\u0060：这是最简单的部分，只需要使用 Go 语言的交叉编译即可，Istio 的早期版本就已经支持；\n- \u0060pilot\u0060：控制平面 Istiod 中运行的镜像；\n- \u0060proxyv2\u0060：在 Ingress Gateway、Egress Gateway 和 Sidecar 中使用的镜像，通过 Kubernetes [mutating webhook](https:\/\/kubernetes.io\/docs\/reference\/access-authn-authz\/admission-controllers\/#mutatingadmissionwebhook) 自动注入；\n\nIstio 数据平面中的 Envoy 是从 Envoy 官方仓库中 fork 出来的，但是 Envoy 早就支持了 arm64，为什么 Istio 官方还不支持呢？这是因为一方面 Istio 的官方 CI 环境 [prow.istio.io](https:\/\/prow.istio.io\/) 运行在 GKE 上的，而 GKE 上并没有 arm64 架构的环境，所以无法执行测试。直到 2022 年 7 月 GKE 才正式提供 arm64 架构的虚拟机，那时才可以方便的编译和测试 arm64 架构的 Istio，详见 [Run your Arm workloads on Google Kubernetes Engine with Tau T2A VMs](https:\/\/cloud.google.com\/blog\/products\/containers-kubernetes\/gke-supports-new-arm-based-tau-t2a-vms)。\n\n{{\u003ccallout note 注意\u003e}}\n\nIstio 官方仅提供了 amd64 和 arm64 架构的镜像，不支持 arm32。\n\n{{\u003c\/callout\u003e}}\n\n至于 arm 架构的镜像构建，可以使用 Docker BuildKit 来实现多平台构建，你可以使用下面的命令编译指定 arm 平台架构的镜像：\n\n\u0060\u0060\u0060bash\ndocker buildx build --platform linux\/arm64\n\u0060\u0060\u0060\n\n关于 \u0060docker buildx\u0060 的详细信息请参考 [Docker 文档](https:\/\/docs.docker.com\/build\/buildx\/multiplatform-images\/)。\n\n你可以像往常一样来安装 Istio，Kubernetes Node 会根据节点的架构自动拉起对应平台架构的镜像。\n', '\/blog\/istio-arm64-support\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">随着 Istio 1.15 的发布，你可以很方便得在 arm64 架构上部署 Istio。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istiocon-2022-recap/">IstioCon 2022 回顾及录像、PPT 分享</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/08/17</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('IstioCon 2022 回顾及录像、PPT 分享', '本文总结了 IstioCon 2022 并分享了 Istio 社区 2022 年的工作重点，同时公布了 B 站视频链接和 PPT 下载地址。', '\n## 前言\n\n这篇回顾文章可能来的有点晚了，之前在云原生社区中国就有好几次有人问我，什么时候可以在 B 站上观看到 IstioCon 2022 的录像（IstioCon 组委会早已将录像上传到了 YouTube，但是国内有些人可能无法访问 YouTube），正好最近我跟会务人员要到了会议录像，将其全部上传到了 B 站。\n\n## 视频回放与 PPT\n\n- [B 站观看视频回放](https:\/\/space.bilibili.com\/1865134855\/channel\/collectiondetail?sid=641840)\n- [IstioCon 2022 Sessions](https:\/\/events.istio.io\/istiocon-2022\/sessions\/)\n\n大部分内容已上传到 B 站，除了以下三个，有人已经提前上传到了 B 站。\n\n![有三个视频撞车了](bilibili.jpg)\n\nPPT 可以直接通过上面的链接选择你感兴趣的话题下载。\n\n## 总结\n\nIstioCon 2022 今年是第二届了，于 4 月 25 日到 29 日在线上举行，笔者作为 IstioCon 的中文场组织者之一参与了本届活动中文场开场及圆桌讨论环节，我们讨论的议题是《Istio 的开源生态展望》，下面是论坛嘉宾。\n\n![中文场开场演讲：Istio 的开源生态展望论坛嘉宾](guests.jpg)\n\n最近两年来，围绕 Istio，在中国涌现出了几个代表性的开源项目，比如腾讯开源的 Aeraki、DaoCloud 开源的 Merbridge 还有网易开源的 Slime 等。基于 Istio 开发的扩展，我看到的基本都是来自中国，这一点可以说是中国特色。\n\n本次 IstioCon 的关键词如下：\n\n- 零信任\n- 多集群\n- Proxyless\n- eBPF\n- Gateway\n- 安全\n\n同时，Google Cloud 的 VP Eric Brewer 宣布了一个大消息，将 Istio 捐献给 CNCF，一旦成功，那么由 Google 主导的三个开源项目 Kubernetes、Istio、Knative 将成为 CNCF 中容器编排、服务网格、Serverless 等 Kubernetes 技术栈的三驾马车。\n\n![Kubernetes 技术栈的三驾马车](k8s-stack.jpg)\n\n## 关于 Istio 你应该了解\n\n- Istio 只适用于特别场景与规模\n- 不会一口吃出一个胖子，要一个一个版本的渐进式提高\n- 理解 Envoy 对于应用 Istio 特别重要\n- 用户不想再学习另一套 CRD，请考虑在 Istio 之上增加一层抽象\n- 不要低估 Day 2 operation 需要消耗的精力\n\n## Istio 在 2022 年的计划\n\n本届大会上还公布了 Istio 在 2022 年的关注点。\n\n### 稳定性与重新定义 Istio 的 API 平面\n\n- 推动当前特性和 API 到稳定版\n- 将 API 配置从 MeshConfig 中移到数据平面中并使其稳定\n- 继续帮助 Kubernetes API 定义与 Istio API 对齐（Kubernetes Gateway API）\n- 继续增强 Telemetry API：增加对使用 OpenTelemetry 等供应商的日志记录的支持，过滤访问日志，以及自定义跟踪服务名称\n\n### 增强升级与故障排查\n\n- 推动基于修订标签的升级到稳定版\n- 将 Helm 安装推广到 Beta 版\n- 在 \u0060istioctl\u0060 中添加更多的分析器，并扩展当前的分析器，包括针对 Kubernetes 集群以外环境的分析器\n- 用户希望用服务网格来排除服务故障，而不是对服务网格进行故障排除\n\n### 增强可扩展性\n\n- Wasm Plugin\n- 自定义授权\n- 增加标准化集成点以加入自定义的 CA 或网关\n\n### 扩展 Istio 的使用场景\n\n- 支持 IPv6 和双栈网络（Dual Stack Networking）\n- 支持 ARM\n- 扩展使用 gRPC 的 proxyless Istio\n- 性能增强：增量 xDS、降低 sidecar 延迟\n\n{{\u003ccallout note \u0022什么是双栈网络？\u0022\u003e}}\n双协议栈技术就是指在一台设备上同时启用 IPv4 协议栈和 IPv6 协议栈。这样的话，这台设备既能和 IPv4 网络通信，又能和 IPv6 网络通信。如果这台设备是一个路由器，那么这台路由器的不同接口上，分别配置了 IPv4 地址和 IPv6 地址，并很可能分别连接了 IPv4 网络和 IPv6 网络。Kubernetes 中支持 IPv4\/IPv6 双协议栈，详见 [Kubernetes 文档](https:\/\/kubernetes.io\/zh-cn\/docs\/concepts\/services-networking\/dual-stack\/)。\n{{\u003c\/callout\u003e}}\n\n### 安全加固\n\n- 默认尽可能安全\n- 继续完善安全最佳实践文档\n- 推动 distroless 镜像\n- 软件 BOM（Bill of Materials，依赖服务清单）\n- 增加格外的模糊测试\n\n### 其他增强\n\n- 用自动化使升级更容易：让 Istio 的升级像其他升级一样工作，发布升级自动化的参考实现\n- 多规模和大规模集群\n- 对于开发者来说，我们已经将每周的工作小组会议合并到。对于开发者来说，我们已经将每周的工作组会议合并，一个在美国，一个在亚太地区。\n\n## 写在最后\n\n希望 Istio 正式进入 CNCF 的那天早日到来，我也希望能够在社区里看到更多源于 Istio 的终端案例分享，也欢迎大家[加入到云原生社区](https:\/\/cloudnative.to\/community\/join\/)中来，我们有专门的 Istio 讨论群。\n', '\/blog\/istiocon-2022-recap\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文总结了 IstioCon 2022 并分享了 Istio 社区 2022 年的工作重点，同时公布了 B 站视频链接和 PPT 下载地址。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/beyond-istio-oss/">Beyond Istio OSS —— Istio 服务网格的现状与未来</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/07/23</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Beyond Istio OSS —— Istio 服务网格的现状与未来', '本文从云原生大背景下重新审视 Istio，讲解 Istio 诞生，在云原生技术栈中的地位及发展方向。', '\n{{\u003ccallout note 关于本文\u003e}}\n本文根据笔者在 GIAC 深圳 2022 年大会上的的演讲[《Beyond Istio OSS —— Istio 的现状及未来》](https:\/\/giac.msup.com.cn\/2022sz\/course?id=16093)整理而成，演讲幻灯片见 [腾讯文档](https:\/\/docs.qq.com\/pdf\/DRWxETHNDZmRsS0l5)。\n{{\u003c\/callout\u003e}}\n\n本文回顾了 Istio 开源近五年来的发展，并展望了 Istio 服务网格的未来方向。本文的主要观点如下：\n\n- 因为 Kubernetes、微服务、DevOps 及云原生架构的流行，导致服务网格技术的兴起；\n- Kubernetes 和可编程代理，为 Istio 的出现打下了坚实的基础；\n- 虽然 eBPF 可以加速 Istio 中的透明流量劫持，但无法取代服务网格中的 sidecar；\n- Istio 的未来在于构建基于混合云的零信任网络；\n\n## Istio 诞生的前夜{#the-dawn-of-istio}\n\n2013 年起，随着移动互联网的爆发，企业对应用迭代的效率要求更高，应用程序架构开始从单体转向微服务，DevOps 也开始变得流行。同年随着 Docker 的开源，解决了应用封装和隔离的问题，使得应用在编排系统中调度变得更容易。2014 年 Kubernetes、Spring Boot 开源，Spring 框架开发微服务应用开始流行，在接下来的几年间大批的 RPC 中间件开源项目出现，如 Google 在 2016 年发布 gRPC 1.0，蚂蚁在 2018 年开源 [SOFAStack](https:\/\/www.sofastack.tech\/) 等，微服务框架百花齐放。为了节约成本，增加开发效率，使应用更具弹性，越来越多的企业正在迁移上云，但这不仅仅是将应用搬到云上那么简单，为了更高效地利用云计算，一套「云原生」方法和理念也呼之欲出。\n\n## Istio 开源时间线{#istio-open-time-line}\n\nIstio 开源发展时间线如下图所示。\n\n![Istio 开源发展时间线示意图](istio-history.svg)\n\n下面我们来简单回顾下 Istio 开源大事件：\n\n- 2016 年 9 月：因为 Envoy 是 Istio 中的重要组成，Istio 的开源时间线应该有 Envoy 一部分。起初 Envoy 在 Lyft 内部仅作为边缘代理，开源前已在 Lyft 内部得到大规模生产验证并受到了 Google 工程师的注意 [^1]，那时候 Google 正打算推出一个服务网格的开源项目。2017 年，Lyft 将 Envoy 捐献给了 [CNCF](https:\/\/cncf.io)。\n- 2017 年 5 月：Istio 由 Google、IBM 和 Lyft 联合宣布开源 [^2]。一开始就使用了微服务架构，确定了数据平面和控制平面的组成以及 Sidecar 模式。\n- 2018 年 3 月：Kubernetes 顺利的成为从 CNCF 中第一个毕业的项目，变得越来越「无聊」，基础 API 已经定型，CNCF 正式将服务网格（Service Mesh）写入到了云原生的第二版定义 [^3] 中。笔者当前就职的公司 [Tetrate](https:\/\/tetrate.io)，也是在那时由 Google Istio 初创团队创业成立的。服务网格在中国开始爆发，ServiceMesher 社区也在蚂蚁集团的支持下成立，在中国布道服务网格技术。\n- 2018 年 7 月：Istio 1.0 发布，号称「生产可用」，Istio 团队重组。\n- 2020 年 3 月：Istio 1.5 发布，架构回归单体，发布周期确定，每三个月发布一个大版本，API 趋于稳定。\n- 2020 年至今：Istio 的发展主要着重于 Day 2 Operation [^4]、性能优化和扩展性发面，多个围绕 Istio 生态的开源项目开始出现，例如 [Slime](https:\/\/github.com\/slime-io\/slime\/)、[Areaki](https:\/\/github.com\/aeraki-mesh\/aeraki)、[Merbridge](https:\/\/github.com\/merbridge\/merbridge)。\n\n## 为什么 Istio 会在 Kubernetes 之后出现？{#why-istio-born-after-kubernetes}\n\n微服务和容器化之后，异构语言使用的增加，服务的数量激增，容器的生命周期变短是导致服务网格出现的根本原因。\n\n我们先来看下服务从部署在 Kubernetes 到 Istio 中架构的变迁，然后再探讨架构演进过程中 Istio 的需求，下文假定读者已了解 [Kubernetes](\/book\/kubernetes-handbook\/architecture\/) 和 [Istio 的架构](https:\/\/istio.io\/latest\/zh\/docs\/ops\/deployment\/architecture\/)。\n\n![Kubernetes 到 Istio 的架构改变示意图](kubernetes-to-istio.svg)\n\n从 Kubernetes 到 Istio，概括的讲应用的部署架构有如下特点：\n\n- Kubernetes 管理应用的生命周期，具体来说，就是应用的部署和管理（扩缩容、自动恢复、发布策略）；\n- 基于 Kubernetes 的自动 sidecar 注入，实现了透明流量拦截。先通过 sidecar 代理拦截到微服务间流量，再通过控制平面配置管理微服务的行为。如今服务网格的部署模式也迎来了新的挑战，sidecar 已经不是 Istio 服务网格所必须的，基于 gRPC 的无代理的服务网格 [^5] 也在测试中。\n\n- 服务网格将流量管理从 Kubernetes 中解耦，服务网格内部的流量无须 \u0060kube-proxy\u0060 组件的支持，通过类似于微服务应用层的抽象，管理服务间的流量，实现安全性和可观测性功能。\n- 控制平面通过 xDS 协议发放代理配置给数据平面，已实现 xDS 的代理有 [Envoy](https:\/\/envoyproxy.io) 和蚂蚁开源的 [MOSN](https:\/\/mosn.io)。\n\n- Kubernetes 集群外部的客户端访问集群内部服务时，原先是通过 Kubernetes [Ingress](\/book\/kubernetes-handbook\/service-discovery\/ingress\/)，在有了 Istio 之后，会通过 Gateway 来访问 [^6]。\n\n\u003e *Kubernetes 容器编排与可编程代理 Envoy 为 Istio 的出现打下了坚实的基础。*\n\n从上面 Kubernetes 到 Istio 的架构的转变的描述中，我们可以看到为了让开发者最小成本地管理服务间的流量，Istio 需要解决三个问题：\n\n1. **透明劫持应用间的流量**：Istio 开源最初的目标是成为网络基础设施，就像水和电人类的基础设施一样，我们使用水电不需要关心如何取水和发电，只需要打开水龙头，按下开关即可。透明流量劫持对于开发者来说，就像使用水和电，不需要修改应用程序就可以快速使用 Istio 带来的流量管理能力；\n1. **代理集群的运维**：如何为每个应用注入一个代理，同时高效地管理这些分布式的 sidecar 代理；\n1. **可编程代理**：代理可以通过 API 动态配置，还要有出色的性能与可扩展性；\n\n以上三个条件对于 Istio 服务网格来说缺一不可，而且，从中我们可以看到，这些要求基本都是对于 sidecar 代理的要求，这个代理的选择将直接影响该项目的走向与成败。为了解决以上三个问题，Istio 选择了 Kubernetes 容器编排和可编程代理 Envoy。\n\n### 透明流量劫持{#traffic-intercept}\n\n如果你使用的是如 gRPC 这类中间件开发微服务，在程序中集成 SDK 后，SDK 中的拦截器会自动为你拦截流量，如下图所示。\n\n![gRPC 的拦截器示意图](grpc.svg)\n\n如何让 Kubernetes  pod 中的流量都通过代理呢？答案是在每个应用程序 pod 中注入一个代理，与应用共享网络空间，再通过修改 pod 内的流量路径，让所有进出 pod 的流量都经过 sidecar，其架构如下图所示。\n\n![Istio 中的透明流量劫持示意图](istio-route-iptables.svg)\n\n从图中我们可以看到其中有一套非常复杂的 iptables 流量劫持逻辑（详见 [Istio 中的 Sidecar 注入、透明流量劫持及流量路由过程详解](\/blog\/sidecar-injection-iptables-and-traffic-routing\/)），使用 iptables 的好处是适用于任何 Linux 操作系统。但是这也带来了一些副作用：\n\n1. Istio 网格中所有的服务都需要在进出 pod 时都增加了一个网络跳跃点（hop），虽然每次 hop 可能只有两三毫秒，但是随着网格中服务和服务间的依赖增加，这种延迟可能会显著增加，对于那种追求低延迟的服务可能就不适用于服务网格了；\n2. 因为 Istio 向数据平面中注入了大量的 sidecar，尤其是当服务数量增大时，控制平面需要下发更多的 Envoy 代理配置到数据平面，这样会使数据平面占用大量的系统内存和网络资源；\n\n针对这两个问题，如何优化服务网格呢？\n\n1. 使用 proxyless 模式：取消 sidecar 代理，重新回到 SDK；\n2. 优化数据平面：减少下发到数据平面的配置的频率和大小；\n3. eBPF：使用 eBPF 优化网络劫持；\n\n本文将在后面[性能优化](#performance-optimizing)一节讲解这些细节。\n\n### Sidecar 运维管理{#sidecar-management}\n\nIstio 是在 Kubernetes 的基础上构建的，它可以利用 Kubernetes 的容器编排和生命周期管理，在 Kubernetes 创建 pod 时，通过准入控制器自动向 pod 中注入 sidecar。\n\n为了解决 Sidecar 的资源消耗问题，有人为服务网格提出了有四种部署模式，如下图所示。\n\n![服务网格的四种部署模式示意图](deployment-model.svg)\n\n下表中详细对比了这四种部署方式，它们各有优劣，具体选择哪种根据实际情况而定。\n\n{{\u003ctable \u0022服务网格的四种部署模式对比\u0022\u003e}}\n| **模式**                           | **内存开销**                                                 | **安全性**                                                   | **故障域**                                                   | **运维**                                                  |\n| :--------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :-------------------------------------------------------- |\n| **Sidecar 代理**                   | 因为为每个 pod 都注入一个代理，所以开销最大。                | 由于 sidecar 必须与工作负载一起部署，工作负载有可能绕过 sidecar。 | Pod 级别隔离，如果有代理出现故障，只影响到 Pod 中的工作负载。 | 可以单独升级某个工作负载的 sidecar 而不影响其他工作负载。 |\n| **节点共享代理**                   | 每个节点上只有一个代理，为该节点上的所有工作负载所共享，开销小。 | 对加密内容和私钥的管理存在安全隐患。                         | 节点级别隔离，如果共享代理升级时出现版本冲突、配置冲突或扩展不兼容等问题，则可能会影响该节点上的所有工作负载。 | 不需要考虑注入 Sidecar 的问题。                           |\n| **Service Account \/ 节点共享代理** | 服务账户 \/ 身份下的所有工作负载都使用共享代理，开销小。      | 工作负载和代理之间的连接的认证及安全性无法保障。             | 节点和服务账号之间级别隔离，故障同“节点共享代理”。          | 同“节点共享代理”。                                       |\n| **带有微代理的共享远程代理**       | 因为为每个 pod 都注入一个微代理，开销比较大。                | 微代理专门处理 mTLS，不负责 L7 路由，可以保障安全性。        | 当需要应用 7 层策略时，工作负载实例的流量会被重定向到 L7 代理上，若不需要，则可以直接绕过。该 L7 代理可以采用共享节点代理、每个服务账户代理，或者远程代理的方式运行。 | 同“Sidecar 代理”。                                       |\n\n{{\u003c\/table\u003e}}\n\n### 可编程代理{#programmable-proxy}\n\nFlomesh 的张晓辉曾在 [为什么需要可编程代理](https:\/\/cloudnative.to\/blog\/what-and-why-programmable-proxy\/) 博客中详细说明了代理软件的发展演化过程，我下面将引用他的一些观点，说明可编程代理 Envoy 在 Istio 中的关键作用。\n\n下图展示了代理从配置到可编程模式的演化过程，及每个阶段中的代表性代理软件。\n\n![代理软件的演化示意图](proxy-evolution.svg)\n\n整个代理演化过程都是随着应用从本地和单体，越来越走向大规模和分布式。下面我将简要概括代理软件的发展过程：\n\n- **配置文件时代**：几乎所有软件都有配置文件，代理软件因为其相对复杂的功能，更离不开配置文件。该阶段的代理主要使用 C 语言开发，包括其扩展模块，突出的代理本身的能力。这也是我们使用代理最原始最基础的形式，这些代理包括 Nginx、Apache HTTP Server、[Squid](http:\/\/www.squid-cache.org\/) 等；\n- **配置语言时代**：这个时代的代理，更具扩展性和灵活性，比如动态数据获取和配套的逻辑判断。代表性代理包括扩 [Varnish](https:\/\/varnish-cache.org\/) 和 HAProxy；\n- **脚本语言时代**：从脚本语言的引入开始，代理软件才真正走向的可编程，我们可以更方便的使用脚本在代理中增加动态逻辑，增加了开发效率。代表性的代理是 Nginx 及其支持的脚本语言；\n- **集群时代**：随着云计算的普及，大规模部署和动态配置 API 成了代理所必需的能力，而且随着网络流量的增加，大规模代理集群也应运而生。这个时代的代表性代理有 Envoy、Kong 等；\n- **云原生时代**：多租户、弹性、异构混合云、多集群、安全和可观测，这些都是云原生时代对代理所提出的更高要求，代表性软件有 Istio、Linkerd、[Pypi](https:\/\/flomesh.io\/)，它们都为代理构建了控制平面。\n\n## 这些都是服务网格吗？{#are-they-service-mesh}\n\n现在我将列举一些流行的服务网格开源项目，让我们一起探索服务网格的发展规律和本质。下表对比了当前流行的服务网格开源项目 [^7]。\n\n{{\u003ctable 服务网格开源项目对比表\u003e}}\n\n| 对比项     | Istio                                                    | Linkerd                                                     | Consul Connect                                               | Traefik Mesh                                                 | Kuma                                | Open Service Mesh (OSM)             |\n| :--------- | :------------------------------------------------------- | :---------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :---------------------------------- | ----------------------------------- |\n| 当前版本   | 1.14                                                     | 2.11                                                        | 1.12                                                         | 1.4                                                          | 1.5                                 | 1.0                                 |\n| 许可证     | Apache License 2.0                                       | Apache License 2.0                                          | Mozilla License                                              | Apache License 2.0                                           | Apache License 2.0                  | Apache License 2.0                  |\n| 发起者     | Google、IBM、Lyft                                        | Buoyant                                                     | HashiCorp                                                    | Traefik Labs                                                 | Kong                                | Microsoft                           |\n| 服务代理   | Envoy，支持 gRPC 的 proxyless 模式                       | [Linkerd2-proxy](https:\/\/github.com\/linkerd\/linkerd2-proxy) | 默认为 [Envoy](https:\/\/www.envoyproxy.io\/)，可替换           | [Traefik Proxy](https:\/\/traefik.io\/traefik\/)                 | [Envoy](https:\/\/www.envoyproxy.io\/) | [Envoy](https:\/\/www.envoyproxy.io\/) |\n| 入口控制器 | Envoy，自定义的 Ingress，支持 Kubernetes  Gateway API    | 无内置                                                      | Envoy，支持 Kubernetes Gateway API                           | 无内置                                                       | Kong                                | 支持 Contour、Nginx，兼容其他       |\n| 治理       | Istio Community 和 Open Usage Commons，已提议捐献给 CNCF | CNCF                                                        | 查看 [贡献指南](https:\/\/github.com\/hashicorp\/consul\/blob\/master\/.github\/CONTRIBUTING.md) | 查看 [贡献指南](https:\/\/github.com\/traefik\/mesh\/blob\/master\/CONTRIBUTING.md) | CNCF                                | CNCF                                |\n\n{{\u003c \/table \u003e}}\n\n上表中列出的都是服务网格，下面再简单评论一下这些项目：\n\n- [Istio](https:\/\/istio.io)：目前最流行的服务网格项目之一，在中国几乎成为了服务网格的代名词；\n- [Linkerd](https:\/\/linkerd.io)：最早出现的服务网格，「Service Mesh」概念提出者，第一个进入 CNCF 的服务网格项目，使用自研的 Rust 语言编写轻量级 sidecar 代理；\n- [Traefik Mesh](https:\/\/traefik.io\/traefik-mesh\/)：由 Traefik 推出的服务网格项目，使用 Treafik proxy 作为 sidecar，支持 SMI（接下来会提到），它的特点是对应用的无侵入性，不会在 pod 中注入 sidecar；\n- [Kuma](https:\/\/kuma.io\/)：由 Kong 推出的服务网格项目，使用 Envoy 作为 Sidecar 代理，特色是使用 Kong 自家的网关作为入口网关；\n- [Consul Connect](https:\/\/www.consul.io\/docs\/connect)：Consul 服务网格，使用 Envoy 作为 sidecar 代理；\n- [Open Service Mesh](https:\/\/openservicemesh.io\/)：由微软开源的服务网格，使用 Envoy 作为 sidecar，兼容 SMI（同样是微软提出）；\n\n另外还有几个项目，也服务网格领域也经常被提及，但它们都不是服务网格：\n\n- [Envoy](https:\/\/envoyproxy.io)：Envoy 本身只是代理，也经常被作为其他基于 Envoy 的服务网格的 sidecar，也经常被用来构建 API Gateway；\n- [Service Mesh Performance（SMP）](https:\/\/smp-spec.io\/)：标准化了服务网格值的指标，通过捕获基础设施容量、服务网格配置和工作负载元数据的细节来描述任何部署的性能；\n- [Service Mesh Interface（SMI）](https:\/\/smi-spec.io\/)：它不是服务网格，而只是一套服务网格实现标准，与 OAM、SPIFFE、CNI、CSI 等类似都是定义接口标准，具体实现就不一而足了。目前 Traefik Mesh 和 Open Service Mesh 声明支持该规范；\n- [Network Service Mesh](https:\/\/networkservicemesh.io\/)：有必要提一下这个项目，因为经常有人把它错认为是一个服务网格。实际上，它面向的是三层网络，使用它可以在不更换 CNI 插件的前提下，连接多云\/混合云。它并不是我们所定义的「服务网格」，而是服务网格的一个有力补充（虽然名字里带有服务网格比较有迷惑性）。\n\n纵观以上项目，我们可以看出大部分服务网格项目的发起者都是根据代理起家，然后做控制平面。而且 Istio、Consul Connect、Open Service Mesh、Kuma 都是使用 Envoy 作为 sidecar 代理。只有 Linkerd 和 Traefik Mesh 推出了自己的代理。而所有的服务网格项目都支持 sidecar 模式。除了 Istio、Linkerd、Consul Connect 已应用于生产上，其他服务网格项目还没有看到被大规模在生产上使用。\n\n## Istio 的性能优化{#performance-optimizing}\n\n在 Istio 1.5 版本确定了稳定的架构之后，社区的主要精力在于优化 Istio 的性能。下面我将向你详细介绍 Istio 中的性能优化方法，包括：\n\n- 采用 Proxyless 模式；\n- 使用 eBPF 优化流量劫持；\n- 控制平面性能优化；\n- 数据平面性能优化；\n\n### Proxyless 模式{#proxyless-pattern}\n\nProxyless 模式是 Istio 在 1.11 版本中提出的实验特性 —— [基于 gRPC 和 Istio 的无 sidecar 代理的服务网格](https:\/\/cloudnative.to\/blog\/grpc-proxyless-service-mesh\/)。使用该模式可以直接将 gRPC 服务添加到 Istio 中，而不需要再向 Pod 中注入 Envoy 代理。下图展示了 sidecar 模式与 proxyless 模式的对比图。\n\n![Sidecar 模式 vs Proxyless 模式](sidecar-to-proxyless.svg)\n\n从上图中我们可以看到，虽然 proxyless 模式不使用 proxy 进行数据平面通信，但仍然需要一个 agent（即 \u0060pilot-agent\u0060）来进行初始化和与控制平面的通信。首先，agent 在启动时生成一个[引导文件](https:\/\/github.com\/grpc\/proposal\/blob\/master\/A27-xds-global-load-balancing.md#xdsclient-and-bootstrap-file)，与为 Envoy 生成引导文件的方式相同。这告诉 gRPC 库如何连接到 \u0060istiod\u0060，在哪里可以找到用于数据平面通信的证书，向控制平面发送什么元数据。接下来，agent 作为 xDS proxy，代表应用程序与 \u0060istiod\u0060 进行连接和认证。最后，agent 获取并轮换数据平面通信中使用的证书，这其实与 Sidecar 模式的流程是一样的，只是将 Envoy 代理的功能内置到 SDK 中了。\n\n\u003e *服务网格的本质不是 Sidecar 模式，也不是配置中心或透明流量拦截，而是标准化的服务间通信标准。*\n\n有人说 proxyless 模式又回到了基于 SDK 开发微服务的老路，服务网格的优势丧失殆尽，那还能叫做服务网格吗 [^9]？其实这也是一种对性能的妥协 —— 如果你主要使用 gRPC 来开发微服务的话，只需要维护不同语言的 gRPC 版本，即可以通过控制平面来管理微服务了。\n\n\u003e *Envoy xDS 已经成为服务网格中服务间通信的事实标准。*\n\n### 使用 eBPF 优化流量劫持{#ebpf}\n\n在[透明流量劫持](#traffic-intercept)一节，我们可以看到一个服务间的流量在到达目的地 pod 时经过的 iptables 规则和路径，其中需要经过多条 iptables 规则，如 \u0060PREROUTING\u0060、\u0060ISTIO_INBOUND\u0060、\u0060ISTIO_IN_REDIRECT\u0060、\u0060OUTPUT\u0060、\u0060ISTIO_OUTPUT\u0060、\u0060POSTROUTING\u0060 等。假设现在有一个服务 A 想要调用非本地主机上的另一个 pod 中的服务 B，经过的网络堆栈如下图所示。\n\n![非同主机 Pod 间的服务访问路径（iptables 模式）](iptables-process.svg)\n\n从图中我们可以看到整个调用流程中经过四次 iptables，其中 Pod A 中的从 Envoy 的出站（iptables2）和 Pod B 中的从 eth0 的入站（iptables3）的 iptables 路由是无法避免的，那么剩下的两个 iptables1 和 iptables4 是否可以优化呢？让两个 socket 直接通信，不就可以缩短网络路径了吗？这就需要通过 eBPF 编程，使得：\n\n- Service A 的流量从直接发送到 Envoy 的 Inbound socket 上；\n- Pod B 中 Envoy 接收到入站流量后，已经确定流量是要发送给本地的服务，直接对接 Outbound socket 与 Service B；\n\n使用 eBPF 模式的透明流量拦截网络路径如下图所示。\n\n![非同主机 Pod 间的服务访问路径（eBPF 模式）](ebpf-diff-node.svg)\n\n如果要访问的服务 A 和服务 B 在同一个节点上，那么网络路径将更短。\n\n![同主机 Pod 间的网络访问路径（eBPF 模式）](ebpf-same-node.svg)\n\n同一个节点中的服务间访问完全绕过了 TCP\/IP 堆栈，变成了 socket 间的直接访问。\n\n{{\u003ccallout note \u0022什么是 eBPF？\u0022\u003e}}\n\n我们知道修改 Linux 内核代码很难，新特性发布到内核中需要很长的周期。eBPF 是一个框架，允许用户在操作系统的内核内加载和运行自定义程序。也就是说，有了 eBPF，你不需要直接修改内核，就可以扩展和改变内核的行为。下面我将简要的为大家介绍一下 eBPF：\n\n- eBPF 程序加载到内核中后需要通过验证器的验证才可以运行，验证器可以防止 eBPF 程序超越权限的访问，这样可以确保内核的安全；\n- eBPF 程序是附着于内核事件上的，当有进入或退出内核函数时被触发；\n- 内核空间的 eBPF 程序必须使用能够支持生成 eBPF 字节码格式的编译器的语言编写，目前你可以用 C 和 Rust 语言编写 eBPF 程序；\n- eBPF 程序对于不同的 Linux 版本存在兼容性问题；\n\n由于 eBPF 程序可以直接监听和操作 Linux 内核，具有对系统最底层的透视，就可以在流量管理、可观测性和安全发挥作用。有关 eBPF 的详细介绍请参考笔者翻译的[《什么是 eBPF》](https:\/\/jimmysong.io\/book\/what-is-ebpf\/)电子书。\n\n{{\u003c\/callout\u003e}}\n\n开源项目 [Merbridge](https:\/\/github.com\/merbridge\/merbridge) 正是利用 eBPF 缩短了透明流量劫持的路径，优化了服务网格的性能。关于 Merbridge 实现的一些细节，请参考 [Istio 博客](https:\/\/istio.io\/latest\/zh\/blog\/2022\/merbridge\/)。\n\n{{\u003ccallout warning 注意\u003e}}\n\nMerbridge 使用的 eBPF 函数需要 Linux 内核版本 ≥ 5.7。\n\n{{\u003c\/callout\u003e}}\n\n乍看上去 eBPF 似乎从更底层实现了 Istio 的功能，更大有取代 sidecar 的趋势。但是 eBPF 也存在很多局限性，导致在可以预见的未来无法取代服务网格和 Sidecar。如果取消 sidecar 转而使用每个主机一个代理的模式，会导致：\n\n1. 代理失败的爆炸半径扩大到整个节点，即一个代理失败了，代理所在节点上的所有工作负载都会受到影响；\n2. 使得安全问题更加复杂，因为一个节点上保存在太多负载的证书，一旦被攻击，会存在秘钥泄露的风险；\n3. 主机上的 Pod 之间的流量争抢问题，即节点上如果有一个工作负载消耗掉代理的所有资源，其他工作负载将无法获得流量；\n\n而且 eBPF 主要负责三\/四层流量，可以与 CNI 一起运行，但是七层流量使用 eBPF 来处理就不太合适了。\n\n\u003e *在可以预见的未来 eBPF 技术无法取代服务网格和 Sidecar。*\n\n关于 eBPF 与服务网格的关系的更详细介绍请参考博客[请暂时抛弃使用 eBPF 取代服务网格和 Sidecar 模式的幻想](\/blog\/ebpf-sidecar-and-service-mesh\/)。\n\n### 控制平面性能优化{#control-plane-perf-optimizing}\n\n以上两种优化都是针对数据平面进行的，我们再来看下控制平面的性能优化。你可以把服务网格想象成是一场演出，控制平面是总导演，数据平面是所有演员，导演不参与演出，但是负责指挥演员。如果这场演出的情节很简单，时长又很短，那要每个演员分配的戏份就会很少，排练起来就会很容易；如果是一个大型演出，演员的数量多，情节有很复杂，要想排练好这场演出，一个导演可能是不够的，他指挥不了这么多演员，因此我们需要多名副导演（扩大控制平面实例数量）；我们还需要给演员准备好台词和脚本，如果演员也可以一个镜头完成一连串的台词和场景的表演（减少都数据平面的打扰，批量推送更新），那我们的排练是不是更加高效？\n\n从上面的类比中，你应该可以找到控制平面性能优化的方向了，那就是：\n\n- 减少需要推送的配置大小；\n- 批处理代理推送；\n- 扩大控制平面规模；\n\n#### 减少需要推送的配置{#reduce-config-size}\n\n控制平面性能优化最直接的方式就是减少要向数据平面推送的代理配置大小。假设有工作负载 A，如果仅将与 A 相关的代理配置（即 A 依赖的服务）推送给 A，而不是将网格内所有服务的配置都推送给 A，这样就可以大大压缩要推送的工作负载范围及配置大小。Istio 中的 Sidecar 资源可以帮助我们实现这一点。下面是 Sidecar 配置示例：\n\n\u0060\u0060\u0060yaml\napiVersion: networking.istio.io\/v1alpha3\nkind: Sidecar\nmetadata:\n  name: default\n  namespace: cn-bj\nspec:\n  workloadSelector:\n    labels:\n      app: app-a\n  egress:\n  - hosts:\n    - \u0022cn-bj\/*\u0022\n\u0060\u0060\u0060\n\n我们通过 \u0060workloadSelector\u0060 字段可以限制该 Sidecar 配置适用的工作负载范围，而 \u0060egress\u0060 字段可以确定该工作负载依赖的服务范围，这样控制平面就可以仅向服务 A 推送其依赖的服务配置，大大减低要向数据平面推送的配置大小，减少了服务网格的内存和网络消耗。\n\n#### 批处理代理配置推送{#batch-push-conf}\n\n控制平面 Istiod 向数据平面推送代理配置的过程比较复杂，下图展示了其中的流程。\n\n![Istiod 向数据平面推送代理配置的流程图](istiod-push.svg)\n\n管理员配置 Istio 网格后，Istiod 中推送代理配置的流程是这样的：\n\n1. 管理员更新 Istio 配置的事件会触发数据平面代理的配置同步；\n2. Istio 的 \u0060DiscoveryServer\u0060 组件监听到这些事件后不会立即将配置推送到数据平面，而是将这些事件添加到队列中，持续合并一段时间内的事件，这个过程叫做去抖动（debouncing），就是为了防止频繁的更新数据平面配置；\n3. 在去抖动周期过后，这些事件将被推送到队列中；\n4. Istiod 会限制同时推送的请求数量，以加快推送进度；\n5. 事件被转换成 Envoy 的配置推送到数据平面的工作负载上；\n\n从以上流程中我们可以看出，优化配置推送的关键就是步骤 2 中去抖动周期和步骤 4 中的限流设置。有这样几个环境变量可以帮助你设置控制平面的推送：\n\n- \u0060PILOT_DEBOUNCE_AFTER\u0060：指定去抖动的时间，将事件添加到推送队列中，默认为 100 毫秒；\n- \u0060PILOT_DEBOUNCE_MAX\u0060：指定允许事件去抖动的最长时间，如果在这段时间内事件没有新的变化则推送事件，默认为 10 秒；\n- \u0060PILOT_ENABLE_EDS_DEBOUNCE\u0060：指定端点更新是否符合去抖动规则或具有优先权并立即落入推送队列，默认是开启的，关闭它后可以加速 EDS 推送；\n- \u0060PILOT_PUSH_THROTTLE\u0060：指定同时处理的推送请求，默认是 100；\n\n关于这些环境变量的默认值和具体配置请参考 [Istio 文档](https:\/\/istio.io\/latest\/docs\/reference\/commands\/pilot-agent\/#envvars)。\n\n这些值究竟如何设置，可以遵循以下原则：\n\n- 如果控制平面资源空闲，为了加快配置更新的传播速度，你可以：\n  - 缩短去抖动周期，增加推送次数；\n  - 增加同时处理的推送请求数量；\n- 如果控制平面饱和，为了降低性能瓶颈，你可以：\n  - 延迟去抖动周期，减少推送次数；\n  - 增加同时处理的推送请求的数量；\n\n至于如何设置最优解，需要结合你的可观测系统来调试。\n\n#### 扩大控制平面规模{#scale-up-control-plane}\n\n如果设置去抖动批处理和 Sidecar 还无法优化控制平面性能的话，最后的选择就是扩大控制平面的规模，包括扩大单个 Istiod 实例的资源和增加 Istiod 的实例个数，究竟采用哪种扩展方式视情况而定：\n\n- 当单个 Istiod 的资源占用饱和时，优先推荐你扩大 Istiod 的实例大小，这通常是因为服务网格中有太多的资源（Istio 的自定义资源，如 VirtualService、DestinationRule 等）需要处理；\n- 如果增加 Istiod 实例的 CPU 和内存依然不起效的话，增加 Istiod 的实例个数，这样可以分散单个实例要管理的工作负载数量；\n\n### 数据平面性能优化{#data-plane-performance}\n\nApache SkyWalking 可以作为 Istio 提供可观测性工具，还可以帮助我们在进行服务动态调试和故障排除剖析服务的性能，其最新推出的 [Apache SkyWalking Rover](https:\/\/github.com\/apache\/skywalking-rover) 组件可以利用 eBPF 技术来准确定位 Istio 的关键性能问题 [^12]。在数据平面，我们可以通过以下方式来增加 Envoy 的吞吐量以优化 Istio 的性能：\n\n- 禁用 Zipkin 追踪或减少采样率\n- 简化访问日志格式\n- 禁用 Envoy 的访问日志服务（ALS）\n\n以上优化方式对 Envoy 吞吐量的影响数据请参阅 [使用 eBPF 准确定位服务网格的关键性能问题](https:\/\/cloudnative.to\/blog\/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf\/#introducing-skywalking-rover)。\n\n## Envoy —— 服务网格的领衔主演{#starring-envoy}\n\n我们知道服务网格是由数据平面和控制平面组成的，从上面的服务网格开源项目列表中我们可以看到，服务网格开源项目大部分都是基于 Envoy，然后开发自己的控制平面。还记得我在本文前面将服务网格比作演出吗？在这场服务网格的演出中，毫无疑问 Envoy 就是领衔主演 —— Envoy 发明的 xDS 协议，基本成为服务网格的通用 API。下面展示的是 Envoy 的架构图。\n\n![Envoy 架构图](envoy-arch.svg)\n\nxDS 是 Envoy 区别于其他代理的关键，它的代码和解析流程十分复杂 [^10]，直接扩展起来也很有难度。下面展示的是 Istio 组件拓扑图，从图中我们可以看到 Istio 数据平面的 Sidecar 容器中不止有 \u0060envoy\u0060 这一个进程，还有一个 \u0060pilot-agent\u0060 进程。\n\n{{\u003cfigure title=\u0022Istio 组件拓扑图\u0022 alt=\u0022Istio 组件拓扑图\u0022 id=\u0022istio-components\u0022 src=\u0022istio-components.svg\u0022\u003e}}\n\n\u0060pilot-agent\u0060 进程的作用如下：\n- 作为 \u0060envoy\u0060 的父进程，负责 Envoy 的生命周期管理；\n-  接收来自控制平面的推送，配置代理和证书；\n- 收集 Envoy 统计信息，汇总 sidecar 的统计数据供 Prometheus 搜集；\n- 内置本地 DNS 代理，用于解析 Kubernetes DNS 解析不了的集群内部域名的场景；\n- 对 Envoy 和 DNS 代理进行健康检查；\n\n从以上功能中我们可以看出 \u0060pilot-agent\u0060 进程主要是用于与 Istiod 交互，为 Envoy 起到指挥和辅助的作用，Istio 的核心组件是 Envoy。那么 Envoy 会不会「演而优则导」，不再配合 Istio，构建一套自己的控制平面呢？\n\n\u003e *在 Sidecar 容器中，\u0060pilot-agent\u0060 就像是 Envoy 的“Sidecar”。*\n\n{{\u003ccallout note 请读者思考一下\u003e}}\n\u0060pilot-agent\u0060 的功能能否直接内置到 Envoy 中，从而取消 \u0060pilot-agent\u0060 呢？\n{{\u003c\/callout\u003e}}\n\n## Envoy Gateway 统一服务网格网关{#envoy-gateway}\n\n在 Kubernetes 中，除 Service 资源对象之外，最早用来暴露集群中服务的资源对象是 Ingress。使用 Ingress 你只需要为集群开放一个对外的访问点即可，通过 HTTP Hosts 和 \u0060path\u0060 来路由流量到具体的服务。相对于直接在 \u0060service\u0060 资源上暴露服务来说，可以减少集群的网络访问点（PEP）[^11] ，降低集群被网络攻击的风险。使用 Ingress 访问集群内的服务流程如下图所示。\n\n![Kubernetes Ingress 流量访问流程图](ingress.svg)\n\n在 Kubernetes 之前，API Gateway 软件就已经被广泛用作边缘路由了，在引用 Istio 时又增加了 Istio 自定义的 Gateway 资源，使得访问 Istio 服务网格中的资源又多了一种选择，如下图所示。\n\n![访问 Istio 网格中的服务的方式](access-cluster.svg)\n\n现在，要想暴露单个 Istio 网格中的服务，\u0060NodePort\u0060、\u0060LoadBalance\u0060、Istio 自定义 Gateway、Kubernetes Ingress 和 API Gateway 软件，如何选择？如果是多集群服务网格，客户端如何访问网格内的服务？我们的服务网格领衔主演 Envoy 已经在这方面做足了功夫，被以多种形式使用：\n\n- Sidecar Proxy：正如在[前文中](#are-they-service-mesh)提到的，Istio、Kuma、Consul Connect 都使用了 Envoy 作为 sidecar 代理；\n- Kubernetes Ingress Controller\/API Gateway：[Contour](https:\/\/github.com\/projectcontour\/contour)、[Emissary](https:\/\/github.com\/emissary-ingress\/emissary)、[Hango](https:\/\/github.com\/hango-io\/hango-gateway)、[Gloo](https:\/\/github.com\/solo-io\/gloo) 等；\n\n这些项目利用 Envoy 来实现服务网格和 API 网关，其中有很多功能重叠，同时又有很多专有功能，或者缺乏社区多样性，这种现状由于 Envoy 社区没有提供控制平面实现而导致的。为了改变现状，Envoy 社区发起了 [Envoy Gateway](https:\/\/github.com\/envoyproxy\/gateway) 项目，该项目旨在结合现有的基于 Envoy 的 API Gateway 相关项目的经验 [^13]，利用带有一些 Envoy 特定扩展的  [Kubernetes Gateway API](https:\/\/gateway-api.sigs.k8s.io\/) 降低 Envoy 用户使用网关的门槛。因为 Envoy Gateway 仍然通过 xDS 下发配置给 Envoy 代理，因此你还可以用它来管理支持 xDS 的网关，如 Istio Gateway。\n\n我们现在所见的网关基本都是在单集群中作为入口网关，对于多集群和多网格就无能为力了。为了应对多集群，我们需要在 Istio 之上再添加一层网关，和一个全局的控制平面以在多集群间路由流量，如下图所示。\n\n![多集群多网格的两级网关示意图](t2-gateway.svg)\n\n{{\u003ccallout note 关于两级网关的简要介绍\u003e}}\n- 一级网关（下文简称 T1）位于应用边缘，用于多集群环境。同一应用会同时托管在不同的集群上，T1 网关将对该应用的请求流量在这些集群之间路由。\n- 二级网关（下文简称 T2）位于一个的集群边缘，用于将流量路由到该集群内由服务网格管理的服务。\n{{\u003c\/callout\u003e}}\n\n通过在 Istio 控制平面以外增加一层全局控制平面和 API，来实现多集群服务网格管理。将 T1 网关部署为集群，可以防止单点故障。想要了解关于两级网关的更多内容，请参考[通过两级网关设计来路由服务网格流量](https:\/\/cloudnative.to\/blog\/designing-traffic-flow-via-tier1-and-tier2-ingress-gateways\/)。\n\nT1 网关的配置如下所示：\n\n\u0060\u0060\u0060yaml\napiVersion: gateway.tsb.tetrate.io\/v2\nkind: Tier1Gateway\nmetadata:\n  name: service1-tier1\n  group: demo-gw-group\n  organization: demo-org\n  tenant: demo-tenant\n  workspace: demo-ws\nspec:\n  workloadSelector:\n    namespace: t1\n    labels:\n      app: gateway-t1\n      istio: ingressgateway\n  externalServers:\n  - name: service1\n    hostname: servicea.example.com\n    port: 80\n    tls: {}\n    clusters:\n    - name: cluster1\n      weight: 75\n    - name: cluster2\n      weight: 25 \n\u0060\u0060\u0060\n\n该配置将 \u0060servicea.example.com\u0060 通过 T1 网关暴露到网格外，并将网格外访问该服务的流量的 \u006075%\u0060 转发到 \u0060cluster1\u0060，\u006025%\u0060 的流量转发到 \u0060cluster2\u0060，另外为了应对多集群中的流量、服务和安全配置，Tetrate 旗舰产品 Tetrate Service Bridge 中还增加了 一系列 Group API，详见 TSB 文档。\n\n## Istio 开源生态{#ecosystem}\n\nIstio 开源在至今已经五年多了，近两年来出现了很多基于 Istio 的开源项目，其中比较代表性的有：\n\n- 网易开源的 Slime\n- 腾讯开源的 Aeraki\n- Istio 官方对 Wasm 插件的支持\n\n它们的出现使得 Istio 更加智能化并扩展了 Istio 的适用范围。\n\n### Slime\n\n[Slime](https:\/\/github.com\/slime-io\/slime\/) 是由网易数帆微服务团队开源的一款基于 Istio 的智能网格管理器。Slime 基于 Kubernetes Operator 实现，可作为 Istio 的 CRD 管理器，无须对 Istio 做任何定制化改造，就可以定义动态的服务治理策略，从而达到自动便捷使用 Istio 和 Envoy 高阶功能的目的。\n\n我们在前文的[控制平面性能优化](#control-plane-perf-optimizing)中提到了通过「减少需要推送的配置」的方式来优化 Istio 的性能，但是 Istio 无法做到自动识别无法依赖以最优化需要推送到每个 sidecar 的代理配置，Slime 提供了 \u0060lazyload\u0060 控制器，可以帮助我们实现配置懒加载，用户无须手动配置 \u0060SidecarScope\u0060 [^15]，Istio 可以按需加载服务配置和服务发现信息。\n\n下图展示的是 Slime 作为 Istio 的管理平面更新数据平面配置的流程图。\n\n![使用 Slime 更新 Istio 数据平面配置的流程图](slime-process.svg)\n\n其中，Global Proxy 使用 Envoy 构建，在每个需要启动配置懒加载的命名空间中部署一个或在整个网格中只部署一个，所有缺失服务发现信息的调用（你也可以手动配置服务调用关系），都会被兜底路由劫持到 Global Proxy，经过其首次转发后，Slime 便可感知到被调用方的信息，然后根据其对应服务的 VirtualService，找到服务名和真实后端的映射关系，将两者的都加入 SidecarScope，以后该服务的调用就不再需要经过 Global Proxy 了。\n\n数据平面配置更新的具体步骤如下：\n\n1. Slime Operator 根据管理员的配置在 Kubernetes 中完成 Slime 组件的初始化，开发者创建符合 Slime CRD 规范的配置并应用到 Kubernetes 集群中；\n2. Slime 持续监听 Slime CRD 的创建；\n3. Slime 查询 Prometheus 中保存的相关服务的监控数据，结合 Slime CRD 中自适应部分的配置，将 Slime CRD 转换为 Istio CRD，同时将其推送到 Global Proxy 中；\n4. Istio 监听 Istio CRD 的创建；\n5. Istio 将代理的配置信息推送到数据平面相应的 Sidecar Proxy 中；\n\n因为数据平面中的所有服务的首次调用都通过 Global Proxy，该 Proxy 可以记录所有服务的调用和依赖信息，根据该依赖信息更新 Istio 中 Sidecar 资源的配置；当某个服务的调用链被 VirtualService 中的路由信息重新定义时，Global Proxy 原有记录就失效了，需要一个新的数据结构来维护该服务的调用关系。Slime 创建了名为 \u0060ServiceFence\u0060 的 CRD 来维护服务调用关系以解决服务信息缺失问题，详见 [Slime 简介](\/blog\/slime-intro\/)。\n\n### Aeraki\n\n[Aeraki Mesh](https:\/\/github.com\/aeraki-mesh\/aeraki) 是腾讯云在 2021 年 3 月开源的一个服务网格领域的项目，基于 Istio 扩展其对七层协议的支持，专注于解决 Istio 中的**非 HTTP 协议**的服务治理，已于 2022 年 6 月进入 CNCF Sandbox。\n\n下图展示了 Aeraki 将非 HTTP 协议纳入到 Istio 网格中的流程图。\n\n![Aeraki 将非 HTTP 协议纳入到 Istio 网格中的流程图](aeraki-arch.svg)\n\n 其详细流程如下：\n\n1. Aeraki 的 X2Istio 组件对接服务注册中心，获取非 HTTP 服务的注册信息，并生成 ServiceEntry 向 Istio 中注册；\n2. Aeraki 作为 Istio 之上的管理平面，它从 Istio 中获取 ServiceEntry 配置；\n3. Aeraki 通过端口命名规判断服务的协议类型（如 \u0060tcp-metaprotocol-dubbo\u0060），然后生成 MetaProtocol Proxy Filter（兼容 EnvoyFilter）配置，同时修改 RDS 地址，将其指向 Aeraki；\n4. Istio 使用 xDS 协议将配置（LDS、CDS、EDS 等）下发给数据平面；\n5. Aeraki 根据服务注册表中的信息和用户设置生成路由规则，通过 RDS 发送给数据平面；\n\n在 Istio 中接入非 HTTP 服务的整个流程中的关键是 **MetaProtocol Proxy** 。Istio 默认支持 HTTP\/HTTP2、TCP 和 gRPC 协议，实验性支持 Mongo、MySQL 和 Redis 协议 [^14]。若要使用 Istio 路由其他协议的流量，不仅需要修改 Istio 控制平面并扩展 Envoy，这将带来巨大的工作量，而且不同协议共享通用的控制逻辑，这还会带来很多重复性工作。MetaProtocol Proxy 是在 Envoy 代码基础上的扩展，为七层协议统一实现了服务发现、负载均衡、RDS 动态路由、流量镜像、故障注入、本地\/全局限流等基础能力，大大降低了在 Envoy 上开发第三方协议的难度。\n\n下图展示的 MetaProtocol Proxy 的架构图。\n\n![MetaProtocol Proxy 架构图](metaprotocol-proxy.svg)\n\n当我们想扩展 Istio 使其支持 Kafka、Dubbo、Thrift 等其他七层协议时，只需要实现上图中的编解码的接口（Decode 和 Encode），就可以基于 MetaProtocol 快速开发一个第三方协议插件。MetaProtocol Proxy 是在 Envoy 基础上的扩展，因此你仍然可以使用多种语言为其开发过滤器，并使用 \u0060EnvoyFilter\u0060 资源将配置下发到数据平面。\n\n### WasmPlugin API\n\n[WasmPlugin](https:\/\/istio.io\/latest\/docs\/reference\/config\/proxy_extensions\/wasm-plugin\/) 是 Istio 1.12 版本引入的 API，作为代理扩展机制，我们可以使用它将自定义和第三方的 Wasm 模块添加到数据平面中。下图中展示了如何在 Istio 中使用 WasmPlugin。\n\n![在 Istio 中使用 WasmPlugin 的流程图](wasmplugin.svg)\n\n具体步骤如下：\n\n1. 用户使用 [Proxy-Wasm SDK](https:\/\/github.com\/proxy-wasm)（目前有 AssemblyScript、C\u002b\u002b、Rust、Zig 和 Go 语言版本）来开发扩展，并构建成 OCI 镜像（如 Docker 镜像）上传到镜像仓库；\n2. 用户编写 \u0060WasmPlugin\u0060 配置并应用到 Istio；\n3. Istio 控制平面根据 \u0060WasmPlugin\u0060 配置中的工作负载选择配置，将 Wasm 模块注入到指定的 Pod 中；\n4. Sidecar 中的 \u0060pilot-agent\u0060 [^16] 从远程或本地文件中获取 Wasm 模块并将其加载到 Envoy 中运行；\n\n## 谁应该使用 Istio？{#whos-should-use-istio}\n\n好了，说了这么说，这跟你有什么关系呢？Istio 跟你的关系取决于你的角色：\n\n- 如果你是平台负责人，应用服务网格后，可能增强你的平台可观测性，具有了一个统一的平台来管理微服务，你将是直接受益者，也应该是服务网格的主要实施者；\n- 如果是应用程序开发者，也会从服务网格中收益，因为你可以更加专属于业务逻辑，而不用担心重试策略、TLS 等其他非功能性问题；\n\n下图展示了服务网格的采用路径。\n\n![服务网格的采用路径](adopt.svg)\n\n是否采用服务网格取决于你公司的技术发展阶段，应用是否实现容器化和微服务，对多语言的需求，是否需要 mTLS 以及对性能损耗的接纳度等。\n\n## 服务网格在云原生技术栈中的定位{#service-mesh-positioning}\n\n技术的发展日新月异，近两年来有一些新技术出现，似乎挑战了服务网格的地位，更有人声称可以直接取代现有经典的 sidecar 模式的服务网格 [^8]，我们不要被外界嘈杂的声音所迷惑，认清服务网格在云原生技术栈中的定位。\n\n\u003e *一味地推广某项技术而忽略它的适用场景，就是耍流氓。*\n\n下图展示的是云原生技术堆栈。\n\n![云原生技术堆栈示意图](cloud-native-stack.svg)\n\n我们可以看到，在云原生技术堆栈图中的「云基础设施」、「中间件」和「应用」层都列举了一些标志性的开源项目，这些项目构建了它们所在领域的标准：\n\n- 在云基础设施领域，Kubernetes 统一了容器编排和应用生命周期管理的标准，Operator 模式奠定了扩展 Kubernetes API 及第三方应用接入的标准；\n- 在中间件领域，服务网格承担起了云原生技术栈中的七层网络、可观测性和安全等多个方面的部分或全部责任，它运行在应用程序下层，对于应用程序来说几乎是无感知的；Dapr（分布式应用程序运行时）定义云原生中间件的能力模型，开发者可以在应用中集成 Dapr 的多语言 SDK，面向 Dapr 提供的分布式能力编程，而不用关心应用所运行的环境及对接的后端基础设施。因为在和应用程序运行在同一个 Pod 中的 Dapr 运行时（Sidecar 模式部署，其中包含各种构建块）自动帮我们对接了后端组件（Component）；\n- 在应用程序领域：OAM 旨在建立一个应用模型标准，通过组件、特征、策略和工作流来一个应用程序；\n\n下图展示了 Istio 在云原生部署中定位于七层网格管理。\n\n![Istio 在云原生架构中定位在七层网络](istio-role.svg)\n\n{{\u003ccallout note \u0022Dapr 与 Istio 是什么关系？\u0022\u003e}}\n\n在云原生技术栈中，Istio 和 Dapr 同时位于中间件层，它们之间有很多区别和联系。\n\nIstio 和 Dapr 之间的相同点：\n\n- Istio 和 Dapr 都可以使用 Sidecar 模式的部署模型；\n- 同属于中间件，同样可以管理服务间通信；\n\nIstio 和 Dapr 之间的不同点：\n- 目标不同：Istio 的目标是构建零信任网络，定义服务间通信标准，Dapr 目标是构建标准的中间件能力的 API；\n- 架构不同：Istio = Envoy \u002b 透明流量劫持 \u002b 控制平面，Dapr = 多语言 SDK \u002b 标准化 API \u002b 分布式能力组件；\n- 面向的人群不同：但是应用 Istio 对于开发者来说几乎无感知，主要需要基础设施运维团队实施，而应用 Dapr 需要开发者自主选择集成 Dapr SDK；\n\n{{\u003c\/callout\u003e}}\n\n## 服务网格的未来{#istio-future}\n\n我在前文中介绍了 Istio 的发展脉络及开源生态，接下来我将为大家介绍 Istio 服务网格的未来趋势：\n\n- 构建零信任网络\n- 成为混合云管理平台的网络基础设施\n\n\u003e *服务网格的未来在于成为零信任网络和混合云的基础设施。*\n\n这也是笔者所在的公司企业级服务网格提供商 [Tetrate](https:\/\/www.tetrate.io\/) 的努力方向，我们致力于构建一个基于零信任的适用于任意环境、任意负载的应用感知网络。下面展示的是 Tetrate 旗舰产品 [Tetrate Service Bridge](https:\/\/www.tetrate.io\/tetrate-service-bridge\/) 的架构图。\n\n![TSB 架构图](tsb.svg)\n\nTetrate 公司是由 Istio 项目的发起人创立的，TSB 是基于开源的 Istio、Envoy 和 Apache SkyWalking 开发的。我们同时积极得贡献上游社区，并参与了旨在简化将 Envoy 网关使用的 [Envoy Gateway](https:\/\/github.com\/envoyproxy\/gateway) 项目的创建（上图中的 XCP 即使用 Envoy 构建的网关）。\n\n## 零信任{#zero-trust}\n\n零信任（Zero Trust）是 IstioCon 2022 里的一个重要话题，Istio 正在成为零信任网络的一个重要组成部分。\n\n{{\u003ccallout note \u0022什么是零信任？\u0022\u003e}}\n零信任（Zero Trust）是一种安全理念，而不是一种所有安全团队都要遵循的最佳实践。零信任概念的提出是为了给云原生世界带来更安全的网络。零信任是一种理论状态，即网络内的所有消费者不仅没有任何权限，而且也不具备对周围网络的感知。零信任的主要挑战是就越来越细化的授权和和对用户授权的时间限制。关于更多零信任的介绍，请阅读[这篇博客](\/blog\/what-is-zero-trust\/)。\n{{\u003c\/callout\u003e}}\n\n### 身份认证{#authn}\n\n零信任网络中最重要的是**面向身份的控制**而不是面向网络的控制。Istio 1.14 中增加了对 SPIRE 的支持，SPIRE（SPIFFE Runtime Environment，CNCF 孵化项目）是 SPIFFE（Secure Production Identity Framework For Everyone，CNCF 孵化项目）的一个实现。在 Kubernetes 中我们使用 [ServiceAccount](\/book\/kubernetes-handbook\/auth\/serviceaccount\/) 为 Pod 中的工作负载提供身份信息，其核心是基于 Token（使用 Secret 资源存储）来表示负载身份。而 Token 是 Kubernetes 集群中的资源，对于多集群及运行在非 Kubernetes 环境（例如虚拟机）中的负载，如何统一它们的身份？这就是 SPIFFE 要解决的问题。\n\nSPIFFE 的目的是基于零信任的理念，建立一个开放、统一的工作负载身份标准，这有助于建立一个零信任的全面身份化的数据中心网络。SPIFFE 的核心是通过简单 API 定义了一个生命周期短暂的加密身份文件—— SVID（SPFFE Verifiable Identity Document），用作工作负载认证时使用的身份文件（基于 X.509 证书或 JWT 令牌）。SPIRE 可以根据管理员定义的策略自动轮换 SVID 证书和秘钥，动态地提供工作负载标识，同时 Istio 可以通过 SPIRE 动态的消费这些工作负载标识。\n\n基于 Kubernetes 的 SPIRE 架构图如下所示。\n\n![SPIRE 部署在 Kubernetes 中的架构图](spire-with-kubernetes.svg)\n\nIstio 中原先是使用 Istiod 中 Citadel 服务 [^17] 负责服务网格中证书管理，通过 xDS（准确的说是 SDS API）协议将证书下发给数据平面。有了 SPIRE 之后，证书管理的工作就交给了 SPIRE Server。SPIRE 同样支持 Envoy SDS API，我们在 Istio 中启用 SPIRE 之后，进入工作负载 Pod 中的流量在被透明拦截到 Sidecar 中后，会经过一次身份认证。身份认证的目的是对比该工作负载的身份，与它所运行的环境信息（所在的节点、Pod 的 ServiceAccount 和 Namespace 等）是否一致，以防止伪造身份。请参考[如何在 Istio 中集成 SPIRE](\/blog\/how-to-integrate-spire-with-istio\/) 以了解如何在 Istio 中使用 SPIRE 做身份认证。\n\n我们可以使用 [Kubernetes Workload Registrar](https:\/\/github.com\/spiffe\/spire\/blob\/main\/support\/k8s\/k8s-workload-registrar\/README.md) 在 Kubernetes 中部署 SPIRE，它会为我们自动注册 Kubernetes 中的工作负载并生成 SVID。该注册机是 Server-Agent 架构，它在每个 Node 上部署一个 SPIRE Agent，Agent 与工作负载通过共享的 UNIX Domain Socket 通信。零信任网络中每个流量会话都需要经过身份认证，Istio 在透明流量劫持时，Sidecar 同时对流量请求进行身份认证。下图展示了在 Istio 中使用 SPIRE 进行身份认证的过程。\n\n![Istio 中基于 SPIRE 的工作负载身份认证过程示意图](workload-attestation.svg)\n\nIstio 中使用 SPIRE 进行工作负载认证的步骤如下：\n\n1. 工作负载的 sidecar 中的 \u0060pilot-agent\u0060 通过共享的 UDS 调用 SPIRE Agent 来获取 SVID 并缓存在 SPIRE Agent 中用于后续身份认证；\n2. SPIRE Agent 询问 Kubernetes（准确的说是节点上的 kubelet）获取工作负载的信息，如所在的 namespace、节点名称、服务账号等；\n3. Kubelet 把从 API 服务器中查询到的信息返回给工作负载验证器；\n4. 验证器将 kubelet 返回的结果与 SPIRE 查询得到的身份信息比对，如果相同，则将正确的 SVID 缓存返回给工作负载，如果不同则认证失败，拒绝流量请求；\n\n关于工作负载的注册和认证的详细过程请参考 [SPIRE 文档](\/book\/kubernetes-handbook\/auth\/spire\/) 。\n\n### NGAC\n\n当每个工作负载都有准确的身份之后，如何对这些身份的权限进行限制？Kubernetes 中默认使用 RBAC 来做访问控制，正如其名，这种访问控制是基于角色的，虽然使用起来比较简单，但是对于大规模集群，存在角色爆炸问题 —— 即存在太多角色，而且角色的类型不是一成不变的，难以对角色权限机型跟踪和审计。另外 RBAC 中的角色的访问权限是固定，没有规定短暂的使用权限，也没有考虑位置、时间或设备等属性。使用 RBAC 的企业很难满足复杂的访问控制要求，以满足其他组织需求的监管要求。\n\nNGAC，即下一代访问控制，采用将访问决定数据建模为 DAG（有向无环图）的方法。NGAC 可以实现系统化、策略一致的访问控制方法，以高精细度授予或拒绝用户管理能力。NGAC 由 [NIST](https:\/\/www.nist.gov\/) （美国国家标准与技术研究所）开发，目前已用于 [Tetrate Service Bridge](https:\/\/www.tetrate.io\/tetrate-service-bridge\/) 中的权限管理。关于为什么选择 NGAC，而不是 ABAC 和 RBAC 的更多内容请参考博客[为什么应该选择使用 NGAC 作为权限控制模型](\/blog\/why-you-should-choose-ngac-as-your-access-control-model\/)。\n\n## 混合云{#hybrid-cloud}\n\n在实际应用中，我们可能出于负载均衡、隔离开发和生产环境、解耦数据处理和数据存储、跨云备份和灾难恢复以及避免厂商锁定等原因，在多种环境下部署多个 Kubernetes 集群。Kubernetes 社区提供了「集群联邦」功能可以帮助我们创建多集群架构，例如下图所示的一种常用的 Kubernetes 多集群架构，其中 Host Cluster 作为控制平面，有两个成员集群，分别是 West 和 East。\n\n![Kubernetes 集群联邦架构](multicluster.svg)\n\n集群联邦要求 Host 集群与成员集群的之间的网络能够互通，对成员集群之间的网络连接性没有要求。Host 集群作为 API 入口，外界所有对 Host 集群的资源请求会转发到成员集群中。Host 集群中部署有集群联邦的控制平面，其中的「Push Reconciler」会将联邦中的身份、角色及角色绑定传播到所有的成员集群中。集群联邦只是简单地将多个集群简单的「连接到了一起」，在多个集群之间复制工作负载，而成员集群之间的流量无法调度，也无法实现真正的多租户。\n\n集群联邦不足以实现混合云，为了实现真正意义上的混合云，就要让集群之间做到互联互通，同时实现多租户。TSB 在 Istio 之上构建一个多集群管理的通用控制平面，然后再增加一个管理平面来管理多集群，提供多租户、管理配置、可观测性等功能。下面是 Istio 管理平面的多租户和 API 示意图。\n\n![TSB 在 Istio 之上构建的管理平面示意图](tsb-management-plane.svg)\n\nTSB 为管理混合云，基于 Istio 构建了一个管理平面，新建了 Tenant 和 Workspace 的资源，并通过选择器，将网关组、流量组和安全组应用到对应集群中的工作负载上。关于 TSB 的详细架构请参考 TSB 文档。\n\n## 更多{#more}\n\n如果你想了解更多关于 Istio 和云原生的内容，下面有一些资料分享给你：\n\n- 为了帮助大家更好的了解 Istio 和云原生，笔者在 2020 年发起了[云原生社区](https:\/\/cloudnative.to)，欢迎大家加入我们一起探索后 Kubernetes 时代的云原生新范式；\n- 2022 年 6 月，云原生社区著的[《深入理解 Istio —— 云原生服务网格进阶实战》](\/blog\/istio-service-mesh-book\/)已图书由电子工业出版社出版，欢迎大家购买；\n- 笔者于 2022 年 5 月，将之前所作电子书、教程和译文全部迁移到了[云原生资料库](\/book\/)欢迎阅读和留言评论。\n\n## 参考\n\n[^1]: 有关 Envoy 开源的详细过程，推荐你阅读 Envoy 作者 Matt Klein 的这篇文章[网络代理 Envoy 开源五周年，创始人 Matt Klein 亲述开源心路历程及经验教训](https:\/\/cloudnative.to\/blog\/envoy-oss-5-year\/)。\n\n[^2]: 后来 IBM 与 Google 反目，大举抨击 Google 没有遵守将 Istio 捐献给 CNCF 的约定，Google 对 Istio 商标的管理也受到了[质疑](https:\/\/thenewstack.io\/googles-management-of-the-istio-service-mesh-raises-questions-in-the-cloud-native-community\/)。\n[^3]: 2018 年，CNCF 为云原生的重新定义是：云原生技术有利于各组织在公有云、私有云和混合云等新型动态环境中，构建和运行可弹性扩展的应用。云原生的代表技术包括容器、服务网格、微服务、不可变基础设施和声明式 API。\n[^4]: Day-2 Operation 是在系统的生命周期结束前，对系统不断改进的过程，以实现效益最大化。参考 [什么是 Day-2 Operation](https:\/\/jimmysong.io\/blog\/what-is-day-2-operation\/)。\n[^5]: Istio 现已推出 proxyless 模式测试版，详见 [基于 gRPC 和 Istio 的无 sidecar 代理的服务网格](https:\/\/cloudnative.to\/blog\/grpc-proxyless-service-mesh\/)。\n[^6]: Kubernetes 预计推出 [Gateway API](\/book\/kubernetes-handbook\/service-discovery\/gateway\/)，Istio 也有计划使用 Kubernetes 的 Gateway API 替换当前 Istio 自定义的 Gateway 资源。\n[^7]: 有关服务网格项目的详细对比请参考 [servicemesh.es](https:\/\/servicemesh.es\/) 网站。\n[^8]: 《[告别 Sidecar—— 使用 eBPF 解锁内核级服务网格](https:\/\/cloudnative.to\/blog\/ebpf-solve-service-mesh-sidecar\/)》这篇文章在云原生社区里引起了一系列关于服务网格将被 eBPF 技术所取代的讨论。[请暂时抛弃使用 eBPF 取代服务网格和 sidecar 模式的幻想](https:\/\/jimmysong.io\/blog\/epbf-sidecar-and-service-mesh\/)，不管有没有 eBPF，在可预见的未来，服务网格都会基于运行在用户空间的 sidecar 代理（proxyless 模式除外）。\n[^9]: 在百度的服务网格团队分享的 [殊途同归，Proxyless Service Mesh 在百度的实践与思考](https:\/\/mp.weixin.qq.com\/s\/G8vmlJyaimux_K-548kFbA) 这篇文章里，详细介绍了百度的服务网格采用路径，以及对服务网格本质的探索。\n[^10]: 关于 xDS 协议，请参考 [Envoy 中的 xDS REST 和 gRPC 协议详解](https:\/\/cloudnative.to\/blog\/envoy-xds-protocol\/) 这篇文章。\n[^11]: [PEP](https:\/\/www.oreilly.com\/library\/view\/network-access-control\/9780470398678\/9780470398678_policy_enforcement_point.html)，全称 Policy Enforcement Point，策略执行点（PEP）是控制用户访问并确保策略决策点 (PDP) 做出授权决策的网络或安全设备。在一些 NAC 实现中，PDP 是有线交换机或无线接入点。在其他情况下，PEP 是防火墙、IPS、服务器或内联设备。根据实施情况，PEP 和 PDP 可以是独立设备，也可以合并为单个设备。\n[^12]: Apache SkyWalking 的 Rover 组件利用 eBPF 技术改进了 SkyWalking 的剖析功能，可用于分析服务网格的性能问题，请参考 [使用 eBPF 准确定位服务网格的关键性能问题](https:\/\/cloudnative.to\/blog\/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf\/)。\n[^13]: 有多家公司正在合作开发 Envoy Gateway，包括 [Ambassador Labs](https:\/\/www.getambassador.io\/)、[Fidelity Investments](https:\/\/www.fidelity.com\/)、[Project Contour](https:\/\/projectcontour.io\/) 和 [VMware](https:\/\/www.vmware.com\/)。\n[^14]: Istio 仅可以路由 TCP 流量，默认支持 HTTP、HTTPS、gRPC 和原始 TCP 协议，其中 Sidecar 和 Gateway 所支持的协议范围有所不同，详见 [Istio 文档](https:\/\/istio.io\/latest\/docs\/ops\/configuration\/traffic-management\/protocol-selection\/)。\n[^15]: SidecarScope 是在 Istio 1.1 版本中引入的，它并不是一个直接面向用户的配置项，而是 Sidecar 资源的包装器，具体来说就是 Sidecar 资源中的 \u0060egress\u0060 选项。通过该配置可以减少 Istio 向 Sidecar 下发的数据量，例如只向某个命名空间中的某些服务下发某些 hosts 的访问配置，从而提高应用提高性能。\n[^16]: \u0060pilot-agent\u0060 是 sidecar 容器中的主进程，你可以在 [Istio 的组成架构图](#istio-components)中看到。\u0060pilot-agent\u0060 中的镜像提取机制（在 Istio 1.9 中引入），从远程 HTTP 源可靠地检索 Wasm 二进制文件，已被扩展到支持从任何 OCI 注册处检索 Wasm OCI 镜像，包括 Docker Hub、Google Container Registry（GCR）、Amazon Elastic Container Registry（Amazon ECR）和其他地方。\n[^17]: Istio 具有身份和证书管理功能，可以实现服务间的终端用户认证，在控制平面还采用微服务架构的时候，其中的 Citadel 组件负责证书管理，在 Istio 1.5 版本被合并到单体 Istiod 中了。\n', '\/blog\/beyond-istio-oss\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文从云原生大背景下重新审视 Istio，讲解 Istio 诞生，在云原生技术栈中的地位及发展方向。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
          <div class="col-12">
 
 
 
 
 
 
 
 
 
 
 
 <nav aria-label="Page navigation">
   <ul class="pagination justify-content-center">
     
     
     <li class="page-item">
       <a class="page-link" href="/blog/">
         ««
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a href="/blog/page/13/" class="page-link">
         «
       </a>
     </li>
     
     
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item">
           <a href="/blog/page/12/" class="page-link">
             12
           </a>
         </li>
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item">
           <a href="/blog/page/13/" class="page-link">
             13
           </a>
         </li>
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item page-item active ">
           <a href="/blog/page/14/" class="page-link">
             14
           </a>
         </li>
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item">
           <a href="/blog/page/15/" class="page-link">
             15
           </a>
         </li>
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item">
           <a href="/blog/page/16/" class="page-link">
             16
           </a>
         </li>
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
     
     
     <li class="page-item">
       <a href="/blog/page/15/" class="page-link">
         »
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a class="page-link" href="/blog/page/26/">
         »»
       </a>
     </li>
     
   </ul>
 </nav>
 
</div>

        </div>
      </div>
      <!-- sidebar -->
      <aside class="col-lg-4 order-1 order-lg-2 d-none d-sm-block">
          <div class="sidebar">
          <!-- categories -->
<div class="blog-categories mb-4">
  <p class="sidebar-title">
      专栏
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/istio" class="sidebar-item">
            <span>Istio</span>
            <span>(70)</span>
        </a>
      
        <a href="/categories/service-mesh" class="sidebar-item">
            <span>Service Mesh</span>
            <span>(39)</span>
        </a>
      
        <a href="/categories/kubernetes" class="sidebar-item">
            <span>Kubernetes</span>
            <span>(24)</span>
        </a>
      
        <a href="/categories/%e9%9a%8f%e7%ac%94" class="sidebar-item">
            <span>随笔</span>
            <span>(21)</span>
        </a>
      
        <a href="/categories/%e4%b8%9a%e6%80%81" class="sidebar-item">
            <span>业态</span>
            <span>(17)</span>
        </a>
      
        <a href="/categories/%e5%85%b6%e4%bb%96" class="sidebar-item">
            <span>其他</span>
            <span>(17)</span>
        </a>
      
        <a href="/categories/envoy" class="sidebar-item">
            <span>Envoy</span>
            <span>(16)</span>
        </a>
      
        <a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f" class="sidebar-item">
            <span>云原生</span>
            <span>(14)</span>
        </a>
      
        <a href="/categories/ai" class="sidebar-item">
            <span>AI</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%ae%89%e5%85%a8" class="sidebar-item">
            <span>安全</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%bc%80%e6%ba%90" class="sidebar-item">
            <span>开源</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%8f%af%e8%a7%82%e6%b5%8b%e6%80%a7" class="sidebar-item">
            <span>可观测性</span>
            <span>(5)</span>
        </a>
      
        <a href="/categories/%e6%97%85%e8%a1%8c" class="sidebar-item">
            <span>旅行</span>
            <span>(4)</span>
        </a>
  </div>
</div>

<div class="blog-categories mb-4">
  <p class="sidebar-title">
      资料
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/%e5%87%ba%e7%89%88%e7%89%a9" class="sidebar-item">
            <span>出版物</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e7%94%b5%e5%ad%90%e4%b9%a6" class="sidebar-item">
            <span>翻译电子书</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e6%96%87%e6%a1%a3" class="sidebar-item">
            <span>翻译文档</span>
            <span>(7)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>翻译图书</span>
            <span>(6)</span>
        </a>
      
        <a href="/categories/%e5%8e%9f%e5%88%9b%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>原创图书</span>
            <span>(2)</span>
        </a>
      
        <a href="/categories/%e6%95%99%e7%a8%8b%e6%89%8b%e5%86%8c" class="sidebar-item">
            <span>教程手册</span>
            <span>(1)</span>
        </a>
  </div>
</div>





          </div>
      </aside>
      <!-- /sidebar -->
    </div>
  </div>
</section>




<footer>
  
  <div class="footer bg-footer section-sm border-bottom overlay ">
    <div class="container-xl">
      <div class="row">
        <div class="col col-xl-4 d-sm-none mb-2 mb-lg-0 d-xl-block d-none">
          
          <p class="h3 text-white mb-4 text-uppercase">联系</p>
          
          <ul class="list-unstyled">
            
            
            <li class="mb-4 text-color">微信公众号</li>
            
            
            <li class="mb-4"><img src="/images/servicemesher-wechat.webp" width="118px" height="118px" alt="footer image"></li>
            
            
            
          
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">博客</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/blog/kubecon-china-2024-recap/">KubeCon China 2024 回顾：引领云原生技术的前沿动态</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/black-myth-wukong-game-life/">从黑神话悟空聊起：我心目中的 3A 大作</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/envoy-gateway-integration-istio-mesh/">集成 Envoy Gateway 作为 Istio 服务网格中的入口网关</a></li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">链接</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://istio.io/latest/zh/" target="_blank" rel="noopener noreferrer">
                  Istio 服务网格
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://tetrate.io/?jimmysong" target="_blank" rel="noopener noreferrer">
                  Tetrate 公司
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener noreferrer">
                  云原生学院|Bilibili
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/awesome-cloud-native/" target="_blank" rel="noopener noreferrer">
                  云原生开源项目大全
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://cloudnative.to" target="_blank" rel="noopener noreferrer">
                  云原生社区（中国）
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">教程</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/envoy-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Envoy 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/istio-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Istio 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/kubernetes-handbook/" >
                  Kubernetes 基础教程
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">通知</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/notice/nist-sp-800-233-service-mesh-proxy-models/">资料分享：云原生应用服务网格代理模型的威胁分析指南</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/kubecon-china-2024-panel/">KubeCon China 2024（香港）</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/website-revamp-notice/">网站改版通知</a></li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>

  
  <div class="copyright py-4 bg-footer overlay">
    <div class="container-xl">
      <div class="row">
        <div class="col-sm-6 text-sm-left text-center">
          <p class="mb-0 text-color">© 2017-2024 Jimmy Song 保留所有权利</p>
        </div>
        <div class="col-sm-6 text-sm-right text-center">
          <ul class="list-inline">
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://twitter.com/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-x-twitter text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/contact/" >
                    <i class="fa-brands fa-weixin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://github.com/rootsongjc" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-github text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://linkedin.com/in/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-linkedin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="mailto:rootsongjc@gmail.com" >
                    <i class="fa-solid fa-envelope text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/blog/index.xml" >
                    <i class="fa-solid fa-rss text-white"></i>
              </a>
            </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>


<!-- JS Plugins -->

<script src="/plugins/popper/popper.min.js"></script>

<script src="/plugins/bootstrap/bootstrap.min.js"></script>

<script src="/plugins/slick/slick.min.js"></script>

<script src="/plugins/filterizr/jquery.filterizr.min.js"></script>

<script src="/plugins/search/fuse.min.js"></script>

<script src="/plugins/search/mark.js"></script>

<script src="/plugins/hex_md5/hex_md5.js"></script>

<script src="/plugins/anchor/anchor.min.js"></script>

<script src="/plugins/tocbot/tocbot.min.js"></script>

<script src="/plugins/bigger-picture/bigger-picture.min.js"></script>


<!-- Main Script -->

<script src="/js/script.min.f94c22b1d478bfc9e2e0a7d954429e47b7e6d36edd423758482e04154ae1842e.js"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-ESY906ZWZ0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ESY906ZWZ0');
</script>


<!-- Baidu analysis -->
<meta name="baidu-site-verification" content="g8IYR9SNLF" />


<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?11f7d254cfa4e0ca44b175c66d379ecc";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>




<script>
    anchors.add();
</script>






<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>










<script src="/js/wowchemy-search.min.7a37268e7bbe4a9160c2e4c33b749816.js" type="module"></script>
<script id="search-hit-fuse-template" type="text/x-template">
  <div class="search-hit" id="summary-{{key}}">
    <div class="search-hit-content border-bottom">
      <div class="search-hit-name">
        <div class='search-hit-link'><a href="{{relpermalink}}">{{title}}</a></div>
        <div class="search-hit-metadata d-flex">
            <span class="mr-1"><i class="fa-regular fa-calendar mr-1"></i>{{date}}</span>
            <span class="mr-1"><i class="fa-regular fa-folder-open mr-1"></i>{{section}}</span>
            <span class="d-sm-block d-none"><i class="fa-solid fa-link mr-1"></i>{{relpermalink}}</span>
        </div>
        <div class="search-hit-description">{{snippet}}</div>
      </div>
    </div>
  </div>
</script>



    </body>
</html>
