<!DOCTYPE html>
<html lang="zh"><head>
  <meta charset="utf-8">
  
  <title>博客 · Jimmy Song</title>
  

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta name="description" content="Jimmy Song 的原创博客及译文。">
  <meta name="author" content="Jimmy Song">
  <meta name="generator" content="Hugo 0.129.0">

  <!-- CSS plugins -->
  
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
  
  <link rel="preload" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" as="style">
  <link rel="stylesheet" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" media="screen">
  

  <!-- Main Stylesheet -->
  
  <link rel="preload" href="/scss/style.min.6fb3e96087b14e4e93b1864f8131c7847fc003876bec82f602ff6e89143fedc8.css" as="style">
  <link rel="stylesheet" href="/scss/style.min.6fb3e96087b14e4e93b1864f8131c7847fc003876bec82f602ff6e89143fedc8.css" media="screen">

  <!-- Bigger picture css -->
  
  <link rel="stylesheet" href="/plugins/bigger-picture/bigger-picture.min.css" media="print" onload="this.media='all'">
  <!--Favicon generate by https://realfavicongenerator.net-->
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="200x200" href="/images/favicon.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">

  <link href='/opensearchdescription.xml' rel='search' title='Content search' type='application/opensearchdescription+xml'/>

  <!--Twitter card-->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="jimmysong.io" />
  <meta name="twitter:creator" content="@jimmysongio" />
  <meta property="og:url" content="https://jimmysong.io/blog/" />
  <meta property="og:title" content="博客 | Jimmy Song" />
  <meta property="twitter:title" content="博客 | Jimmy Song" />

  
  <meta property="og:description" content="Jimmy Song 的原创博客及译文。" />
  <meta property="twitter:description" content="Jimmy Song 的原创博客及译文。" />

  
  <meta property="og:image" content="https://jimmysong.io/images/banner/default.jpg" />
  <meta property="twitter:image" content="https://jimmysong.io/images/banner/default.jpg" />

  
  
</head>
<body>
<header class="fixed-top header">
  
  
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa fa-arrow-circle-up" aria-hidden="true"></i></button>
  
  <div class="navigation w-100 ">
    <div class="container-xl">
      <nav class="navbar navbar-expand-lg navbar-light p-0">
        <a class="navbar-brand" href="/">
            
            <b>JIMMY SONG</b>
            
        </a>
        <button class="navbar-toggler rounded-0" type="button" data-toggle="collapse" data-target="#navigation"
          aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse text-center" id="navigation">
          <ul class="navbar-nav ml-auto">
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/blog">博客</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/book">资料</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/tags">标签</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/notice">公告</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/contact">联系</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/about">关于</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/community/">社区</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener">视频 <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i></a>
              
            </li>
            
            

          
          
          <li class="nav-item">
            
            
            
              
              
                
                
                
                  
                    
                    <a class="nav-link" href="/en/blog/">English</a>
                    
                  
                
              
              
              
                
                  
                    
                    
                  
                
                
                
              
          </li>
          
          
          <!-- search -->
           <button type="button" class="search-btn js-search" id="searchOpen" aria-label="Search">
              <div class="search-container d-flex justify-content-center">
              <span class="search-content">
                  <i class="fa fa-search"></i>
                  <span>搜索</span>
              </span>
              <span class="search-shortcuts d-none d-sm-block">
                  <kbd class="cmd-key">⌘</kbd>
                  <kbd class="k-key">K</kbd>
              </span>
              </div>
          </button>
          
          </ul>
        </div>
      </nav>
    </div>
  </div>
</header>


            <aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between">
        <div class="col-6 search-title">
          <p>站内搜索</p> 
        </div>
        <div class="col-6 col-search-close">
          <div class="js-search" aria-label="关闭"><i class="fa-solid fa-circle-xmark text-muted" aria-hidden="true"></i></div>
        </div>
      </div>

      <div id="search-box">
        <i class="fa-solid fa-magnifying-glass" id="search-icon" aria-hidden="true"></i>
        <input name="q" id="search-query" placeholder="请输入搜索词" autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control" aria-label="请输入搜索词">
        
        <div class="mt-4">
          <span>搜索类型: </span>
          <span>
            <input type="radio" id="all" name="search_type" value="all" checked>
            <label for="all">所有</label>
            
              <input type="radio" id="blog" name="search_type" value="blog">
              <label for="blog">原创</label>
              <input type="radio" id="trans" name="search_type" value="trans">
              <label for="trans">译文</label>
            
            <input type="radio" id="book" name="search_type" value="book">
            <label for="book">资料</label>
            <input type="radio" id="notice" name="search_type" value="notice">
            <label for="notice">公告</label>
          </span>
        </div>
      </div>
      
    </section>
    <section class="section-search-results">
      <div id="search-results-count" class="search-results-count"></div>
      <div id="search-hits">
        
      </div>
    </section>
  </div>
</aside>

        
        
            

<section class="bg-cover page-title-section overlay" style="background-image: url('/images/backgrounds/circle.svg'),url('/images/backgrounds/page-title.webp');background-size: cover;">
    <div class="container-xl">
        <div class="row">
            <div class="col-12">
                <p class="h1">
                    博客
                </p>
                <p class="page-description">
                    Jimmy Song 的原创博客及译文。
                </p>
                
            </div>
        </div>
    </div>
</section>

        


<section class="section-sm book-list-section bg-gray">
  <div class="container-xl">
    <div class="row">
      <div class="col-lg-8 order-2 order-lg-1">
        <div class="row">
          
          
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/cloud-native-devops-book/">TheNewStack 云原生 Devops 报告解读</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2019/06/02</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f"> 
             云原生
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('TheNewStack 云原生 Devops 报告解读', '本书是 TheNewStack 编辑集结 DevOps 领域的专家在各种大会上的发言、演讲编纂而成。', '\n本书的主旨是：如果没有成熟的 DevOps 实践，云原生是玩转不起来的。DevOps 已经不是什么新鲜的话题，但到底什么是 \u0022Cloud Native DevOps”及如何实践 Cloud Native DevOps，这正是本书要探讨的内容。\n\nDevOps 正在经历一次转型，从自动化构建到声明式基础设施、微服务和 Serverless。大部分人对云原生存在误解，以为\u0060云原生\u0060就是\u0060运行在云上\u0060，其实云原生更偏向于一种理念，即应用的定义及架构方式，而不是将应用运行在哪里。而云上的 DevOps 与传统的 DevOps 有什么区别，开发者和运维人员在云原生时代如何转型？也许本书会给你答案。\n\n## 关于本书\n\n本书是由 [TheNewStack](https:\/\/thenewstack.com) 出品的免费电子书，可以在 [TheNewStack 网站](https:\/\/thenewstack.io\/ebooks\/devops\/cloud-native-devops-2019\/) 上获取本书的电子版，同时推荐 [TheNewStack 的电子书系列](https:\/\/thenewstack.io\/ebooks)，囊括了容器、微服务、Kubernetes、云原生诸多主题，可以作为企业决策的参考读物。\n\n本书是 TheNewStack 编辑集结 DevOps 领域的专家在各种大会上的发言、演讲，有很多观点引用，并结合了一些调查问卷数据展示了一幅云原生 DevOps 的趋势与全景图，下文中我会找一些代表性的观点和图表来说明。\n\n下面是本书目录，一共分为三大部分：构建、部署和管理，其中前两个部分还给出了参考书目、示例研究等。\n\n![云原生 DevOps 目录](a.jpg)\n\n## 谁适合读这本书\n\nIT 经理、CIO、团队领导者，希望规划自己公司或团队的云原生化 DevOps 的实践路径以面对大规模场景。\n\n## 云原生化的 DevOps\n\n\u003e 云原生是对业务价值和团队功能的重构。\n\n云原生化的 DevOps 在应用的管理上与原始的 DevOps 最大的区别就是——使用 YAML 文件配置的声明式基础设施（Declarative infrastructure）与应用程序的代码本身放在同一个存储库中，这些 \u0060代码\u0060 将由开发团队来维护，而运维团队的职能将转变为基础设施的构建者，服务安全性、健壮性、可见性及耐用性的守护者。\n\nAWS 的 Serverless 布道师 Chris Munns 早已甚至预测到 2025 年非云供应商的运维人员将不复存在，虽然听上去有点危言耸听，但这也是为传统 IT 运维人员的职业生涯敲响的警钟。\n\n![云原生 DevOps 高亮部分](b.jpg)\n\n开发接手了原来传统运维的一些职责，如配置和发布，减少了每次发布的成本，而运维的职责向管理整个系统的复杂性转变，例如转变为 SRE（Site Reliability Engineer）。\t\n\n## 工作流自动化的价值\n\nDevOps 的原始教义：DevOps 不是一种工具或流程，而是一种重视整个组织的持续沟通、协作、集成和自动化的实践。\n\n![工作流自动化的五个案例](c.jpg)\n\n根据自动化的驱动力及持续时间的长短，将 Workflow Automation 划分为五个类别。\n\n- 业务流程自动化\n- 分布式系统通信\n- 分布式事务\n- 编排\n- 决策自动化\n\n## 运维需要做出的转变\n\nDamon Edwards 提出于运维需要面对的四个灾难（[圣经启示录中的四骑士](https:\/\/zh.wikipedia.org\/wiki\/启示录中的四骑士)）：\n\n- Silos（孤岛）\n- Ticket queues（无尽的低效的工单）\n- Toil（干脏活累活的辛勤）\n- Low trust（低信任度）\n\n要向云原生 DevOps 转变就要克服以上几个问题。\n\n## DevOps 领域的扩展\n\n本书第三章中提到 DevOps 的领域扩展到 Security 和 Networking。\n\n- 为了维持合规的编程语言\n- 容器镜像扫描\n- 基于策略的网络安全\n- 金丝雀测试\n- 运行时的威胁检测\n- 日志分析', '\/blog\/cloud-native-devops-book\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本书是 TheNewStack 编辑集结 DevOps 领域的专家在各种大会上的发言、演讲编纂而成。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/open-source-cla/">开源社区贡献者协议 CLA 介绍</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2019/04/20</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e5%bc%80%e6%ba%90"> 
             开源
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('开源社区贡献者协议 CLA 介绍', '很多从事开源人可能会注意到有些开源项目要求贡献者在提交 PR 前首先签署 CLA。', '\n很多从事开源人可能会注意到有些开源项目要求贡献者在提交 PR 前首先签署 CLA，只有签署了 CLA 之后 PR 才可以合并。\n\n## 开源贡献协议简介\n\n下面列举了开源贡献协议的一些简介：\n\n- 开源贡献协议有 CLA（Contributor License Agreement）和 [DCO](https:\/\/developercertificate.org\/)（Developer Certificate of Origin）两种；\n- DCO 由 Linux Foundation 提出，是固定的简短条文（只有 4 条），旨在让贡献者保证遵守开源 license；\n- CLA 是对开源 license 的法律性质补充，由法务制定；\n- CLA 可以自定义，不论是个人还是企业级签署的时候都需要提供详细的信息，如姓名、公司、邮箱、地址、电话等；\n- 下表中对比了 CLA 和 DCO 的特性，推荐大型跨公司开源项目使用 CLA，利用项目更加正规和长久发展；\n\n开源社区的贡献者协议一般分为两种 CLA 和 DCO，这两种协议各有优缺点如下。\n\n| 特性         | CLA                                                | DCO                                                        |\n| ------------ | -------------------------------------------------- | ---------------------------------------------------------- |\n| 社区属性     | 弱                                                 | 强                                                         |\n| 签署方式     | 一次性                                             | 每次提交时在 commit 信息里追加 \u0060Signed-off-by: email\u0060 信息 |\n| 法律责任     | 明确法律义务                                       | 无声明，用来限制提交者遵守开源 license                     |\n| 是否可自定义 | 公司或组织可自行定义                               | 否                                                         |\n| 使用案例     | Google、Pivotal、CNCF、阿里巴巴、Apache SkyWalking | GitLab、Chef、Harbor、TiKV                                 |\n| 公司属性     | 强，可以签署公司级别的 CLA                         | 弱                                                         |\n\n## 什么是 CLA\n\nCLA 是 Contributor License Agreement 的缩写，CLA 可以看做是对开源软件本身采用的开源协议的补充。一般分为公司级和个人级别的 CLA，所谓公司级即某公司代表签署 CLA 后即可代表该公司所有员工都签署了该 CLA，而个人级别 CLA 只代表个人认可该 CLA。\n\n## CLA 包含哪些内容？\n\n因为 CLA 是每个公司或组织自定义的，在细节上可能稍有不同，不过总体都包含以下内容：\n\n- 关于签署该 CLA 的主体和贡献的定义；\n- 授予著作权给拥有该软件知识产权的公司或组织；\n- 专利许可的授予；\n- 签署者保证依法有权授予上述许可；\n- 签署者确保所有的贡献内容均为原创作品；\n- 签署者为贡献内容支持的免责描述；\n- 说明贡献者提交非原创作品应该采用的方式；\n- 保证在获悉任何方面不准确的事实或情况之时通知签约方；\n\n对于主体在中国的企业，还加入了一些本地化的内容，如 [Alibaba Open Source Individual CLA](https:\/\/github.com\/aliyun\/cla)。\n\n因为 CLA 分别为个人级和公司级，所以对于不同名义签署时需要提供不同的信息。签署个人级 CLA 的时候需要提供个人信息（姓名、地址、邮箱、电话等），签署公司级 CLA 还需要提供公司信息（名称、地址、联系电话、邮箱、传真等）；\n\n## 什么是 DCO\n\nDCO 是 Developer Certificate of Origin 的缩写，由 Linux Foundation 于 2004 年制定。DCO 最大的优点是可以减轻开发者贡献的阻碍，不用阅读冗长的 CLA 法律条文，只需要在提交的时候签署邮件地址即可。Chef 和 GitLab 已分别于 2016 年和 2017 年从 CLA 迁移到 DCO。\n\n如 CNCF 的 Sandbox 项目 [harbor](https:\/\/github.com\/goharbor\/harbor) 就是使用的 DCO。\n\n[DCO](\u003chttps:\/\/developercertificate.org\/\u003e) 目前是 1.1 版本，内容很简单，开源项目的贡献者只需要保证以下四点：\n\n1. 该贡献全部或部分由我创建，我有权根据文件中指明的开源许可提交；要么\n2. 该贡献是基于以前的工作，这些工作属于适当的开源许可，无论这些工作全部还是部分由我完成，我有权根据相同的开源许可证（除非我被允许根据不同的许可证提交）提交修改后的工作；要么\n3. 该贡献由 1、2、或 3 证明的其他人直接提供给我，而我没有对其进行修改。\n4. 我理解并同意该项目和贡献是公开的，并且该贡献的记录（包括我随之提交的所有个人信息，包括我的签字）将无限期保留，并且可以与本项目或涉及的开源许可证保持一致或者重新分配。\n\n## CLA vs DCO\n\nKubernetes 社区中有过讨论将 Kubernetes 贡献者从 CLA 迁移到 DCO，最后 TOC 成员 Tim Hockin 觉得签署 CLA 对于贡献者只需要痛苦一次，每次提交都签署 DCO 是持续的痛苦，因此最后还是坚持使用 CLA。参考[Move from CLA to DCO #2649](https:\/\/github.com\/kubernetes\/community\/issues\/2649)。\n\n2018 年 CNCF 对其托管的项目的 Maintainer 做了调研，从反馈来看，Maintainer 对 DCO 是存在痛点的，并希望 CNCF 投入更多的 PR 和市场力量来对抗具有全职 PR\/marketing 的初创公司。\n\n如果为了更注重个人贡献者，考虑社区属性，可以使用 DCO，这样对于开源项目的管理者来说就不用指定复杂的 CLA 了，但是对于大型项目由众多合作方的项目，建议使用 CLA。\n\n## 阿里巴巴 CLA\n\n阿里巴巴只提供个人级别的 CLA 签署：\u003chttps:\/\/cla-assistant.io\/alibaba\/weex\u003e\n\nCLA 内容见：\u003chttps:\/\/github.com\/aliyun\/cla\u003e\n\n阿里巴巴的 CLA 是参照 [Apache CLA](https:\/\/www.apache.org\/licenses\/icla.pdf) 撰写的，最后加上两条补充，协议受中国杭州的法院监管，同时提供双语版本，如中引文版本有冲突以英文版本为准。\n\n## Google CLA\n\nGoogle 的 CLA 也是仿照 Apache CLA 撰写的，Google 开源的一些列项目如 Istio、TensorFlow、Knative 等都是需要签署 [Google CLA](\u003chttps:\/\/cla.developers.google.com\/clas\u003e)。\n\n1. 要贡献者授予 Google 以及其他软件用户贡献内容的版权以及内容背后的专利权。贡献者不要因为版权和专利权诉讼 Google 和其他软件用户。\n2. 明确贡献的原创性。不要因为贡献者的不适当抄袭行为，导致 Google 和其他软件使用者被诉讼。\n3. 签署公司级别 CLA 的人要能代表所在公司的所有贡献者。\n4. 维护贡献者列表的不一定是跟签署该协议的是同一个人，签名者可以指定一个人来管理。\n\n参考：[解读：Google Software Grant and Corporate Contributor License Agreement](https:\/\/docs.google.com\/document\/d\/1FJkYaEZbKwmoEWrsbzDxdI-ytlEg73OsOcMXaF8Z01E\/)\n\n## Pivotal CLA\n\nPivotal 的 CLA 也是仿照 Apache CLA 撰写的，唯一增加了一点是协议受美国加州法律监管。签署个人级协议的时候需要提供姓名、邮箱、邮寄地址（可选）、国家（可选）、电话（可选），签署公司级别的 CLA 的条款了还增加了一条对于签名者必须有权利代表整个公司，要求的信息也更加详细，包括姓名、邮箱、邮寄地址、国家、电话、公司名称、GitHub 组织、头衔等。参与贡献 Pivotal 主导的 Spring 社区和 CloudFoundry 里的项目需要签署 [Pivotal CLA](\u003chttps:\/\/cla.pivotal.io\/\u003e)。\n\n## 建议\n\n如果你的开源项目可能会有公司间合作或者要贡献给基金会，为了防范法律风险，请直接使用 CLA；如果更看重社区内的合作，可以使用 DCO。\n\n## 参考\n\n- [Individual Contributor License Agreement (“Agreement”) V2.0](https:\/\/www.apache.org\/licenses\/icla.pdf)\n- [Move from CLA to DCO #2649 - github.com](https:\/\/github.com\/kubernetes\/community\/issues\/2649)\n- [Alphabet CLA Policy and Rationale - opensource.google.com](https:\/\/opensource.google.com\/docs\/cla\/policy\/)\n- [The Apache Software Foundation Software Grant and Corporate Contributor License Agreement (\u0022Agreement\u0022) - apache.org](\u003chttps:\/\/www.apache.org\/licenses\/cla-corporate.txt\u003e)\n- [Alibaba Open Source Individual CLA - github.com](https:\/\/github.com\/aliyun\/cla)\n', '\/blog\/open-source-cla\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">很多从事开源人可能会注意到有些开源项目要求贡献者在提交 PR 前首先签署 CLA。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/contribute-project-to-cncf/">如何将一个开源项目加入 CNCF？</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2019/04/15</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e5%bc%80%e6%ba%90"> 
             开源
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('如何将一个开源项目加入 CNCF？', ' CNCF 基金会的开源项目治理规则和组织架构，还有如何将一个开源项目加入到 CNCF。', '\n前段时间看了一篇文章[为什么中国没有 Apache 基金会这样的组织？](https:\/\/www.infoq.cn\/article\/l0bCXU3SojYXpz-AhP3v)，二叉树视频中采访了[开源社](http:\/\/www.kaiyuanshe.cn\/)的理事长老刘，他的一番话也让我很受启发，在关注和参与 CNCF 基金会这几年来我也有很多收获，有一点就是了解到了一个开源社区（基金会）治理的规则。\n\n虽然 CNCF 没有 Apache、GNOME、FreeBSD 历史那么悠久，但是它成立的短短几年内就成功的运作了 [Kubernetes](https:\/\/kubernetes.io) 这样的超大型开源项目，一定有其可取之处。今天我就来给大家分享下 CNCF 基金会的开源项目治理规则和组织架构，还有如何将一个开源项目加入到 CNCF。\n\nCNCF 根据“[鸿沟理论](\/blog\/crossing-the-chasm\/)”将其托管的项目分成三个成熟阶段，并设置了项目晋级到更高阶段的标准。\n\n\u003e “鸿沟理论”是由 Geoffrey A. Moore 提出的高科技产品的市场营销理论。新技术要想跨越鸿沟，必须能够实现一些跨越式的发展，**拥有某一些以前不可能实现的功能**，具有某种内在价值并能够**赢得非技术人员的**青睐。\n\n![CNCF 项目的成熟度分类](cncf-graduation.jpg)\n\n*图片来自 \u003chttps:\/\/www.cncf.io\/projects\/\u003e*\n\n### 开源项目如何加入 CNCF\n\n1. 开源项目所支持的公司成为 CNCF 会员\n2. 开源项目满足 CNCF 的要求（见后文）\n3. 在 GitHub 上提交 [proposal](https:\/\/github.com\/cncf\/toc\/issues\/113)（GitHub Issue）列举项目介绍、现状、目标、license、用户与社区等\n4. 由 Chris Aniszczyk 安排该项目在某个 TOC 双月会议上介绍给 TOC 成员\n5. 1.TOC 会将开源项目指定到某个 [SIG](https:\/\/jimmysong.io\/kubernetes-handbook\/cloud-native\/cncf-sig.html) 中\n6. 项目获得两个 TOC 成员的赞成可进入 [sandbox](https:\/\/github.com\/cncf\/toc\/blob\/master\/process\/sandbox.md)（也可以直接获得 2\/3 多数 TOC 投票进入 Incubating 状态）\n7. 知识产权转移给 CNCF\n8. CNCF 安排博客撰写、PR 等\n9. 每年一次评审，晋升到 incubating 需要 2\/3 的 TOC 成员投票赞成；至少 3 家用户成功在生产上使用；通过 TOC 的尽职调查；贡献者数量健康稳定\n10. Sandbox 中的项目没有时效性质，可能永远都无法进入 incubating 状态，被 CNCF 谨慎宣传\n\n### CNCF 开源项目成熟度演进\n\nCNCF 的开源项目遵循如下图所示的成熟度演进。\n\n![CNCF 项目成熟度级别](cncf-graduation-criteria-v2.jpg)\n\n关于上图的一些说明：\n\n- 加入 Sandbox 只需要 2 个 TOC 成员赞成\n- 成熟一点的项目可以直接进入 incubating 阶段，但是 CNCF 会控制不同阶段的项目比例\n- 晋级到 Incubating 或 Graduated 需要至少 2\/3 的 TOC 成员（6 名或以上）投票赞成\n- 每年将评审一次\n\n目前处于沙箱、孵化中、已毕业项目的数量比例为 5:16:13，详见 \u003chttps:\/\/cncf.io\/projects\u003e。其中沙箱（sandbox）项目因为其处于早期阶段并没有直接在上面的链接页面中列出，而是一个单独的 [Sandbox](https:\/\/www.cncf.io\/sandbox-projects\/) 页面，因为 CNCF 为 sandbox 阶段的项目会谨慎背书。\n\n### 纳入 CNCF 开源版图的项目需要符合其对云原生的定义\n\nCNCF 中托管的开源项目要符合云原生定义：\n\n- 云原生技术有利于各组织在公有云、私有云和混合云等新型动态环境中，构建和运行可弹性扩展的应用。**云原生的代表技术包括容器、服务网格、微服务、不可变基础设施和声明式 API**。\n- 这些技术能够构建容错性好、易于管理和便于观察的松耦合系统。结合可靠的自动化手段，云原生技术使工程师能够轻松地对系统作出频繁和可预测的重大变更。\n- 云原生计算基金会（CNCF）致力于培育和维护一个厂商中立的开源生态系统，来推广云原生技术。我们通过将最前沿的模式民主化，让这些创新为大众所用。\n\n### 项目运作流程\n\n下图演示了开源项目加入 CNCF 后的整个运作流程。\n\n![CNCF 中的项目运作](006tNc79ly1g1yz80ag98j31cs0n2gr7.jpg)\n\n### 开源项目如何加入 CNCF\n\n1. 开源项目所支持的公司成为 CNCF 会员\n2. 开源项目满足 CNCF 的要求（见后文）\n3. 在 GitHub 上提交[proposal](https:\/\/github.com\/cncf\/toc\/issues\/113)（GitHub Issue）列举项目介绍、现状、目标、license、用户与社区等\n4. 由 Chris Aniszczyk 安排该项目在某个 TOC 双月会议上介绍给 TOC 成员\n5. 1.TOC 会将开源项目指定到某个 [SIG](https:\/\/jimmysong.io\/kubernetes-handbook\/cloud-native\/cncf-sig.html) 中\n6. 项目获得两个 TOC 成员的赞成可进入[sandbox](https:\/\/github.com\/cncf\/toc\/blob\/master\/process\/sandbox.md)（也可以直接获得 2\/3 多数 TOC 投票进入 Incubating 状态）\n7. 知识产权转移给 CNCF\n8. CNCF 安排博客撰写、PR 等\n9. 每年一次评审，晋升到 incubating 需要 2\/3 的 TOC 成员投票赞成；至少 3 家用户成功在生产上使用；通过 TOC 的尽职调查；贡献者数量健康稳定\n10. Sandbox 中的项目没有时效性质，可能永远都无法进入 incubating 状态，被 CNCF 谨慎宣传\n\n### 开源项目加入 CNCF 的最低要求（Sandbox）\n\n一个开源项目要想加入 CNCF 必须满足以下要求：\n\n- 项目名称必须在 CNCF 中唯一\n- 项目描述（用途、价值、起源、历史）\n- 与 CNCF 章程一致的声明\n- 来自 TOC 的 sponsor（项目辅导）\n- license（默认为 Apache 2）\n- 源码控制（Github）\n- 网站（英文）\n- 外部依赖（包括 license）\n- 成熟度模型评估（参考 [开源项目加入 CNCF Sandbox 的要求](https:\/\/jimmysong.io\/kubernetes-handbook\/cloud-native\/cncf-sandbox-criteria.html)）\n- 创始 committer（贡献项目的时长）\n- 基础设施需求（CI\/CNCF 集群）\n- 沟通渠道（slack、irc、邮件列表）\n- issue 追踪（GitHub）\n- 发布方法和机制\n- 社交媒体账号\n- 社区规模和已有的赞助商\n- svg 格式的项目 logo\n\n### 由 Sandbox 升级到 Incubating 的要求\n\n- 通过 TOC 的[尽职调查](https:\/\/github.com\/cncf\/toc\/blob\/master\/process\/due-diligence-guidelines.md)\n- 至少有 3 个独立的终端用户在在生产上使用该项目：一般在项目的官网列举实际用户\n- 足够健康数量的贡献者：项目的 GitHub 上有明确的 committer 权限划分、职责说明及成员列表，TOC 将根据项目大小来确认多少 committer 才算健康\n- **展示项目在持续进行、良好的发布节奏、贡献频率十分重要**\n\n### 由 Incubating 升级到 Graduated 的要求\n\n- 满足 Sandbox 和 Incubating 的所有要求\n- **至少有来自两个组织的贡献者**\n- 明确定义的项目治理及 committer 身份、权限管理\n- 接受 CNCF 的[行为准则](https:\/\/github.com\/cncf\/foundation\/blob\/master\/code-of-conduct.md)，参考[Prometheus](https:\/\/bestpractices.coreinfrastructure.org\/en\/projects\/486)\n- 获得 CII 最佳实践徽章\n- 在项目主库或项目官网有公开的采用者的 logo\n\n参考归档的 Review：\u003chttps:\/\/github.com\/cncf\/toc\/tree\/master\/reviews\u003e\n\n### 参考\n\n- [鸿沟理论 - jianshu.com](https:\/\/www.jianshu.com\/p\/a305fa93580b)\n- [CNCF Graduation Criteria v1.2 - github.com](https:\/\/github.com\/cncf\/toc\/blob\/master\/process\/graduation_criteria.adoc)\n- [为什么中国没有 Apache 基金会这样的组织？ - infoq.cn](\u003chttps:\/\/www.infoq.cn\/article\/l0bCXU3SojYXpz-AhP3v\u003e)\n- [开源社首页 - kaiyuanshe.cn](\u003chttp:\/\/www.kaiyuanshe.cn\/\u003e)\n', '\/blog\/contribute-project-to-cncf\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text"> CNCF 基金会的开源项目治理规则和组织架构，还有如何将一个开源项目加入到 CNCF。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/cncf-annual-report-2018-review/">CNCF 年度报告解读（2018 年）</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2019/02/13</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f"> 
             云原生
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('CNCF 年度报告解读（2018 年）', '本文是对 CNCF（云原生计算基金会）2018 年年度报告的解读。', '\n2019 年 2 月初，CNCF 发布了 2018 年的年度报告，这是 CNCF 继 2017 年度报告之后，第二次发布年度报告，2017 年度的报告只有区区 14 页，今年的报告长度增长了一倍达 31 页。下面我将带大家一起来深度解读下这份 2018 年的年度报告，一窥 CNCF 过去一年里在推广云原生的道路上取得的进展。\n\n*注：本文最后附上了 2017 年和 2018 年度的报告下载地址。*\n\n## CNCF 年度报告涵盖的范围\n\n在解读 CNCF 的 2018 年度报告之前，我们先简单回顾下2017 年度的报告，因为 2017 年度报告是 CNCF 的首份年度报告，这样我们也能更好的了解 CNCF 的来龙去脉。\n\n2017 年度报告已经基本确定了 CNCF 每个年度报告所包含的主题：\n\n- 自我定位\n- 会员参与情况\n- 终端用户社区\n- 项目更新\n- 会议和活动\n- 社区\n- 培训和认证\n\n以上为 CNCF 主要的市场活动，2017 年时其成立的第二年，经过一年时间的筹备，这一年里各种市场活动都已经开始确立并有声有色的开展了起来，包括 KubeCon、成员单位、终端用户都已经发展起来了，以后历年里只是对其不断的发展和完善。\n\n2018 年度报告中又新增了一些主题，这些主题是从 2018 年开始开展的，包括：\n\n- **项目更新与满意度调查**\n  - 给 CNCF 项目的维护者发调查问卷询问满意度\n  - [CNCF charter](https:\/\/www.cncf.io\/about\/charter\/) 的修订（2018 年 11 月）\n  - 项目更新与发布\n  - 项目服务与支援\n  - 专项活动、文档、网站与博客支持\n  - 本地化、IT 支持和培训\n- **社区拓展**\n  - 社区奖项\n  - CNCF Meetup\n  - [CNCF Ambassador 计划](https:\/\/www.cncf.io\/people\/ambassadors\/)\n  - 卡通吉祥物 Phippy\n- **生态系统工具**\n  - [devstats](https:\/\/devstats.cncf.io\/)\n  - [CNCF Landscape](https:\/\/landscape.cncf.io) 和路线图\n  - 项目 logo 物料\n- **测试一致性项目**\n- **国际化**\n  - 进入中国\n  - 本地化网站\n\n详情请大家从本文最后的链接下载报告原文以查看详情。\n\n## CNCF 的定位\n\nCNCF（云原生计算基金会）成立于 2015 年 12 月 11 日，每届年度报告的开篇都会阐明 CNCF 的定位，CNCF 的自我定位在 2018 年发生了一次变动，这也说明基金会是跟随市场形势而动，其定位不是一成不变的，其中的变化暗含着 CNCF 战略的转变。\n\n### CNCF 的 2017 年度定位\n\n2017 年度报告中是这样正式介绍自己的：\n\nThe Cloud Native Computing Foundation (CNCF) is an open source software foundation dedicated to making cloud-native computing universal and sustainable. Cloud-native computing uses an **open source** software stack to deploy applications as **microservices**, packaging each part into its own **container**, and **dynamically orchestrating** those containers to optimize resource utilization. Cloud-native technologies enable software developers to build great products faster. \n\nWe are a community of open source projects, including Kubernetes, Envoy and Prometheus. Kubernetes and other CNCF projects are some of the highest velocity projects in the history of open source. \n\n可以看到介绍中的重点技术是：微服务、容器、动态编排。而在 2018 年 CNCF 对自己进行了重新的定位和包装，增加了新的内容。\n\n### CNCF 的 2018 年度定位\n\n[2018 年度报告](https:\/\/www.cncf.io\/wp-content\/uploads\/2019\/02\/CNCF_Annual_Report_2018_FInal.pdf)中 CNCF 对自己的定位是：\n\nThe Cloud Native Computing Foundation (CNCF) is an open source software foundation dedicated to making cloud native computing universal and sustainable. Cloud native technologies empower organizations to build and run scalable applications in modern, dynamic environments such as public, private, and hybrid clouds. **Containers**, **service meshes**, **microservices**, **immutable infrastructure**, and **declarative APIs** exemplify this approach. \n\nWe are a community of open source projects, including Kubernetes, Prometheus, Envoy, and many others. Kubernetes and other CNCF projects are some of the highest velocity projects in the history of open source. \n\n我们可以看到其表述中更加注重多云环境，主要涉及的技术比 2017 年多了 Service Mesh（服务网格）、不可变基础设施和声明式 API。\n\n## 数读报告\n\nCNCF 年度报告的原文主要是汇报了 CNCF 一年来的所展开的活动和进展，下表示根据 CNCF 2017 和 2018 年度报告整理了关键数据。\n\n| **Year**                                   | **2016** | **2017** | **2018** |\n| ------------------------------------------ | -------- | -------- | -------- |\n| **Members**                                | 63       | 170      | 365      |\n| **Contributors**                           | -        | 18687    | 47358    |\n| **CNCF Meetup Members**                    | -        | 53925    | 89112    |\n| **Projects**                               | 4        | 14       | 32       |\n| **End User Community Members**             | -        | 32       | 69       |\n| **Conference and Events Participants**     | -        | 4085     | -        |\n| **Certified Kubernetes Partners**          | -        | 44       | -        |\n| **Certified Kubernetes Service Providers** | -        | 28       | 74       |\n| **CNCF Ambassador**                        | -        | -        | 65       |\n| **Kubernetes Training Partners**           | -        | -        | 18       |\n\n**注**：其中 2016 年是 CNCF 正式开始工作的第一年，大部分数据因为活动尚未开展而缺失。\n\n从上表中我们可以看到 CNCF 诞生三年来基金会成员规模、托管项目的贡献者、参加 CNCF 名义的 Meetup 的人数取得较大范围的增长，尤其是 2018 年，因为基金会成员的爆发式增长（\u002b130%），CNCF 开始给成员分级，会员级别、费用和权益也在 [CNCF 官网](https:\/\/www.cncf.io\/about\/join\/)上明码标价。\n\n2018 年 CNCF 组织的 KubeCon\u0026CloudNativeCon 开始固定每年在西欧、北美和中国举行，且 2018 年是首次进入中国；原来的 Certified Kubernetes Partners 也取消了变成了 Certified Kubernetes Service Providers；CNCF 的 [Ambassador](https:\/\/www.cncf.io\/people\/ambassadors\/) 计划拥有了来自 15 个国家的 65 位 Ambassador，在世界各地为云原生布道；CNCF 还首次引入了 Kubernetes Training Partner。\n\n2018 年 CNCF 又推出了一系列新的认证（CKA 为 2017 年推出），包括：\n\n- [CKA](https:\/\/www.cncf.io\/certification\/cka\/)（Kubernetes 管理员认证）：这是 CNCF 最早制定的一个证书，顾名思义，通过该认证证明用户具有管理 Kubernetes 集群的技能、知识和能力。虽然该证书在 2017 年即推出，但 2018 年对考试做了更细致的指导。KCSP 要求企业必须有至少三人通过 CKA。\n- [CKAD](https:\/\/www.cncf.io\/certification\/ckad\/)（Kubernetes 应用开发者认证）：该认证证明用户可以为 Kubernetes 设计、构建、配置和发布云原生应用程序。经过认证的 Kubernetes Application Developer 可以定义应用程序资源并使用核心原语来构建、监控 Kubernetes 中可伸缩应用程序和排除故障。\n- [KCSP](https:\/\/www.cncf.io\/certification\/kcsp\/)（Kubernetes 服务提供商认证）：截止本文发稿时共有 74 家企业通过该认证。该认证的主体是企业或组织，通过 KCSP 的企业意味着可以为其他组织提供 Kubernetes 支持、咨询、专业服务和培训。通过该认证的中国企业有：灵雀云、阿里云、博云、才云、DaoCloud、EasyStack、易建科技、精灵云、谐云科技、华为、时速云、星号科技、睿云智合、沃趣、元鼎科技、ZTE。\n- [Certified Kubernetes Conformance](https:\/\/www.cncf.io\/certification\/software-conformance\/)（Kubernetes 一致性认证）：通过该认证的 Kubernetes 提供商所提供的服务，意味着其可以保证 Kubernetes API 的可移植性及跨云的互操作性；及时更新到最新的 Kubernetes 版本；是否一致是可以通过[运行开源脚本](https:\/\/github.com\/cncf\/k8s-conformance\/blob\/master\/instructions.md)验证的。截止本文发稿通过该认证的中国企业的发行版有：灵雀云（ACE、ACP、AKS）、才云 Compass、华为 FusionStage、酷栈科技 CStack MiaoYun、Daocloud Enterprise、新智认知新氦云、浪潮云、京东 TIG、网易云、七牛云、同方有云、睿云智合 WiseCloud；通过认证的中国企业托管平台有：阿里云、百度云、博云、EasyStack、易建科技、谐云科技、华为云 CCE、腾讯云 TKE、时速云、ZTE TECS。\n\n以上是 CNCF 提供的主要证书，一般通过 KCSP 的企业都要先通过 Kubernetes 一致性认证，而通过 Kubernetes 一致性认证不一定要同时通过 KCSP，所以我们看到很多通过 Kubernetes 一致性认证的企业就不一定会通过 KCSP，因为 KCSP 的要求更多，至少要成为 CNCF 会员才可以。\n\n下面将就 CNCF 会员、托管项目的成熟度等级划分、Kubernetes 服务提供商认证和 Kubernetes 提供商认证做详细说明。\n\n## CNCF 会员\n\n2018 年 CNCF 的会员单位经历了爆发式增长，从 170 家增长到 365 家。CNCF 制定了如下的会员等级：\n\n- Silver Member\n- Gold Member\n- Platinum Member\n- Academic\/Nonprofit Member\n- End User Member\n\n不同等级的会员需要交纳的年费与权益不同，详情请见 \u003chttps:\/\/www.cncf.io\/about\/join\/\u003e。\n\n### 成为 CNCF 会员的好处\n\n成为 CNCF 会员包括但不限于如下好处：\n\n- 将可以参与 CNCF 市场委员会、CNCF Webinar、在 CNCF 和 Kubernetes 官网发表博客、博客被 KubeWeekly 收录、\n- 获得 KubeCon \u002b CloudNativeCon 的门票折扣和参与大会的市场活动\n- 对于 Kubernetes 系列认证如 KCSP、入选 TOC 也要求必须成为 CNCF 会员才可以获得\n- End User Case Study\n- 有机会加入 Ambassador 计划\n- 在社区里具有更多的话语权，例如 CNCF 在全球范围内组织的活动\n\n## 项目成熟度等级\n\n自 2015 年底 CNCF 创立之初 Kubernetes 成为其首个托管项目以来，截止到 2018 年底，CNCF 已经托管了[32 个开源项目](https:\/\/www.cncf.io\/projects\/)，随着越来越多的项目加入到 CNCF，为了更好的管理这些项目，为这些项目划分不同的成熟度等级就成了迫在眉睫的事情。\n\n![CNCF 项目成熟度级别](cncf-graduation-criteria-v2.jpg)\n\n根据《Crossing the Chasm》一书中的技术采用生命周期理论，CNCF 将其托管的项目划分为三个等级：\n\n- Graduated：对应于早期成熟项目。截止到本文发稿时只有 [Kubernetes](https:\/\/kubernetes.io\/)、[Prometheus](https:\/\/prometheus.io\/)、[Envoy](https:\/\/www.envoyproxy.io\/) 和 https:\/\/coredns.io\/ 毕业。\n- Incubating：对应于早期采用者阶段。截止到本文发稿时有 16 个项目。\n- Sandbox：对应于创新者阶段。截止到本文发稿时有 12 个项目。\n\n查看 CNCF 托管的项目列表请访问：https:\/\/www.cncf.io\/projects\/\n\nCNCF 通过为项目设置成熟度水平是来建议企业应该采用哪些项目。CNCF 中托管的项目通过向 CNCF 的技术监督委员会（TOC）展示其可持续发展性来提高其成熟度：项目的采用率，健康的变化率，有来自多个组织的提交者，采用了 [CNCF 行为准则](https:\/\/github.com\/cncf\/foundation\/blob\/master\/code-of-conduct-languages\/zh.md)，实现并维护了核心基础设施倡议（Core Infrastructure Initiative）[最佳实践证书](https:\/\/bestpractices.coreinfrastructure.org\/)。详细信息在 [毕业标准 v1.1](https:\/\/github.com\/cncf\/toc\/blob\/master\/process\/graduation_criteria.adoc)。\n\n## Certified Kubernetes Service Provider\n\n通过 [KCSP](https:\/\/www.cncf.io\/certification\/kcsp\/) 意味着企业具有为其他企业或组织提供 Kubernetes 支持、咨询、专业服务和培训的资质。2018 年又有 46 家企业通过了[KCSP](https:\/\/www.cncf.io\/certification\/kcsp\/)，通过该认证的企业累计达到 76 家。\n\n**如何通过 KCSP**\n\n要想通过 KCSP 必须满足以下三个条件：\n\n- 三名或更多工程师通过认证 Kubernetes 管理员（CKA）考试。*（CKAD 考试不计入此要求）* \n- 支持企业最终用户的商业模式，包括为客户提供驻场工程师\n- 成为 CNCF 会员\n\n通过 KCSP 有如下好处：\n\n- 企业的 logo 会出现在 [Kubernetes Partners](https:\/\/kubernetes.io\/partners\/) 页面\n- 参加与云原生项目 leader、TOC 成员、CNCF Governing Board 的月度会议\n- 向终端用户的 leader 寻求帮助\n\n因为有如上这些好处，为了获得 Kubernetes 项目实施的资质，同时保持与基金会至今的交流，Kubernetes 厂商对该认证都趋之若鹜。\n\n## Certified Kubernetes offering\n\n通过 KCSP 认证只代表企业有为他人实施 Kubernetes 项目的资质，而企业自身可能并不对外提供 Kubernetes 平台或服务，这些企业可能只是系统集成商或 ISV，这时候 CNCF 又推出了 Kubernetes 提供商认证。\n\nKubernetes 认证的提供商包括 Kubernetes 发行版、托管平台和安装器，通过认证的工具或平台将允许使用 Kubernetes 认证的 Logo，并保证 Kubernetes 一致性认证。\n\n## 展望 2019\n\n2018 年 Kubernetes 成为 CNCF 孵化的首个毕业项目，根据 CNCF 打造的项目成熟度模型，Prometheus、Envoy、CoreDNS 相继毕业，CNCF 的眼光早已不再仅盯着 Kubernetes 了，[CNCF Landscape](https:\/\/landscape.cncf.io) 几乎包揽了所有云计算相关开源项目。可以说 CNCF 早已超出了 Kubernetes 的范畴，而是旨在一个建立在 Kubernetes 为底层资源调度和应用生命周期管理之上的生态系统，CNCF 中还演进出了如 Service Mesh 和 Serverless 之类的分支。\n\n从 CNCF 2017 和 2018 年度的变化来看，其中已经去掉了”dynamically orchestrating“的字眼，也就意味着 Kubernetes 在容器编排领域已经胜出，进而强调多云环境，同时 CNCF 推动的 Kubernetes 一致性认证也受到众多云厂商的支持，这也意味着 Kubernetes 将成为多云环境 API 一致性的保证。\n\nCNCF 在 2019 年的战略将更聚焦于开发者社区，协助尤其是来自终端用户的开发者成为项目的 contributor 和 maintainer，保证终端用户的意见能够在社区里被正确地传达和并最终成功地采纳云原生。\n\n## 参考\n\n- CNCF Annual Report 2017 pdf\n- [CNCF Annual Report 2018 pdf](https:\/\/www.cncf.io\/wp-content\/uploads\/2019\/02\/CNCF_Annual_Report_2018_FInal.pdf)\n- [CNCF  Projects](https:\/\/www.cncf.io\/projects\/)\n- [CNCF Landscape](https:\/\/landscape.cncf.io)\n- [CNCF Ambassadors](https:\/\/www.cncf.io\/people\/ambassadors\/)\n- [Kubernetes Certified Service Providers](https:\/\/www.cncf.io\/certification\/kcsp\/)\n\n', '\/blog\/cncf-annual-report-2018-review\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文是对 CNCF（云原生计算基金会）2018 年年度报告的解读。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/service-mesh-in-action-by-yangzhangxian-review/">《Service Mesh 实战—基于 Linkerd 和 Kubernetes 的微服务实践》读后感</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2019/01/08</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('《Service Mesh 实战—基于 Linkerd 和 Kubernetes 的微服务实践》读后感', '顺便对比了下 Linkerd 和 Envoy，给读者一些我自己的建议。', '\n最近在回顾 Service Mesh 技术在 2018 年的发展，想再看看 Linkerd，正好**杨彰显**的这本《Service Mesh 实战——基于 Linkerd 和 Kubernetes 的微服务实践》上市发售了，**机械工业出版社**的编辑送了我一本，🙏**杨福川**编辑，我看了下抽空写了点读后感，我看了下抽空写了点读后感，其实也说不上是读后感，就当是自己的一点感悟吧，就当拿此书借题发挥吧，这个知识爆炸的年代，技术发展如此迅速，可以说是 IT 人员的幸运，也是不幸！有多少写开源软件的书推出一版后能撑过三年的？如果软件红得发紫，持续迭代 N 个版本，例如 Kubernetes，最近两年以每三个月一个版本的速度迭代，之前的书早就跟不上节奏，要么就要不断推出新版，直到软件稳定后不再有大的改动。还有种可能就是软件推广和发展的不理想，无人问津，写这样软件的书就不会有再版了。\n\n拿到本书后我的第一反应就是看看这本书定稿的时候 Istio 是什么版本，Linkerd 又是什么版本。因为在这一年内两款开源软件都有较大的版本变动，如果书籍定稿的时候基于的软件版本太低，软件架构可能会有较大的变化，影响书中示例和部分章节的时效性。这也是大多技术书籍名短的症结所在，技术发展是在太快，传统的书籍出版流程往往过于繁琐和冗长，等到书籍出版后所介绍的软件都出了好几个版本。例如 Kubernetes 这种的软件，每三个月一个版本，而写一般书从策划到发行少说半年，一般也要一年的时间。\n\n## 关于书籍定稿时的软件版本\n\n**Istio 0.8**\n\n本书第一章「Service Mesh 简介」对 Service Mesh 相关开源产品介绍时提到本书定稿时 Istio 是 0.8 版本，而 Istio 在 2018 年 7 月 31 日发布了 1.0 版本。\n\n这本书定稿时，Istio 的最新版本是 0.8。\n\n**Linkerd 1.3.6**\n\n本书从序言开始一直到第二章结束也没有提及写作时基于的 Linkerd 版本，我在第二章的安装步骤中看到了说明。\n\n可以看到本书写作时是基于 Linkerd 1.3.6 版本，而 Linkerd 在同年的 9 月 18 日发布了 [2.0 GA](https:\/\/cloudnative.to\/blog\/linkerd-2-0-in-general-availability\/)，这一版本跟 1.x 版本相比有重大变化——它还将项目从集群范围的 service mesh 转换为可组合的 *service sidecar* ，旨在为开发人员和服务所有者提供在云原生环境中成功所需的关键工具。\n\n## Linkerd vs Envoy\n\nLinkerd 2.0 的 service sidecar 设计使开发人员和服务所有者能够在他们的服务上运行 Linkerd，提供自动可观测性、可靠性和运行时诊断，而无需更改配置或代码。通过提供轻量级的增量路径来获得平台范围的遥测、安全性和可靠性的传统 service mesh 功能，service sidecar 方法还降低了平台所有者和系统架构师的风险。该版本还用 Rust 重写了代理部分，在延迟，吞吐量和资源消耗方面产生了数量级的改进。\n\n而 Linkerd 1.x 继承自 Twitter 开源的 Finagle 高性能 RPC，所有想要深度学习 Linkerd 1.x 还需要了解 Finagle，这就跟 Istio 将 Envoy 作为默认的数据平面一样，要想深度学习 Istio 必须了解 Envoy。\n\n二者几乎使用了完全不同的术语，假如你已经了解了 [Envoy](https:\/\/envoyproxy.io) 想要再切换到 Linkerd 上，那么就要再费很多心力来学习它的概念和原理，例如如下这些术语或配置（Linkerd 中独有的配置）：\n\n- **dtab（委托表）**：由一系列路由组成，由一系列路由规则组成，以逻辑路径为输入，然后经过路由规则做一系列转换生成具体名字。这是 Linkerd 路由机制的根本，就像 Envoy 中的 [xDS 协议](https:\/\/jimmysong.io\/istio-handbook\/data-plane\/envoy-xds.html)一样，本书的第四章「深入 Linkerd 数据访问流」专门讲解了 dtab 的实现机制。\n- **dentry（委托表记录）**：委托表的每条路由规则称为 dentry，如 \/consul =\u003e \/#\/io.l5d.consul\/dc1。\n- **namer**：配置 Linkerd 支持的服务发现工具。\n- **namerd**：Linkerd 的控制平面，相当于 Istio 中的 Pilot，对接各种服务发现。当然 Linkerd 也可以直接与某个服务发现平台对接如 consul，而不使用 namerd 这个集中路由和配置管理组件。\n- **interpreter**：interpreter 决定如何解析服务名字和客户端名字。\n\n虽然 Linkerd 也是 [CNCF 中的项目](https:\/\/www.cncf.io\/projects\/)，但它目前还处于孵化阶段，而 Envoy 的 [xDS 协议](https:\/\/jimmysong.io\/istio-handbook\/data-plane\/envoy-xds.html)已经被众多开源项目所支持，如 [Istio](https:\/\/istio.io\/zh)、[SOFAMesh](https:\/\/github.com\/alipay\/sofa-mesh)、[NginxMesh](https:\/\/github.com\/nginxinc\/nginmesh) 等，且 Envoy 已经从 CNCF 中毕业，以后可能成为 Service Mesh 领域的标准协议，Linkerd 的生存状况堪忧。\n\n## 关于本书\n\n本书中所有示例都提供了虚拟机的快速上手环境，只要使用 Vagrant 即可创建虚拟机和应用，所以在本书的[示例代码](https:\/\/github.com\/yangzhares\/linkerd-in-action)有大量的 Vagrantfile。\n\n本书第三部分「实战篇」花了大量篇幅（本书一半的页数）来讲解如何使用 Linkerd 和 Kubernetes 来管理微服务，可以参考我 2017 年 8 月 1 日写的这篇[微服务管理框架 service mesh——Linkerd 安装试用笔记](https:\/\/jimmysong.io\/posts\/linkerd-user-guide\/)，那时候还是基于 Linkerd 1.1.2，还有 [Linkerd 官方示例](https:\/\/github.com\/linkerd\/linkerd-examples\/)，这些示例基本都不怎么更新了。\n\n因为该书定稿时所基于的 Linkerd 版本距离本书发售时的 Linkerd 已经落后一个大版本（最新版本是 [Linkerd 2.1](https:\/\/blog.linkerd.io\/2018\/12\/06\/announcing-linkerd-2-1\/)），所以读者一定要注意这一点，老实说我只花了两个夜晚快速过了一下本书，无法对本书内容给出具体评论，所以本书是否是你所需要的就要你自己去思考了。\n\n', '\/blog\/service-mesh-in-action-by-yangzhangxian-review\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">顺便对比了下 Linkerd 和 Envoy，给读者一些我自己的建议。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/envoy-proxy-config-deep-dive/">Istio 的数据平面 Envoy Proxy 配置详解</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2019/01/07</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/envoy"> 
             Envoy
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio 的数据平面 Envoy Proxy 配置详解', '本文介绍了 Envoy proxy 的概念，对应的 xDS 的版本以及配置的详细解析。', '\nEnvoy 是 Istio Service Mesh 中默认的 Sidecar，Istio 在 Envoy 的基础上按照 Envoy 的 xDS 协议扩展了其控制平面，在讲到 Envoy xDS 协议之前还需要我们先熟悉下 Envoy 的基本术语。下面列举了 Envoy 里的基本术语及其数据结构解析，关于 Envoy 的详细介绍请参考 [Envoy 官方文档](https:\/\/cloudnative.to\/envoy\/)，至于 Envoy 在 Service Mesh（不仅限于 Istio）中是如何作为转发代理工作的请参考网易云刘超的这篇[深入解读 Service Mesh 背后的技术细节 ](https:\/\/www.cnblogs.com\/163yun\/p\/8962278.html)以及[理解 Istio Service Mesh 中 Envoy 代理 Sidecar 注入及流量劫持](\/blog\/envoy-sidecar-injection-in-istio-service-mesh-deep-dive\/)，本文引用其中的一些观点，详细内容不再赘述。\n\n![Envoy proxy 架构图](xds.svg)\n\n## 基本术语\n\n下面是您应该了解的 Envoy 里的基本术语：\n\n- **Downstream（下游）**：下游主机连接到 Envoy，发送请求并接收响应，即发送请求的主机。\n- **Upstream（上游）**：上游主机接收来自 Envoy 的连接和请求，并返回响应，即接受请求的主机。\n- **Listener（监听器）**：监听器是命名网地址（例如，端口、unix domain socket 等)，下游客户端可以连接这些监听器。Envoy 暴露一个或者多个监听器给下游主机连接。\n- **Cluster（集群）**：集群是指 Envoy 连接的一组逻辑相同的上游主机。Envoy 通过服务发现来发现集群的成员。可以选择通过主动健康检查来确定集群成员的健康状态。Envoy 通过负载均衡策略决定将请求路由到集群的哪个成员。\n\n我将在本文的后半部分解释以上术语与 Kubernetes、Istio 中概念之间的联系。\n\n## 关于 xDS 的版本\n\n有一点需要大家注意，就是 Envoy 的 API 有 v1 和 v2 两个版本，从 Envoy 1.5.0 起 v2 API 就已经生产就绪了，为了能够让用户顺利的向 v2 版本的额 API 过度，Envoy 启动的时候设置了一个 \u0060--v2-config-only\u0060 的标志，Envoy 不同版本对 v1\/v2 API 的支持详情请参考 [Envoy v1 配置废弃时间表](https:\/\/groups.google.com\/forum\/#!topic\/envoy-announce\/Lb1QZcSclGQ)。\n\nEnvoy 的作者 Matt Klein 在 [Service Mesh 中的通用数据平面 API 设计](https:\/\/cloudnative.to\/blog\/the-universal-data-plane-api\/)这篇文章中说明了 Envoy API v1 的历史及其缺点，还有 v2 的引入。v2 API 是 v1 的演进，而不是革命，它是 v1 功能的超集。\n\n在 Istio 1.0 及以上版本中使用的是 **Envoy 1.8.0-dev** 版本，其支持 v2 的 API，同时在 Envoy 作为 Sidecar proxy 启动的使用使用了例如下面的命令：\n\n\u0060\u0060\u0060bash\n$ \/usr\/local\/bin\/envoy -c \/etc\/istio\/proxy\/envoy-rev0.json --restart-epoch 0 --drain-time-s 45 --parent-shutdown-time-s 60 --service-cluster ratings --service-node sidecar~172.33.14.2~ratings-v1-8558d4458d-ld8x9.default~default.svc.cluster.local --max-obj-name-len 189 --allow-unknown-fields -l warn --v2-config-only\n\u0060\u0060\u0060\n\n上面是都 Bookinfo 示例中的 rating pod 中的 sidecar 启动的分析，可以看到其中指定了 \u0060--v2-config-only\u0060，表明 Istio 1.0\u002b 只支持 xDS v2 的 API。\n\n## Istio sidecar proxy 配置\n\n假如您使用 [kubernetes-vagrant-centos-cluster](https:\/\/github.com\/rootsongjc\/kubernetes-vagrant-centos-cluster) 部署了 Kubernetes 集群并开启了 [Istio Service Mesh](https:\/\/istio.io\/zh)，再部署 [bookinfo 示例](https:\/\/istio.io\/latest\/zh\/docs\/examples\/bookinfo\/)，那么在 \u0060default\u0060 命名空间下有一个名字类似于 \u0060ratings-v1-7c9949d479-dwkr4\u0060 的 Pod，使用下面的命令查看该 Pod 的 Envoy sidecar 的全量配置：\n\n\u0060\u0060\u0060bash\nkubectl -n default exec ratings-v1-7c9949d479-dwkr4 -c istio-proxy curl http:\/\/localhost:15000\/config_dump \u003e dump-rating.json\n\u0060\u0060\u0060\n\n将 Envoy 的运行时配置 dump 出来之后你将看到一个长 6000 余行的配置文件。\n\nIstio 会在为 Service Mesh 中的每个 Pod 注入 Sidecar 的时候同时为 Envoy 注入 Bootstrap 配置，其余的配置是通过 Pilot 下发的，注意整个数据平面即 Service Mesh 中的 Envoy 的动态配置应该是相同的。您也可以使用上面的命令检查其他 sidecar 的 Envoy 配置是否跟最上面的那个相同。\n\n使用下面的命令检查 Service Mesh 中的所有有 Sidecar 注入的 Pod 中的 proxy 配置是否同步。\n\n\u0060\u0060\u0060bash\n$ istioctl proxy-status\nPROXY                                                 CDS        LDS        EDS               RDS          PILOT                            VERSION\ndetails-v1-876bf485f-sx7df.default                    SYNCED     SYNCED     SYNCED (100%)     SYNCED       istio-pilot-5bf6d97f79-6lz4x     1.0.0\n...\n\u0060\u0060\u0060\n\n[istioctl](https:\/\/istio.io\/zh\/docs\/reference\/commands\/istioctl\/) 这个命令行工具就像 [kubectl](https:\/\/jimmysong.io\/kubernetes-handbook\/guide\/kubectl-cheatsheet.html) 一样有很多神器的魔法，通过它可以高效的管理 Istio 和 debug。\n\n## Envoy proxy 配置解析\n\nIstio envoy sidecar proxy 配置中包含以下四个部分。\n\n- **bootstrap**：Envoy proxy 启动时候加载的静态配置。\n- **listeners**：监听器配置，使用 LDS 下发。\n- **clusters**：集群配置，静态配置中包括 xds-grpc 和 zipkin 地址，动态配置使用  CDS 下发。\n- **routes**：路由配置，静态配置中包括了本地监听的服务的集群信息，其中引用了 cluster，动态配置使用 RDS 下发。\n\n每个部分中都包含静态配置与动态配置，其中 bootstrap 配置又是在集群启动的时候通过 sidecar 启动参数注入的，配置文件在 \u0060\/etc\/istio\/proxy\/envoy-rev0.json\u0060。\n\n由于 bootstrap 中的配置是来自 Envoy 启动时加载的静态文件，主要配置了节点信息、tracing、admin 和统计信息收集等信息，这不是本文的重点，大家可以自行研究。\n\nBootstrap 是 Envoy 中配置的根本来源，Bootstrap 消息中有一个关键的概念，就是静态和动态资源的之间的区别。例如 Listener 或 Cluster 这些资源既可以从 static_resources 静态的获得也可以从 dynamic_resources 中配置的 LDS 或 CDS 之类的 xDS 服务获取。\n\n### Listener\n\nListener 顾名思义，就是监听器，监听 IP 地址和端口，然后根据策略转发。\n\n**Listener 的特点**\n\n- 每个 Envoy 进程中可以有多个 Listener，Envoy 与 Listener 之间是一对多的关系。\n- 每个 Listener 中可以配置一条 filter 链表（filter_chains），Envoy 会根据 filter 顺序执行过滤。\n- Listener 可以监听下游的端口，也可以接收来自其他 listener 的数据，形成链式处理。\n- filter 是可扩展的。\n- 可以静态配置，也可以使用 LDS 动态配置。\n- 目前只能监听 TCP，UDP 还未支持。\n\n**Listener 的数据结构**\n\nListener 的数据结构如下，除了 \u0060name\u0060、\u0060address\u0060 和 \u0060filter_chains\u0060 为必须配置之外，其他都为可选的。\n\n\u0060\u0060\u0060json\n{\n  \u0022name\u0022: \u0022...\u0022,\n  \u0022address\u0022: \u0022{...}\u0022,\n  \u0022filter_chains\u0022: [],\n  \u0022use_original_dst\u0022: \u0022{...}\u0022,\n  \u0022per_connection_buffer_limit_bytes\u0022: \u0022{...}\u0022,\n  \u0022metadata\u0022: \u0022{...}\u0022,\n  \u0022drain_type\u0022: \u0022...\u0022,\n  \u0022listener_filters\u0022: [],\n  \u0022transparent\u0022: \u0022{...}\u0022,\n  \u0022freebind\u0022: \u0022{...}\u0022,\n  \u0022socket_options\u0022: [],\n  \u0022tcp_fast_open_queue_length\u0022: \u0022{...}\u0022,\n  \u0022bugfix_reverse_write_filter_order\u0022: \u0022{...}\u0022\n}\n\u0060\u0060\u0060\n\n下面是关于上述数据结构中的常用配置解析。\n\n- **name**：该 listener 的 UUID，唯一限定名，默认 60 个字符，例如 \u006010.254.74.159_15011\u0060，可以使用命令参数指定长度限制。\n\n- **address**：监听的逻辑\/物理地址和端口号，例如\n\n  \u0060\u0060\u0060json\n  \u0022address\u0022: {\n         \u0022socket_address\u0022: {\n          \u0022address\u0022: \u002210.254.74.159\u0022,\n          \u0022port_value\u0022: 15011\n         }\n  }\n  \u0060\u0060\u0060\n\n- **filter_chains**：这是一个列表，Envoy 中内置了一些通用的 filter，每种 filter 都有特定的数据结构，Envoy 会根据该配置顺序执行 filter。Envoy 中内置的 filter 有：[envoy.client_ssl_auth](https:\/\/www.envoyproxy.io\/docs\/envoy\/v1.8.0\/configuration\/network_filters\/client_ssl_auth_filter#config-network-filters-client-ssl-auth)、[envoy.echo](https:\/\/www.envoyproxy.io\/docs\/envoy\/v1.8.0\/configuration\/network_filters\/echo_filter#config-network-filters-echo)、[Envoy.http_connection_manager](https:\/\/www.envoyproxy.io\/docs\/envoy\/v1.8.0\/configuration\/http_conn_man\/http_conn_man#config-http-conn-man)、[envoy.mongo_proxy](https:\/\/www.envoyproxy.io\/docs\/envoy\/v1.8.0\/configuration\/network_filters\/mongo_proxy_filter#config-network-filters-mongo-proxy)、[envoy.rate_limit](https:\/\/www.envoyproxy.io\/docs\/envoy\/v1.8.0\/configuration\/network_filters\/rate_limit_filter#config-network-filters-rate-limit)、[Envoy.redis_proxy](https:\/\/www.envoyproxy.io\/docs\/envoy\/v1.8.0\/configuration\/network_filters\/redis_proxy_filter#config-network-filters-redis-proxy)、[envoy.tcp_proxy](https:\/\/www.envoyproxy.io\/docs\/envoy\/v1.8.0\/configuration\/network_filters\/tcp_proxy_filter#config-network-filters-tcp-proxy)、[http_filters](https:\/\/www.envoyproxy.io\/docs\/envoy\/v1.8.0\/intro\/arch_overview\/http_filters)、[thrift_filters](https:\/\/www.envoyproxy.io\/docs\/envoy\/v1.8.0\/configuration\/thrift_filters\/thrift_filters)等。这些 filter 可以单独使用也可以组合使用，还可以自定义扩展，例如使用 Istio 中的 EnvoyFilter 配置。\n\n- **use_original_dst**：这是一个布尔值，如果使用 iptables 重定向连接，则代理接收的端口可能与原始目的地址的端口不一样。当此标志设置为 true 时，Listener 将重定向的连接切换到与原始目的地址关联的 Listener。如果没有与原始目的地址关联的 Listener，则连接由接收它的 Listener 处理。默认为 false。注意：该参数将被废弃，请使用原始目的地址的 Listener filter 替代。该参数的主要用途是：Envoy 通过监听 15001 端口将应用的流量截取后再由其他 Listener 处理而不是直接转发出去，详情见 [Virtual Listener](https:\/\/zhaohuabing.com\/post\/2018-09-25-istio-traffic-management-impl-intro\/#virtual-listener)。\n\n关于 Listener 的详细介绍请参考 Envoy v2 API reference - listener。\n\n### Route\n\n我们在这里所说的路由指的是 HTTP 路由，这也使得 Envoy 可以用来处理网格边缘的流量。HTTP 路由转发是通过路由过滤器实现的。该过滤器的主要职能就是执行路由表中的指令。除了可以做重定向和转发，路由过滤器还需要处理重试、统计之类的任务。\n\n**HTTP 路由的特点**\n\n- 前缀和精确路径匹配规则。\n- 可跨越多个上游集群进行基于权重\/百分比的路由。\n- 基于优先级的路由。\n- 基于哈希策略的路由。\n\n**Route 的数据结构**\n\n\u0060\u0060\u0060json\n{\n  \u0022name\u0022: \u0022...\u0022,\n  \u0022virtual_hosts\u0022: [],\n  \u0022internal_only_headers\u0022: [],\n  \u0022response_headers_to_add\u0022: [],\n  \u0022response_headers_to_remove\u0022: [],\n  \u0022request_headers_to_add\u0022: [],\n  \u0022request_headers_to_remove\u0022: [],\n  \u0022validate_clusters\u0022: \u0022{...}\u0022\n}\n\u0060\u0060\u0060\n\n下面是关于上述数据结构中的常用配置解析。\n\n- **name**：该名字跟 \u0060envoy.http_connection_manager\u0060 filter 中的 \u0060http_filters.rds.route_config_name\u0060 一致，在 Istio Service Mesh 中为 Envoy 下发的配置中的 Route 是以监听的端口号作为名字，而同一个名字下面的 \u0060virtual_hosts\u0060 可以有多个值（数组形式）。\n- **virtual_hosts**：因为 **VirtualHosts** 是 Envoy 中引入的一个重要概念，我们在下文将详细说明 \u0060virtual_hosts\u0060 的数据结构。\n- **validate_clusters**：这是一个布尔值，用来设置开启使用 cluster manager 来检测路由表引用的 cluster 是否有效。如果是路由表是通过 route_config 静态配置的则该值默认设置为 true，如果是使用 rds 动态配置的话，则该值默认设置为 false。\n\n#### route.VirtualHost\n\nVirtualHost 即上文中 Route 配置中的 \u0060virtual_hosts\u0060，VirtualHost 是路由配置中的顶级元素。每个虚拟主机都有一个逻辑名称以及一组根据传入请求的 host header 路由到它的域。这允许单个 Listener 为多个顶级域路径树提供服务。基于域选择了虚拟主机后 Envoy  就会处理路由以查看要路由到哪个上游集群或是否执行重定向。\n\n**VirtualHost 的数据结构**\n\n下面是 VirtualHost 的数据结构，除了 \u0060name\u0060 和 \u0060domains\u0060 是必须配置项外，其他皆为可选项。\n\n\u0060\u0060\u0060json\n{\n  \u0022name\u0022: \u0022...\u0022,\n  \u0022domains\u0022: [],\n  \u0022routes\u0022: [],\n  \u0022require_tls\u0022: \u0022...\u0022,\n  \u0022virtual_clusters\u0022: [],\n  \u0022rate_limits\u0022: [],\n  \u0022request_headers_to_add\u0022: [],\n  \u0022request_headers_to_remove\u0022: [],\n  \u0022response_headers_to_add\u0022: [],\n  \u0022response_headers_to_remove\u0022: [],\n  \u0022cors\u0022: \u0022{...}\u0022,\n  \u0022per_filter_config\u0022: \u0022{...}\u0022,\n  \u0022include_request_attempt_count\u0022: \u0022...\u0022\n}\n\u0060\u0060\u0060\n\n下面是关于上述数据结构中的常用配置解析。\n\n- **name**：该 VirtualHost 的名字，一般是 FQDN 加端口，如 \u0060details.default.svc.cluster.local:9080\u0060。\n- **domains**：这是个用来匹配 VirtualHost 的域名（host\/authority header）列表，也可以使用通配符，但是通配符不能匹配空字符，除了仅使用 \u0060*\u0060 作为 domains，注意列表中的值不能重复和存在交集，只要有一条 domain 被匹配上了，就会执行路由。Istio 会为该值配置所有地址解析形式，包括 IP 地址、FQDN 和短域名等。\n- **routes**：针对入口流量的有序路由列表，第一个匹配上的路由将被执行。我们在下文将详细说明 route 的数据结构。\n\n下面是一个实际的 VirtualHost 的例子，该配置来自 [Bookinfo 应用](https:\/\/istio.io\/latest\/zh\/docs\/examples\/bookinfo\/)的 details 应用的 Sidecar 服务。\n\n\u0060\u0060\u0060json\n{\n            \u0022name\u0022: \u0022details.default.svc.cluster.local:9080\u0022,\n            \u0022domains\u0022: [\n                \u0022details.default.svc.cluster.local\u0022,\n                \u0022details.default.svc.cluster.local:9080\u0022,\n                \u0022details\u0022,\n                \u0022details:9080\u0022,\n                \u0022details.default.svc.cluster\u0022,\n                \u0022details.default.svc.cluster:9080\u0022,\n                \u0022details.default.svc\u0022,\n                \u0022details.default.svc:9080\u0022,\n                \u0022details.default\u0022,\n                \u0022details.default:9080\u0022,\n                \u002210.254.4.113\u0022,\n                \u002210.254.4.113:9080\u0022\n            ],\n            \u0022routes\u0022: [\n                {\n                    \u0022match\u0022: {\n                        \u0022prefix\u0022: \u0022\/\u0022\n                    },\n                    \u0022route\u0022: {\n                        \u0022cluster\u0022: \u0022outbound|9080||details.default.svc.cluster.local\u0022,\n                        \u0022timeout\u0022: \u00220s\u0022,\n                        \u0022max_grpc_timeout\u0022: \u00220s\u0022\n                    },\n                    \u0022decorator\u0022: {\n                        \u0022operation\u0022: \u0022details.default.svc.cluster.local:9080\/*\u0022\n                    },\n                    \u0022per_filter_config\u0022: {\n                        \u0022mixer\u0022: {\n                            \u0022forward_attributes\u0022: {\n                                \u0022attributes\u0022: {\n                                    \u0022destination.service.uid\u0022: {\n                                        \u0022string_value\u0022: \u0022istio:\/\/default\/services\/details\u0022\n                                    },\n                                    \u0022destination.service.host\u0022: {\n                                        \u0022string_value\u0022: \u0022details.default.svc.cluster.local\u0022\n                                    },\n                                    \u0022destination.service.namespace\u0022: {\n                                        \u0022string_value\u0022: \u0022default\u0022\n                                    },\n                                    \u0022destination.service.name\u0022: {\n                                        \u0022string_value\u0022: \u0022details\u0022\n                                    },\n                                    \u0022destination.service\u0022: {\n                                        \u0022string_value\u0022: \u0022details.default.svc.cluster.local\u0022\n                                    }\n                                }\n                            },\n                            \u0022mixer_attributes\u0022: {\n                                \u0022attributes\u0022: {\n                                    \u0022destination.service.host\u0022: {\n                                        \u0022string_value\u0022: \u0022details.default.svc.cluster.local\u0022\n                                    },\n                                    \u0022destination.service.uid\u0022: {\n                                        \u0022string_value\u0022: \u0022istio:\/\/default\/services\/details\u0022\n                                    },\n                                    \u0022destination.service.name\u0022: {\n                                        \u0022string_value\u0022: \u0022details\u0022\n                                    },\n                                    \u0022destination.service.namespace\u0022: {\n                                        \u0022string_value\u0022: \u0022default\u0022\n                                    },\n                                    \u0022destination.service\u0022: {\n                                        \u0022string_value\u0022: \u0022details.default.svc.cluster.local\u0022\n                                    }\n                                }\n                            },\n                            \u0022disable_check_calls\u0022: true\n                        }\n                    }\n                }\n            ]\n        }\n\u0060\u0060\u0060\n\n#### route.Route\n\n路由既是如何匹配请求的规范，也是对下一步做什么的指示（例如，redirect、forward、rewrite 等）。\n\n**route.Route 的数据结构**\n\n下面是是 route.Route 的数据结构，除了 \u0060match\u0060 之外其余都是可选的。\n\n\u0060\u0060\u0060json\n{\n  \u0022match\u0022: \u0022{...}\u0022,\n  \u0022route\u0022: \u0022{...}\u0022,\n  \u0022redirect\u0022: \u0022{...}\u0022,\n  \u0022direct_response\u0022: \u0022{...}\u0022,\n  \u0022metadata\u0022: \u0022{...}\u0022,\n  \u0022decorator\u0022: \u0022{...}\u0022,\n  \u0022per_filter_config\u0022: \u0022{...}\u0022,\n  \u0022request_headers_to_add\u0022: [],\n  \u0022request_headers_to_remove\u0022: [],\n  \u0022response_headers_to_add\u0022: [],\n  \u0022response_headers_to_remove\u0022: []\n}\n\u0060\u0060\u0060\n\n下面是关于上述数据结构中的常用配置解析。\n\n- **match**：路由匹配参数。例如 URL prefix（前缀）、path（URL 的完整路径）、regex（规则表达式）等。\n- **route**：这里面配置路由的行为，可以是 route、redirect 和 direct_response，不过这里面没有专门的一个配置项用来配置以上三种行为，而是根据实际填充的配置项来确定的。例如在此处添加 \u0060cluster\u0060 配置则暗示路由动作为”route“，表示将流量路由到该 cluster。详情请参考 route.RouteAction。\n- **decorator**：被匹配的路由的修饰符，表示被匹配的虚拟主机和 URL。该配置里有且只有一个必须配置的项 \u0060operation\u0060，例如 \u0060details.default.svc.cluster.local:9080\/*\u0060。\n- **per_filter_config**：这是一个 map 类型，\u0060per_filter_config\u0060 字段可用于为 filter 提供特定路由的配置。Map 的 key 应与 filleter 名称匹配，例如用于 HTTP buffer filter 的 \u0060envoy.buffer\u0060。该字段是特定于 filter 的，详情请参考 HTTP filter。\n\n### Cluster\n\nCluster 是指 Envoy 连接的一组逻辑相同的上游主机。Envoy 通过服务发现来发现 cluster 的成员。可以选择通过主动健康检查来确定集群成员的健康状态。Envoy 通过负载均衡策略决定将请求路由到 cluster 的哪个成员。\n\n**Cluster 的特点**\n\n- 一组逻辑上相同的主机构成一个 cluster。\n- 可以在 cluster 中定义各种负载均衡策略。\n- 新加入的 cluster 需要一个热身的过程才可以给路由引用，该过程是原子的，即在 cluster 热身之前对于 Envoy 及 Service Mesh 的其余部分来说是不可见的。\n- 可以通过多种方式来配置 cluster，例如静态类型、严格限定 DNS、逻辑 DNS、EDS 等。\n\n**Cluster 的数据结构**\n\nCluster 的数据结构如下，除了 \u0060name\u0060 字段，其他都是可选的。\n\n\u0060\u0060\u0060json\n{\n  \u0022name\u0022: \u0022...\u0022,\n  \u0022alt_stat_name\u0022: \u0022...\u0022,\n  \u0022type\u0022: \u0022...\u0022,\n  \u0022eds_cluster_config\u0022: \u0022{...}\u0022,\n  \u0022connect_timeout\u0022: \u0022{...}\u0022,\n  \u0022per_connection_buffer_limit_bytes\u0022: \u0022{...}\u0022,\n  \u0022lb_policy\u0022: \u0022...\u0022,\n  \u0022hosts\u0022: [],\n  \u0022load_assignment\u0022: \u0022{...}\u0022,\n  \u0022health_checks\u0022: [],\n  \u0022max_requests_per_connection\u0022: \u0022{...}\u0022,\n  \u0022circuit_breakers\u0022: \u0022{...}\u0022,\n  \u0022tls_context\u0022: \u0022{...}\u0022,\n  \u0022common_http_protocol_options\u0022: \u0022{...}\u0022,\n  \u0022http_protocol_options\u0022: \u0022{...}\u0022,\n  \u0022http2_protocol_options\u0022: \u0022{...}\u0022,\n  \u0022extension_protocol_options\u0022: \u0022{...}\u0022,\n  \u0022dns_refresh_rate\u0022: \u0022{...}\u0022,\n  \u0022dns_lookup_family\u0022: \u0022...\u0022,\n  \u0022dns_resolvers\u0022: [],\n  \u0022outlier_detection\u0022: \u0022{...}\u0022,\n  \u0022cleanup_interval\u0022: \u0022{...}\u0022,\n  \u0022upstream_bind_config\u0022: \u0022{...}\u0022,\n  \u0022lb_subset_config\u0022: \u0022{...}\u0022,\n  \u0022ring_hash_lb_config\u0022: \u0022{...}\u0022,\n  \u0022original_dst_lb_config\u0022: \u0022{...}\u0022,\n  \u0022least_request_lb_config\u0022: \u0022{...}\u0022,\n  \u0022common_lb_config\u0022: \u0022{...}\u0022,\n  \u0022transport_socket\u0022: \u0022{...}\u0022,\n  \u0022metadata\u0022: \u0022{...}\u0022,\n  \u0022protocol_selection\u0022: \u0022...\u0022,\n  \u0022upstream_connection_options\u0022: \u0022{...}\u0022,\n  \u0022close_connections_on_host_health_failure\u0022: \u0022...\u0022,\n  \u0022drain_connections_on_host_removal\u0022: \u0022...\u0022\n}\n\u0060\u0060\u0060\n\n下面是关于上述数据结构中的常用配置解析。\n\n- **name**：如果你留意到作为 Sidecar 启动的 Envoy 的参数的会注意到 \u0060--max-obj-name-len 189\u0060，该选项用来用来指定 cluster 的名字，例如 \u0060inbound|9080||ratings.default.svc.cluster.local\u0060。该名字字符串由 \u0060|\u0060 分隔成四个部分，分别是 \u0060inbound\u0060 或 \u0060outbound\u0060 代表入向流量或出向流量、端口号、subcluster 名称、FQDN，其中 subcluster 名称将对应于 Istio \u0060DestinationRule\u0060 中配置的 \u0060subnet\u0060，如果是按照多版本按比例路由的话，该值可以是版本号。\n- **type**：即服务发现类型，支持的参数有 \u0060STATIC\u0060（缺省值）、\u0060STRICT_DNS\u0060、\u0060LOGICAL_DNS\u0060、\u0060EDS\u0060、\u0060ORIGINAL_DST\u0060。\n- **hosts**：这是个列表，配置负载均衡的 IP 地址和端口，只有使用了  \u0060STATIC\u0060、\u0060STRICT_DNS\u0060、\u0060LOGICAL_DNS\u0060 服务发现类型时才需要配置。\n- **eds_cluster_config**：如果使用 \u0060EDS\u0060 做服务发现，则需要配置该项目，其中包括的配置有 \u0060service_name\u0060 和 \u0060ads\u0060。\n\n## 参考\n\n- [深入解读 Service Mesh 背后的技术细节 - cnblogs.com](https:\/\/www.cnblogs.com\/163yun\/p\/8962278.html)\n- [理解 Istio Service Mesh 中 Envoy 代理 Sidecar 注入及流量劫持 - jimmysong.io](https:\/\/jimmysong.io\/blog\/envoy-sidecar-injection-in-istio-service-mesh-deep-dive\/)\n', '\/blog\/envoy-proxy-config-deep-dive\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文介绍了 Envoy proxy 的概念，对应的 xDS 的版本以及配置的详细解析。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/envoy-sidecar-routing-of-istio-service-mesh-deep-dive/">理解 Istio Service Mesh 中 Envoy Sidecar 代理的路由转发</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2018/12/26</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('理解 Istio Service Mesh 中 Envoy Sidecar 代理的路由转发', 'Sidecar proxy 中 Indbound\/Outbound 流量处理过程详解。', '\n本文以 Istio 官方的 [bookinfo 示例](https:\/\/preliminary.istio.io\/zh\/docs\/examples\/bookinfo)来讲解在进入 Pod 的流量被 iptables 转交给 Envoy sidecar 后，Envoy 是如何做路由转发的，详述了 Inbound 和 Outbound 处理过程。关于流量拦截的详细分析请参考[理解 Istio Service Mesh 中 Envoy 代理 Sidecar 注入及流量劫持](https:\/\/jimmysong.io\/posts\/envoy-sidecar-injection-in-istio-service-mesh-deep-dive\/)。\n\n下面是 Istio 官方提供的 bookinfo 的请求流程图，假设 bookinfo 应用的所有服务中没有配置 DestinationRule。\n\n![Bookinfo 示例](006tNbRwgy1fvlwjd3302j31bo0ro0x5.jpg)\n\n下面是 Istio 自身组件与 Bookinfo 示例的连接关系图，我们可以看到所有的 HTTP 连接都在 9080 端口监听。\n\n![Bookinfo 示例与 Istio 组件连接关系图](006tNbRwly1fyitp0jsghj31o70u0x6p.jpg)\n\n\n可以在 [Google Drive](https:\/\/drive.google.com\/open?id=19ed3_tkjf6RgGboxllMdt_Ytd5_cocib) 上下载原图。\n\n## Sidecar 注入及流量劫持步骤概述\n\n下面是从 Sidecar 注入、Pod 启动到 Sidecar proxy 拦截流量及 Envoy 处理路由的步骤概览。\n\n**1.** Kubernetes 通过 Admission Controller 自动注入，或者用户使用 \u0060istioctl\u0060 命令手动注入 sidecar 容器。\n\n**2.** 应用 YAML 配置部署应用，此时 Kubernetes API server 接收到的服务创建配置文件中已经包含了 Init 容器及 sidecar proxy。\n\n**3.** 在 sidecar proxy 容器和应用容器启动之前，首先运行 Init 容器，Init 容器用于设置 iptables（Istio 中默认的流量拦截方式，还可以使用 BPF、IPVS 等方式）将进入 pod 的流量劫持到 Envoy sidecar proxy。所有 TCP 流量（Envoy 目前只支持 TCP 流量）将被 sidecar 劫持，其他协议的流量将按原来的目的地请求。\n\n**4.** 启动 Pod 中的 Envoy sidecar proxy 和应用程序容器。这一步的过程请参考[通过管理接口获取完整配置](https:\/\/zhaohuabing.com\/post\/2018-09-25-istio-traffic-management-impl-intro\/#%E9%80%9A%E8%BF%87%E7%AE%A1%E7%90%86%E6%8E%A5%E5%8F%A3%E8%8E%B7%E5%8F%96%E5%AE%8C%E6%95%B4%E9%85%8D%E7%BD%AE)。\n\n\u003e **Sidecar proxy 与应用容器的启动顺序问题**\n\u003e\n\u003e 启动 sidecar proxy 和应用容器，究竟哪个容器先启动呢？正常情况是 Envoy Sidecar 和应用程序容器全部启动完成后再开始接收流量请求。但是我们无法预料哪个容器会先启动，那么容器启动顺序是否会对 Envoy 劫持流量有影响呢？答案是肯定的，不过分为以下两种情况。\n\u003e\n\u003e **情况 1：应用容器先启动，而 sidecar proxy 仍未就绪**\n\u003e\n\u003e 这种情况下，流量被 iptables 转移到 15001 端口，而 Pod 中没有监听该端口，TCP 链接就无法建立，请求失败。\n\u003e\n\u003e **情况 2：Sidecar 先启动，请求到达而应用程序仍未就绪**\n\u003e\n\u003e 这种情况下请求也肯定会失败，至于是在哪一步开始失败的，留给读者来思考。\n\n**问题**：如果为 sidecar proxy 和应用程序容器添加[就绪和存活探针](https:\/\/jimmysong.io\/kubernetes-handbook\/guide\/configure-liveness-readiness-probes.html)是否可以解决该问题呢？\n\n**5.** 不论是进入还是从 Pod 发出的 TCP 请求都会被 iptables 劫持，inbound 流量被劫持后经 Inbound Handler 处理后转交给应用程序容器处理，outbound 流量被 iptables 劫持后转交给 Outbound Handler 处理，并确定转发的 upstream 和 Endpoint。\n\n**6.** Sidecar proxy 请求 Pilot 使用 xDS 协议同步 Envoy 配置，其中包括 LDS、EDS、CDS 等，不过为了保证更新的顺序，Envoy 会直接使用 ADS 向 Pilot 请求配置更新。\n\n## Envoy 如何处理路由转发\n\n 下图展示的是 \u0060productpage\u0060 服务请求访问 \u0060http:\/\/reviews.default.svc.cluster.local:9080\/\u0060，当流量进入 \u0060reviews\u0060 服务内部时，\u0060reviews\u0060 服务内部的 Envoy Sidecar 是如何做流量拦截和路由转发的。可以在 [Google Drive](https:\/\/drive.google.com\/file\/d\/1n-h235tm8DnL_RqxTTA95rgGtrLkBsyr\/view?usp=sharing) 上下载原图。\n\n![Envoy sidecar 流量劫持与路由转发示意图](envoy-sidecar-traffic-interception-zh-20210818.png)\n\n\n第一步开始时，\u0060productpage\u0060 Pod 中的 Envoy sidecar 已经通过 EDS 选择出了要请求的 \u0060reviews\u0060 服务的一个 Pod，知晓了其 IP 地址，发送 TCP 连接请求。\n\nIstio 官网中的 Envoy 配置深度解析中是以发起 HTTP 请求的一方来详述 Envoy 做流量转发的过程，而本文中考虑的是接受 downstream 的流量的一方，它既要接收 downstream 发来的请求，自己还需要请求其他服务，例如 \u0060reviews\u0060 服务中的 Pod 还需要请求 \u0060ratings\u0060 服务。\n\n\u0060reviews\u0060 服务有三个版本，每个版本有一个实例，三个版本中的 sidecar 工作步骤类似，下文只以 \u0060reviews-v1-cb8655c75-b97zc\u0060 这一个 Pod 中的 Sidecar 流量转发步骤来说明。\n\n## 理解 Inbound Handler\n\nInbound handler 的作用是将 iptables 拦截到的 downstream 的流量转交给 localhost，与 Pod 内的应用程序容器建立连接。\n\n查看下 \u0060reviews-v1-cb8655c75-b97zc\u0060 pod 中的 Listener。\n\n运行 \u0060istioctl pc listener reviews-v1-cb8655c75-b97zc\u0060 查看该 Pod 中的具有哪些 Listener。\n\n\u0060\u0060\u0060ini\nADDRESS            PORT      TYPE \n172.33.3.3         9080      HTTP \u003c--- 接收所有 Inbound HTTP 流量，该地址即为当前 Pod 的 IP 地址\n10.254.0.1         443       TCP  \u003c--\u002b\n10.254.4.253       80        TCP     |\n10.254.4.253       8080      TCP     |\n10.254.109.182     443       TCP     |\n10.254.22.50       15011     TCP     |\n10.254.22.50       853       TCP     |\n10.254.79.114      443       TCP     | \n10.254.143.179     15011     TCP     |\n10.254.0.2         53        TCP     | 接收与 0.0.0.0_15001 监听器配对的 Outbound 非 HTTP 流量\n10.254.22.50       443       TCP     |\n10.254.16.64       42422     TCP     |\n10.254.127.202     16686     TCP     |\n10.254.22.50       31400     TCP     |\n10.254.22.50       8060      TCP     |\n10.254.169.13      14267     TCP     |\n10.254.169.13      14268     TCP     |\n10.254.32.134      8443      TCP     |\n10.254.118.196     443       TCP  \u003c--\u002b\n0.0.0.0            15004     HTTP \u003c--\u002b\n0.0.0.0            8080      HTTP    |\n0.0.0.0            15010     HTTP    | \n0.0.0.0            8088      HTTP    |\n0.0.0.0            15031     HTTP    |\n0.0.0.0            9090      HTTP    | \n0.0.0.0            9411      HTTP    | 接收与 0.0.0.0_15001 配对的 Outbound HTTP 流量\n0.0.0.0            80        HTTP    |\n0.0.0.0            15030     HTTP    |\n0.0.0.0            9080      HTTP    |\n0.0.0.0            9093      HTTP    |\n0.0.0.0            3000      HTTP    |\n0.0.0.0            8060      HTTP    |\n0.0.0.0            9091      HTTP \u003c--\u002b    \n0.0.0.0            15001     TCP  \u003c--- 接收所有经 iptables 拦截的 Inbound 和 Outbound 流量并转交给虚拟监听器处理\n\u0060\u0060\u0060\n\n当来自 \u0060productpage\u0060 的流量抵达 \u0060reviews\u0060 Pod 的时候已经，downstream 必须明确知道 Pod 的 IP 地址为 \u0060172.33.3.3\u0060 所以才会访问该 Pod，所以该请求是 \u0060172.33.3.3:9080\u0060。\n\n**\u0060virtual\u0060 Listener**\n\n从该 Pod 的 Listener 列表中可以看到，0.0.0.0:15001\/TCP 的 Listener（其实际名字是 \u0060virtual\u0060）监听所有的 Inbound 流量，下面是该 Listener 的详细配置。\n\n\u0060\u0060\u0060json\n{\n    \u0022name\u0022: \u0022virtual\u0022,\n    \u0022address\u0022: {\n        \u0022socketAddress\u0022: {\n            \u0022address\u0022: \u00220.0.0.0\u0022,\n            \u0022portValue\u0022: 15001\n        }\n    },\n    \u0022filterChains\u0022: [\n        {\n            \u0022filters\u0022: [\n                {\n                    \u0022name\u0022: \u0022envoy.tcp_proxy\u0022,\n                    \u0022config\u0022: {\n                        \u0022cluster\u0022: \u0022BlackHoleCluster\u0022,\n                        \u0022stat_prefix\u0022: \u0022BlackHoleCluster\u0022\n                    }\n                }\n            ]\n        }\n    ],\n    \u0022useOriginalDst\u0022: true\n}\n\u0060\u0060\u0060\n\n**UseOriginalDst**：从配置中可以看出 \u0060useOriginalDst\u0060 配置指定为 \u0060true\u0060，这是一个布尔值，缺省为 false，使用 iptables 重定向连接时，proxy 接收的端口可能与原始目的地址的端口不一样，如此处 proxy 接收的端口为 15001，而原始目的地端口为 9080。当此标志设置为 true 时，Listener 将连接重定向到与原始目的地址关联的 Listener，此处为 \u0060172.33.3.3:9080\u0060。如果没有与原始目的地址关联的 Listener，则连接由接收它的 Listener 处理，即该 \u0060virtual\u0060 Listener，经过 \u0060envoy.tcp_proxy\u0060 过滤器处理转发给 \u0060BlackHoleCluster\u0060，这个 Cluster 的作用正如它的名字，当 Envoy 找不到匹配的虚拟监听器时，就会将请求发送给它，并返回 404。这个将于下文提到的 Listener 中设置 \u0060bindToPort\u0060 相呼应。\n\n**注意**：该参数将被废弃，请使用原始目的地址的 Listener filter 替代。该参数的主要用途是：Envoy 通过监听 15001 端口将 iptables 拦截的流量经由其他 Listener 处理而不是直接转发出去，详情见 [Virtual Listener](https:\/\/zhaohuabing.com\/post\/2018-09-25-istio-traffic-management-impl-intro\/#virtual-listener)。\n\n**Listener 172.33.3.3_9080**\n\n上文说到进入 Inbound handler 的流量被 \u0060virtual\u0060 Listener 转移到 \u0060172.33.3.3_9080\u0060 Listener，我们在查看下该 Listener 配置。\n\n运行 \u0060istioctl pc listener reviews-v1-cb8655c75-b97zc --address 172.33.3.3 --port 9080 -o json\u0060 查看。\n\n\u0060\u0060\u0060json\n[{\n    \u0022name\u0022: \u0022172.33.3.3_9080\u0022,\n    \u0022address\u0022: {\n        \u0022socketAddress\u0022: {\n            \u0022address\u0022: \u0022172.33.3.3\u0022,\n            \u0022portValue\u0022: 9080\n        }\n    },\n    \u0022filterChains\u0022: [\n        {\n            \u0022filterChainMatch\u0022: {\n                \u0022transportProtocol\u0022: \u0022raw_buffer\u0022\n            },\n            \u0022filters\u0022: [\n                {\n                    \u0022name\u0022: \u0022envoy.http_connection_manager\u0022,\n                    \u0022config\u0022: {\n                        ... \n                        \u0022route_config\u0022: {\n                            \u0022name\u0022: \u0022inbound|9080||reviews.default.svc.cluster.local\u0022,\n                            \u0022validate_clusters\u0022: false,\n                            \u0022virtual_hosts\u0022: [\n                                {\n                                    \u0022domains\u0022: [\n                                        \u0022*\u0022\n                                    ],\n                                    \u0022name\u0022: \u0022inbound|http|9080\u0022,\n                                    \u0022routes\u0022: [\n                                        {\n                                            ...\n                                            \u0022route\u0022: {\n                                                \u0022cluster\u0022: \u0022inbound|9080||reviews.default.svc.cluster.local\u0022,\n                                                \u0022max_grpc_timeout\u0022: \u00220.000s\u0022,\n                                                \u0022timeout\u0022: \u00220.000s\u0022\n                                            }\n                                        }\n                                    ]\n                                }\n                            ]\n                        },\n                        \u0022use_remote_address\u0022: false,\n                        ...\n                    }\n                }\n            ]，\n            \u0022deprecatedV1\u0022: {\n                \u0022bindToPort\u0022: false\n            }\n        ...\n        },\n        {\n            \u0022filterChainMatch\u0022: {\n                \u0022transportProtocol\u0022: \u0022tls\u0022\n            },\n            \u0022tlsContext\u0022: {...\n            },\n            \u0022filters\u0022: [...\n            ]\n        }\n    ],\n...\n}]\n\u0060\u0060\u0060\n\n**bindToPort**：注意其中有一个 [\u0060bindToPort\u0060](https:\/\/www.envoyproxy.io\/docs\/envoy\/v1.6.0\/api-v1\/listeners\/listeners) 的配置，其值为 \u0060false\u0060，该配置的缺省值为 \u0060true\u0060，表示将 Listener 绑定到端口上，此处设置为 \u0060false\u0060 则该 Listener 只能处理其他 Listener 转移过来的流量，即上文所说的 \u0060virtual\u0060 Listener，我们看其中的 filterChains.filters 中的 \u0060envoy.http_connection_manager\u0060 配置部分：\n\n\u0060\u0060\u0060json\n\u0022route_config\u0022: {\n                            \u0022name\u0022: \u0022inbound|9080||reviews.default.svc.cluster.local\u0022,\n                            \u0022validate_clusters\u0022: false,\n                            \u0022virtual_hosts\u0022: [\n                                {\n                                    \u0022domains\u0022: [\n                                        \u0022*\u0022\n                                    ],\n                                    \u0022name\u0022: \u0022inbound|http|9080\u0022,\n                                    \u0022routes\u0022: [\n                                        {\n                                            ...\n                                            \u0022route\u0022: {\n                                                \u0022cluster\u0022: \u0022inbound|9080||reviews.default.svc.cluster.local\u0022,\n                                                \u0022max_grpc_timeout\u0022: \u00220.000s\u0022,\n                                                \u0022timeout\u0022: \u00220.000s\u0022\n                                            }\n                                        }\n                                    ]\n                                }\n                            ]\n                        }\n\u0060\u0060\u0060\n\n该配置表示流量将转交给 Cluster \u0060inbound|9080||reviews.default.svc.cluster.local\u0060 处理。\n\n**Cluster \u0060inbound|9080||reviews.default.svc.cluster.local\u0060**\n\n运行 \u0060istioctl pc cluster reviews-v1-cb8655c75-b97zc --fqdn reviews.default.svc.cluster.local --direction inbound -o json\u0060 查看该 Cluster 的配置如下。\n\n\u0060\u0060\u0060json\n[\n    {\n        \u0022name\u0022: \u0022inbound|9080||reviews.default.svc.cluster.local\u0022,\n        \u0022connectTimeout\u0022: \u00221.000s\u0022,\n        \u0022hosts\u0022: [\n            {\n                \u0022socketAddress\u0022: {\n                    \u0022address\u0022: \u0022127.0.0.1\u0022,\n                    \u0022portValue\u0022: 9080\n                }\n            }\n        ],\n        \u0022circuitBreakers\u0022: {\n            \u0022thresholds\u0022: [\n                {}\n            ]\n        }\n    }\n]\n\u0060\u0060\u0060\n\n可以看到该 Cluster 的 Endpoint 直接对应的就是 localhost，再经过 iptables 转发流量就被应用程序容器消费了。\n\n## 理解 Outbound Handler\n\n因为 \u0060reviews\u0060 会向 \u0060ratings\u0060 服务发送 HTTP 请求，请求的地址是：\u0060http:\/\/ratings.default.svc.cluster.local:9080\/\u0060，Outbound handler 的作用是将 iptables 拦截到的本地应用程序发出的流量，经由 Envoy 判断如何路由到 upstream。\n\n应用程序容器发出的请求为 Outbound 流量，被 iptables 劫持后转移给 Envoy  Outbound handler 处理，然后经过 \u0060virtual\u0060 Listener、\u00600.0.0.0_9080\u0060 Listener，然后通过 Route 9080 找到 upstream 的 cluster，进而通过 EDS 找到 Endpoint 执行路由动作。这一部分可以参考 Istio 官网中的 Envoy 深度配置解析。\n\n**Route 9080**\n\n\u0060reviews\u0060 会请求 \u0060ratings\u0060 服务，运行 \u0060istioctl proxy-config routes reviews-v1-cb8655c75-b97zc --name 9080 -o json\u0060 查看 route 配置，因为 Envoy 会根据 HTTP header 中的 domains 来匹配 VirtualHost，所以下面只列举了 \u0060ratings.default.svc.cluster.local:9080\u0060 这一个 VirtualHost。\n\n\u0060\u0060\u0060json\n[{\n    \u0022name\u0022: \u0022ratings.default.svc.cluster.local:9080\u0022,\n    \u0022domains\u0022: [\n        \u0022ratings.default.svc.cluster.local\u0022,\n        \u0022ratings.default.svc.cluster.local:9080\u0022,\n        \u0022ratings\u0022,\n        \u0022ratings:9080\u0022,\n        \u0022ratings.default.svc.cluster\u0022,\n        \u0022ratings.default.svc.cluster:9080\u0022,\n        \u0022ratings.default.svc\u0022,\n        \u0022ratings.default.svc:9080\u0022,\n        \u0022ratings.default\u0022,\n        \u0022ratings.default:9080\u0022,\n        \u002210.254.234.130\u0022,\n        \u002210.254.234.130:9080\u0022\n    ],\n    \u0022routes\u0022: [\n        {\n            \u0022match\u0022: {\n                \u0022prefix\u0022: \u0022\/\u0022\n            },\n            \u0022route\u0022: {\n                \u0022cluster\u0022: \u0022outbound|9080||ratings.default.svc.cluster.local\u0022,\n                \u0022timeout\u0022: \u00220.000s\u0022,\n                \u0022maxGrpcTimeout\u0022: \u00220.000s\u0022\n            },\n            \u0022decorator\u0022: {\n                \u0022operation\u0022: \u0022ratings.default.svc.cluster.local:9080\/*\u0022\n            },\n            \u0022perFilterConfig\u0022: {...\n            }\n        }\n    ]\n},\n..]\n\u0060\u0060\u0060\n\n从该 Virtual Host 配置中可以看到将流量路由到 Cluster \u0060outbound|9080||ratings.default.svc.cluster.local\u0060。\n\n**Endpoint \u0060outbound|9080||ratings.default.svc.cluster.local\u0060**\n\nIstio 1.1 以前版本不支持使用 \u0060istioctl\u0060 命令直接查询 Cluster 的 Endpoint，可以使用查询 Pilot 的 debug 端点的方式折中。\n\n\u0060\u0060\u0060bash\nkubectl exec reviews-v1-cb8655c75-b97zc -c istio-proxy curl http:\/\/istio-pilot.istio-system.svc.cluster.local:9093\/debug\/edsz \u003e endpoints.json\n\u0060\u0060\u0060\n\n\u0060endpoints.json\u0060 文件中包含了所有 Cluster 的 Endpoint 信息，我们只选取其中的 \u0060outbound|9080||ratings.default.svc.cluster.local\u0060 Cluster 的结果如下。\n\n\u0060\u0060\u0060json\n{\n  \u0022clusterName\u0022: \u0022outbound|9080||ratings.default.svc.cluster.local\u0022,\n  \u0022endpoints\u0022: [\n    {\n      \u0022locality\u0022: {\n\n      },\n      \u0022lbEndpoints\u0022: [\n        {\n          \u0022endpoint\u0022: {\n            \u0022address\u0022: {\n              \u0022socketAddress\u0022: {\n                \u0022address\u0022: \u0022172.33.100.2\u0022,\n                \u0022portValue\u0022: 9080\n              }\n            }\n          },\n          \u0022metadata\u0022: {\n            \u0022filterMetadata\u0022: {\n              \u0022istio\u0022: {\n                  \u0022uid\u0022: \u0022kubernetes:\/\/ratings-v1-8558d4458d-ns6lk.default\u0022\n                }\n            }\n          }\n        }\n      ]\n    }\n  ]\n}\n\u0060\u0060\u0060\n\nEndpoint 可以是一个或多个，Envoy 将根据一定规则选择适当的 Endpoint 来路由。\n\n**注**：Istio 1.1 将支持 \u0060istioctl pc endpoint\u0060 命令来查询 Endpoint。\n\n## 参考\n\n- 调试 Envoy 和 Pilot - istio.io\n- [理解 Istio Service Mesh 中 Envoy 代理 Sidecar 注入及流量劫持 - jimmysong.io](https:\/\/jimmysong.io\/posts\/envoy-sidecar-injection-in-istio-service-mesh-deep-dive\/)\n- [Istio 流量管理实现机制深度解析 - zhaohuabing.com](https:\/\/zhaohuabing.com\/post\/2018-09-25-istio-traffic-management-impl-intro\/)\n\n', '\/blog\/envoy-sidecar-routing-of-istio-service-mesh-deep-dive\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">Sidecar proxy 中 Indbound/Outbound 流量处理过程详解。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-service-and-traffic-model/">Istio 中的服务和流量的抽象模型</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2018/12/17</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio 中的服务和流量的抽象模型', '本文介绍了 Istio 和 Kubernetes 中的一些服务和流量的抽象模型。', '\n本文介绍了 Istio 和 Kubernetes 中的一些服务和流量的抽象模型。虽然 Istio 一开始确定的抽象模型与对接的底层平台无关，但目前来看基本绑定 Kubernetes，本文仅以 Kubernetes 说明。另外在 ServiceMesher 社区中最近有很多关于 Istio、Envoy、Kubernetes 之中的服务模型关系的讨论，本文作为一个开篇说明，Kubernetes 和 Isito 之间有哪些共有的服务模型，Istio 在 Kubernetes 的服务模型之上又增加了什么。\n\n**服务具有多个版本。** 在 CI\/CD 过程中，同一个服务可能同时部署在多个环境中，如开发、生产和测试环境等，这些服务版本不一定具有不同的 API，可能只是一些小的更改导致的迭代版本。在 A\/B 测试和灰度发布中经常遇到这种情况。\n\n## Kubernetes 与 Istio 中共有的模型\n\n因为 Istio 基本就是绑定在 Kubernetes 上，下面是我们熟知的 Kubernetes 及 Istio 中共有的服务模型。\n\nKubernetes 中 iptables 代理模式（另外还有 IPVS 模式）下的 service，管理员可以在 kube-proxy 中配置简单的负载均衡，对整个 node 生效，无法配置到单个服务的负载均衡和其他微服务的高级功能，例如熔断、限流、追踪等，这些功能只能在应用中实现了，而在 Istio 的概念模型中完全去掉了 \u0060kube-proxy\u0060  这个组件，将其分散到每个应用 Pod 中同时部署的 Envoy 中实现。\n\n下面列举的是 Kubernetes 和 Istio 中共有的模型。\n\n### Service\n\n这实际上跟 Kubernetes 中的 service 概念是一致的，请参考 [Kubernetes 中的 service](https:\/\/jimmysong.io\/kubernetes-handbook\/concepts\/service.html)。Istio 推出了比 service 更复杂的模型 \u0060VirtualService\u0060，这不单纯是定义一个服务了，而是在服务之上定义了路由规则。\n\n每个服务都有一个完全限定的域名（FQDN），监听一个或多个端口。服务还可以有与其相关联的单个负载均衡器或虚拟 IP 地址。针对 FQDN 的 DNS 查询将解析为该负载均衡器或者虚拟 IP 的地址。\n\n例如 Kubernetes 中一个服务为 \u0060foo.default.svc.cluster.local\u0060 ，虚拟 IP \/ClusterIP 是 10.0.1.1，监听的端口是 80 和 8080。\n\n### Endpoint\n\n这里指的是 Kubernetes 中的 endpoint，一个 endpoint 是实现了某服务的具体实例，一个服务可能有一个或者多个 Endpoint，表示为 IP 地址加端口，也可以为 DNS 名称加端口。\n\n其实到底哪些实例属于同一个 service，还是需要 通过 label 匹配来选择。\n\n### Label\n\n服务的版本、对应的引用名称等是通过 label 来标记的，例如下面 Kubernetes 中一个应用的 YAML 配置。\n\n\u0060\u0060\u0060yaml\napiVersion: extensions\/v1beta1\nkind: Deployment\nmetadata:\n  name: ratings-v1\nspec:\n  replicas: 1\n  template:\n    metadata:\n      labels:\n        app: ratings\n        version: v1\n    spec:\n      containers:\n      - name: ratings\n        image: istio\/examples-bookinfo-ratings-v1:1.8.0\n        imagePullPolicy: IfNotPresent\n        ports:\n        - containerPort: 9080\n\u0060\u0060\u0060\n\n \u0060version: v1\u0060 标记该服务是 v1 版本，\u0060version\u0060 是一个约定俗称的标签，建议大家的服务上都带上该标签。\n\n当然服务的 label 可以设置任意多个，这样的好处是在做路由的时候可以根据标签匹配来做细粒度的流量划分。\n\n## 数据平面 Envoy\n\nEnvoy 是 Istio 中默认的 sidecar proxy，负责服务间的流量管控、认证与安全加密、可观测性等。\n\n下面是 Envoy 的架构图。\n\n![Envoy 架构图](envoy-arch-20190114.png)\n\n我再给大家介绍 Envoy 中的如下几个重要概念。\n\n### Cluster\n\n集群（cluster）是 Envoy 连接到的一组逻辑上相似的上游主机。Envoy 通过服务发现发现集群中的成员。Envoy 可以通过主动运行状况检查来确定集群成员的健康状况。Envoy 如何将请求路由到集群成员由负载均衡策略确定。\n\n这个与 Kubernetes 中的 Service 概念类似，只不过 Kubernetes 中的服务发现中并不包含健康状况检查，而是通过[配置 Pod 的 liveness 和 readiness 探针](https:\/\/jimmysong.io\/kubernetes-handbook\/guide\/configure-liveness-readiness-probes.html)来实现，服务发现默认也是通过 DNS 来实现。\n\n### Listener\n\n监听器（listener）是可以由下游客户端连接的命名网络位置（例如，端口、unix 域套接字等）。Envoy 公开一个或多个下游主机连接的侦听器。一般是每台主机运行一个 Envoy，使用单进程运行，但是每个进程中可以启动任意数量的 Listener（监听器），目前只监听 TCP，每个监听器都独立配置一定数量的（L3\/L4）网络过滤器。Listenter 也可以通过 Listener Discovery Service（**LDS**）动态获取。\n\n### Listener filter\n\nListener 使用 listener filter（监听器过滤器）来操作链接的元数据。它的作用是在不更改 Envoy 的核心功能的情况下添加更多的集成功能。Listener filter 的 API 相对简单，因为这些过滤器最终是在新接受的套接字上运行。在链中可以互相衔接以支持更复杂的场景，例如调用速率限制。Envoy 已经包含了多个监听器过滤器。\n\n## Istio 中增加的流量模型\n\n\u0060VirtualService\u0060、\u0060DestinationRule\u0060、\u0060Gateway\u0060、\u0060ServiceEntry\u0060 和 \u0060EnvoyFilter\u0060 都是 Istio 中为流量管理所创建的 CRD，这些概念其实是做路由配置和流量管理的，而 Kubernetes 中的 service 只是用来做服务发现。Service Mesh 中真正的服务模型应该是 Envoy 的 [xDS 协议](https:\/\/cloudnative.to\/blog\/envoy-xds-protocol\/)，其中包括了服务的流量治理，服务的端点是通过 EDS 来配置的。\n\n![Istio pilot 架构图](istio-pilot.png)\n\n上图是 Pilot 设计图，来自[Istio Pilot design overview](https:\/\/github.com\/istio\/old_pilot_repo\/blob\/master\/doc\/design.md)。\n\n### Routing\n\nKubernetes 中的 service 是没有任何路由属性可以配置的，Istio 在设计之初就通过在同一个 Pod 中，在应用容器旁运行一个 sidecar proxy 来透明得实现细粒度的路由控制。\n\n### VirtualService\n\n\u0060VirtualService\u0060 定义针对指定服务流量的路由规则。每个路由规则都针对特定协议的匹配规则。如果流量符合这些特征，就会根据规则发送到服务注册表中的目标服务（或者目标服务的子集或版本）。对于 A\/B 测试和灰度发布等场景，通常需要使用划分 \u0060subset\u0060，VirtualService 中根据 destination 中的 subset 配置来选择路由，但是这些 subset 究竟对应哪些服务示例，这就需要 \u0060DestionationRule\u0060。\n\n### DestinationRule\n\n\u0060DestinationRule\u0060 所定义的策略，决定了经过路由处理之后的流量的访问策略。这些策略中可以定义负载均衡配置、连接池尺寸以及外部检测（用于在负载均衡池中对不健康主机进行识别和驱逐）配置。\n\n### Gateway\n\n\u0060Gateway\u0060 描述了一个负载均衡器，用于承载网格边缘的进入和发出连接。这一规范中描述了一系列开放端口，以及这些端口所使用的协议、负载均衡的 SNI 配置等内容。\n\n这个实际上就是定义服务网格的边缘路由。\n\n### ServiceEntry\n\n\u0060ServiceEntry\u0060 能够在 Istio 内部的服务注册表中加入额外的条目，从而让网格中自动发现的服务能够访问和路由到这些手工加入的服务。\u0060ServiceEntry\u0060 描述了服务的属性（DNS 名称、VIP、端口、协议以及端点）。这类服务可能是网格外的 API，或者是处于网格内部但却不存在于平台的服务注册表中的条目（例如需要和 Kubernetes 服务沟通的一组虚拟机服务）。\n\n如果没有配置 ServiceEntry 的话，Istio 实际上是无法发现服务网格外部的服务的。\n\n### EnvoyFilter\n\n\u0060EnvoyFilter\u0060 对象描述了针对代理服务的过滤器，这些过滤器可以定制由 Istio Pilot 生成的代理配置。这一功能一定要谨慎使用。错误的配置内容一旦完成传播，可能会令整个服务网格进入瘫痪状态。\n\nEnvoy 中的 listener 可以配置多个 filter，这也是一种通过 Istio 来扩展 Envoy 的机制。\n\n## 参考\n\n- [Kubernetes 中的 service - jimmysong.io](https:\/\/jimmysong.io\/kubernetes-handbook\/concepts\/service.html)\n- [Istio services model - github.com](https:\/\/github.com\/istio\/old_pilot_repo\/blob\/master\/doc\/service-registry.md)\n- [Istio 文档 - istio.io](https:\/\/istio.io)\n', '\/blog\/istio-service-and-traffic-model\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文介绍了 Istio 和 Kubernetes 中的一些服务和流量的抽象模型。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/software-defined-delivery-manifesto/">软件定义交付（SDD）宣言</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2018/11/30</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e4%b8%9a%e6%80%81"> 
             业态
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('软件定义交付（SDD）宣言', '今天给大家分享的是《软件定义交付宣言》，该宣言发出已经有一周多时间了，还在联署签名中。', '\n今天给大家分享的是《软件定义交付宣言》，该宣言发出已经有一周多时间了，目前该宣言的官方网站（\u0060https:\/\/sdd-manifesto.org\/\u0060 已停止维护）还在联署签名中。\n\n云原生通过不可变基础设施与声明式配置，作为了软件定义交付的基础，再假以持续交付工具可以极大的提高软件交付效率，本宣言的起草者中包含众多云原生理念的鉴定拥护者如 Kenny Bastani、Matt Stine 等。\n\n该宣言通过 GitHub 协作草拟（\u003chttps:\/\/github.com\/sdd-manifesto\/manifesto\u003e），仍未达到 1.0 版本。下面是《软件定义交付宣言》的中文版。\n\n## 软件定义交付宣言\n\n我们从日常生产和实践中认识到软件塑造了我们的世界。我们认识到代码才是指定精确操作的最佳方式。我们认识到代码仅在被交付时才有用。\n\n开发的软件被能够被交付出去就软件本身存在的目的。现在是时候将我们的核心技能应用到实际的工作中去了。是时候对交付去做出 *设计* 了。我们将区别人类和计算机在交付工作中承担的作用：人类做决策，计算机来完成自动化任务。\n\n每一次交付工作本质上都是独一无二的。应用程序、组织、部署环境和团队组合千差万别。我们认识到每个团队都需要能够理解这种交付的独特性和对交付做自动化。我们认识到，虽然持续交付对满足业务需求至关重要，但自动执行所有重复任务也非常重要。\n\n我们使用与加速应用程序开发类似的方式来加速软件交付：使用现代架构和编程语言，通用功能的框架、库和服务。\n\n交付基础设施现在是可编程的，我们将对其进行编程。\n\n## 软件定义交付是指\n\n**核心**：交付是每个软件团队和组织的基础和战略能力。\n\n- **优先**：交付的代码是生产代码。\n- **战略**：决定团队和组织层面的策略；在代码中实现精确控制。\n- **不断发展**：不断改进交付。\n\n**工程设计**：强大，可测试的代码。70 年代的脚本语言是不够的。\n\n- **现代软件架构**：事件驱动和可扩展。\n- **现代编程语言**：逻辑最好用代码指定，而不是图片或 GUI。脚本不好扩展。\n- **基于模型**：由软件领域的模型支持，具有对代码的理解。\n- **可测试**：在生产之前启用小规模应用以发现错误。\n\n**协作**：\n\n- **从群众中来**：所有人都可以在代码中表述自己的专业知识，这对大家都有利。\n- **到软件中去**：使用最好的工具，但将它们结合起来之后就是独一无二的。\n- **在人与软件之间**：协同自动化可以增强我们的感知和帮助我们做决策。将信息落实到行动，使我们能够体察软件的自动化行为。通过代码来区分团队的共享交付目标集及其实现。\n\n**加速**：\n\n- **通过自动化**：自动执行重复任务，加快了工作速度还可以避免错误发生。\n- **通过重用**：在开发人员、团队和组织之间共享通用功能。\n\n**可观测性**：通常用于观察和排除作为生产系统的交付过程中发生的情况。\n\n- **跟踪**：观察系统中的活动并跟踪操作之间的关系。\n- **调试**：检查和与交付流程交互。\n- **指标**：在整个交付流程的活动中获取指标。\n\n**作者**：(姓氏按字母顺序排列）：本宣言由 Kenny Bastani、Marc Holmes、Rod Johnson、Jessica Kerr、Mik Kersten、Russ Miles、Erin Schnabel、Matt Stine 及其他社区成员草拟。\n\n©2018，上述作者和本声明可以任何形式自由复制，但需全文复制本声明。\n', '\/blog\/software-defined-delivery-manifesto\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">今天给大家分享的是《软件定义交付宣言》，该宣言发出已经有一周多时间了，还在联署签名中。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/kubecon-cloudnativecon-china-2018/">KubeCon&amp;CloudNativeCon China 2018</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2018/11/16</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e9%9a%8f%e7%ac%94"> 
             随笔
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('KubeCon\u0026CloudNativeCon China 2018', 'KubeCon\u0026CloudNativeCon China 2018 参会回顾。', '\n本次大会是一个难得的机会，让我见到了很多朋友，很多都是第一次在线下见面。\n\n![KubeCon\u0026CloudNativeCon China 上海 2018](kubecon-shanghai-2018-group.webp)\n\n*图中由上自下的大合影是：ServiceMesher 社区上海聚首合影；中美日的 Kubernetes、Envoy、Istio、Apache Skywalking、ServiceMesher 社区在 KubeCon 上海；Yahoo Japan 与蚂蚁集团团队在上海中心办公室合影。*\n\n## 活动\n\n**Meet the Ambassadors**\n\n参加了一场 **Meet the Ambassadors** 采访，第一次参加英文的采访，本来准备的英文回答没用上，现场反而还紧张了。。。工作人员的摄像机又没就位，我还充当了摄影师（本色出演）。一共采访了四位中国的 Ambassador。\n\n- Jiayao (Julia) Han, Caicloud\n- Jia Xuan, China Mobile Research Institute\n- Jimmy Song, Ant Group\n- Jessie Qian, Alauda\n\n我们的名字不约而同的都是 J 字头。\n\n**Service Mesh Roundtable**\n\n然后参加了一场 Service Mesh Roundtable，参加人员有：\n\n- Jimmy Song, Developer Advocate on Cloud Native at Ant Group \n- Yulin Son, Principal Architect at Huawei \n- George Miranda, PagerDuty \n- Nic Jackson, Developer Advocate at HashiCorp \n\n我们就 Service Mesh 的现状，存在的问题后未来进行了广泛的探讨。\n\n## PPT\n\nKubeCon China 会议的很多 PPT 在[大会的官网](https:\/\/www.lfasiallc.com\/events\/kubecon-cloudnativecon-china-2018\/schedule-chinese\/)上都可以下载，或者通过[百度网盘](https:\/\/pan.baidu.com\/s\/1oihwETA063WSFyigWsn8Mw)下载 zip 包，提取码：**5vn0**。或者通过[GitHub](https:\/\/github.com\/bbotte\/cncf-presentations\/tree\/master\/KubeCon%2BCloudNativeCon-2018)下载单个 PPT。\n\n## 飞行\n\n在会场随便一坐，就能遇到熟人。还有很多我都叫不上名字的人来打招呼，不能一一道谢了，感谢晚餐以及收到的 Prometheus 飞行袜。\n\n11 月 12 日晚在上海静安寺上空飞行，航拍的南京西路夜景。\n\n\u003cdiv style=\u0022position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;\u0022\u003e\n  \u003ciframe src=\u0022\/\/player.bilibili.com\/player.html?aid=36041724\u0026cid=63259487\u0026page=1\u0022 style=\u0022position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;\u0022 allowfullscreen title=\u0022Jimmy Song 的航拍视频\u0022\u003e\u003c\/iframe\u003e\n\u003c\/div\u003e\n', '\/blog\/kubecon-cloudnativecon-china-2018\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">KubeCon&amp;CloudNativeCon China 2018 参会回顾。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
          <div class="col-12">
 
 
 
 
 
 
 
 
 
 
 
 <nav aria-label="Page navigation">
   <ul class="pagination justify-content-center">
     
     
     <li class="page-item">
       <a class="page-link" href="/blog/">
         ««
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a href="/blog/page/21/" class="page-link">
         «
       </a>
     </li>
     
     
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item">
           <a href="/blog/page/20/" class="page-link">
             20
           </a>
         </li>
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item">
           <a href="/blog/page/21/" class="page-link">
             21
           </a>
         </li>
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item page-item active ">
           <a href="/blog/page/22/" class="page-link">
             22
           </a>
         </li>
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item">
           <a href="/blog/page/23/" class="page-link">
             23
           </a>
         </li>
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item">
           <a href="/blog/page/24/" class="page-link">
             24
           </a>
         </li>
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
     
     
     <li class="page-item">
       <a href="/blog/page/23/" class="page-link">
         »
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a class="page-link" href="/blog/page/25/">
         »»
       </a>
     </li>
     
   </ul>
 </nav>
 
</div>

        </div>
      </div>
      <!-- sidebar -->
      <aside class="col-lg-4 order-1 order-lg-2 d-none d-sm-block">
          <div class="sidebar">
          <!-- categories -->
<div class="blog-categories mb-4">
  <p class="sidebar-title">
      专栏
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/istio" class="sidebar-item">
            <span>Istio</span>
            <span>(68)</span>
        </a>
      
        <a href="/categories/service-mesh" class="sidebar-item">
            <span>Service Mesh</span>
            <span>(38)</span>
        </a>
      
        <a href="/categories/kubernetes" class="sidebar-item">
            <span>Kubernetes</span>
            <span>(23)</span>
        </a>
      
        <a href="/categories/%e9%9a%8f%e7%ac%94" class="sidebar-item">
            <span>随笔</span>
            <span>(20)</span>
        </a>
      
        <a href="/categories/%e4%b8%9a%e6%80%81" class="sidebar-item">
            <span>业态</span>
            <span>(17)</span>
        </a>
      
        <a href="/categories/envoy" class="sidebar-item">
            <span>Envoy</span>
            <span>(15)</span>
        </a>
      
        <a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f" class="sidebar-item">
            <span>云原生</span>
            <span>(13)</span>
        </a>
      
        <a href="/categories/%e5%85%b6%e4%bb%96" class="sidebar-item">
            <span>其他</span>
            <span>(13)</span>
        </a>
      
        <a href="/categories/ai" class="sidebar-item">
            <span>AI</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%bc%80%e6%ba%90" class="sidebar-item">
            <span>开源</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%ae%89%e5%85%a8" class="sidebar-item">
            <span>安全</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e5%8f%af%e8%a7%82%e6%b5%8b%e6%80%a7" class="sidebar-item">
            <span>可观测性</span>
            <span>(5)</span>
        </a>
      
        <a href="/categories/%e5%ae%b9%e5%99%a8" class="sidebar-item">
            <span>容器</span>
            <span>(4)</span>
        </a>
      
        <a href="/categories/%e6%97%85%e8%a1%8c" class="sidebar-item">
            <span>旅行</span>
            <span>(4)</span>
        </a>
  </div>
</div>

<div class="blog-categories mb-4">
  <p class="sidebar-title">
      资料
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/%e5%87%ba%e7%89%88%e7%89%a9" class="sidebar-item">
            <span>出版物</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e7%94%b5%e5%ad%90%e4%b9%a6" class="sidebar-item">
            <span>翻译电子书</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e6%96%87%e6%a1%a3" class="sidebar-item">
            <span>翻译文档</span>
            <span>(7)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>翻译图书</span>
            <span>(6)</span>
        </a>
      
        <a href="/categories/%e5%8e%9f%e5%88%9b%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>原创图书</span>
            <span>(2)</span>
        </a>
      
        <a href="/categories/%e6%95%99%e7%a8%8b%e6%89%8b%e5%86%8c" class="sidebar-item">
            <span>教程手册</span>
            <span>(1)</span>
        </a>
  </div>
</div>





          </div>
      </aside>
      <!-- /sidebar -->
    </div>
  </div>
</section>




<footer>
  
  <div class="footer bg-footer section-sm border-bottom overlay ">
    <div class="container-xl">
      <div class="row">
        <div class="col col-xl-4 d-sm-none mb-2 mb-lg-0 d-xl-block d-none">
          
          <p class="h3 text-white mb-4 text-uppercase">联系</p>
          
          <ul class="list-unstyled">
            
            
            <li class="mb-4 text-color">微信公众号</li>
            
            
            <li class="mb-4"><img src="/images/servicemesher-wechat.webp" width="118px" height="118px" alt="footer image"></li>
            
            
            
          
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">博客</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/blog/securing-istio-addressing-critical-security-gaps-and-best-practices/">保障 Istio 安全：解决关键安全漏洞及最佳实践</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/ulanqab-trip/">乌兰察布之旅：探索火山与失落的村庄</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/explore-tetrate-enterprise-gateway/">介绍 Tetrate Enterprise Gateway 及与 Istio 集成：云原生应用的全面网关解决方案</a></li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">链接</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://istio.io/latest/zh/" target="_blank" rel="noopener noreferrer">
                  Istio 服务网格
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://tetrate.io/?jimmysong" target="_blank" rel="noopener noreferrer">
                  Tetrate 公司
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener noreferrer">
                  云原生学院|Bilibili
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/awesome-cloud-native/" target="_blank" rel="noopener noreferrer">
                  云原生开源项目大全
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://cloudnative.to" target="_blank" rel="noopener noreferrer">
                  云原生社区（中国）
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">教程</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/envoy-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Envoy 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/istio-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Istio 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/kubernetes-handbook/" >
                  Kubernetes 基础教程
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">通知</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/notice/kubecon-china-2024-panel/">KubeCon China 2024 圆桌论坛预告：Istio 和现代 API 网关——引领服务网格的未来</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/website-revamp-notice/">网站改版通知</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/cloud-native-meetup-dalian-2024/">2024 大连云原生技术开放日</a></li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>

  
  <div class="copyright py-4 bg-footer overlay">
    <div class="container-xl">
      <div class="row">
        <div class="col-sm-6 text-sm-left text-center">
          <p class="mb-0 text-color">© 2017-2024 Jimmy Song 保留所有权利</p>
        </div>
        <div class="col-sm-6 text-sm-right text-center">
          <ul class="list-inline">
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://twitter.com/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-x-twitter text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/contact/" >
                    <i class="fa-brands fa-weixin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://github.com/rootsongjc" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-github text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://linkedin.com/in/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-linkedin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="mailto:rootsongjc@gmail.com" >
                    <i class="fa-solid fa-envelope text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/blog/index.xml" >
                    <i class="fa-solid fa-rss text-white"></i>
              </a>
            </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>


<!-- JS Plugins -->

<script src="/plugins/popper/popper.min.js"></script>

<script src="/plugins/bootstrap/bootstrap.min.js"></script>

<script src="/plugins/slick/slick.min.js"></script>

<script src="/plugins/filterizr/jquery.filterizr.min.js"></script>

<script src="/plugins/search/fuse.min.js"></script>

<script src="/plugins/search/mark.js"></script>

<script src="/plugins/hex_md5/hex_md5.js"></script>

<script src="/plugins/anchor/anchor.min.js"></script>

<script src="/plugins/tocbot/tocbot.min.js"></script>

<script src="/plugins/bigger-picture/bigger-picture.min.js"></script>


<!-- Main Script -->

<script src="/js/script.min.f94c22b1d478bfc9e2e0a7d954429e47b7e6d36edd423758482e04154ae1842e.js"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-ESY906ZWZ0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ESY906ZWZ0');
</script>


<!-- Baidu analysis -->
<meta name="baidu-site-verification" content="g8IYR9SNLF" />


<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?11f7d254cfa4e0ca44b175c66d379ecc";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>









<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>










<script src="/js/wowchemy-search.min.7a37268e7bbe4a9160c2e4c33b749816.js" type="module"></script>
<script id="search-hit-fuse-template" type="text/x-template">
  <div class="search-hit" id="summary-{{key}}">
    <div class="search-hit-content border-bottom">
      <div class="search-hit-name">
        <div class='search-hit-link'><a href="{{relpermalink}}">{{title}}</a></div>
        <div class="search-hit-metadata d-flex">
            <span class="mr-1"><i class="fa-regular fa-calendar mr-1"></i>{{date}}</span>
            <span class="mr-1"><i class="fa-regular fa-folder-open mr-1"></i>{{section}}</span>
            <span class="d-sm-block d-none"><i class="fa-solid fa-link mr-1"></i>{{relpermalink}}</span>
        </div>
        <div class="search-hit-description">{{snippet}}</div>
      </div>
    </div>
  </div>
</script>



    </body>
</html>
