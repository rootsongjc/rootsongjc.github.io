<!DOCTYPE html>
<html lang="zh"><head>
  <meta charset="utf-8">
  
  <title>博客 - Jimmy Song</title>
  

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta name="description" content="专注开源技术、云原生与生活随笔的分享与思考。">
  <meta name="author" content="Jimmy Song">
  <meta name="generator" content="Hugo 0.136.0">

  <!-- CSS plugins -->
  
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
  
  <link rel="preload" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" as="style">
  <link rel="stylesheet" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" media="screen">
  

  <!-- Main Stylesheet -->
  
  <link rel="preload" href="/scss/style.min.f6911c0ac7d2b5b69c3f2d9f2a2b3b496b5da0608580347fdb4dc11ef74f3ec5.css" as="style">
  <link rel="stylesheet" href="/scss/style.min.f6911c0ac7d2b5b69c3f2d9f2a2b3b496b5da0608580347fdb4dc11ef74f3ec5.css" media="screen">

  <!-- Bigger picture css -->
  
  <link rel="stylesheet" href="/plugins/bigger-picture/bigger-picture.min.css" media="print" onload="this.media='all'">
  <!--Favicon generate by https://realfavicongenerator.net-->
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="200x200" href="/images/favicon.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">

  <link href='/opensearchdescription.xml' rel='search' title='Content search' type='application/opensearchdescription+xml'/>

  <!--Twitter card-->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="jimmysong.io" />
  <meta name="twitter:creator" content="@jimmysongio" />
  <meta property="og:url" content="https://jimmysong.io/blog/" />
  <meta property="og:title" content="博客 | Jimmy Song" />
  <meta property="twitter:title" content="博客 | Jimmy Song" />

  
  <meta property="og:description" content="专注开源技术、云原生与生活随笔的分享与思考。" />
  <meta property="twitter:description" content="专注开源技术、云原生与生活随笔的分享与思考。" />

  
  <meta property="og:image" content="https://jimmysong.io/images/banner/default.jpg" />
  <meta property="twitter:image" content="https://jimmysong.io/images/banner/default.jpg" />

  
  
</head>
<body>
<header class="fixed-top header">
  
  
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa fa-arrow-circle-up" aria-hidden="true"></i></button>
  
  <div class="navigation w-100 ">
    <div class="container-xl">
      <nav class="navbar navbar-expand-lg navbar-light p-0">
        <a class="navbar-brand" href="/">
            
            <b>JIMMY SONG</b>
            
        </a>
        <button class="navbar-toggler rounded-0" type="button" data-toggle="collapse" data-target="#navigation"
          aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse text-center" id="navigation">
          <ul class="navbar-nav ml-auto">
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/blog">博客</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/book">资料</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/tags">标签</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/notice">公告</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/contact">联系</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/about">关于</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/community/">社区</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener">视频 <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i></a>
              
            </li>
            
            

          
          
          <li class="nav-item">
            
            
            
              
              
                
                
                
                  
                    
                    <a class="nav-link" href="/en/blog/">English</a>
                    
                  
                
              
              
              
                
                  
                    
                    
                  
                
                
                
              
          </li>
          
          
          <!-- search -->
           <button type="button" class="search-btn js-search" id="searchOpen" aria-label="Search">
              <div class="search-container d-flex justify-content-center">
              <span class="search-content">
                  <i class="fa fa-search"></i>
                  <span>搜索</span>
              </span>
              <span class="search-shortcuts d-none d-sm-block">
                  <kbd class="cmd-key">⌘</kbd>
                  <kbd class="k-key">K</kbd>
              </span>
              </div>
          </button>
          
          </ul>
        </div>
      </nav>
    </div>
  </div>
</header>


            <aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between">
        <div class="col-6 search-title">
          <p>站内搜索</p> 
        </div>
        <div class="col-6 col-search-close">
          <div class="js-search" aria-label="关闭"><i class="fa-solid fa-circle-xmark text-muted" aria-hidden="true"></i></div>
        </div>
      </div>

      <div id="search-box">
        <i class="fa-solid fa-magnifying-glass" id="search-icon" aria-hidden="true"></i>
        <input name="q" id="search-query" placeholder="请输入搜索词" autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control" aria-label="请输入搜索词">
        
        <div class="mt-4">
          <span>搜索类型: </span>
          <span>
            <input type="radio" id="all" name="search_type" value="all" checked>
            <label for="all">所有</label>
            
              <input type="radio" id="blog" name="search_type" value="blog">
              <label for="blog">原创</label>
              <input type="radio" id="trans" name="search_type" value="trans">
              <label for="trans">译文</label>
            
            <input type="radio" id="book" name="search_type" value="book">
            <label for="book">资料</label>
            <input type="radio" id="notice" name="search_type" value="notice">
            <label for="notice">公告</label>
          </span>
        </div>
      </div>
      
    </section>
    <section class="section-search-results">
      <div id="search-results-count" class="search-results-count"></div>
      <div id="search-hits">
        
      </div>
    </section>
  </div>
</aside>

        
        
            

<section class="bg-cover page-title-section overlay" style="background-image: url('/images/backgrounds/circle.svg'),url('/images/backgrounds/page-title.webp');background-size: cover;">
    <div class="container-xl">
        <div class="row">
            <div class="col-12">
                <p class="h1">
                    博客
                </p>
                <p class="page-description">
                    专注开源技术、云原生与生活随笔的分享与思考。
                </p>
                
            </div>
        </div>
    </div>
</section>

        


<section class="section-sm book-list-section bg-gray">
  <div class="container-xl">
    <div class="row">
      <div class="col-lg-8 order-2 order-lg-1">
        <div class="row">
          
          
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/why-you-should-learn-wasm/">为什么要学习 WebAssembly？</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2023/01/13</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e9%9a%8f%e7%ac%94"> 
             随笔
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('为什么要学习 WebAssembly？', '2023 年我决定学习一门新技术——WebAssembly。', '\n2023 年你有什么学习计划？我计划要学习一门新技术——WebAssembly！\n\n## 为什么要学习 WebAssembly？{#why}\n\n2019 年，Docker 创始人 Solomon Hykes 发布了一条推特在业界引起了轩然大波（见下面的推文），他说如果 2008 年 WebAssembly 和 WASI 就存在的话，他就没必要创建 Docker。一时间，关于 WebAssembly 取代 Docker 的讨论此起彼伏。也是从那时起，WebAssembly 正式进入我的视线。\n\n\u003cblockquote class=\u0022twitter-tweet\u0022\u003e\u003cp lang=\u0022en\u0022 dir=\u0022ltr\u0022\u003eIf WASM\u002bWASI existed in 2008, we wouldn\u0026#39;t have needed to created Docker. That\u0026#39;s how important it is. Webassembly on the server is the future of computing. A standardized system interface was the missing link. Let\u0026#39;s hope WASI is up to the task! \u003ca href=\u0022https:\/\/t.co\/wnXQg4kwa4\u0022\u003ehttps:\/\/t.co\/wnXQg4kwa4\u003c\/a\u003e\u003c\/p\u003e\u0026mdash; Solomon Hykes \/ @shykes@hachyderm.io (@solomonstre) \u003ca href=\u0022https:\/\/twitter.com\/solomonstre\/status\/1111004913222324225?ref_src=twsrc%5Etfw\u0022\u003eMarch 27, 2019\u003c\/a\u003e\u003c\/blockquote\u003e \u003cscript async src=\u0022https:\/\/platform.twitter.com\/widgets.js\u0022 charset=\u0022utf-8\u0022\u003e\u003c\/script\u003e\n\n到了 2021 年，网上突然多了很多关于 WebAssembly 的炒作文章，包括我长期关注的 Istio 也在当年发布的 1.12 版本开始支持 WebAssembly（见 [Istio 1.12 引入 Wasm 插件配置 API 用于扩展 Istio 生态](https:\/\/cloudnative.to\/blog\/istio-wasm-extensions-and-ecosystem\/)），通过引入 [WasmPlugin](https:\/\/istio.io\/latest\/docs\/reference\/config\/proxy_extensions\/wasm-plugin\/) API，使开发人员更方便扩展服务网格和网关。\n\n最近我看到一篇介绍 WebAssembly 在 2023 年有哪些新趋势的[文章](https:\/\/cloudnative.to\/blog\/webassembly-5-predictions-for-2023\/)，文章的作者 Matt Butcher 颇有来头，他是 WebAssembly Cloud 公司 Fermyon 的联合创始人和 CEO，也是 Helm、Brigade、CNAB、OAM、Glide 和 Krustlet 的原始创建者之一。通过他的介绍让我笃定，WebAssembly 是一门颇有前景的技术，是时候学习它了。\n\n## WebAssembly 的市场前景 {#prospect}\n\n更何况 WebAssembly 的应用领域越来越广，像 [WasmEdge](https:\/\/wasmedge.org\/) 这样的公司正在使用 Tensorflow 来突破可以使用 Wasm 运行的边界。[Fermyon](https:\/\/www.fermyon.com\/) 正在构建用于微服务的 WebAssembly 工具，而 [Vercel](https:\/\/vercel.com\/docs\/concepts\/functions\/edge-functions\/wasm)、[Fastly](https:\/\/docs.fastly.com\/products\/compute-at-edge)、[Shopify](https:\/\/shopify.engineering\/shopify-webassembly) 和 [Cloudflare](https:\/\/developers.cloudflare.com\/workers\/platform\/languages\/) 使用 WebAssembly 在边缘运行代码。[Figma](https:\/\/www.figma.com\/blog\/webassembly-cut-figmas-load-time-by-3x\/)（2022 年以 200 亿美元被 Adobe 公司收购）正在使用 WebAssembly 为其应用程序在浏览器中提供更高的性能，而他们的新母公司 [Adobe](https:\/\/web.dev\/ps-on-the-web\/) 正在使用 WebAssembly 将他们的桌面应用程序带到 Web。\n\n## 如何学习 WebAssembly？{#how-to-learn-wasm}\n\n为了学习 WebAssembly，我制定了以下学习目标：\n\n1. 了解 WebAssembly 的基本概念，包括它是什么、为什么要使用它、如何在浏览器中运行它；\n\n2. 学习 WebAssembly 的语言，这是一种类似于汇编语言的低级语言，可以编译成二进制文件；\n\n3. 使用工具将代码编译成 WebAssembly 格式；\n\n4. 在 JavaScript 中调用 WebAssembly 模块；\n\n5. 学习 WebAssembly 的其他特性，如内存管理、多线程和 WebAssembly System Interface（WASI）；\n\n6. 了解 WebAssembly 如何增强安全防护；\n\n7. 学习 WebAssembly 的最佳实践，如代码优化和调试；\n\n8. 在 Istio 中开发 WebAssembly 插件；\n\n9. 学习使用 WebAssembly 开发的开源项目；\n\n## WebAssembly 参考资料 {#materials}\n\n下面列出了一些有助于学习 WebAssembly 的参考资料，包括网站和图书：\n\n- [WebAssembly 官网](https:\/\/webassembly.org\/)\n- [WebAssembly 教程](https:\/\/developer.mozilla.org\/zh-CN\/docs\/WebAssembly)\n- WebAssembly 在线编译器\n- [WebAssembly 学习资源](https:\/\/webassembly.org\/getting-started\/developers-guide\/)\n- [《WebAssembly：权威指南：安全、快速和可移植的代码，第 1 版，2022 年 1 月》](https:\/\/www.amazon.com\/WebAssembly-Definitive-Guide-Safe-Portable\/dp\/1492089842\/)\n- [wazero: the zero dependency WebAssembly runtime for Go developers](https:\/\/wazero.io\/)\n\n## 总结 {#summary}\n\nWebAssembly 不仅是用于浏览器端有效弥补 JavaScript 缺陷的一门技术，凭借它的小巧、高效和可移植性在后端也会有很广泛的应用。2023 年，让我们一起来学习 WebAssembly 吧！我也会适时得在云原生社区中创建 Wasm 学习小组，欢迎大家[加入云原生社区](https:\/\/cloudnative.to\/community\/join\/)共同交流学习。\n\n## 参考 {#reference}\n\n- [Istio 1.12 引入 Wasm 插件配置 API 用于扩展 Istio 生态 - cloudnative.to](https:\/\/cloudnative.to\/blog\/istio-wasm-extensions-and-ecosystem\/)\n- [在 Istio 中引入 Wasm 意味着什么？- cloudnative.to](https:\/\/cloudnative.to\/blog\/importance-of-wasm-in-istio\/)\n- [2023 年 WebAssembly 技术五大趋势预测 - cloudnative.to](https:\/\/cloudnative.to\/blog\/webassembly-5-predictions-for-2023\/)\n', '\/blog\/why-you-should-learn-wasm\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">2023 年我决定学习一门新技术——WebAssembly。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/technical-deep-dive-securing-automation-acme-dns-challenge-validation/">[译] 深入探讨：ACME DNS 质询验证的自动化</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2023/01/10</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e5%ae%89%e5%85%a8"> 
             安全
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://www.eff.org/deeplinks/2018/02/technical-deep-dive-securing-automation-acme-dns-challenge-validation" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('深入探讨：ACME DNS 质询验证的自动化', '本文深入探讨了 DNS 质询的自动化。', '\n注：原文发布于 2018 年 2 月 26 日。\n\n2018 年 [Let\u0027s Encrypt](https:\/\/www.letsencrypt.org\/) （免费、自动化、开放的证书颁发机构 EFF 在两年前帮助推出）达到了一个巨大的里程碑： [颁发了超过 5000 万个有效证书](https:\/\/www.eff.org\/deeplinks\/2018\/02\/lets-encrypt-hits-50-million-active-certificates-and-counting)。而且这个数字只会继续增长，因为几周后 Let\u0027s Encrypt 也将开始颁发“通配符”证书 —— 这是许多系统管理员一直要求的功能。\n\n## 什么是通配符证书？\n\n为了验证 HTTPS 证书，用户的浏览器会检查以确保证书中实际列出了网站的域名。例如，来自 \u0060www.eff.org\u0060 的证书实际上必须将 \u0060www.eff.org\u0060 列为该证书的有效域。如果所有者只想对他的所有域使用一个证书，则证书还可以列出多个域（例如，\u0060www.eff.org\u0060、\u0060ssd.eff.org\u0060、\u0060sec.eff.org\u0060 等）。通配符证书只是一个证书，上面写着“我对这个域中的所有子域都有效”，而不是明确地将它们全部列出。（在证书中，这是通过使用通配符来表示的，用星号表示。所以如果你今天检查 eff.org 的证书，它会说它对 *.eff.org 有效。）这样，\n\n为了颁发通配符证书，Let\u0027s Encrypt 将要求用户通过使用基于 [DNS](https:\/\/en.wikipedia.org\/wiki\/Domain_Name_System) 的质询来证明他们对域的控制，DNS 是一种域名系统，可将 \u0060www.eff.org\u0060 等域名转换为 69.50.232.54 等 IP 地址。从像 Let\u0027s Encrypt 这样的证书颁发机构 (CA) 的角度来看，没有比修改其 DNS 记录更好的证明您控制域的方法，因为控制域是 DNS 的本质。\n\n但 Let\u0027s Encrypt 背后的一个关键思想是获取证书应该是一个自动过程。但是，为了实现自动化，请求证书的软件还需要能够修改该域的 DNS 记录。为了修改 DNS 记录，该软件还需要能够访问 DNS 服务的凭据（例如登录名和密码，或加密令牌），并且这些凭据必须存储在自动化发生的任何地方。在许多情况下，这意味着如果处理该过程的机器受到威胁，DNS 凭据也会受到威胁，这才是真正的危险所在。在本文的其余部分，我们将深入探讨该过程中涉及的组件，以及使它更安全的选项。\n\n## DNS 质询如何运作？\n\n在高层次上，DNS 质询的工作方式与作为 ACME 协议一部分的所有其他自动质询一样 —— 证书颁发机构 (CA)（如 Let\u0027s Encrypt）和客户端软件（如 Certbot）使用该协议来就服务器请求的证书进行通信，以及服务器应该如何证明相应域名的所有权。在 DNS 质询中，用户使用支持 DNS 质询类型的 Certbot 等 ACME 客户端软件向 CA 申请证书。当客户端请求证书时，CA 要求客户端通过向其 DNS 区域添加特定的 TXT 记录来证明对该域的所有权。更具体地说，CA 向 ACME 客户端发送一个唯一的随机令牌，并且控制域的任何人都应该将此 TXT 记录放入其 DNS 区域，在名为 \u0060_acme-challenge\u0060 的预定义记录中。当令牌值添加到 DNS 区域时，客户端告诉 CA 继续验证质询，之后 CA 将向域的权威服务器执行 DNS 查询。如果权威 DNS 服务器回复包含正确质询令牌的 DNS 记录，则证明域的所有权并且证书颁发过程可以继续。\n\n## DNS 控制数字身份\n\nDNS 区域泄露之所以如此危险，是因为 DNS 是用户的浏览器所依赖的，以了解他们在尝试访问您的域时应该联系的 IP 地址。这适用于在您的域下使用可解析名称的每项服务，从电子邮件到 Web 服务。当 DNS 受到威胁时，恶意攻击者可以轻松拦截指向您的电子邮件或其他受保护服务的所有连接，终止 TLS 加密（因为他们现在可以证明对该域的所有权并为其获取自己的有效证书），阅读明文数据，然后重新加密数据并将连接传递到您的服务器。对于大多数人来说，这很难被发现。\n\n## 独立和有限的特权\n\n严格来说，为了让 ACME 客户端以自动方式处理更新，客户端只需要访问可以更新 \u0060_acme-challenge\u0060 子域的 TXT 记录的凭据。不幸的是，大多数 DNS 软件和 DNS 服务提供商不提供允许限制这些权限的精细访问控制，或者根本不提供 API 来处理基本 DNS 区域更新或传输之外的自动化。这使得可能的自动化方法无法使用或不安全。\n\n一个简单的技巧可以帮助克服这些限制：使用 [CNAME 记录](https:\/\/en.wikipedia.org\/wiki\/CNAME_record)。CNAME 记录本质上充当到另一个 DNS 记录的链接。Let\u0027s Encrypt 遵循 CNAME 记录链，并将解析链中最后一条记录的质询验证令牌。\n\n## 缓解问题的方法\n\n即使使用 CNAME 记录，潜在的问题仍然存在，即 ACME 客户端仍然需要访问允许它修改某些 DNS 记录的凭据。有不同的方法可以缓解这个潜在的问题，在泄露的情况下具有不同程度的复杂性和安全影响。在接下来的部分中，本文将介绍其中一些方法，同时尝试解释如果凭据被泄露可能产生的影响。除了一个例外，它们都使用 CNAME 记录。\n\n### 只允许更新 TXT 记录\n\n第一种方法是创建一组具有仅允许更新 TXT 记录的权限的凭证。在泄露的情况下，此方法将影响限制为攻击者能够为 DNS 区域内的所有域颁发证书（因为他们可以使用 DNS 凭据来获取自己的证书），以及中断邮件传递。对邮件传递的影响源于邮件特定的 TXT 记录，即 [SPF](https:\/\/en.wikipedia.org\/wiki\/Sender_Policy_Framework)、 [DKIM](https:\/\/en.wikipedia.org\/wiki\/DomainKeys_Identified_Mail)、其扩展名 [ADSP](https:\/\/en.wikipedia.org\/wiki\/Author_Domain_Signing_Practices) 和 [DMARC](https:\/\/en.wikipedia.org\/wiki\/DMARC)。泄露这些还可以很容易地发送网络钓鱼电子邮件，这些电子邮件冒充来自相关受感染域的发件人。\n\n### 使用“一次性”验证域\n\n第二种方法是为 \u0060_acme-challenge\u0060 子域手动创建 CNAME 记录，并将它们指向一个验证域，该验证域位于由一组不同的凭据控制的区域中。例如，如果您想获得涵盖 \u0060yourdomain.tld\u0060 和 \u0060www.yourdomain.tld\u0060 的证书，则必须创建两个 CNAME 记录 ——\u0060_acme-challenge.yourdomain.tld\u0060 和 \u0060_acme-challenge.www.yourdomain.tld\u0060—— 并将它们都指向外部域以进行验证。\n\n用于质询验证的域应位于外部 DNS 区域或具有自己的一组管理凭据的子委托 DNS 区域中。（子委托 DNS 区域是使用 NS 记录定义的，它有效地将对该区域的一部分的完全控制委托给外部机构。）\n\n这种方法的泄露影响相当有限。由于实际存储的凭据是针对外部 DNS 区域的，因此获得凭据的攻击者只能获得为指向该区域中的记录的所有域颁发证书的能力。\n\n然而，弄清楚哪些域确实指向那里是微不足道的：攻击者只需阅读 [证书透明度](https:\/\/www.certificate-transparency.org\/) 日志并检查这些证书中的域是否具有指向受感染 DNS 区域的神奇子域。\n\n### 有限的 DNS 区域访问\n\n如果您的 DNS 软件或提供商允许创建绑定到子域的权限，这可以帮助您缓解整个问题。不幸的是，在发布时，我们发现唯一允许这样做的提供商是 [Microsoft Azure DNS](https:\/\/docs.microsoft.com\/en-us\/azure\/dns\/dns-protect-zones-recordsets)。据推测，Dyn 也有细粒度的权限，但我们无法在他们的服务中找到除“更新记录”之外的更低级别的权限，这仍然使该区域完全容易受到攻击。\n\nRoute53 和其他可能允许他们的用户创建子委托区域、新用户凭据、将 NS 记录指向新区域，并使用 CNAME 记录将 \u0060_acme-challenge\u0060 验证子域指向他们。使用这种方法正确地进行特权分离需要做很多工作，因为人们需要为他们想要使用 DNS 挑战的每个域完成所有这些步骤。\n\n### 使用 ACME-DNS\n\n作为免责声明，下面讨论的软件由作者编写，并用作以安全方式处理 DNS 质询自动化所需凭据所需功能的示例。最后一种方法是一款名为 ACME-DNS 的软件，专为解决这个问题而编写，它能够完全缓解这个问题。一个缺点是它为您的基础设施增加了一项需要维护的东西，以及对公共互联网开放 DNS 端口 (53) 的要求。ACME-DNS 充当具有有限 HTTP API 的简单 DNS 服务器。API 本身只允许更新自动生成的随机子域的 TXT 记录。没有方法可以请求丢失的凭据、更新或添加其他记录。它提供了两个端点：\n\n- \/register：此端点生成一个新的子域供您使用，并附有用户名和密码。作为可选参数，注册端点采用 CIDR 范围列表，以从中进行白名单更新。\n- \/update：此端点用于将实际质询令牌更新到服务器。\n\n为了使用 ACME-DNS，您首先必须为其创建 A\/AAAA 记录，然后将 NS 记录指向它以创建委托节点。之后，您只需通过 \/register 端点创建一组新的凭据，并将 CNAME 记录从原始区域的 \u0060_acme-challenge\u0060 验证子域指向新生成的子域。\n\n唯一保存在本地的凭据是用于 ACME-DNS 的凭据，它们仅适用于更新验证子域的确切 TXT 记录。这有效地限制了可能的危害对攻击者能够为这些域颁发证书的影响。有关 ACME-DNS 的更多信息，请访问 \u003chttps:\/\/github.com\/joohoi\/acme-dns\/\u003e。\n\n## 结论\n\n为了缓解 ACME DNS 挑战验证的问题，已经讨论了向 IETF 的 ACME 工作组提出的[辅助 DNS 等提案，但目前仍未得到解决](https:\/\/mailarchive.ietf.org\/arch\/msg\/acme\/6_j3fecaxIgwNTpJ3693U_n0Kec)。由于限制泄露的唯一方法是将 DNS 区域凭据权限限制为仅更改特定的 TXT 记录，因此当前安全地实现 DNS 验证自动化的可能性很小。唯一可持续的选择是让 DNS 软件和服务提供商要么实施方法来创建更细粒度的区域凭据，要么为这个确切的用例提供全新类型的凭据。\n', '\/trans\/technical-deep-dive-securing-automation-acme-dns-challenge-validation\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文深入探讨了 DNS 质询的自动化。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/secure-ingress-gateway-of-istio/">使用 cert-manager ACME Issuer 为 Istio 中的入口网关设置证书</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2023/01/09</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('使用 cert-manager ACME Issuer 为 Istio 中的入口网关设置证书', '本文就将使用 Let\u0027s Encrypt、cert-manager 来管理 Istio 中入口网关的证书。', '\n本文将以 Bookinfo 应用为例，为 Istio 的入口网关设置一个真实的 TLS\/SSL 证书。我们将使用 Let\u0027s Encrypt、cert-manager 来管理 Istio 中入口网关的证书。\n\n## 准备 {#prerequisite}\n\n请先参考 [Istio 文档](https:\/\/istio.io\/latest\/zh\/docs\/setup\/)安装 Istio 和 [Bookinfo 应用](https:\/\/istio.io\/latest\/zh\/docs\/examples\/bookinfo\/)，笔者在 GKE 中安装了 Istio 1.16。\n\n本文中安装的各组件版本信息如下：\n\n- Kubernetes 1.24.7\n- Istio 1.16\n- Gateway API 0.5.1\n- cert-manager 1.10.1\n\n## 架构 {#arch}\n\n本实验中包含以下关键组件：\n\n- 使用 Cloudflare 提供 DNS 解析\n- 使用 Let\u0027s Encrypt 创建证书\n- 使用 cert-manager 自动申请和续期证书\n- 使用 Gateway API 来创建入口网关\n- 所有组件部署在 GKE 中\n\n图 1 展示了本实验的架构以及流量路由过程。\n\n![图 1：Istio 入口网关证书挂载模式](arch.svg)\n\n流量路由过程如下：\n\n1. 在 Gateway 创建完成后通过 LoadBalancer 暴露网关 IP，将该 IP 配置在 DNS 解析记录中；\n2. Gateway 通过注解引用 [ACME Issuer](https:\/\/cert-manager.io\/docs\/configuration\/acme\/)；\n3. ACME Issuer 向 cert-manager 发送请求证书（[order 和 challenge](https:\/\/cert-manager.io\/docs\/concepts\/acme-orders-challenges\/)），并使用 [DNS01 Challenge Provider](https:\/\/cert-manager.io\/docs\/configuration\/acme\/dns01\/)；\n4. cert-manager 向 ACME 服务器 Let\u0027s Encrypt 请求证书并创建 Kubernetes Secret；\n5. 在 Gateway 中通过应用 Secret 挂载 TLS 证书；\n6. HTTPRoute 将入口流量路由到 productpage 服务；\n\n## ACME Issuer\n\nIstio 包含了开箱即用的 mTLS 支持，你也可以使用[自定义 CA](https:\/\/istio.io\/latest\/zh\/docs\/tasks\/security\/cert-management\/plugin-ca-cert\/) 或 [SPIRE](\/blog\/cert-manager-spire-istio\/) 来管理集群内证书，但是对于入口网关的证书，就需要我们单独设置。你可以[手动为入口网关配置证书](https:\/\/istio.tetratelabs.io\/zh\/istio-in-practice\/setting-up-ssl-certs\/)，不过管理起来会比较麻烦，因为你需要负责证书的轮换以防止证书过期，或使用 [Let\u0027s Encrypt](https:\/\/letsencrypt.org\/) 这样的 ACME Issuer 来自动化管理证书。\n\nACME (Automated Certificate Management Environment) Issuer 是一种认证机构，可以使用 ACME 协议为客户端申请和管理证书。ACME 是一种用于自动化 SSL\/TLS 证书颁发和管理的开放协议。它通常用于网站或其他在线服务的证书管理，以确保安全连接。\n\nLet\u0027s Encrypt 是一个非营利性的 ACME Issuer，可以为网站提供免费的 SSL\/TLS 证书。它的目标是使加密技术普及化，并帮助提升网络安全水平。Let\u0027s Encrypt 使用 ACME 协议与客户端通信，可以为客户端申请和管理证书。ACME 协议是开放的，因此任何机构都可以成为 ACME Issuer，只要它们遵守 ACME 协议的规定。\n\n## 详细步骤 {#details-steps}\n\n1. 安装 Gateway API：\n\n   \u0060\u0060\u0060bash\n   kubectl apply -f https:\/\/github.com\/kubernetes-sigs\/gateway-api\/releases\/download\/v0.5.1\/standard-install.yaml\n   \u0060\u0060\u0060\n\n2. 安装 cert-manager\n\n   \u0060\u0060\u0060bash\n   kubectl apply -f https:\/\/gist.githubusercontent.com\/rootsongjc\/78487acdea70a3c27c1a1b794546d031\/raw\/0df08b91dfaff6412bbd891ccedffaa882a9a99f\/cert-manager.yaml\n   \u0060\u0060\u0060\n\n   它为 cert-manager Deployment 增加了以下启动项：\n\n   \u0060\u0060\u0060bash\n   args:\n     - --feature-gates=ExperimentalGatewayAPISupport=true\n   \u0060\u0060\u0060\n\n3. 在 Cloudflare 中创建一个名为 \u0060lets-encrypt-token\u0060 的 API token，自定义模板设置如下：\n\n   Permissions：\n\n   - \u0060Zone - DNS - Edit\u0060\n   - \u0060Zone - Zone - Read\u0060\n\n   Zone Resources:\n\n   - \u0060Include - All Zones\u0060\n\n   将该 token 存储在一个 Secret 中：\n\n   \u0060\u0060\u0060yaml\n   kubectl apply -n default -f - \u003c\u003cEOF\n   apiVersion: v1\n   kind: Secret\n   metadata:\n     name: cloudflare-api-token-secret\n     namespace: istio-system\n   type: Opaque\n   stringData:\n     api-token: \u003cAPI Token\u003e\n   EOF\n   \u0060\u0060\u0060\n\n   {{\u003ccallout warning 注意\u003e}}\n\n   本次实验中该 Token 实际上并没起到作用，正常情况下 cert-manager 会通过 Cloudflare API 与 Cloudflare 交互，为我们配置 DNS 记录。该问题还需要进一步排查。\n\n   {{\u003c\/callout\u003e}}\n\n4. 配置 Let\u0027s Encrypt  Issuer：\n\n   \u0060\u0060\u0060bash\n   kubectl apply -n default -f - \u003c\u003cEOF\n   apiVersion: cert-manager.io\/v1\n   kind: Issuer\n   metadata:\n     name: letsencrypt\n   spec:\n     acme:\n       email: rootsongjc@gmail.com\n       server: https:\/\/acme-v02.api.letsencrypt.org\/directory\n       privateKeySecretRef:\n         name: lets-encrypt-issuer-account-key\n       solvers:\n       - dns01:\n           cloudflare:\n             apiTokenSecretRef:\n               name: cloudflare-api-token-secret\n               key: api-token\n         selector:\n           dnsNames:\n           - \u0027bookinfo.jimmysong.io\u0027\n   EOF\n   \u0060\u0060\u0060\n\n5. 配置 Gateway：\n\n   \u0060\u0060\u0060bash\n   kubectl apply -n default -f - \u003c\u003cEOF\n   apiVersion: gateway.networking.k8s.io\/v1beta1\n   kind: Gateway\n   metadata:\n     name: bookinfo-gateway\n     annotations:\n       cert-manager.io\/issuer: letsencrypt\n   spec:\n     gatewayClassName: istio\n     listeners:\n     - name: http\n       hostname: bookinfo.jimmysong.io\n       port: 443\n       protocol: HTTPS\n       allowedRoutes:\n         namespaces:\n           from: Same\n       tls:\n         mode: Terminate\n         certificateRefs:\n           kind: Secret\n           group: \u0022\u0022\n           name: bookinfo-tls\n   EOF\n   \u0060\u0060\u0060\n\n   在 Gateway 创建完成后，会在 default 命名空间中创建一个网关 Pod 以及 LoadBalancer 资源的服务。\n\n   查看 \u0060default\u0060 命名空间中的 Secret，你会发现 \u0060bookinfo-tls\u0060，它是由 cert-manager 创建的，查看该 Secret 中保存的证书，你将会看到由 Let\u0027s Encrypt 颁发的证书信任链：\n\n   - \u0060bookinfo.jimmysong.io\u0060 \n   - \u0060ISRG Root X1\u0060\n   - \u0060DST Root CA X3\u0060\n\n6. 配置 HTTPRoute：\n\n   \u0060\u0060\u0060bash\n   kubectl apply -n default -f - \u003c\u003cEOF\n   apiVersion: gateway.networking.k8s.io\/v1beta1\n   kind: HTTPRoute\n   metadata:\n     name: bookinfo\n   spec:\n     parentRefs:\n     - name: bookinfo-gateway\n     rules:\n     - matches:\n       - path:\n           type: Exact\n           value: \/productpage\n       - path:\n           type: PathPrefix\n           value: \/static\n       - path:\n           type: Exact\n           value: \/login\n       - path:\n           type: Exact\n           value: \/logout\n       - path:\n           type: PathPrefix\n           value: \/api\/v1\/products\n       backendRefs:\n       - name: productpage\n         port: 9080\n   EOF\n   \u0060\u0060\u0060\n\n7. 在 Cloudflare 中配置域名记录：将网关服务的外网 IP 及域名 \u0060bookinfo.jimmysong.io\u0060 添加到 Cloudflare 的 DNS 记录中就可以实现域名解析。\n\n   {{\u003ccallout warning 注意\u003e}}\n\n   本实验中发现网关 Pod 并没有挂载 \u0060bookinfo-tls\u0060  Secret 中的证书，我们只好通过 Cloudflare 来配置 TLS 证书：为网站开启全（严格）SSL\/TLS，这将使用 Cloudflare 颁发的 TLS 证书。\n\n   {{\u003c\/callout\u003e}}\n\n8. 在浏览器中访问 \u003chttps:\/\/bookinfo.jimmysong.io\/productpage\u003e 就可以访问 bookinfo 应用了。\n\n## 总结 {#summary}\n\n本次实验虽然实现了网关的 TLS 加密，也为网关生成了 TLS 证书，但实际上网关使用的是 Cloudflare 颁发的证书。这并不是我们最初的目标，即使用 ACME Server（Let\u0027s Encrypt）为网关颁发的证书。为什么网关 Pod 没有挂载我们应用的 Secret 中的证书，Cloudflare DNS01 Challenge Provider 为什么没有生效，这两个问题还需要我们进一步调查。\n\n## 参考 {#reference}\n\n- [Acquire SSL Certificates In Kubernetes From Let’s Encrypt With Cert-Manager - thinktecture.com](https:\/\/www.thinktecture.com\/en\/kubernetes\/ssl-certificates-with-cert-manager-in-kubernetes\/)\n- [How To Secure Kubernetes NGINX Ingress With Cert-Manager](https:\/\/getbetterdevops.io\/k8s-ingress-with-letsencrypt\/)\n- [Securing gateway.networking.k8s.io Gateway Resources - cert-manager.io](https:\/\/cert-manager.io\/docs\/usage\/gateway\/)\n', '\/blog\/secure-ingress-gateway-of-istio\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文就将使用 Let&#39;s Encrypt、cert-manager 来管理 Istio 中入口网关的证书。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/webassembly-5-predictions-for-2023/">[译] 2023 年 WebAssembly 技术五大趋势预测</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2023/01/09</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e4%b8%9a%e6%80%81"> 
             业态
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://thenewstack.io/webassembly-5-predictions-for-2023/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('2023 年 WebAssembly 技术五大趋势预测', '2023 年将是 Wasm 年。', '\n2022 年，WebAssembly（通常缩写为 Wasm）成为了[焦点](https:\/\/thenewstack.io\/yes-webassembly-can-replace-kubernetes\/)。新的 Wasm 初创企业出现。老牌公司宣布支持 Wasm。Bytecode Alliance 发布了许多 Wasm 标准。Cloud Native Computing Foundation 举办了两次 WasmDay 活动。而其中最大的 Wasm 用户之一 Figma 被 Adobe 以惊人的 200 亿美元的价格收购。\n\nWasm 是一种二进制格式。许多不同的语言都可以编译为相同的格式，并且该二进制格式可以在大量操作系统和体系结构上运行。Java 和 .NET 在这方面也很相似，但是 Wasm 有一个重要的区别：Wasm 运行时不信任执行的二进制文件。\n\nWasm 应用程序被隔离在沙盒中，只能访问用户明确允许的资源（如文件或环境变量）。Wasm 还有许多其他理想的特性（例如非常出色的性能），但正是它的安全模型使 Wasm 在广泛的环境中使用，从浏览器到边缘和 IoT，甚至到云端。\n\n如果要在 2022 年发现 Wasm 趋势，那就是 Wasm 现在在浏览器之外也同样成功。这一趋势是 2023 年的基础。随着 Wasm 出现在嵌入式设备到大数据中心的各个地方，2023 年将成为 Wasm 的一年。以下是我对 2023 Wasm 生态系统的五个预测。\n\n## 1. 组件模型将是分水岭时刻\n\n标准很少是一个生态系统中最令人兴奋的部分。而且，随着“组件模型”这样的名字，激起兴奋感确实是一项艰巨的任务。但是，在这个乏味的名字背后是 Wasm 为软件世界带来的最重要的创新。\n\n组件模型描述了 Wasm 二进制文件之间如何交互的方式。更具体地说，两个组件可以告诉对方它们提供的服务以及需要履行的期望。然后，Wasm 模块可以利用彼此的能力。这为软件开发人员提供了一种新的建立应用程序的方式。开发人员可以声明应用程序所需的组件（或者更抽象地说，应用程序所需的功能），然后 Wasm 运行时可以代表用户组装正确的组件集合。\n\nWasm 最多产的贡献者之一 [Dan Gohman](https:\/\/github.com\/sunfishcode) 写了一篇很好的[概述文章](https:\/\/blog.sunfishcode.online\/what-is-a-wasm-component\/)。Fermyon 的 [Joel Dice](https:\/\/github.com\/dicej) 则为那些对内部更感兴趣的人写了一篇[技术概述](https:\/\/www.fermyon.com\/blog\/webassembly-component-model)。\n\n组件模型正在迅速成熟，已经出现了参考实现。2023 年将是组件模型开始重新定义我们如何编写软件的一年。\n\n## 2. Serverless 将是 Wasm 的最佳应用场景\n\nServerless 的承诺已经在过去几年中显而易见。AWS Lambda 让我们看到了一种新的、简单的编程模型 —— 函数即服务（FaaS）。然而，尽管 Serverless 的概念的势头正在建立，但是底层技术的运行成本仍然很高。这种成本已经转嫁给用户。此外，虽然 FaaS 应用的启动速度比容器快，但仍然满足不了当前对于网络性能的期望。还有提升速度的空间。\n\nWasm [改变了](https:\/\/www.fermyon.com\/blog\/serverless-reckoning) Serverless 的潜力。几乎立即的启动时间、小的二进制大小和平台和体系结构的中立性，使得 Wasm 二进制文件可以使用比运行今天的 Serverless 基础设施所需的资源少得多的资源来执行。\n\n如果全球经济正在进入一个不确定的时期，那么知道 Wasm 可以帮助我们控制成本，同时还能推进开发人员喜欢的 Serverless 函数模型，这是件好事。Wasm 的更快的启动时间和适度的资源消耗需要的计算能力比基于容器的系统少得多，并且比 Lambda 等 FaaS 系统更便宜。\n\n这种对 Wasm 可以改变 Serverless 环境的认识，促使 Fermyon 创建了 [Spin](https:\/\/developer.fermyon.com\/spin\/index)。Spin 是一个面向开发者的工具，用于引导、构建、测试和部署 Serverless 功能。Spin 的核心是其基于 Wasm 运行时。它是开源的，已经得到 [Fermyon Cloud](https:\/\/www.fermyon.com\/cloud) 和微软 Azure 的 AKS 的支持，2023 年还会有更多的支持。\n\n小、快、便宜、更好。这就是 Wasm 在 2023 年为 Serverless 世界带来的组合。\n\n## 3. Wasm 应用程序将存储在 DockerHub 和容器注册表中\n\n包管理——这是从编程语言到操作系统再到像 Kubernetes 这样的集群编排器的必要功能。每次我们发明一项新技术时，我们似乎注定要（重新）发明一个管理该技术资产的系统。\n\n早在 2022 年初，我们看到了几种管理 Wasm 对象的方法。没有一种方法流行起来。一小群工程师一直坚持把 OCI Registry（也称为 Docker Registry）作为存储 Wasm 的系统。但事实是，OCI Registry 格式不支持非容器工件。它是用来存储 Docker 镜像的。\n\n然后 OCI Registries 的一项重大变化改变了景观。OCI（[Open Container Initiative](https:\/\/thenewstack.io\/open-container-initiative-creates-a-distribution-specification-for-registries\/)）是一个小型标准机构，致力于管理围绕 OCI 容器（或我们过去所称的 Docker 容器）的标准。OCI 定义了容器格式、安全模型和运行时。它还定义了如何在注册表和客户端之间传输容器映像。\n\n在 2022 年底，OCI Registries 工作组宣布了一种官方方法来存储除容器映像之外的其他内容。这可能包括 Helm 图表、照片或（你猜到了）Wasm 应用程序。这项新功能被称为“工件存储”。\n\n当 DockerHub [宣布支持](https:\/\/www.docker.com\/blog\/announcing-docker-hub-oci-artifacts-support\/)这一新的工件存储规范时，Wasm 生态系统中传遍了信号：我们可以简单地将我们的应用程序存储在像 DockerHub 这样的 OCI 注册表中，而不是重新发明轮子。Wasm 生态系统必须进行新的工作，使这成为现实，但这项工作正在进行中。2023 年将是 Wasm 应用程序在 OCI 注册表中找到家的一年。\n\n## 4. 所有大型编程语言都将支持 Wasm\n\n语言支持是 Wasm 成功的关键因素。随着能够将 Wasm 编译成 Wasm 的新语言的出现，新的开发人员群体可以获得 Wasm 的优势。几乎所有排名前 20 的编程语言都在[添加 Wasm 支持](https:\/\/www.fermyon.com\/wasm-languages\/webassembly-language-support)。\n\n在 2022 年，我们看到 Wasm 取得了三个巨大的进步。[Python](https:\/\/pythondev.readthedocs.io\/wasm.html) 添加了支持。然后是 [Ruby](https:\/\/www.ruby-lang.org\/en\/news\/2022\/12\/06\/ruby-3-2-0-rc1-released\/)。10 月，一直支持浏览器内的 Wasm 的 .NET 增加了更深入的 Wasm 支持，使其[能够在浏览器之外运行](https:\/\/www.fermyon.com\/blog\/dotnet-wasi)。\n\n另外三种语言在今年也取得了一些进展，但 2023 年将是这些语言可以使用的一年。这三种语言是 Kotlin、Dart 和当然是世界上最流行的编程语言：JavaScript。\n\nKotlin 和 Dart 社区都一直积极参与构建 Wasm 编译目标。但是两者都在等待 Wasm 的一项标准成熟 —— 一项描述垃圾收集的标准，这是语言运行时中的一项功能，允许内存在程序执行时清理。我们的预测是 [Wasm-GC 建议书](https:\/\/github.com\/WebAssembly\/gc\/blob\/main\/proposals\/gc\/Overview.md)将在 2023 年初可用并支持，因此 Kotlin 和 Dart 将很快发布 Wasm 编译器。\n\n我们的最后一种语言非常重要，因此它值得特别预测。\n\n## 5. JavaScript 将成为最受欢迎的 Wasm 语言\n\nJavaScript 与 Wasm 的关系最为复杂。在最初的设想中，Wasm 与浏览器中的 JavaScript 交互。事实上，Wasm 最初的承诺是，它将延伸浏览器语言支持超出 JavaScript。\n\n但实际使用情况会使假设渐渐淡化。\n\n由于 Wasm 在浏览器外，许多开发人员希望能够在任何可以运行 Wasm 的地方运行他们的 JavaScript 代码。最好的方法是使 JavaScript 在 Wasm 运行时内部运行（而不是浏览器中的下方）。在 2022 年，我们看到几个新的 Wasm 项目专注于将 JS 带入新的运行时。这些项目中的大多数使用了一个叫 [QuickJS](https:\/\/bellard.org\/quickjs\/) 的优秀开源项目。\n\nQuickJS 有许多优点，其中最重要的是它完全符合最新的 JavaScript 标准。但它不是设计成最快或最强大的 JavaScript 引擎的。它非常易于嵌入，许多早期的 Wasm 项目已经找到了将解释器编译到 Wasm 并在 Wasm 运行时内部运行 JavaScript 的方法。\n\n但是有一个主流的 JavaScript 运行时正在加入竞争。Mozilla 的 [SpiderMonkey](https:\/\/spidermonkey.dev\/) 引擎以其性能和健壮性而闻名，正在进入 Wasm 世界。它最著名的用途是在 Mozilla Firefox 浏览器中使用，但也可以在浏览器外使用。作为一个可以不断优化执行的脚本的运行时，SpiderMonkey 引擎将是 Wasm 世界中最快的 JS 引擎。早期数据表明，由于在这种环境中可以进行的优化，JavaScript 在 Wasm 版本的 SpiderMonkey 中运行的速度可能[比浏览器中的 JavaScript 快 13 倍](https:\/\/bytecodealliance.org\/articles\/making-javascript-run-fast-on-webassembly)。\n\nJavaScript 是世界上最受欢迎的编程语言。随着 QuickJS 和 SpiderMonkey 等 Wasm 运行时的出现，Wasm 的潜力突然对巨大的开发人员社区开放。是的，C 是第一种支持 Wasm 的编程语言。是的，Rust 有相当大的红利。当然，我们也看到 Python 和 Ruby 在行动。但 JavaScript 将像火箭一样冲入 Wasm 宇宙。\n\n## 结论：2023 年是 Wasm 年\n\n我对 Wasm 生态系统内将发生什么做出了五个大胆的预测。随着这些里程碑的实现，Wasm 将作为浏览器以外的通用技术变得更加有用。在文章开头，我提出 2023 年有望成为 Wasm 的一年。考虑到这五个预测，很容易看出为什么：新功能、巧妙的用例、与 Docker Hub 的集成以及广泛的语言支持相结合，使得这种对开发人员友好的技术具有巨大的前途。\n\n## 关于作者\n\nMatt Butcher，他是 WebAssembly Cloud 公司 Fermyon 的联合创始人和 CEO。Matt 是 Helm、Brigade、CNAB、OAM、Glide 和 Krustlet 的原始创建者之一。他撰写和合作撰写了许多书籍，包括《学习 Helm》和《Go in Practice》。他是 \u0022Kubernetes 插图儿童指南\u0022系列的共同创造者。目前，他主要从事 WebAssembly 项目，如 Spin、Fermyon Cloud 和 Bartholomew。他拥有哲学博士学位，住在科罗拉多州。\n', '\/trans\/webassembly-5-predictions-for-2023\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">2023 年将是 Wasm 年。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/how-service-mesh-layers-microservices-security-with-traditional-security-to-move-fast-safely/">[译] 如何通过服务网格增强微服务的安全性</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2023/01/05</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://tetrate.io/blog/how-service-mesh-layers-microservices-security-with-traditional-security-to-move-fast-safely/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('如何通过服务网格增强微服务的安全性', '我们认为，服务网格最适合作为现有安全模型的一部分，通过在传统安全控制之上添加更细粒度的安全策略来实现。', '\n本文是 Tetrate 即将出版的《Istio in Production》一书中摘录的服务网格最佳实践系列的第一篇，作者是 Tetrate 创始工程师 Zack Butcher。\n\n我们接到许多实施网格的企业的问题，其中之一是“我还需要哪些控制，而网格提供哪些控制？”换句话说，他们想知道网格如何适应现有的安全模型。我们发现，网格最适合作为一组安全控制的内圈，这些控制从物理网络到应用本身的每一层都被实施。\n\n## 服务网格作为通用策略执行点\n\n我们看到网格的 Sidecar 作为通用策略执行点（[NIST SP 800-204B：使用服务网格的基于属性的访问控制](https:\/\/csrc.nist.gov\/publications\/detail\/sp\/800-204b\/final)）。由于它拦截了所有进出应用程序的流量，Sidecar 为我们提供了一个强大的位置来实现各种策略。我们可以实现传统的安全策略，如基于应用程序标识而非网络位置的更高保证的应用程序之间的授权。但我们也可以实施之前不切实际或需要与应用程序深度参与的策略。例如，网格允许你编写以下策略：“后端可以从数据库读取（使用应用级身份进行身份验证和授权），但前提是请求具有有效的最终用户凭证并具有读取范围（使用最终用户身份进行身份验证和授权）。”\n\n虽然服务网格提供了一个强大，动态和一致的安全基线，你可以在其上构建应用程序安全模型，但网格本身永远无法提供应用程序所需的 100% 运行时安全。例如，由于 Sidecar 位于用户空间中，网格在减轻许多类型的网络拒绝服务攻击方面不如传统防火墙机制。另一方面，由于同样的原因，网格在减轻许多应用级拒绝服务攻击方面比传统基础设施更有效。\n\n## 作为一个强大的中间层\n\n网格作为基础架构的强大中间层：位于物理网络和所实施的 L3\/L4 控制之上，但位于应用程序之下。这允许更脆弱和更难以改变的松散配置 —— 允许更高层的更大敏捷性 —— 因为控制体系在更高层被考虑。\n\n![图 1：增加细粒度策略层以增强传统安全。](f1.png)\n\n网格提供的主要安全功能是：\n\n- 作为 X.509 证书的**运行时身份**，用于在传输期间加密，以及服务之间通信的身份验证和授权。\n- **策略执行点**，用于在网格中的所有应用程序上实施一致的最终用户身份验证和授权。\n- 服务身份和最终用户身份的**运行时策略执行**（例如，“A 只能使用具有读取范围的有效最终用户凭证与 B 进行通信”）。\n- **速率限制和弹性功能**，用于减轻常见的应用级拒绝服务攻击，并保护免受常见的级联故障模式的影响。\n- **WAF** 和其他**深层包检测**功能，用于内部流量，而不仅仅是在边缘。\n- 来自网格中所有应用程序的**一致的操作遥测**，可用于理解、实施和审核安全策略。\n- 具有动态运行时更新的**策略即代码**（Policy-as-code）模型，独立于应用程序生命周期。\n\n## 服务网格作为分层防御的一部分\n\n考虑到网格的安全功能，我们认为，组织采用它作为分层防御方法的一部分是最合理的。\n\n![图 2：每层策略的示例以及一个示例部署拓扑。](f2.png)\n\n## L3 层的敏捷性：粗粒度的入口和出口策略以及 L7 的细粒度控制\n\n在边缘的 L3 控制（如防火墙）在粗粒度的入口和出口策略方面仍然有效，但通常会减慢应用程序开发敏捷性。由于网格提供了细粒度的服务间授权，所以可以在 L3 上设置更广泛的策略，为平台、安全和应用程序团队提供更多敏捷性。\n\n**实施对外部服务的访问控制**。网格的出口代理特别适用于实施应用程序到外部服务的控制，而只有出口代理本身被外出防火墙 allow-listed：这为平台或安全团队在管理哪些应用程序允许与企业基础架构之外的通信提供了很多敏捷性，同时保持现有的基于周界的模型。\n\n**使用加密和动态访问控制代替“可达性即授权”**。网格可以开始有效地取代 VPN 和基于 IPSec 的网络“可达性即授权”模式，提供传输中的加密，以及每个应用而不是每个主机的认证和授权。\n\n## L4 层的改进：更扁平和易于管理的网络微分段\n\n微分段之类的控制可以通过网格进一步改进：尽管我们可能允许整个（小）子网在基于分段的策略中进行通信，但我们可以使用网格按方法和动词对单独的服务间通信进行控制。\n\n**补充现有的微分段同时展平网络**。通过提供细粒度的服务间控制，网格往往会补充现有的微分段策略，同时使得组织更容易管理的较平的网络得以采用（例如，在云环境中）。\n\n**使用工作负载身份启用传输期间的加密（mTLS）和服务级别访问控制**。传输层几乎总是处理加密传输，网格通过根据 SPIFFE 规范发布和轮换短期（\u003c24 小时）工作负载身份证书来为应用程序实现此功能，从而允许传输期间的加密以及服务级别的身份验证和授权。\n\n## L7 层的增强：无处不在的边缘和访问控制\n\n**为所有流量提供边缘控制**。L7 控制，如 Web 应用程序防火墙（WAF）以及“API 网关功能”（如流量限制）几乎总是在边缘实施。网格可以通过为网格中所有流量（包括内部的“东西”通信）启用相同的功能来增强这些现有部署。\n\n**简化应用程序的访问控制**。除了使边缘控制无处不在之外，网格还可以在应用程序看到请求之前执行端用户身份验证和粗粒度授权，从而大大简化应用程序本身必须执行的访问控制。在未来，我们将看到越来越多的访问控制功能从应用程序迁移到网格中。\n\n## 总结和展望\n\n我们认为，服务网格最适合作为现有安全模型的一部分，通过在传统安全控制之上添加更细粒度的安全策略来实现。作为一个通用策略执行点，网格在更改最困难的较低层提供了更松散的策略，将敏捷性推向堆栈的顶部，其中更多的上下文允许在更高层实现更特定的控制。这种强大的安全层对于大多数组织来说都是采用分层防御深度方法的最佳选择。\n\n## 接下来：服务网格部署最佳实践\n\n我们服务网格最佳实践系列博客文章的下一篇将讨论部署拓扑。在多个集群的真实基础架构中部署服务网格时存在一些移动部分。在下一篇文章中，我们将更详细地研究：\n\n- 控制平面应如何部署在应用程序附近。 \n- 应该如何部署入口，以促进安全和敏捷性。\n- 如何使用 Envoy 促进跨集群的负载平衡。\n- 证书在网格中应该是什么样子的。\n\n---\n\n如果你不熟悉服务网格和 Kubernetes 安全性，我们在 [Tetrate Academy](https:\/\/tetr8.io\/academy) 提供了一系列免费在线课程，可以让你快速了解 Istio 和 Envoy。\n\n如果你正在寻找一种快速将 Istio 投入生产的方法，请查看 [Tetrate Istio Distribution (TID)](https:\/\/tetr8.io\/tid)。TID 是 Tetrate 的强化、完全上游的 Istio 发行版，具有经过 FIPS 验证的构建和支持。这是开始使用 Istio 的好方法，因为你知道你有一个值得信赖的发行版，有一个支持你的专家团队，并且如果需要，还可以选择快速获得 FIPS 合规性。\n\n一旦启动并运行 Istio，你可能需要更简单的方法来管理和保护你的服务，而不仅仅是 Istio 中可用的方法，这就是 Tetrate Service Bridge 的用武之地。你可以[在这里](https:\/\/tetr8.io\/tsb)详细了解 Tetrate Service Bridge 如何使服务网格更安全、更易于管理和弹性，或[联系我们进行快速演示](https:\/\/tetr8.io\/contact)。\n', '\/trans\/how-service-mesh-layers-microservices-security-with-traditional-security-to-move-fast-safely\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">我们认为，服务网格最适合作为现有安全模型的一部分，通过在传统安全控制之上添加更细粒度的安全策略来实现。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/cert-manager-spire-istio/">使用 cert-manager 和 SPIRE 管理 Istio 中的证书</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/12/27</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('使用 cert-manager 和 SPIRE 管理 Istio 中的证书', '本文介绍如何集成 SPIRE 和使用 cert-manager 实现细粒度的证书管理以及证书轮换。', '{{\u003ccallout warning\u0022注意\u0022\u003e}}\n\n从 v1.5.4 版本开始，SPIRE 移除了 Kubernetes Workload Registrar 组件，改用 SPIRE Controller Manager，详见 [spire\/spire issue #3853](https:\/\/github.com\/spiffe\/spire\/pull\/3853)。根据我的测试，本文中的程序在 v1.5.4 或更高版本上无法执行，因为会遇到一系列身份验证失败的问题。\n{{\u003c\/callout\u003e}}\n\n在[上一篇博客](\/blog\/istio-certificates-management\/)中我介绍了 Istio 中是如何管理证书的，这篇文章将指导你如何使用外置 CA，通过集成 [SPIRE](https:\/\/spiffe.io\/) 和 [cert-manager](https:\/\/cert-manager.io\/) 实现细粒度的证书管理和自动证书轮换。\n\n如果你还不了解什么是 SPIRE 以及为什么我们要使用 SPIRE，推荐你阅读以下内容：\n\n- [为什么 Istio 要使用 SPIRE 做身份认证？](\/blog\/why-istio-need-spire\/)\n- [如何在 Istio 中集成 SPIRE？](\/blog\/how-to-integrate-spire-with-istio\/)\n- [零信任的基石：使用 SPIFFE 为基础设施创建通用身份](\/book\/spiffe\/)\n\n## 证书签发管理流程简介 {#intro}\n\n下图展示了本文中使用的基于 cert-manager 和 SPIRE 的证书信任链：\n\n![基于 cert-manager、SPIRE 的证书信任链](spire-chain-tree.svg)\n\n从图中你可以看出：\n\n- cert-manager 作为根 CA 为 *istiod* 和 SPIRE 颁发证书，我们使用了[自签名 Issuer](https:\/\/cert-manager.io\/docs\/configuration\/selfsigned\/)，你还可以为其配置使用 Let\u0027s Encrypt、Vault、Venafi 等内置 Issuer，或其他外置的 Issuer；另外你也可以选择使用其他 [UpstreamAuthority](https:\/\/spiffe.io\/docs\/latest\/deploying\/spire_server\/)，例如 Vault、SPIRE 联邦等；\n- SPIRE 为 Istio 网格内工作负载和 Ingress Gateway、Egress Gateway 颁发 SVID 证书，用于服务间 mTLS；\n- 其中网格外访问 Ingress Gateway 时的使用的证书及 Egress Gateway 访问网格外服务使用的证书需要额外配置；\n\n下图展示了在 Istio 中集成 SPIRE 和 cert-manger 后的证书颁发和更新流程。\n\n![Istio 集成 SPIRE 和 cert-manager 后的证书颁发和更新流程](cert-manager-spire-istio.svg)\n\n1. SPIRE Server 中的 SPIRE Controller Manager 自动注册 Kubernetes 中的工作负载，为所有工作负载生成 SPIFFE 标准的身份；\n2. cert-manager 为 *istiod* 颁发并管理 CA 证书；\n3. 工作负载中的 Envoy 代理通过 UNIX Domain Socket（UDS）通过 SDS API 向同节点上的 SPIRE Agent 发送 CSR 请求；\n4. SPIRE Agent 向 SPIRE Server 发送 CSR；\n5. SPIRE Server 向 SPIRE Agent 返回签名后的证书；\n6. SPIRE Agent 向工作负载返回签名后的证书；\n7. SPIRE 负责工作负载的证书管理和更新；\n\n在了解了大致流程后，下面我们将依次安装各个组件。各个组件版本如下：\n\n- cert-manager v1.15.1\n- SPIRE v1.2.0\n- Istio v1.21.1\n\n## 安装 cert-manager {#install-cert-manager}\n\n运行下面的命令安装 cert-manager，我们将使用它来实现自动证书轮换：\n\n\u0060\u0060\u0060bash\nkubectl apply -f https:\/\/github.com\/cert-manager\/cert-manager\/releases\/download\/v1.15.1\/cert-manager.yaml\n\u0060\u0060\u0060\n\n根 CA 是用自签名证书，运行下面的命令配置根 CA：\n\n\u0060\u0060\u0060yaml\ncat \u003c\u003c EOF | kubectl apply -f -\n---\napiVersion: cert-manager.io\/v1\nkind: Issuer\nmetadata:\n  name: selfsigned\n  namespace: cert-manager\nspec:\n  selfSigned: {}\n---\napiVersion: cert-manager.io\/v1\nkind: Certificate\nmetadata:\n  name: selfsigned-ca\n  namespace: cert-manager\nspec:\n  isCA: true\n  duration: 21600h\n  secretName: selfsigned-ca\n  commonName: certmanager-ca\n  subject:\n    organizations:\n      - cert-manager\n  issuerRef:\n    name: selfsigned\n    kind: Issuer\n    group: cert-manager.io\n---\napiVersion: cert-manager.io\/v1\nkind: ClusterIssuer\nmetadata:\n  name: selfsigned-ca\nspec:\n  ca:\n    secretName: selfsigned-ca\nEOF\n\u0060\u0060\u0060\n\n然后为 *istiod* 配置证书：\n\n\u0060\u0060\u0060yaml\nkubectl create namespace istio-system\ncat \u003c\u003c EOF | kubectl apply -f -\n---\napiVersion: cert-manager.io\/v1\nkind: Certificate\nmetadata:\n  name: cacerts\n  namespace: istio-system\nspec:\n  secretName: cacerts\n  duration: 1440h\n  renewBefore: 360h\n  commonName: istiod.istio-system.svc\n  isCA: true\n  usages:\n    - digital signature\n    - key encipherment\n    - cert sign\n  dnsNames:\n    - istiod.istio-system.svc\n  issuerRef:\n    name: selfsigned-ca\n    kind: ClusterIssuer\n    group: cert-manager.io\nEOF\n\u0060\u0060\u0060\n\n现在我们已经安装好了 cert-manager，并创建了名为 \u0060selfsigned-ca\u0060 的 \u0060clusterIssuer\u0060，接下来，我们来安装 SPIRE 并将 cert-manager 作为 SPIRE 的  [\u0060UpstreamAuthority\u0060](https:\/\/github.com\/spiffe\/spire\/blob\/main\/doc\/plugin_server_upstreamauthority_cert_manager.md)。\n\n## 安装 SPIRE {#install-spire}\n\n运行下面的命令快速安装 SPIRE：\n\n\u0060\u0060\u0060bash\nkubectl apply -f https:\/\/jimmysong.io\/blog\/cert-manager-spire-istio\/manifests\/spire-with-cert-manager-upstream-authority-quick-start.yaml\n\u0060\u0060\u0060\n\n该 YAML 文件比起 Istio 安装包中的 [\u0060samples\/security\/spire\/spire-quickstart.yaml\u0060](https:\/\/raw.githubusercontent.com\/istio\/istio\/release-1.22\/samples\/security\/spire\/spire-quickstart.yaml) 文件增加了对 cert-manager 的适配，如：\n\n- 为 \u0060spire-server-cluster-role\u0060 ClusterRole 增加了对 \u0060cert-manager.io\u0060 API 组的权限；\n- 在 SPIRE Server 的配置中增加了 \u0060UpstreamAuthority \u0022cert-manager\u0022\u0060 配置； \n\n{{\u003ccallout note \u0022注意\u0022\u003e}}\n\nSPIRE Server 配置中的 \u0060trust_domain\u0060 应与安装 Istio 时指定的 \u0060TRUST_DOMAIN\u0060 环境变量的值保持一致。\n\n{{\u003c\/callout\u003e}}\n\n该命令中会安装 SPIRE Controller Manager，自动注册 Kubernetes 中的工作负载。所有工作负载将根据其服务账户注册 SPIFFE 标准的服务身份格式 \u0060spiffe:\/\/\u003ctrust-domain\u003e\/ns\/\u003cnamespace\u003e\/sa\/\u003cservice-account\u003e\u0060。\n\n如果你想调整 SPIRE CA 和 SVID 证书的 TTL，可以在 SPIRE Server 的配置中修改 \u0060ca_ttl\u0060（默认 24h）和 \u0060default_svid_ttl\u0060（默认 1h），详见 [SPIRE Server 配置](https:\/\/spiffe.io\/docs\/latest\/deploying\/spire_server\/)。\n\n## 安装 Istio {#install-istio}\n\nPod 中的 Envoy 代理将共享本地 SPIRE Agent 的 Unix Domain Socket，通过 Workload API 与 SPIRE Server 通信获取证书，如下图所示。\n\n![SPIRE Agent 架构图](spire-agent.svg)\n\n运行下面的命令安装 Istio 并启用 CA 证书自动轮换：\n\n\u0060\u0060\u0060yaml\nistioctl install --skip-confirmation -f - \u003c\u003cEOF\napiVersion: install.istio.io\/v1alpha1\nkind: IstioOperator\nmetadata:\n  namespace: istio-system\nspec:\n  profile: default\n  meshConfig:\n    # 信任域应与 SPIRE Server 中配置的信任域相同\n    trustDomain: example.org\n  values:\n    global:\n    # 自定义 sidecar 模板\n    sidecarInjectorWebhook:\n      templates:\n        spire: |\n          spec:\n            containers:\n            - name: istio-proxy\n              volumeMounts:\n              - name: workload-socket\n                mountPath: \/run\/secrets\/workload-spiffe-uds\n                readOnly: true\n            volumes:\n              - name: workload-socket\n                csi:\n                  driver: \u0022csi.spiffe.io\u0022\n                  readOnly: true\n  components:\n    pilot:\n      k8s:\n        env:\n          # 如果启用，如果用户引入新的中间插件 CA，用户不需要重新启动 istiod 来获取证书。Istiod 会获取新添加的中间插件 CA 的证书并更新它。不支持插入新的 Root-CA。\n          - name: AUTO_RELOAD_PLUGIN_CERTS\n            value: \u0022true\u0022 \n    ingressGateways:\n      - name: istio-ingressgateway\n        enabled: true\n        label:\n          istio: ingressgateway\n        k8s:\n          overlays:\n            - apiVersion: apps\/v1\n              kind: Deployment\n              name: istio-ingressgateway\n              patches:\n                - path: spec.template.spec.volumes.[name:workload-socket]\n                  value:\n                    name: workload-socket\n                    csi:\n                      driver: \u0022csi.spiffe.io\u0022\n                      readOnly: true\n                - path: spec.template.spec.containers.[name:istio-proxy].volumeMounts.[name:workload-socket]\n                  value:\n                    name: workload-socket\n                    mountPath: \u0022\/run\/secrets\/workload-spiffe-uds\u0022\n                    readOnly: true\nEOF\n\u0060\u0060\u0060\n\n因为我们要使用 Istio Operator 中声明的 \u0060spire\u0060 模板来部署工作负载，因此我们运行下面的命令部署 Bookinfo 应用：\n\n\u0060\u0060\u0060bash\nistioctl kube-inject -f bookinfo-with-spire-template.yaml | kubectl apply -n default -f -\n\u0060\u0060\u0060\n\n**注意**：上面命令中使用的 \u0060bookinfo-with-spire-template.yaml\u0060 文件可以在[这里](.\/manifests\/bookinfo-with-spire-template.yaml)找到，与 Istio 安装包中的 [\u0060samples\/bookinfo\/platform\/kube\/bookinfo.yaml\u0060](https:\/\/github.com\/istio\/istio\/blob\/master\/samples\/bookinfo\/platform\/kube\/bookinfo.yaml) 文件唯一的区别就是每个 Deployment 的 template 中都增加了以下注解：\n\n\u0060\u0060\u0060yaml\nannotations:\n  inject.istio.io\/templates: \u0022sidecar,spire\u0022\n\u0060\u0060\u0060\n\n## 验证 SPIRE {#validate-spire}\n\n我们将通过检查 productpage 服务的身份和证书配置来验证 SPIRE 是否生效。\n\n使用下面的命令可以检查 SPIRE 是否给工作负载颁发了身份证明：\n\n\u0060\u0060\u0060bash\nkubectl exec -i -t spire-server-0 -n spire -c spire-server -- \/bin\/sh -c \u0022bin\/spire-server entry show -socketPath \/run\/spire\/sockets\/server.sock -spiffeID spiffe:\/\/example.org\/ns\/default\/sa\/bookinfo-productpage\u0022\n\u0060\u0060\u0060\n\n你可以在输出结果中看到 protuctpage 服务的身份信息：\n\n\u0060\u0060\u0060\nFound 1 entry\nEntry ID         : 69fbf896-a296-4c3c-8179-44bf4e49e474\nSPIFFE ID        : spiffe:\/\/example.org\/ns\/default\/sa\/bookinfo-productpage\nParent ID        : spiffe:\/\/example.org\/k8s-workload-registrar\/demo-cluster\/node\/gke-cluster-1-default-pool-18d66649-z1lm\nRevision         : 1\nTTL              : default\nSelector         : k8s:node-name:gke-cluster-1-default-pool-18d66649-z1lm\nSelector         : k8s:ns:default\nSelector         : k8s:pod-uid:73347537-a3e5-4e43-b8c5-bd315c7385b7\nDNS name         : productpage-v1-7f444fc4dd-rq47m\nDNS name         : productpage.default.svc\n\u0060\u0060\u0060\n\n查看 \u0060productpage\u0060 pod 的证书信任链：\n\n\u0060\u0060\u0060bash\nistioctl -n default proxy-config secret deployment\/productpage-v1 -o json | jq -r \\\n\u0027.dynamicActiveSecrets[0].secret.tlsCertificate.certificateChain.inlineBytes\u0027 | base64 --decode \u003e chain.pem\n\u0060\u0060\u0060\n\n查看根证书：\n\n\u0060\u0060\u0060bash\nistioctl -n default proxy-config secret deployment\/productpage-v1 -o json | jq -r \\\n\u0027.dynamicActiveSecrets[1].secret.validationContext.trustedCa.inlineBytes\u0027 | base64 --decode \u003e root.pem\n\u0060\u0060\u0060\n\n\u0060chain.pem\u0060 文件是证书信任链，其中包含两个证书，将它们保存到两个文件中：\n\n\u0060\u0060\u0060bash\nsplit -p \u0022-----BEGIN CERTIFICATE-----\u0022 chain.pem cert-\n\u0060\u0060\u0060\n\n后使用 OpenSSL 查看所有证书：\n\n\u0060\u0060\u0060\nopenssl x509 -noout -text -in cert-aa\nopenssl x509 -noout -text -in cert-ab\nopenssl x509 -noout -text -in root.pem\n\u0060\u0060\u0060\n\n你将看到如下的证书信任链 \u0060root.pem\u0060 -\u003e \u0060cert-aa\u0060  -\u003e \u0060cert-ab\u0060，如下图所示：\n\n![Productpage 服务的证书信任链](spire-bookinfo-cert-chain.svg)\n\n查看 Istiod 的证书：\n\n\u0060\u0060\u0060bash\nistioctl -n istio-system proxy-config secret deployment\/istiod -o json | jq -r \\\n\u0027.dynamicActiveSecrets[0].secret.tlsCertificate.certificateChain.inlineBytes\u0027 | base64 --decode \u003e chain.pem\n\u0060\u0060\u0060\n\n从证书信任链中我们可以看到：\n\n- cert-manager 做为 PKI 的根节点为 *istiod* 颁发证书；\n- SPIRE 作为中间 CA 再为各个工作负载颁发证书；\n- Istio 网格中工作负载的 X509 v3 主体别名中的 URI 遵循了 SPIFF 身份规范；\n- Istio 服务网格中的所有工作负载的身份和证书都由 SPIRE 来管理；\n\n## 设置证书自动轮换 {#cert-auto-rotate}\n\n如果你要修改 *istiod* 证书的轮换周期，从 60 天（1440 小时）缩短到 30 天（720 小时），运行下面的命令：\n\n\u0060\u0060\u0060yaml\ncat \u003c\u003c EOF | kubectl apply -f -\n---\napiVersion: cert-manager.io\/v1\nkind: Certificate\nmetadata:\n  name: cacerts\n  namespace: istio-system\nspec:\n  secretName: cacerts\n  duration: 720h \n  renewBefore: 360h\n  commonName: istiod.istio-system.svc\n  isCA: true\n  usages:\n    - digital signature\n    - key encipherment\n    - cert sign\n  dnsNames:\n    - istiod.istio-system.svc\n  issuerRef:\n    name: selfsigned-ca\n    kind: ClusterIssuer\n    group: cert-manager.io\nEOF\n\u0060\u0060\u0060\n\n运行下面的命令查看 *istiod* 的日志：\n\n\u0060\u0060\u0060bash\nkubectl logs -l app=istiod -n istio-system -f\n\u0060\u0060\u0060\n\n过两分钟后，你将看到类似如下的证书更改记录：\n\n\u0060\u0060\u0060\n2022-12-23T03:48:42.697360Z\tinfo\tUpdate Istiod cacerts\n2022-12-23T03:48:42.697503Z\tinfo\tUsing kubernetes.io\/tls secret type for signing ca files\n2022-12-23T03:48:42.778241Z\tinfo\tIstiod has detected the newly added intermediate CA and updated its key and certs accordingly\n2022-12-23T03:48:42.779459Z\tinfo\tx509 cert - Issuer: \u0022CN=istiod.istio-system.svc\u0022, Subject: \u0022\u0022, SN: d7acac2301045f741e5e30cff380deaf, NotBefore: \u00222022-12-23T03:46:42Z\u0022, NotAfter: \u00222032-12-20T03:48:42Z\u0022\n2022-12-23T03:48:42.779561Z\tinfo\tx509 cert - Issuer: \u0022CN=certmanager-ca,O=cert-manager\u0022, Subject: \u0022CN=istiod.istio-system.svc\u0022, SN: 164bf045670a1716ed3f0f1c89b56122, NotBefore: \u00222022-12-23T03:48:14Z\u0022, NotAfter: \u00222023-01-22T03:48:14Z\u0022\n2022-12-23T03:48:42.779642Z\tinfo\tx509 cert - Issuer: \u0022CN=certmanager-ca,O=cert-manager\u0022, Subject: \u0022CN=certmanager-ca,O=cert-manager\u0022, SN: 8533dbfe0b84ed1fc4e3c76be7ef612f, NotBefore: \u00222022-12-20T07:50:12Z\u0022, NotAfter: \u00222025-06-07T07:50:12Z\u0022\n2022-12-23T03:48:42.779657Z\tinfo\tIstiod certificates are reloaded\n\u0060\u0060\u0060\n\n要修改工作负载证书的自动轮换周期，你可以设置 \u0060pilot-agent\u0060 命令的环境变量 \u0060SECRET_TTL\u0060，默认值为 \u006024h0m0s\u0060。\n\n## 总结 {#summary}\n\n在本文中，我们使用了 cert-manager 作为 PKI，将 SPIRE 集成到我们的证书信任链中，并为 Istio 网格中的工作负载创建身份和证书。通过使用 cert-manager，你不用担心 *istiod* 证书过期的问题，还可以根据需要更新证书。你还可以根据需要将 cert-manager 集成到其他证书供应商，如 [Let\u0027s Encrypt](https:\/\/letsencrypt.org\/)、[HashiCorp Vault](https:\/\/www.vaultproject.io\/)、[Venafi](https:\/\/www.venafi.com\/) 等。你也可以使用 [istio-csr](https:\/\/github.com\/cert-manager\/istio-csr) 直接让 cert-manager 来管理 Istio 中的证书，或[使用 Vault 来存储证书](https:\/\/cloudnative.to\/blog\/how-to-use-hashicorp-vault-as-a-more-secure-way-to-store-istio-certificates\/)。\n\n## 参考 {#reference}\n\n- [将 Istio 纳入信任链：使用现有 PKI 作为信任根 - cloudnative.to](https:\/\/cloudnative.to\/blog\/istio-trust\/)\n- [在生产中大规模自动化 Istio CA 轮换 - cloudnative.to](https:\/\/cloudnative.to\/blog\/automate-istio-ca-rotation-in-production-at-scale\/)\n- [如何使用 Hashicorp Vault 作为一种更安全的方式来存储 Istio 证书 - cloudnative.to](https:\/\/cloudnative.to\/blog\/how-to-use-hashicorp-vault-as-a-more-secure-way-to-store-istio-certificates\/)\n- [如何在 Istio 中集成 SPIRE - cloudnative.to](https:\/\/cloudnative.to\/blog\/istio-spire-integration\/)\n- [SPIRE Server Configuration Reference - spiffe.io](https:\/\/spiffe.io\/docs\/latest\/deploying\/spire_server\/#built-in-plugins)\n- [Server plugin: UpstreamAuthority \u0022cert-manager\u0022 - github.com](https:\/\/github.com\/spiffe\/spire\/blob\/v1.5.3\/doc\/plugin_server_upstreamauthority_cert_manager.md)\n- [Configuring SPIRE - spiffe.io](https:\/\/spiffe.io\/docs\/latest\/deploying\/configuring\/)\n', '\/blog\/cert-manager-spire-istio\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文介绍如何集成 SPIRE 和使用 cert-manager 实现细粒度的证书管理以及证书轮换。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/istio-trust/">[译] 将 Istio 纳入信任链：使用现有 PKI 作为信任根</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/12/20</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://tetrate.io/blog/istio-trust/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('将 Istio 纳入信任链：使用现有 PKI 作为信任根', '本文讲解了如何让 Istio 信任现有 PKI 的步骤。', '\n当我们与想要使用 Istio 的客户或用户交流时，这一个问题时长会出现——Istio 中的证书信任如何工作的？Istio 有自己的证书颁发机构，而我们也有自己的证书颁发机构，如何确保它们相互信任？ \n\n简而言之，通过中间签名证书将 Istio 纳入到您现有的信任链中。 \n\n如果您使用 Istio 作为演示或开箱即用，它将拥有自己的自签名证书 —— 它是自己的根证书。对于在多个集群中运行 Istio 的用户来说，这是一个常见的痛点：他们无意中创建了两个互不不信任的孤岛，因此没有安全通信。\n\n以下是如何通过让 Istio 信任您现有的 PKI 的步骤。\n\n## 简述\n\n这是简短的版本：您应该通过为每个 Istio 部署创建一个中间签名证书来让 Istio 信任您现有的 PKI（并且每个集群应该有一个 Istio 部署）。然后你会：\n\n1. 启用跨 Istio 部署的通信\n2. 允许细粒度的证书撤销，而无需同时在整个基础架构中强制使用新证书（如果这听起来像是等待发生的重大中断，那么您是对的）。 \n3. 启用签名证书的轻松轮换。您需要做的就是创建一个新的中间件并使用新证书重新启动 Istio。因为它在同一个信任根中，所以一切都继续工作。 \n\nIstio 必须适应您现有的架构，以在组织内实现增量采用 —— 使网格适应您的组织，而不是让组织来适应网格。从了解对中间证书签名密钥的需求开始，将为您的成功做好准备，并使任何基础架构或环境更改更加顺利。\n\n## 详述\n\n我们先来了解一下证书验证的过程。在基本证书中，证书检查从信任根开始，向下延伸到特定身份（叶子）。证书路径验证算法是我们确保证书可信的方式。当我们使用 TLS 等安全协议连接到另一台机器时，服务器会向我们提供部分或全部证书链以证明其身份。如果链中的证书被确定为无效，则证书链将被拒绝且不会建立信任。如果我们顺利到达链的末端，则路径（以及证书）是有效的。成功！我们可以信任服务器！\n\n![带有叶证书、中间证书和根证书的证书链。服务器可以选择发送整个链，或者只发送一部分；只要有足够的链从根到叶，我们就可以验证证书。](f1.jpg)\n\n当 TLS 握手时，路径验证算法不关心有多少证书链驻留在我们的信任包中。基于我们带来的和他们提供的证书，它只关心我们能否构建一条从服务器的叶节点到我们的捆绑包中的信任根的链。上面的示例显示验证发生在证书交换中，这足以让叶子在证书颁发机构中找到它的位置。 \n\n当您在生产环境中运行 Istio 时，您将拥有多个叶节点和中间节点，但**只有一个根节点。**\n\n![具有根、三个中间签名 CA 和四个叶证书（由树中的各种中间体颁发）的 PKI 证书树。](f2.jpg)\n\n这就是为什么要在现有 PKI 中建立信任，因为有以下三个主要好处：\n\n1. 可以在 Istio 部署之间的交叉通信\n2. 细粒度证书撤销\n3. 轻松轮换证书\n\n### 跨 Istio 部署的通信\n\n对于 Istio，有两种方法可以确保跨部署的通信 —— 简单的方法和困难的方法。 \n\n困难的方法涉及 Istio 运维人员采取耗时、复杂且昂贵的步骤来确保两个根同时在另一个的证书颁发机构 (CA) 捆绑包中。\n\n![我们可以通过确保所有参与方的根都在 CA 捆绑包中来确保跨不同根的信任。如果它们不是彼此信任包的一部分，则来自每个 Citadel 的证书不能用于跨集群通信。](f3.jpg)\n\n简单的方法是为每个部署使用单独的中间签名证书部署 Istio，所有这些证书都共享相同的根。\n\n![当 Citadel 使用来自同一根 PKI 的中间证书时，最容易促进跨集群通信。我们看到与上面相同的 PKI 树，但中间 CA 被标记为不同集群中的 Citadel 实例。](f4.jpg)\n\n当涉及到细粒度撤销和证书轮换时，这一决定的连锁反应是巨大的。\n\n### 细粒度证书撤销\n\n撤销证书会将证书标记为不再受信任。当证书路径验证算法从叶节点走到根节点时，会对每个证书进行吊销状态检查。这使您能够撤销对单个组件或整个部署部分的信任。\n\n![使用与之前相同的 PKI 树，我们展示了在树的一部分中撤销中间 CA 如何使该中间证书以及由它创建的叶证书无效。](f5.jpg)\n\n这很重要，因为如果签名密钥被泄露，恶意行为者可能会通过出示您的客户认为是有效证书来冒充您的服务器。这在 Istio 中更为重要，因为我们使用证书来识别彼此的工作负载 —— 攻击者可以伪装成您网格中的任何服务！ \n\n通常，处理撤销是管理任何 PKI 中最困难的部分。Istio 帮助降低这种风险的方法之一是颁发非常短暂的证书。典型的吊销列表最多可能需要 24 小时才能在整个组织中传播。Istio 颁发的证书有效期少于 12 小时，因此几乎不需要撤销 Istio 颁发的身份证书。您只需要担心为每个 Istio 部署创建的签名证书。\n\n### 轻松轮换证书\n\n与吊销一样，中间证书的轮换更容易。优点包括，如果您能够按集群轮换证书而不是在根节点轮换证书，您将体验到更少的停机时间（以及相关的复杂性，即在任何地方发布一个带有新根的更新的 CA 包）。而且，就像任何好的 PKI 一样，这可以让您使根离线并安全地存储起来。\n\n## 总结\n\n用简单的方法来做！将 Istio 引入您现有的信任根中，以避免痛苦和心痛。中间签名证书的存在是为了让采用 Istio 更容易、更安全。\n', '\/trans\/istio-trust\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文讲解了如何让 Istio 信任现有 PKI 的步骤。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-certificates-management/">Istio 中的证书管理方式介绍</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/12/20</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio 中的证书管理方式介绍', '本文介绍了数字证书和 Istio 中的证书管理方式。', '\n我在[如何理解 Istio 中的 mTLS 流量加密](\/blog\/understanding-the-tls-encryption-in-istio\/)这篇文章中提出流量加密的关键是证书管理。我们可以使用 Istio 中内置了 CA（证书授权机构）也可以使用自定义 CA 来管理网格内的证书。这篇博客将为你讲解 Istio 是如何进行证书管理的。\n\n## 什么是证书？ {#certificates-introduction}\n\n在介绍 Istio 的证书管理方式之前，我们先来了解一下什么是证书。若你已了解证书的作用及原理，请直接跳到 Istio 中的证书管理部分。\n\n证书（Certificate），又称电子证书，是用于身份认证和加密通信的一种数字证明文件。在了解 Istio 的证书管理之前，我们先来了解一下什么是证书。如果你已经了解了证书，可以跳过这一节。\n\n证书有很多类别，本文中的证书特指的是 [X.509 V3 证书](https:\/\/datatracker.ietf.org\/doc\/html\/rfc5280)。X509 证书是一种常见的数字证书格式，用于在计算机网络中识别实体的身份。X509 是公钥基础设施（PKI）的国际标准，主要用于身份认证和信息加密，例如 TLS。X.509 证书中包含了个人、组织或计算机的身份信息和公钥。V3 是它的最新版本。它主要用于在客户端和服务器之间进行安全通信，例如在通过 HTTPS 访问网站时。x509 证书通常由 CA 颁发，该 CA 会验证实体的身份，并将这些信息编码到证书中。当客户端连接到服务器时，服务器会向客户端提供其 x509 证书，客户端会验证证书的有效性，并通过该证书来识别服务器的身份。通过这种方式，双方可以安全地进行通信，并确保数据传输的完整性和保密性。\n\n### 哈希函数 {#hash}\n\n谈到证书就不得不提哈希（Hash）函数，因为证书的内容会使用哈希函数进行哈希处理，然后用证书颁发者的私钥进行签名。这样，当收到一份证书时，接收者就可以使用证书颁发者的公钥来验证证书的合法性。\n\n哈希函数是一种将任意长度的输入（也称为消息）映射为固定长度的输出的函数。这个输出也称为哈希值或消息摘要。\n\n哈希函数有许多用途，其中一个重要的用途是密码存储。当用户在系统中设置密码时，通常不会将真实的密码直接存储在系统中。相反，会将密码进行哈希处理，并将哈希值存储在系统中。当用户登录时，系统会将用户输入的密码进行哈希处理，然后与存储的哈希值进行比较。如果两者相同，则证明用户输入的密码正确，反之则错误。\n\n哈希函数有很多种类型，例如 MD5、SHA-1 等。这些函数都有一些共同的特点，比如输出固定长度、不可逆、散列冲突少等。\n\n哈希函数的安全性与其输出的长度有关。一般来说，输出长度越长，哈希函数就越安全。但是，输出长度越长，哈希处理的时间就越长，因此要在安全性和效率之间进行平衡。\n\n### 证书的作用 {#cert-works}\n\n证书的用途广泛，凡是需要加密、认证、授权的场景都会用到它，比如：\n\n- 在 Kubernetes 中你需要给各个组件配置证书，你可以选择[手动生成证书](https:\/\/kubernetes.io\/zh-cn\/docs\/tasks\/administer-cluster\/certificates\/)；\n- Istio 中为实现自动 mTLS 给各个工作负载颁发的证书；\n- 访问 HTTPS 网站所用到的证书等；\n\n证书就像是由权威机构印发的名片，供使用者表明其身份，同时还可以为信息加密，保证通信的安全性和完整性。下图展示的是 TLS 通信的大概步骤，其中证书承担了证明服务器身份和加密通信的职责。\n\n下面以一个网站的 HTTP 链接为例，颁发数字证书、验证和加密通信的过程如下图所示。\n\n![TLS 证书颁发和校验过程](tls.svg)\n\n详细步骤如下：\n\n1. 服务器（网站所有者）向 CA 提交证书签名请求；\n2. CA  验证服务器的身份和网站的真实性后为服务器颁发数字证书，服务器安装该证书，以便访问者能够验证网站的安全性；\n3. 用户通过浏览器（客户端）向网站发送请求；\n4. 服务器向客户端返回 TLS 证书；\n5. 客户端向 CA 验证证书的有效性，若有效则建立连接，若无效则提示用户拒绝连接；\n6. 客户端生成一对随机的公钥和私钥；\n7. 客户端将并将自己的公钥发送给服务端；\n8. 服务端使用客户端的公钥加密消息；\n9. 服务端将加密后的数据发送给客户端；\n10. 客户端使用自己的私钥解密服务端发送的数据；\n\n至此，双方建立了一个安全的通道，并可以通过该通道进行双向加密的数据传输。\n\n### 如何生成证书？{#how-to-generate-certificates}\n\n你可以通过以下开源工具生成 X.509 证书：\n\n- [Easy-RSA](https:\/\/github.com\/OpenVPN\/easy-rsa)：一个简单地命令行工具，由 OpenVPN 项目组维护，使用 EasyRSA 可以轻松地为 OpenVPN 网络生成安全的证书和密钥；\n- [OpenSSL](https:\/\/github.com\/openssl\/openssl)：由个人发起于 1995 年，现由独立组织维护，只提供命令行工具；\n- [CFSSL](https:\/\/github.com\/cloudflare\/cfssl)：由 CloudFlare 开发和维护，不仅仅是一个用于生成证书的命令行工具，还可以作为 PKI 服务器；\n- [BoringSSL](https:\/\/github.com\/google\/boringssl)：Google 开发和维护的 OpenSSL 分支，已用于 Chrome 浏览器和安卓操作系统；\n\n因为可能大多数人都对 OpenSSL 比较熟悉，所以下文中我们将使用 OpenSSL 来创建证书。\n\n### 证书的组成 {#cert-component}\n\n下面以 X.509 V3 证书为例，讲解数字证书的组成。下面是该证书的一个示例：\n\n\u0060\u0060\u0060\nCertificate:\n    Data:\n        Version: 3 (0x2)\n        Serial Number:\n            fc:c6:18:2e:20:bd:27:b5:6b:60:bc:47:23:6b:8b:d9\n    Signature Algorithm: sha256WithRSAEncryption\n        Issuer: O=cluster.local\n        Validity\n            Not Before: Dec 15 07:25:32 2022 GMT\n            Not After : Dec 16 07:27:32 2022 GMT\n        Subject:\n        Subject Public Key Info:\n            Public Key Algorithm: rsaEncryption\n                RSA Public-Key: (2048 bit)\n                Modulus:\n                    00:eb:40:16:87:6c:17:5a:9c:b2:91:00:94:d1:31:\n                    37:bb:d7:1e:e6:06:1c:a1:c1:35:64:54:82:54:af:\n                    b8:4b:40:6f:e0:73:86:4e:c1:c6:75:b8:c8:30:ac:\n                    69:16:e8:68:25:cb:dd:e8:53:55:ec:7a:bd:a9:d3:\n                    42:44:7f:e5:f5:52:dd:99:ae:c2:1a:a2:06:1f:be:\n                    1b:e6:3e:69:87:a3:fc:91:21:39:b0:a7:67:11:f2:\n                    3c:55:c6:4b:04:15:1b:ff:49:14:88:c4:58:87:79:\n                    96:5b:6e:00:1c:c1:e7:2c:53:0c:d1:77:dc:a8:82:\n                    cc:fa:26:c1:bb:6c:df:a8:43:0c:b7:cc:f0:a2:11:\n                    9b:e8:3f:8a:1d:ed:2a:ff:1f:d1:03:eb:8a:b9:98:\n                    40:18:83:24:4f:14:95:a3:59:ef:67:0f:35:6d:ae:\n                    91:81:b2:04:02:16:80:d1:39:bd:70:cf:0f:cb:9a:\n                    81:39:d9:fe:52:a5:cf:79:4f:a3:69:d8:0d:39:6a:\n                    48:24:8d:2b:88:04:fa:81:de:65:50:7d:1a:3d:cd:\n                    f3:1c:42:63:29:75:a0:9b:8e:16:44:3a:89:d6:2b:\n                    41:76:65:a5:2e:c8:b6:d2:89:42:5d:21:24:33:30:\n                    f0:9d:0b:4d:cf:78:d5:45:2d:49:5a:55:50:98:93:\n                    03:f5\n                Exponent: 65537 (0x10001)\n        X509v3 extensions:\n            X509v3 Key Usage: critical\n                Digital Signature, Key Encipherment\n            X509v3 Extended Key Usage:\n                TLS Web Server Authentication, TLS Web Client Authentication\n            X509v3 Basic Constraints: critical\n                CA:FALSE\n            X509v3 Authority Key Identifier:\n                keyid:BA:31:8A:9C:ED:EB:49:D2:54:09:98:D9:4C:3A:9C:42:D0:64:8D:B2\n\n            X509v3 Subject Alternative Name: critical\n                URI:spiffe:\/\/cluster.local\/ns\/default\/sa\/httpbin\n    Signature Algorithm: sha256WithRSAEncryption\n         90:7f:cb:6f:0b:16:cb:59:7d:f4:87:a7:5a:38:fa:0a:16:d8:\n         83:0d:b1:36:77:a2:4a:fe:38:52:ab:49:e9:89:50:1a:4c:e9:\n         94:07:37:7f:27:bc:2c:ce:c1:d2:33:75:5d:b6:ab:ae:cb:2e:\n         71:f4:22:c0:40:15:27:02:75:c1:32:2e:83:49:73:6c:9a:ea:\n         04:ef:55:2d:8d:71:30:9b:e4:30:dd:95:20:0d:7c:d2:f4:30:\n         2f:07:2e:9f:53:37:e6:3d:14:c7:41:f4:09:8b:a3:76:56:c7:\n         c7:92:0f:fc:17:5a:5a:32:6c:9e:87:18:2e:51:75:54:68:d8:\n         01:c1:07:cc:b0:35:bf:0b:6c:62:a6:5b:23:61:35:c8:4f:7f:\n         e7:1f:a0:e9:11:44:a6:17:52:4d:00:40:21:de:63:ee:02:c8:\n         2b:5d:a1:7a:5d:7f:d5:d3:c1:7d:5f:00:40:e8:80:8d:cc:e9:\n         8a:c6:b4:98:fe:7a:7d:37:0c:6f:4c:31:91:7a:79:30:84:cd:\n         01:a7:14:f6:1b:33:8f:0f:50:1c:36:38:6b:24:da:cf:49:8a:\n         5b:28:cf:27:76:e1:a5:c7:e6:d5:6e:d8:36:85:aa:1f:a5:ac:\n         fa:f1:2e:a2:36:2e:25:b0:71:24:d1:3e:d5:e5:19:2b:0b:6f:\n         b7:17:e4:75\n\u0060\u0060\u0060\n\n证书中各个字段的含义如下：\n\n- 证书版本（Version）：表示证书的版本号。\n- 序列号（Serial Number）：表示证书的唯一序列号。\n- 签名算法（Signature Algorithm）：表示证书的签名算法，例如 RSA、DSA 或 ECDSA 等。\n- 证书颁发机构（Issuer）：表示颁发该证书的可信的第三方机构的名称。\n- 有效期（Validity）：表示证书的有效期，包括证书生效日期（Not Before）和证书失效日期（Not After）。\n- 使用者（Subject）：表示证书所有者的名称。\n- 公钥信息（Subject Public Key Info）：表示证书所有者的公钥以及公钥的算法。\n- 扩展（Extensions）：表示证书的扩展信息，包括：\n  - 密钥用法扩展（Key Usage Extension）：表示证书所有者的密钥可用于哪些操作，例如数字签名、密钥加密等。\n  - 扩展密钥用法扩展（Extended Key Usage Extension）：表示证书所有者的密钥可用于哪些扩展的操作，例如 TLS Web Server Authentication、TLS Web Client Authentication 等。\n  - 基本约束扩展（Basic Constraints Extension）：表示证书所有者是否是证书颁发机构的下级机构，以及是否允许其作为证书颁发机构颁发其他证书。\n  - 主体密钥表示扩展（Authority Key Identifier）：包含一个或多个唯一的标识符，用于表示证书颁发机构的密钥。这些标识符可以是证书颁发机构的公钥哈希值，也可以是证书颁发机构的证书序列号。该扩展用于验证证书的合法性，例如在验证证书链时，用于验证证书颁发机构是否为可信的机构。这个扩展字段是可选的，但在许多情况下都会被使用。\n  - 主体替代名称扩展（Subject Alternative Name Extension）：表示证书所有者的其他名称，例如域名、IP 地址、电子邮件地址等。\n\n### 证书信任链 {#certificate-trust-chain}\n\n证书的验证需要通过证书信任链（Certificate Trust Chain）。证书信任链是指用于身份验证的一系列证书，它们形成一条从一个可信任的根证书颁发机构开始，逐级向下连接，直到用于验证某个特定证书的中间证书或终端证书的一种方式。证书信任链允许数字证书的可信度随着证书级别的升高而提高。\n\n在下面的证书信任链示意图中，你可以看到四条信任链。\n\n![证书信任链](certificate-trust-chain.svg)\n\n证书的信任链是一个树形结构，每个 CA 都可以有一或多个子 CA，一共有三种角色：\n\n- 根 CA：最顶层的 CA，可以颁发证书给中间 CA；\n- 中间 CA：除根 CA 以外的 CA，可颁发终端证书；\n- 终端实体：拥有终端证书的设备或服务；\n\n根 CA 是数字证书的最顶级颁发机构，因此它所颁发的证书是最可信的。根证书颁发机构通常由政府机构或其他权威机构（如国际基础设施安全组织）经营和监管。常见的根 CA 包括：\n\n- Symantec\/VeriSign\n- Comodo\n- DigiCert\n- GlobalSign\n- GoDaddy\n- Entrust\n- GeoTrust\n- RapidSSL\n- Baltimore CyberTrust Root\n\n请注意，上述列表只是一个样例，实际上有许多其他根 CA。\n\n在 Chrome 浏览器中打开一个 HTTPS 网页，你可以通过点击地址栏左侧的锁图标查看证书信息，其中包括证书信任链，例如 [https:\/\/tetrate.io](https:\/\/tetrate.io) 的证书信任链如下图：\n\n![Tetrate.io 的证书信任链](tetrate-cert.jpg)\n\n证书信任链允许客户端（例如，Web 浏览器）在验证终端证书时，逐级向上验证每个证书，以确定它是否可信。数字证书签发的原理是 CA 将证书拥有者的公钥与身份信息绑定在一起，然后 CA 使用其专有的私钥生成正式的数字签名，用以表示这个证书是经 CA 签发的。在证书校验时使用 CA 的公钥对这个证书上的数字签字进行验证即可。\n\n## 将 Istio 纳入 PKI 证书信任链 {#istio-pki}\n\n在使用 Istio 之前，企业通常有自己的内部 PKI（公钥基础设施），那么如何将 Istio 纳入到 PKI 的证书信任链中呢？\n\n我们知道 Istio 内置了证书管理功能，可以开箱即用，Istio 启动时会为 *istiod* 创建自签名证书，作为网格内所有工作负载的根证书。这样做有个问题，如果你有多网格，内置的根证书无法做到网格间互信。正确的做法是不使用 Istio 自签名证书，而是将 Istio 纳入到你的证书信任链中，将 Istio 集成到你的 PKI，为 PKI 每个网格创建一个中间证书，这样两个网格拥有了共同的信任根，就可以做到网格间互信。\n\n通过为 Istio 网格创建中间 CA 使其纳入到企业内部 PKI 证书信任链中，如下图所示。\n\n![为多网格创建中间 CA 使得 Istio 纳入到企业内部 PKI 证书信任链](cluster-ca.svg)\n\n将 Istio 纳入企业内部 PKI 证书信任链后有诸多好处：\n\n- 可以实现跨网格\/集群之间的通信：有了共同的信任根，集群之间就可以互相验证身份，进而实现跨集群通信；\n- 更细粒度的证书撤销：你可以撤销某个实体或中间 CA 的证书来撤销某个服务或集群的证书；\n- 轻松实现证书轮换：你可以按集群\/网格实现证书轮换，而不是轮换根节点证书，这样会减少停机时间，推荐您使用 [cert-manager](https:\/\/github.com\/cert-manager\/cert-manager) 来实现自动化的大规模 CA 证书轮换，详情请参考[在生产中大规模自动化 Istio CA 轮换](https:\/\/cloudnative.to\/blog\/automate-istio-ca-rotation-in-production-at-scale\/)；\n\n关于将 Istio 纳入企业内部 PKI 的证书信任链的详细说明请参考[这篇博客](https:\/\/cloudnative.to\/blog\/istio-trust\/)。\n\n## Istio 中使用自定义 CA 的步骤 {#istio-custom-ca}\n\n默认情况下，Istio CA 会生成一个自签名的根证书和密钥，并使用它们来签署工作负载证书。为了保护根 CA 密钥，你应该使用在安全机器上离线运行的根 CA，并使用根 CA 向运行在每个集群上的 Istio CA 签发中间证书。Istio CA 可以使用管理员指定的证书和密钥来签署工作负载证书，并将管理员指定的根证书作为信任根分配给工作负载。\n\n下图展示了 Istio 中的证书签发和挂载过程。\n\n![Istio 中的证书签发和挂载过程](cert-process.svg)\n\n1. Istio 向 Pod 中注入的 Envoy 代理中有两个进程——\u0060envoy\u0060 和 \u0060pilot-agent\u0060。\u0060pilot-agent\u0060 为 Envoy 生成私钥，通过 UNIX Domain Socekt（UDS）使用 Secret Discovery Service（SDS）向 CA 发起证书签名请求（CSR），如果你没有配置 CA 插件的话，Istio 默认向 *istiod* 发起 CSR；\n2. \u0060istiod\u0060 内置 CA 向 \u0060pilot-agent\u0060 返回证书；\n3. \u0060pilot-agent\u0060 将生成的私钥和 CA 返回的证书发送给 \u0060envoy\u0060 挂载；\n\nIstio 默认使用内置于 *istiod* 中的 CA，也支持插入其他 CA，见 [Istio 文档](https:\/\/istio.io\/latest\/zh\/docs\/tasks\/security\/cert-management\/plugin-ca-cert\/)。若想使用自定义的 CA 证书和密钥为服务创建身份，你需要：\n\n- 创建 CA 配置文件并使用它来创建自签名的 CA 根证书和密钥；\n- 为服务创建私钥、签名请求配置文件；\n- 为服务创建证书签名请求（CSR）；\n- 使用根证书和密钥以及服务的签名请求文件为服务创建证书；\n\n接下来，我们将以为 Bookinfo 的 productpage 服务创建和挂载证书为例详述 Istio 内置 CA 签发证书的流程。\n\n## Istio 内置 CA 签发证书流程  {#istio-ca}\n\nIstio 启动时将创建一个自签名的 CA 证书，然后再用该 CA 证书为网格内的服务颁发证书。下面我们手动模拟 Istio 内置 CA 签发证书的步骤：\n\n1. 创建 CA 私钥 \u0060ca.key\u0060；\n\n   \u0060\u0060\u0060bash\n   openssl genrsa -out ca.key\n   \u0060\u0060\u0060\n\n2. 创建 CA 配置文件 \u0060ca.conf\u0060：\n\n   \u0060\u0060\u0060ini\n   [ req ]\n   default_bits = 2048\n   prompt = no\n   utf8 = yes\n   encrypt_key = no\n   distinguished_name  = req_dn\n   req_extensions = req_ext\n   x509_extensions = req_ext\n   \n   [ req_dn ]\n   O = Istio\n   CN = Root CA\n   \n   [ req_ext ]\n   subjectKeyIdentifier = hash\n   basicConstraints = critical, CA:true\n   keyUsage = critical, digitalSignature, nonRepudiation, keyEncipherment, keyCertSign\n   \u0060\u0060\u0060\n\n3. 使用 CA 私钥 \u0060ca.key\u0060 生成自签名证书 \u0060ca.pem\u0060，其中主题中包含 CA 的信息：\n\n   \u0060\u0060\u0060bash\n   openssl req -x509 -new -nodes -key ca.key -days 365 -out ca.pem -config ca.conf\n   \u0060\u0060\u0060\n\n   {{\u003ccallout note \u0022关于 PEM 文件\u0022\u003e}}\n\n   PEM 文件是一种用于存储证书、公钥或私钥的文件。它采用 Base64 编码的 ASCII 格式，并使用特定的文件扩展名，例如 \u0060.pem\u0060、\u0060.crt\u0060、\u0060.cer\u0060 或 \u0060.key\u0060。PEM 文件通常用于存储加密密钥、数字证书和公钥基础设施（PKI）证书。\n\n   PEM 文件的内容通常以一组特定的标头和脚本开始，例如 \u0060-----BEGIN RSA PRIVATE KEY-----\u0060 和 \u0060-----END RSA PRIVATE KEY-----\u0060。这些标头和脚本指定了文件的类型和数据的开始和结束位置。\n\n   PEM 文件可以通过文本编辑器直接打开，但并不可读，因为它是由二进制编码格式 DER（可分辨编码规则）转化而来，要想解析它需要使用特别的工具，例如 OpenSSL。\n\n   {{\u003c\/callout\u003e}}\n\n4. 为工作负载创建私钥 \u0060workload.key\u0060：\n\n   \u0060\u0060\u0060bash\n   openssl genrsa -out workload.key\n   \u0060\u0060\u0060\n\n5. 创建证书签名请求配置文件 \u0060csr.conf\u0060，其中包含 CA 的地址及附加信息；\n\n   \u0060\u0060\u0060ini\n   [ req ]\n   default_bits = 2048\n   prompt = no\n   utf8 = yes\n   encrypt_key = no\n   distinguished_name  = dn\n   req_extensions = req_ext\n   x509_extensions = req_ext\n   \n   [ req_dn ]\n   O = Istio\n   CN = productpage\n   \n   [ req_ext ]\n   subjectKeyIdentifier = hash\n   basicConstraints = critical, CA:true\n   keyUsage = critical, digitalSignature, nonRepudiation, keyEncipherment, keyCertSign\n   \u0060\u0060\u0060\n\n6. 基于工作负载的 CSR 配置文件 \u0060csr.conf\u0060 和工作负载的私钥文件 \u0060workload.key\u0060 创建证书签名请求 \u0060workload.csr\u0060：\n\n   \u0060\u0060\u0060bash\n   openssl req -new -key workload.key -out workload.csr -config csr.conf\n   \u0060\u0060\u0060\n\n7. 基于 CA 的私钥 \u0060ca.key\u0060、CA 的证书 \u0060ca.pem\u0060 和工作负载的证书签名请求创建服务器证书 \u0060workload.pem\u0060：\n\n   \u0060\u0060\u0060bash\n   openssl x509 -req -in workload.csr -CA ca.pem -CAkey ca.key \\\n       -CAcreateserial -out workload.pem -days 365 \\\n       -extensions req_ext -extfile csr.conf -sha256\n   \u0060\u0060\u0060\n\n   Istiod 在收到工作负载的 CSR 后将根证书 \u0060ca.pem\u0060 和服务证书下发给工作负载；\n\n8. 查看工作负载中 Envoy 代理挂载的证书链：\n\n   \u0060\u0060\u0060bash\n   istioctl proxy-config secret deployment\/productpage-v1 -o json | jq -r \\\n   \u0027.dynamicActiveSecrets[0].secret.tlsCertificate.certificateChain.inlineBytes\u0027 | base64 --decode \u003e chain.pem\n   \u0060\u0060\u0060\n\n   \u0060chain.pem\u0060 文件中保存着 \u0060productpage\u0060 服务的证书链，因为我们使用的 Istio 内置 CA 作为根 CA，所以该文件中只保存有一个证书，可以运行下面的命令查看：\n\n   \u0060\u0060\u0060bash\n   openssl x509 -noout -text -in chain.pem\n   \u0060\u0060\u0060\n\n9. 查看 Envoy 代理挂载的根证书：\n\n   \u0060\u0060\u0060bash\n   istioctl proxy-config secret deployment\/productpage-v1 -o json | jq -r \\\n   \u0027.dynamicActiveSecrets[1].secret.validationContext.trustedCa.inlineBytes\u0027 | base64 --decode \u003e root.pem\n   \u0060\u0060\u0060\n\n   \u0060root.pem\u0060 即为根证书，运行下面的命令查看：\n\n   \u0060\u0060\u0060bash\n   openssl x509 -noout -text -in root.pem\n   \u0060\u0060\u0060\n\n   {{\u003ccallout note \u0022提示\u0022\u003e}}\n\n   \u0060root.pem\u0060 中的内容与 \u0060istiod-ca-cert\u0060 ConfigMap 中的 \u0060root-cert.pem\u0060 及 \u0060istio-ca-secret\u0060 中的 \u0060ca-cert.pem\u0060 是一样的，虽然现在 Envoy 已不在通过读取挂载卷来获得证书内容，但之所以保留了这些卷是为了向后兼容。\n\n   {{\u003c\/callout\u003e}}\n\n   证书挂载到 Envoy 代理之后，*istiod* 将负责定期替换密钥证书，以及根据需要撤销密钥证书。\n\n## 总结 {#summary}\n\n本文向你介绍了数字证书的作用、组成和证书信任链，以及 Istio 中内置的开箱即用的证书管理器运作的流程。但是 Istio 内置 CA 仍然有一定限制，在下一篇博客中我将向你介绍如何使用插件 SPIRE 和 cert-manager 来实现细粒度的证书管理和自动证书轮换。\n\n## 参考 {#reference}\n\n- [插入 CA 证书 - istio.io](https:\/\/istio.io\/latest\/zh\/docs\/tasks\/security\/cert-management\/plugin-ca-cert\/)\n- [如何设置 SSL 证书 - istio.tetratelabs.io](https:\/\/istio.tetratelabs.io\/zh\/istio-in-practice\/setting-up-ssl-certs\/)\n- [管理集群中的 TLS 认证 - kubernetes.io](https:\/\/kubernetes.io\/zh-cn\/docs\/tasks\/tls\/managing-tls-in-a-cluster\/)\n- [手动生成证书 - kubernetes.io](https:\/\/kubernetes.io\/zh-cn\/docs\/tasks\/administer-cluster\/certificates\/)\n- [将 Istio 纳入信任链：使用现有 PKI 作为信任根 - jimmysong.io](https:\/\/cloudnative.to\/blog\/istio-trust\/)\n- [如何使用 Hashicorp Vault 作为一种更安全的方式来存储 Istio 证书 - jimmysong.io](https:\/\/cloudnative.to\/blog\/how-to-use-hashicorp-vault-as-a-more-secure-way-to-store-istio-certificates\/)\n', '\/blog\/istio-certificates-management\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文介绍了数字证书和 Istio 中的证书管理方式。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/how-to-use-hashicorp-vault-as-a-more-secure-way-to-store-istio-certificates/">[译] 如何使用 Hashicorp Vault 作为一种更安全的方式来存储 Istio 证书</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/12/19</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://tetrate.io/blog/how-to-use-hashicorp-vault-as-a-more-secure-way-to-store-istio-certificates/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('如何使用 Hashicorp Vault 作为一种更安全的方式来存储 Istio 证书', '本文将指导你使用 Vault 存储 Istio 的证书。', '\n在本文中，我们将探讨如何使用 Hashicorp Vault 作为一种比使用 Kubernetes [Secret](https:\/\/kubernetes.io\/docs\/concepts\/configuration\/secret) 更安全的方式来存储 Istio 证书。默认情况下，Secret 使用 base64 编码存储在 *etcd* 中。在安全策略严格的环境中，这可能是不可接受的，因此需要额外的措施来保护它们。一种此类解决方案涉及将机密存储在外部机密存储提供程序中，例如 [HashiCorp Vault](https:\/\/www.vaultproject.io\/)。\n\nVault 可以托管在 Kubernetes 集群内部和外部。在本案例中，我们将探索使用托管在 Kubernetes 外部的 Vault，以便它可以同时为多个集群提供秘密。该设置也非常适合探索 Istio 的[多集群功能](https:\/\/istio.io\/latest\/docs\/setup\/install\/multicluster)，它需要一个共享的信任域。\n\n利用 \u0060vault-agent-init\u0060 容器，我们可以将证书和私钥材料注入实际的 Istio 控制平面 Pod，以便它们使用外部 CA 证书进行引导。这避免了依赖 Secret 来引导 Istio 控制平面。该技术也完全适用于入口和出口证书。\n\n有关如何在 Istio 中使用和管理证书的更多信息，请参见官方文档：\n\n- [身份和证书管理](https:\/\/istio.io\/latest\/zh\/docs\/concepts\/security\/#pki)\n- [插入 CA 证书](https:\/\/istio.io\/latest\/zh\/docs\/tasks\/security\/cert-management\/plugin-ca-cert)\n- [使用 Kubernetes CSR 的自定义 CA 集成](https:\/\/istio.io\/latest\/zh\/docs\/tasks\/security\/cert-management\/custom-ca-k8s)\n\n有关基于实际生产经验的最佳实践，另请查看以下 [Tetrate](https:\/\/tetrate.io\/) 的博客文章：\n\n- [在 Istio 中构建证书信任链：将现有 PKI 作为信任根](\/trans\/istio-trust\/)\n- [在生产中大规模自动化 Istio CA 轮换](\/trans\/automate-istio-ca-rotation-in-production-at-scale)\n\n这篇博文附带的代码可以在以下存储库中找到：\n\nhttps:\/\/github.com\/tetratelabs\/istio-vault-ext-certs\n\n## **Istiod 证书处理**\n\n尽管上述博文中解释了一些决策逻辑，但也值得参考[源代码](https:\/\/github.com\/istio\/istio\/blob\/master\/pilot\/pkg\/bootstrap\/istio_ca.go)以查找一些未记录的行为。\n\n在 Istio 的源码 \u0060istio\/pilot\/pkg\/bootstrap\/istio_ca.go\u0060 文件中，你将看到：为了向后兼容，Istio 保留了对用于自签名证书 \u0060cacerts\u0060 Secret 的支持。它安装在相同的位置，如果发现了就会被使用——创建秘密就足够了，不需要额外的选项。在旧安装程序中，\u0060LocalCertDir\u0060 被硬编码到 \u0060\/etc\/cacerts\u0060 并使用 \u0060cacerts\u0060  Secret 安装。已删除对签署其他根 CA 的支持——太危险，没有明确的用例。\n\n默认配置，用于向后兼容 Citadel：\n\n- 如果 \u0060istio-system\u0060 中存在 \u0060cacerts\u0060 秘密，将被挂载。它可能包含一个可选的 \u0060root-cert.pem\u0060，\n带有额外的根和可选的 \u0060{ca-key, ca-cert, cert-chain}.pem\u0060 由用户提供的根 CA。\n- 如果未找到用户提供的根 CA，则使用 \u0060istio-ca-secret\u0060 Secret，以及 \u0060ca-cert.pem\u0060 和 \u0060ca-key.pem\u0060 文件。\n- 如果两者均未找到，将创建 \u0060istio-ca-secret\u0060。\n- 带有 \u0060caTLSRootCert\u0060 文件的 \u0060istio-security\u0060 ConfigMap 将用于根证书，并在需要时创建。该 ConfigMap 由节点代理使用，不再可能在 sds-agent 中使用，但我们仍保留它以向后兼容。将与 node-agent 一起删除。sds-agent 使用 K8S root 直接调用 \u0060NewCitadelClient\u0060 。\n\n为了指示 Istio 从其他地方获取证书，而不是标准 Kubernetes Secret，我们将利用 *istio-pilot*（又名 istiod 或 Istio 控制平面）的环境变量（[见此文档](https:\/\/istio.io\/latest\/docs\/reference\/commands\/pilot-discovery)），从 Kubernetes Pod 中的另一个位置获取证书。这是必需的，因为 \u0060vault-agent-init\u0060 注入容器将创建一个新的挂载卷 \u0060\/vault\/secrets\u0060 ，以放置从外部 Vault 服务器拉出的证书和私钥。\n\n| 变量名称      | 类型   | 默认值         | 描述                         |\n| ------------- | ------ | -------------- | ---------------------------- |\n| \u0060ROOT_CA_DIR\u0060 | 字符串 | \u0060\/etc\/cacerts\u0060 | 本地或安装的 CA 根目录的位置 |\n\n## Pod 内的 \u0060vault-agent-init\u0060 容器注解\n\n我们将利用 Vault 注入器注解来指示 Sidecar 提取哪些数据以及在这样做时使用什么 Vault 角色。我们还确保容器在我们实际的主容器之前运行，因此后者可以获取证书和密钥材料以正确引导自身。[此处](https:\/\/developer.hashicorp.com\/vault\/docs\/platform\/k8s\/injector\/annotations)列举并记录了 Vault 注解。我们将在本教程中使用的相关注释如下：\n\n| **注解**                                     | **默认值** | **描述**                                                     |\n| -------------------------------------------- | ---------- | ------------------------------------------------------------ |\n| \u0060vault.hashicorp.com\/agent-inject\u0060           | false      | 配置是否为 Pod 显式启用或禁用注入。这应该设置为 true 或 false。 |\n| \u0060vault.hashicorp.com\/agent-init-first\u0060       | false      | 如果为 true，则将 Pod 配置为首先运行 Vault Agent init 容器（如果为 false，则最后运行）。当其他 init 容器需要预填充的秘密时，这很有用。这应该设置为 true 或 false。 |\n| \u0060vault.hashicorp.com\/role\u0060                   | –          | 配置 Vault 代理自动验证方法使用的 Vault 角色。\u0060vault.hashicorp.com\/agent-configmap\u0060 未设置时需要。 |\n| \u0060vault.hashicorp.com\/auth-path\u0060              | –          | 配置 Kubernetes 身份验证方法的身份验证路径。默认为 \u0060auth\/kubernetes\u0060。 |\n| \u0060vault.hashicorp.com\/agent-inject-secret-\u0060   | –          | 配置 Vault 代理以从容器所需的 Vault 中检索秘密。Secret 的名称是 \u0060vault.hashicorp.com\/agent-inject-secret-\u0060 之后的任意唯一字符串，例如 \u0060vault.hashicorp.com\/agent-inject-secret-foobar\u0060 该值是 secret 所在的 Vault 中的路径。 |\n| \u0060vault.hashicorp.com\/agent-inject-template-\u0060 | –          | 配置 Vault Agent 应该用于呈现秘密的模板。模板的名称是 v\u0060ault.hashicorp.com\/agent-inject-template-\u0060 之后的任何唯一字符串，例如 \u0060vault.hashicorp.com\/agent-inject-template-foobar\u0060。这应该映射到 \u0060vault.hashicorp.com\/agent-inject-secret-\u0060 中提供的相同唯一值。如果未提供，则使用默认的通用模板。 |\n\n## Vault 服务器注意事项 {#vault-server-considerations}\n\nVault 支持多种客户端验证自己的方法。我们将利用 [Kubernetes 身份验证后端](https:\/\/developer.hashicorp.com\/vault\/docs\/auth\/kubernetes)，这意味着我们将利用 Kubernetes ServiceAccount JWT 令牌验证。请注意，自 Kubernetes 1.24 以来，不再自动生成 ServiceAccount 令牌。您仍然可以手动创建这些 API 令牌，如[此处所述](https:\/\/kubernetes.io\/docs\/tasks\/configure-pod-container\/configure-service-account\/#manually-create-an-api-token-for-a-serviceaccount)。\n\n至于证书和私钥材料的存储，我们有两种选择：\n\n- [PKI 秘密引擎](https:\/\/developer.hashicorp.com\/vault\/docs\/secrets\/pki)\n- [KV 秘密引擎](https:\/\/developer.hashicorp.com\/vault\/docs\/secrets\/kv)\n\n因为 PKI 秘密引擎不提供精简的 API 来检索我们需要的证书和私钥，并且因为 PKI 秘密引擎会为每次调用（例如，每次 *istiod* 重启）生成一个新的中间证书，我们将使用通用的 KV 秘密引擎，将我们需要的所有值存储在一个简单的键值数据结构中。我们假设中间证书的更新是通过一些服务门户或 CI\/CD 过程在外部处理的，这些过程也将更新的中间证书存储在 Vault 服务器中。\n\nIstio 的控制平面 Pod 需要以下文件才能在 CA 中正确引导其构建：\n\n| Key            | 值（PEM 编码） | 细节                                    |\n| -------------- | -------------- | --------------------------------------- |\n| ca-key.pem     | 私钥           | 中间证书的私钥，用作 *istiod* 的根 CA。 |\n| ca-cert.pem    | CA 公共证书    | 中间证书，用作 *istiod* 的根 CA。       |\n| root-cert.pem  | CA 根证书      | 我们新生成的中间证书的信任根。          |\n| cert-chain.pem | 完整的证书链   | 中间证书在顶部，根证书在底部。          |\n\n## 设置\n\n如果要遵循本地设置，则安装软件的先决条件包括：\n\n- *kubectl* 与 Kubernetes 集群交互（[下载](https:\/\/kubernetes.io\/docs\/tasks\/tools\/#kubectl)）\n- *helm* 安装 Vault injector 和 Istio chart（[下载](https:\/\/helm.sh\/docs\/intro\/install)）\n- 用于配置 Vault 服务器的 *vault cli* 工具（[下载](https:\/\/developer.hashicorp.com\/vault\/tutorials\/getting-started\/getting-started-install#install-vault)）\n\n如果您想要本地演示环境，请按照[此处](https:\/\/github.com\/tetratelabs\/istio-vault-ext-certs\/blob\/main\/local-setup.md)的说明进行操作，该说明使用 \u0060docker-compose\u0060 启动一个 Vault 服务器和两个独立的 k3s 集群。如果您使用自己的 Kubernetes 集群和外部托管的 Vault 实例，请跳至下一节。\n\n- *docker-compose* 启动本地环境（[下载](https:\/\/github.com\/docker\/compose\/releases)）\n\n为了取得进展，我们希望根据您的环境设置以下 shell 变量。\n\n\u0060\u0060\u0060bash\nexport VAULT_SERVER=\nexport K8S_API_SERVER_1=\nexport K8S_API_SERVER_2=\n\u0060\u0060\u0060\n\n## **Vault Kubernetes 身份验证后端**\n\n正如在有关 [Vault 服务器注意事项](#vault-server-considerations)的介绍部分中提到的，我们将使用 [Kubernetes 身份验证后端](https:\/\/developer.hashicorp.com\/vault\/docs\/auth\/kubernetes)。由于 *istiod* 将从 Vault 服务器获取证书和私钥材料，让我们从在两个集群中创建相应的服务账户开始。\n\n\u0060\u0060\u0060bash\nkubectl --kubeconfig kubecfg1.yml create ns istio-system\nkubectl --kubeconfig kubecfg2.yml create ns istio-system\nkubectl --kubeconfig kubecfg1.yml apply -f istio-sa.yml\nkubectl --kubeconfig kubecfg2.yml apply -f istio-sa.yml\n\u0060\u0060\u0060\n\nServiceAccount、Secret 和 ClusterRoleBinding 如下：\n\n\u0060\u0060\u0060yaml\n# istio-sa.yaml\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: istiod\n  namespace: istio-system\n  labels: # added for istio helm installation\n    app: istiod\n    app.kubernetes.io\/managed-by: Helm\n    release: istio-istiod\n  annotations: # added for istio helm installation\n    meta.helm.sh\/release-name: istio-istiod\n    meta.helm.sh\/release-namespace: istio-system\n---\napiVersion: v1\nkind: Secret\nmetadata:\n  name: istiod\n  namespace: istio-system\n  annotations:\n    kubernetes.io\/service-account.name: istiod\ntype: kubernetes.io\/service-account-token\n---\napiVersion: rbac.authorization.k8s.io\/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: role-tokenreview-binding\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: system:auth-delegator\nsubjects:\n  - kind: ServiceAccount\n    name: istiod\n    namespace: istio-system\n\u0060\u0060\u0060\n\n\u003e 注意：*我们在 istiod ServiceAccount 上添加了 Helm 标签和注解，以免与稍后的 Istio Helm 部署发生冲突。*\n\n在两个集群中创建 ServiceAccount 后，让我们将它们的 Secret 令牌和 ca.cert 值存储在 output 文件夹中：\n\n\u0060\u0060\u0060bash\nmkdir -p .\/output\nkubectl --kubeconfig kubecfg1.yml get secret -n istio-system istiod -o go-template=\u0022{{ .data.token }}\u0022 | base64 --decode \u003e output\/istiod1.jwt\nkubectl --kubeconfig kubecfg1.yml config view --raw --minify --flatten -o jsonpath=\u0022{.clusters[].cluster.certificate-authority-data}\u0022 | base64 --decode \u003e output\/k8sapi-cert1.pem\nkubectl --kubeconfig kubecfg2.yml get secret -n istio-system istiod -o go-template=\u0022{{ .data.token }}\u0022 | base64 --decode \u003e output\/istiod2.jwt\nkubectl --kubeconfig kubecfg2.yml config view --raw --minify --flatten -o jsonpath=\u0022{.clusters[].cluster.certificate-authority-data}\u0022 | base64 --decode \u003e output\/k8sapi-cert2.pem\n\u0060\u0060\u0060\n\n关于 Kubernetes API 证书和 istiod ServiceAccount JWT 令牌的详细内容的更多信息可以在[这里](https:\/\/github.com\/tetratelabs\/istio-vault-ext-certs\/blob\/main\/output)找到，在这里我们也更深入地描述了 Vault 的交互过程，即通过 REST API 调用来验证和获取秘密。在调试权限拒绝的问题时，这些可以派上用场。\n\n让我们根据刚刚检索到的 Kubernetes CA 证书和 JWT 令牌创建必要的 Vault 身份验证配置：\n\n\u0060\u0060\u0060bash\nexport VAULT_ADDR=http:\/\/localhost:8200\nvault login root\nvault auth enable --path=kubernetes-cluster1 kubernetes\nvault auth enable --path=kubernetes-cluster2 kubernetes\nvault write auth\/kubernetes-cluster1\/config \\\n  kubernetes_host=\u0022$K8S_API_SERVER_1\u0022 \\\n  kubernetes_ca_cert=@output\/k8sapi-cert1.pem \\\n  token_reviewer_jwt=\u0060cat output\/istiod1.jwt\u0060 \\\n  disable_local_ca_jwt=\u0022true\u0022\nvault write auth\/kubernetes-cluster2\/config \\\n  kubernetes_host=\u0022$K8S_API_SERVER_2\u0022 \\\n  kubernetes_ca_cert=@output\/k8sapi-cert2.pem \\\n  token_reviewer_jwt=\u0060cat output\/istiod2.jwt\u0060 \\\n  disable_local_ca_jwt=\u0022true\u0022\n\u0060\u0060\u0060\n\n\u003e 注意：如果您使用的是 *docker-compose* 提供的环境，则 \u0060VAULT_ADDR\u0060 设置为 localhost。\n\n## *Vault kv* Secret 中的 Istio 证书和私钥\n\n接下来我们将创建一个新的自签名根证书并为我们的两个集群生成中间证书。我们将在[这里](https:\/\/github.com\/istio\/istio\/tree\/master\/tools\/certs)使用上游 Istio 提供的辅助 *Makefile* 脚本：\n\n\u0060\u0060\u0060bash\ncd certs\nmake -f ..\/certs-gen\/Makefile.selfsigned.mk root-ca\nmake -f ..\/certs-gen\/Makefile.selfsigned.mk istiod-cluster1-cacerts\nmake -f ..\/certs-gen\/Makefile.selfsigned.mk istiod-cluster2-cacerts\ncd ..\n\u0060\u0060\u0060\n\n有关实际内容和正在设置的 X509v3 扩展的更多详细信息，请参见[此处](https:\/\/github.com\/tetratelabs\/istio-vault-ext-certs\/blob\/main\/certs)。您可以通过[此处](https:\/\/github.com\/tetratelabs\/istio-vault-ext-certs\/blob\/main\/certs-gen)的 *Makefile*文档和相应的 *Makefile* 覆盖值微调证书。\n\n让我们将生成的证书和私钥添加到 Vault *kv* secret 中：\n\n\u0060\u0060\u0060bash\nexport VAULT_ADDR=http:\/\/localhost:8200\nvault login root\nvault secrets enable -path=kubernetes-cluster1-secrets kv\nvault secrets enable -path=kubernetes-cluster2-secrets kv\nvault kv put kubernetes-cluster1-secrets\/istiod-service\/certs \\\n  ca_key=@certs\/istiod-cluster1\/ca-key.pem \\\n  ca_cert=@certs\/istiod-cluster1\/ca-cert.pem \\\n  cert_chain=@certs\/istiod-cluster1\/cert-chain.pem \\\n  root_cert=@certs\/istiod-cluster1\/root-cert.pem\nvault kv put kubernetes-cluster2-secrets\/istiod-service\/certs \\\n  ca_key=@certs\/istiod-cluster2\/ca-key.pem \\\n  ca_cert=@certs\/istiod-cluster2\/ca-cert.pem \\\n  cert_chain=@certs\/istiod-cluster2\/cert-chain.pem \\\n  root_cert=@certs\/istiod-cluster2\/root-cert.pem\n\u0060\u0060\u0060\n\n通过限制对每个集群的这些证书和私钥的访问，绑定到基于 Kubernetes *istiod* ServiceAccount 的身份验证后端：\n\n\u0060\u0060\u0060bash\necho \u0027path \u0022kubernetes-cluster1-secrets\/istiod-service\/certs\u0022 {\n  capabilities = [\u0022read\u0022]\n}\u0027 | vault policy write istiod-certs-cluster1 -\necho \u0027path \u0022kubernetes-cluster2-secrets\/istiod-service\/certs\u0022 {\n  capabilities = [\u0022read\u0022]\n}\u0027 | vault policy write istiod-certs-cluster2 -\nvault write auth\/kubernetes-cluster1\/role\/istiod \\\n  bound_service_account_names=istiod \\\n  bound_service_account_namespaces=istio-system \\\n  policies=istiod-certs-cluster1 \\\n  ttl=24h\nvault write auth\/kubernetes-cluster2\/role\/istiod \\\n  bound_service_account_names=istiod \\\n  bound_service_account_namespaces=istio-system \\\n  policies=istiod-certs-cluster2  \\\n  ttl=24h\n\u0060\u0060\u0060\n\n## 部署 *vault-inject* 和 Istio Helm Charts\n\n为了部署 Vault 注入器，我们将利用官方 Vault [Helm chart](https:\/\/github.com\/hashicorp\/vault-helm)。\n\n\u0060\u0060\u0060bash\nhelm repo add hashicorp https:\/\/helm.releases.hashicorp.com\nhelm repo update\nkubectl --kubeconfig kubecfg1.yml create ns vault\nkubectl --kubeconfig kubecfg2.yml create ns vault\nhelm --kubeconfig kubecfg1.yml install -n vault vault-inject hashicorp\/vault --set \u0022injector.externalVaultAddr=$VAULT_SERVER\u0022\nhelm --kubeconfig kubecfg2.yml install -n vault vault-inject hashicorp\/vault --set \u0022injector.externalVaultAddr=$VAULT_SERVER\u0022\nkubectl --kubeconfig kubecfg1.yml -n vault get pods\nkubectl --kubeconfig kubecfg2.yml -n vault get pods\n\u0060\u0060\u0060\n\n\u0060\u0060\u0060\nNAME                                           READY   STATUS    RESTARTS   AGE\nvault-inject-agent-injector-5776975795-9vt9w   1\/1     Running   0          92s\nNAME                                           READY   STATUS    RESTARTS   AGE\nvault-inject-agent-injector-5776975795-9vjnx   1\/1     Running   0          91s\n\u0060\u0060\u0060\n\n要安装 Istio，我们将使用 Tetrate Istio Distro [Helm chart](https:\/\/github.com\/tetratelabs\/helm-charts)。\n\n\u0060\u0060\u0060bash\nhelm repo add tetratelabs https:\/\/tetratelabs.github.io\/helm-charts\nhelm repo update\nhelm --kubeconfig kubecfg1.yml install -n istio-system istio-base tetratelabs\/base\nhelm --kubeconfig kubecfg2.yml install -n istio-system istio-base tetratelabs\/base\nhelm --kubeconfig kubecfg1.yml install -n istio-system istio-istiod tetratelabs\/istiod --values=.\/cluster1-values.yaml\nhelm --kubeconfig kubecfg2.yml install -n istio-system istio-istiod tetratelabs\/istiod --values=.\/cluster2-values.yaml\nkubectl --kubeconfig kubecfg1.yml -n istio-system get pods\nkubectl --kubeconfig kubecfg2.yml -n istio-system get pods\n\u0060\u0060\u0060\n\n请注意我们如何利用多个 Istio Helm chart 值覆盖来我们预期的目标：\n\n- 注入一个 pilot Pod 环境变量 \u0060ROOT_CA_DIR\u0060 来告诉 *istiod* 从哪里获取证书和私钥\n- 告诉 \u0060vault-agent-init\u0060 容器在 *istiod* 容器之前运行，因此秘密安装在 \u0060\/vault\/secrets\u0060 的卷中可用\n- 指示 Vault 注入器从正确的位置和数据密钥获取机密\n- 这样做时承担 Vault *istiod* 角色\n- 覆盖默认的 Kubernetes auth-path，因为我们有多个集群 \n\n\u0060\u0060\u0060yaml\npilot:\n  env:\n    ROOT_CA_DIR: \/vault\/secrets\n  podAnnotations:\n    vault.hashicorp.com\/agent-inject: \u0022true\u0022\n    vault.hashicorp.com\/agent-init-first: \u0022true\u0022\n    vault.hashicorp.com\/agent-inject-secret-ca-key.pem: \u0022kubernetes-cluster1-secrets\/istiod-service\/certs\u0022\n    vault.hashicorp.com\/agent-inject-template-ca-key.pem: |\n        {{- with secret \u0022kubernetes-cluster1-secrets\/istiod-service\/certs\u0022 -}}\n        {{ .Data.ca_key }}\n        {{ end -}}\n    vault.hashicorp.com\/agent-inject-secret-ca-cert.pem: \u0022kubernetes-cluster1-secrets\/istiod-service\/certs\u0022\n    vault.hashicorp.com\/agent-inject-template-ca-cert.pem: |\n        {{- with secret \u0022kubernetes-cluster1-secrets\/istiod-service\/certs\u0022 -}}\n        {{ .Data.ca_cert }}\n        {{ end -}}\n    vault.hashicorp.com\/agent-inject-secret-root-cert.pem: \u0022kubernetes-cluster1-secrets\/istiod-service\/certs\u0022\n    vault.hashicorp.com\/agent-inject-template-root-cert.pem: |\n        {{- with secret \u0022kubernetes-cluster1-secrets\/istiod-service\/certs\u0022 -}}\n        {{ .Data.root_cert }}\n        {{ end -}}\n    vault.hashicorp.com\/agent-inject-secret-cert-chain.pem: \u0022kubernetes-cluster1-secrets\/istiod-service\/certs\u0022\n    vault.hashicorp.com\/agent-inject-template-cert-chain.pem: |\n        {{- with secret \u0022kubernetes-cluster1-secrets\/istiod-service\/certs\u0022 -}}\n        {{ .Data.cert_chain }}\n        {{ end -}}\n    vault.hashicorp.com\/role: \u0022istiod\u0022\n    vault.hashicorp.com\/auth-path: \u0022auth\/kubernetes-cluster1\u0022\n\u0060\u0060\u0060\n\n当我们查看 \u0060vault-agent-init\u0060 容器日志时，我们应该看到类似这样的内容。我们的控制平面已经正确地获取了 Vault 注入的秘密。\n\n\u0060\u0060\u0060bash\nkubectl --kubeconfig kubecfg1.yml logs -n istio-system -l app=istiod -c vault-agent-init --tail=-1\n\u0060\u0060\u0060\n\n\u0060\u0060\u0060\n==\u003e Vault agent started! Log data will stream in below:\n\n  ==\u003e Vault agent configuration:\n\n                      Cgo: disabled\n                Log Level: info\n                  Version: Vault v1.12.0, built 2022-10-10T18:14:33Z\n              Version Sha: 558abfa75702b5dab4c98e86b802fb9aef43b0eb\n\n  2022-11-18T11:01:21.398Z [INFO]  sink.file: creating file sink\n  2022-11-18T11:01:21.398Z [INFO]  sink.file: file sink configured: path=\/home\/vault\/.vault-token mode=-rw-r-----\n  2022-11-18T11:01:21.398Z [INFO]  template.server: starting template server\n  2022-11-18T11:01:21.398Z [INFO]  sink.server: starting sink server\n  2022-11-18T11:01:21.398Z [INFO]  auth.handler: starting auth handler\n  2022-11-18T11:01:21.398Z [INFO]  auth.handler: authenticating\n  2022-11-18T11:01:21.398Z [INFO] (runner) creating new runner (dry: false, once: false)\n  2022-11-18T11:01:21.398Z [INFO] (runner) creating watcher\n  2022-11-18T11:01:21.402Z [INFO]  auth.handler: authentication successful, sending token to sinks\n  2022-11-18T11:01:21.402Z [INFO]  auth.handler: starting renewal process\n  2022-11-18T11:01:21.402Z [INFO]  sink.file: token written: path=\/home\/vault\/.vault-token\n  2022-11-18T11:01:21.402Z [INFO]  sink.server: sink server stopped\n  2022-11-18T11:01:21.402Z [INFO]  sinks finished, exiting\n  2022-11-18T11:01:21.402Z [INFO]  template.server: template server received new token\n  2022-11-18T11:01:21.402Z [INFO] (runner) stopping\n  2022-11-18T11:01:21.402Z [INFO] (runner) creating new runner (dry: false, once: false)\n  2022-11-18T11:01:21.402Z [INFO] (runner) creating watcher\n  2022-11-18T11:01:21.402Z [INFO] (runner) starting\n  2022-11-18T11:01:21.403Z [INFO]  auth.handler: renewed auth token\n  2022-11-18T11:01:21.515Z [INFO] (runner) rendered \u0022(dynamic)\u0022 =\u003e \u0022\/vault\/secrets\/root-cert.pem\u0022\n  2022-11-18T11:01:21.515Z [INFO] (runner) rendered \u0022(dynamic)\u0022 =\u003e \u0022\/vault\/secrets\/ca-cert.pem\u0022\n  2022-11-18T11:01:21.515Z [INFO] (runner) rendered \u0022(dynamic)\u0022 =\u003e \u0022\/vault\/secrets\/cert-chain.pem\u0022\n  2022-11-18T11:01:21.516Z [INFO] (runner) rendered \u0022(dynamic)\u0022 =\u003e \u0022\/vault\/secrets\/ca-key.pem\u0022\n  2022-11-18T11:01:21.516Z [INFO] (runner) stopping\n  2022-11-18T11:01:21.516Z [INFO]  template.server: template server stopped\n  2022-11-18T11:01:21.516Z [INFO] (runner) received finish\n  2022-11-18T11:01:21.516Z [INFO]  auth.handler: shutdown triggered, stopping lifetime watcher\n  2022-11-18T11:01:21.516Z [INFO]  auth.handler: auth handler stopped\n\u0060\u0060\u0060\n\n当我们查看 \u0060discovery\u0060 容器日志时，我们应该看到如下内容：\n\n\u0060\u0060\u0060bash\nkubectl --kubeconfig kubecfg1.yml logs -n istio-system -l app=istiod -c discovery --tail=-1\n\u0060\u0060\u0060\n\n\u0060\u0060\u0060\n info\tUsing istiod file format for signing ca files\n  info\tUse plugged-in cert at \/vault\/secrets\/ca-key.pem\n  info\tx509 cert - Issuer: \u0022CN=Intermediate CA,O=Istio,L=istiod-cluster1\u0022, Subject: \u0022\u0022, SN: 39f67569f10d36a1fc91e9d82156b07d, NotBefore: \u00222022-11-18T11:11:59Z\u0022, NotAfter: \u00222032-11-15T11:13:59Z\u0022\n  info\tx509 cert - Issuer: \u0022CN=Root CA,O=Istio\u0022, Subject: \u0022CN=Intermediate CA,O=Istio,L=istiod-cluster1\u0022, SN: dedf298a147681d6, NotBefore: \u00222022-11-17T22:01:54Z\u0022, NotAfter: \u00222024-11-16T22:01:54Z\u0022\n  info\tx509 cert - Issuer: \u0022CN=Root CA,O=Istio\u0022, Subject: \u0022CN=Root CA,O=Istio\u0022, SN: f5bcd7e89bdb6248, NotBefore: \u00222022-11-17T22:01:52Z\u0022, NotAfter: \u00222032-11-14T22:01:52Z\u0022\n  info\tIstiod certificates are reloaded\n  info\tspiffe\tAdded 1 certs to trust domain cluster.local in peer cert verifier\n\u0060\u0060\u0060\n\n我们可以看到我们的 Istio 控制平面已经正确地获取了我们的 Vault 注入证书和私钥。任务完成！\n\n## 结论\n\n在本文中，我们已经使用外部 Vault 存储的证书和私钥成功引导了 Istio 控制平面。实现这一目标的步骤包括：\n\n- 将证书和私钥存储在每个集群专用的 Vault 秘密安装路径中\n- 为每个集群设置 Kubernetes Vault 身份验证后端，链接到正确的 ServiceAccount\n- 定义适当的角色和策略以允许从 *istiod* ServiceAccount 访问 Vault 机密\n- 将 Istio Pilot 引导程序参数调整为：\n  - 注入 *vault-agent-init* sidecar\n  - 获取包含我们的证书和私钥的正确 Vault 机密\n  - 使用正确的角色和身份验证后端来这样做\n  - 从正确的 vault secret 安装路径中获取证书和私钥\n\n我们可以使用完全相同的技术来注入*入口网关*和*出口网关*证书。创建 Istio [Gateway](https:\/\/istio.io\/latest\/docs\/reference\/config\/networking\/gateway\/#ServerTLSSettings) 对象时，请确保将 *serverCertificate*、*privateKey* 和 *caCertificates* 指向 \u0060\/vault\/secrets\u0060 挂载卷中的正确文件。我们将把它作为练习留给读者。\n\n通过将证书注入绑定到 Kubernetes ServiceAccount，我们现在已将证书生命周期管理委托给外部秘密 Vault 实例。现在可以使用专用角色和写入\/更新策略创建服务门户或 CI\/CD 管道等外部流程，以提供必要的证书生命周期管理安全性。\n', '\/trans\/how-to-use-hashicorp-vault-as-a-more-secure-way-to-store-istio-certificates\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文将指导你使用 Vault 存储 Istio 的证书。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/the-top-6-zero-trust-principles-for-kubernetes-security/">[译] Kubernetes 安全的 6 大零信任原则</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/12/13</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e5%ae%89%e5%85%a8"> 
             安全
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://tetrate.io/blog/top-3-mtls-best-practices-for-zero-trust-kubernetes-security/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Kubernetes 安全的 6 大零信任原则', '本文是 NIST 的核心零信任架构原则以及建议在实践中应用它们的 Kubernetes 和 Istio 参考架构。', '\n传统的网络安全依赖于围绕可信内部网络的强大防御边界，以将不良行为者拒之门外，将敏感数据拒之门外。在日益复杂的网络环境中，维护强大的边界越来越困难。\n\n零信任安全正在成为企业保护其传统和现代云原生应用程序的首选方法。零信任网络架构颠覆了边界安全的假设。在零信任网络中，每个资源都在内部受到保护，就好像它暴露在开放的互联网中一样。\n\n为了为行业和美国联邦政府建立零信任安全指南，美国国家标准与技术研究院 (NIST) 在一系列出版物中建立了零信任安全指南，从 SP 800-207 开始，介绍一般的零信任架构及其配套[SP 800-204 微服务安全标准系列](https:\/\/tetr8.io\/3zi85IC)。\n\n以下是 NIST 的核心零信任架构原则以及建议在实践中应用它们的 Kubernetes 和 Istio 参考架构。\n\n## 零信任网络的六项原则\n\n1. **无论网络位置如何，所有通信都应该是安全的**。网络位置和可达性并不意味着信任。企业拥有或其他专用网络内部的访问请求必须满足与来自任何其他位置的通信相同的安全要求。零信任系统的一个标准是，您可以将它暴露在开放的互联网上，并且它仍然是安全的，没有未经授权的系统、数据或通信访问。\n2. **所有通信都应加密**。线路上的加密可防止窃听，并确保消息真实且未被篡改。这意味着至少为所有通信实施 TLS，将[mTLS 和相关的安全工作负载身份作为服务间通信的最佳实践](https:\/\/tetr8.io\/3Na982k)。\n3. **对每个资源的访问都应该根据动态策略进行身份验证和授权**。在允许任何访问之前，对服务身份和最终用户凭据进行动态身份验证和授权。访问请求的动态上下文应该是访问决策的一部分。这可能包括行为属性，如与观察到的使用模式的偏差或请求资产的状态，如安装的软件版本、网络位置和请求的时间 \/ 日期。授予访问权限时，应以所需的最低权限授予它。\n4. **对资源的访问应该在空间上有界**。围绕资源的信任范围应尽可能小 —— 理想情况下为零。访问应该由每个能够检索和执行访问决策的资源前面的策略执行点 (PEP) 进行调解。这应该适用于所有入站、出站和服务到服务的访问。\n5. **应及时限制对资源的访问**。身份验证和授权绑定到一个短暂的会话，之后它们必须重新建立。这可确保频繁做出访问决策，并使用最新的可用上下文。\n6. **对资源的访问应该是可观察的**。应收集并使用尽可能多的信息来改善安全态势。这允许持续监控所有资产的完整性和安全状况，并持续确保策略执行。此外，应反馈从观察中获得的见解以改进政策。\n\n## 为什么零信任安全性更好\n\n- **网络可达性不是授权**。与边界安全性不同，对服务的访问不会仅仅因为该服务可访问而被授予。它也必须经过明确的身份验证和授权。\n- **周边突破口的有限爆炸半径可防止攻击者横向移动**。经过身份验证和授权的工作负载免受边界破坏。及时限制凭证泄露的风险。\n- **细粒度策略**。空间边界允许高粒度的策略执行。\n- **频繁的政策评估**。通过在短期会话上执行动态策略来及时绑定可确保授权基于最新的策略。\n- **安全、真实的通信**。加密和强大的工作负载身份限制了侦察并提供了通信的真实性。\n- **安全状况和合规性的实时和可审计保证**。细粒度的可观测性允许实时保证和政策实施的事后审计以及故障排除和分析所需的数据。\n\n## 如何使用 Istio 在 Kubernetes 中实现零信任安全：现代微服务应用程序的参考架构\n\n作为 NIST 的一般零信任架构标准的补充，NIST 还发布了如何将零信任原则专门应用于微服务应用程序的标准。这些标准由 Tetrate 创始工程师 Zack Butcher 共同编写，并编入[NIST 的 SP 800-204 系列](https:\/\/tetr8.io\/3zi85IC)。\n\n在该标准中，NIST 建立了一个由 Kubernetes 组成的参考平台，用于编排和资源管理，并使用 Istio 服务网格提供核心安全功能。\n\n## Kubernetes 安全漏洞\n\n由于 Kubernetes 主要专注于编排、资源管理和基本连接，因此它将零信任网络安全问题留给其他方解决。Kubernetes 中的主要网络安全漏洞是（NIST SP 800-204B，§2.1.1）：\n\n- 默认情况下不安全的通信\n- 缺少在 pod 之间强制执行 TLS 所需的内置证书管理机制\n- 缺乏身份和访问管理机制\n- 在 OSI L3 而非 L7 运行的防火墙策略，因此无法窥视数据包或做出元数据驱动的决策\n\n## 服务网格填补了 Kubernetes 的安全漏洞：微服务应用程序的安全内核\n\n为了增强 Kubernetes 的安全性，Istio 充当 NIST 参考架构中的安全内核。Istio 满足参考监视器的三个要求（NIST SP 800-204B，§5.1）。Istio 是：\n\n- 不可旁路\n- 防止修改\n- 验证和测试是正确的\n\nEnvoy 数据平面通过每个服务前面以及每个入口和出口网关的不可绕过的策略执行点 (PEP) 提供参考监视器。服务网格代码独立于应用程序，因此它的生命周期可以独立管理，并且不能在运行时修改。而且，网格是系统的一个严格控制的元素，可以通过更多的眼睛和更仔细的检查来强化（NIST SP 800-204B，§5.1）。\n\n而且，作为专用的基础架构层，Istio 提供：\n\n- 解决**横切应用程序问题的**统一方法；\n- **快速解决这些问题的标准插件**和构建自定义插件的框架；\n- **简化**操作复杂性；\n- **易于管理**第三方开发人员和集成商；\n- **降低**开发和运营成本。\n\n## 下一步\n\n\u003e 要从联邦安全标准的合著者那里了解有关**如何实施零信任架构的更多信息，**[请阅读 Zack Butcher 的零信任架构白皮书](https:\/\/tetr8.io\/zta-wp)。\n\u003e\n\u003e 有关 NIST 安全建议的深入指南以及 Tetrate 如何帮助您实施该标准，请查看[Tetrate 的微服务联邦安全要求指南](https:\/\/tetr8.io\/3Ccg6Qt)。\n\n如果您正在寻找使用 Istio 投入生产的最快方式，请查看我们的开源[Tetrate Istio Distro (TID)](https:\/\/istio.tetratelabs.io\/)。TID 是经过审查的 Istio 上游发行版 ——Istio 的强化映像，具有持续支持，更易于安装、管理和升级。对于在联邦监管环境中运营的组织，Tetrate Istio Distro 是唯一[具有可用 FIPS 验证构建](https:\/\/istio.tetratelabs.io\/fips-request\/)的 Istio 发行版。\n\n如果您需要一种统一且一致的方式来保护和管理一系列应用程序中的服务，请查看 [Tetrate Service Bridge (TSB)](https:\/\/tetrate.io\/tetrate-service-bridge\/)，这是我们基于 Istio 和 Envoy 构建的全面的边缘到工作负载应用程序连接平台。\n', '\/trans\/the-top-6-zero-trust-principles-for-kubernetes-security\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文是 NIST 的核心零信任架构原则以及建议在实践中应用它们的 Kubernetes 和 Istio 参考架构。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
          <div class="col-12">
 
 
 
 
 
 
 
 
 
 
 
 <nav aria-label="Page navigation">
   <ul class="pagination justify-content-center">
     
     
     <li class="page-item">
       <a class="page-link" href="/blog/">
         ««
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a href="/blog/page/14/" class="page-link">
         «
       </a>
     </li>
     
     
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item">
           <a href="/blog/page/13/" class="page-link">
             13
           </a>
         </li>
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item">
           <a href="/blog/page/14/" class="page-link">
             14
           </a>
         </li>
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item page-item active ">
           <a href="/blog/page/15/" class="page-link">
             15
           </a>
         </li>
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item">
           <a href="/blog/page/16/" class="page-link">
             16
           </a>
         </li>
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item">
           <a href="/blog/page/17/" class="page-link">
             17
           </a>
         </li>
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
     
     
     <li class="page-item">
       <a href="/blog/page/16/" class="page-link">
         »
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a class="page-link" href="/blog/page/29/">
         »»
       </a>
     </li>
     
   </ul>
 </nav>
 
</div>

        </div>
      </div>
      <!-- sidebar -->
      <aside class="col-lg-4 order-1 order-lg-2 d-none d-sm-block">
          <div class="sidebar">
          <!-- categories -->
<div class="blog-categories mb-4">
  <p class="sidebar-title">
      专栏
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/istio" class="sidebar-item">
            <span>Istio</span>
            <span>(81)</span>
        </a>
      
        <a href="/categories/service-mesh" class="sidebar-item">
            <span>Service Mesh</span>
            <span>(42)</span>
        </a>
      
        <a href="/categories/kubernetes" class="sidebar-item">
            <span>Kubernetes</span>
            <span>(25)</span>
        </a>
      
        <a href="/categories/%e9%9a%8f%e7%ac%94" class="sidebar-item">
            <span>随笔</span>
            <span>(22)</span>
        </a>
      
        <a href="/categories/%e5%85%b6%e4%bb%96" class="sidebar-item">
            <span>其他</span>
            <span>(19)</span>
        </a>
      
        <a href="/categories/envoy" class="sidebar-item">
            <span>Envoy</span>
            <span>(17)</span>
        </a>
      
        <a href="/categories/%e4%b8%9a%e6%80%81" class="sidebar-item">
            <span>业态</span>
            <span>(17)</span>
        </a>
      
        <a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f" class="sidebar-item">
            <span>云原生</span>
            <span>(14)</span>
        </a>
      
        <a href="/categories/ai" class="sidebar-item">
            <span>AI</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%ae%89%e5%85%a8" class="sidebar-item">
            <span>安全</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%bc%80%e6%ba%90" class="sidebar-item">
            <span>开源</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e6%97%85%e8%a1%8c" class="sidebar-item">
            <span>旅行</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e5%b7%a5%e5%85%b7" class="sidebar-item">
            <span>工具</span>
            <span>(6)</span>
        </a>
      
        <a href="/categories/%e5%8f%af%e8%a7%82%e6%b5%8b%e6%80%a7" class="sidebar-item">
            <span>可观测性</span>
            <span>(5)</span>
        </a>
  </div>
</div>

<div class="blog-categories mb-4">
  <p class="sidebar-title">
      资料
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/%e5%87%ba%e7%89%88%e7%89%a9" class="sidebar-item">
            <span>出版物</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e7%94%b5%e5%ad%90%e4%b9%a6" class="sidebar-item">
            <span>翻译电子书</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e6%96%87%e6%a1%a3" class="sidebar-item">
            <span>翻译文档</span>
            <span>(7)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>翻译图书</span>
            <span>(6)</span>
        </a>
      
        <a href="/categories/%e5%8e%9f%e5%88%9b%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>原创图书</span>
            <span>(2)</span>
        </a>
      
        <a href="/categories/%e6%95%99%e7%a8%8b%e6%89%8b%e5%86%8c" class="sidebar-item">
            <span>教程手册</span>
            <span>(2)</span>
        </a>
  </div>
</div>





          </div>
      </aside>
      <!-- /sidebar -->
    </div>
  </div>
</section>




<footer>
  
  <div class="footer bg-footer section-sm border-bottom overlay ">
    <div class="container-xl">
      <div class="row">
        <div class="col col-xl-4 d-sm-none mb-2 mb-lg-0 d-xl-block d-none">
          
          <p class="h3 text-white mb-4 text-uppercase">联系</p>
          
          <ul class="list-unstyled">
            
            
            <li class="mb-4 text-color">微信公众号</li>
            
            
            <li class="mb-4"><img src="/images/servicemesher-wechat.webp" width="118px" height="118px" alt="footer image"></li>
            
            
            
          
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">博客</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/blog/istio-ambient-l7-flow-analysis/">深入 Istio Ambient 模式：从 ztunnel 到 Waypoint 代理的 L7 流量路径解析</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/building-private-ai-knowledge-base-anythingllm/">探索 AnythingLLM：借助开源 AI 打造私有化智能知识库</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/migrate-to-istio-telemetry-api/">从 MeshConfig 迁移到 Istio Telemetry API：提升网格观测性和灵活性</a></li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">链接</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://istio.io/latest/zh/" target="_blank" rel="noopener noreferrer">
                  Istio 服务网格
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://tetrate.io/?jimmysong" target="_blank" rel="noopener noreferrer">
                  Tetrate 公司
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener noreferrer">
                  云原生学院|Bilibili
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/awesome-cloud-native/" target="_blank" rel="noopener noreferrer">
                  云原生开源项目大全
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://cloudnative.to" target="_blank" rel="noopener noreferrer">
                  云原生社区（中国）
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">教程</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/envoy-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Envoy 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/istio-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Istio 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/kubernetes-handbook/" >
                  Kubernetes 基础教程
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/envoy-made-simple/" >
                  简明 Envoy 教程
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">通知</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/notice/nist-sp-800-233-service-mesh-proxy-models/">资料分享：云原生应用服务网格代理模型的威胁分析指南</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/kubecon-china-2024-panel/">KubeCon China 2024（香港）</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/website-revamp-notice/">网站改版通知</a></li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>

  
  <div class="copyright py-4 bg-footer overlay">
    <div class="container-xl">
      <div class="row">
        <div class="col-sm-6 text-sm-left text-center">
          <p class="mb-0 text-color">© 2017-2024 Jimmy Song 保留所有权利</p>
        </div>
        <div class="col-sm-6 text-sm-right text-center">
          <ul class="list-inline">
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://twitter.com/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-x-twitter text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/contact/" >
                    <i class="fa-brands fa-weixin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://github.com/rootsongjc" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-github text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://linkedin.com/in/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-linkedin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="mailto:rootsongjc@gmail.com" >
                    <i class="fa-solid fa-envelope text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/blog/index.xml" >
                    <i class="fa-solid fa-rss text-white"></i>
              </a>
            </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>


<!-- JS Plugins -->

<script src="/plugins/popper/popper.min.js"></script>

<script src="/plugins/bootstrap/bootstrap.min.js"></script>

<script src="/plugins/slick/slick.min.js"></script>

<script src="/plugins/filterizr/jquery.filterizr.min.js"></script>

<script src="/plugins/search/fuse.min.js"></script>

<script src="/plugins/search/mark.js"></script>

<script src="/plugins/hex_md5/hex_md5.js"></script>

<script src="/plugins/anchor/anchor.min.js"></script>

<script src="/plugins/tocbot/tocbot.min.js"></script>

<script src="/plugins/bigger-picture/bigger-picture.min.js"></script>


<!-- Main Script -->

<script src="/js/script.min.f94c22b1d478bfc9e2e0a7d954429e47b7e6d36edd423758482e04154ae1842e.js"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-ESY906ZWZ0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ESY906ZWZ0');
</script>


<!-- Baidu analysis -->
<meta name="baidu-site-verification" content="g8IYR9SNLF" />





<script>
    anchors.add();
</script>






<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>










<script src="/js/wowchemy-search.min.7a37268e7bbe4a9160c2e4c33b749816.js" type="module"></script>
<script id="search-hit-fuse-template" type="text/x-template">
  <div class="search-hit" id="summary-{{key}}">
    <div class="search-hit-content border-bottom">
      <div class="search-hit-name">
        <div class='search-hit-link'><a href="{{relpermalink}}">{{title}}</a></div>
        <div class="search-hit-metadata d-flex">
            <span class="mr-1"><i class="fa-regular fa-calendar mr-1"></i>{{date}}</span>
            <span class="mr-1"><i class="fa-regular fa-folder-open mr-1"></i>{{section}}</span>
            <span class="d-sm-block d-none"><i class="fa-solid fa-link mr-1"></i>{{relpermalink}}</span>
        </div>
        <div class="search-hit-description">{{snippet}}</div>
      </div>
    </div>
  </div>
</script>



    </body>
</html>
