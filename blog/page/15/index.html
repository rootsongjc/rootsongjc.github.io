<!DOCTYPE html>
<html lang="zh"><head>
  <meta charset="utf-8">
  
  <title>博客 · Jimmy Song</title>
  

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta name="description" content="Jimmy Song 的原创博客及译文。">
  <meta name="author" content="Jimmy Song">
  <meta name="generator" content="Hugo 0.129.0">

  <!-- CSS plugins -->
  
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
  
  <link rel="preload" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" as="style">
  <link rel="stylesheet" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" media="screen">
  

  <!-- Main Stylesheet -->
  
  <link rel="preload" href="/scss/style.min.595949bd12db88434115e2a1e70965cf2928cc646e73acc6437c4cbbc323f585.css" as="style">
  <link rel="stylesheet" href="/scss/style.min.595949bd12db88434115e2a1e70965cf2928cc646e73acc6437c4cbbc323f585.css" media="screen">

  <!-- Bigger picture css -->
  
  <link rel="stylesheet" href="/plugins/bigger-picture/bigger-picture.min.css" media="print" onload="this.media='all'">
  <!--Favicon generate by https://realfavicongenerator.net-->
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="200x200" href="/images/favicon.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">

  <link href='/opensearchdescription.xml' rel='search' title='Content search' type='application/opensearchdescription+xml'/>

  <!--Twitter card-->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="jimmysong.io" />
  <meta name="twitter:creator" content="@jimmysongio" />
  <meta property="og:url" content="https://jimmysong.io/blog/" />
  <meta property="og:title" content="博客 | Jimmy Song" />
  <meta property="twitter:title" content="博客 | Jimmy Song" />

  
  <meta property="og:description" content="Jimmy Song 的原创博客及译文。" />
  <meta property="twitter:description" content="Jimmy Song 的原创博客及译文。" />

  
  <meta property="og:image" content="https://jimmysong.io/images/banner/default.jpg" />
  <meta property="twitter:image" content="https://jimmysong.io/images/banner/default.jpg" />

  
  
</head>
<body>
<header class="fixed-top header">
  
  
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa fa-arrow-circle-up" aria-hidden="true"></i></button>
  
  <div class="navigation w-100 ">
    <div class="container-xl">
      <nav class="navbar navbar-expand-lg navbar-light p-0">
        <a class="navbar-brand" href="/">
            
            <b>JIMMY SONG</b>
            
        </a>
        <button class="navbar-toggler rounded-0" type="button" data-toggle="collapse" data-target="#navigation"
          aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse text-center" id="navigation">
          <ul class="navbar-nav ml-auto">
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/blog">博客</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/book">资料</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/tags">标签</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/notice">公告</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/contact">联系</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/about">关于</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/community/">社区</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener">视频 <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i></a>
              
            </li>
            
            

          
          
          <li class="nav-item">
            
            
            
              
              
                
                
                
                  
                    
                    <a class="nav-link" href="/en/blog/">English</a>
                    
                  
                
              
              
              
                
                  
                    
                    
                  
                
                
                
              
          </li>
          
          
          <!-- search -->
           <button type="button" class="search-btn js-search" id="searchOpen" aria-label="Search">
              <div class="search-container d-flex justify-content-center">
              <span class="search-content">
                  <i class="fa fa-search"></i>
                  <span>搜索</span>
              </span>
              <span class="search-shortcuts d-none d-sm-block">
                  <kbd class="cmd-key">⌘</kbd>
                  <kbd class="k-key">K</kbd>
              </span>
              </div>
          </button>
          
          </ul>
        </div>
      </nav>
    </div>
  </div>
</header>


            <aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between">
        <div class="col-6 search-title">
          <p>站内搜索</p> 
        </div>
        <div class="col-6 col-search-close">
          <div class="js-search" aria-label="关闭"><i class="fa-solid fa-circle-xmark text-muted" aria-hidden="true"></i></div>
        </div>
      </div>

      <div id="search-box">
        <i class="fa-solid fa-magnifying-glass" id="search-icon" aria-hidden="true"></i>
        <input name="q" id="search-query" placeholder="请输入搜索词" autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control" aria-label="请输入搜索词">
        
        <div class="mt-4">
          <span>搜索类型: </span>
          <span>
            <input type="radio" id="all" name="search_type" value="all" checked>
            <label for="all">所有</label>
            
              <input type="radio" id="blog" name="search_type" value="blog">
              <label for="blog">原创</label>
              <input type="radio" id="trans" name="search_type" value="trans">
              <label for="trans">译文</label>
            
            <input type="radio" id="book" name="search_type" value="book">
            <label for="book">资料</label>
            <input type="radio" id="notice" name="search_type" value="notice">
            <label for="notice">公告</label>
          </span>
        </div>
      </div>
      
    </section>
    <section class="section-search-results">
      <div id="search-results-count" class="search-results-count"></div>
      <div id="search-hits">
        
      </div>
    </section>
  </div>
</aside>

        
        
            

<section class="bg-cover page-title-section overlay" style="background-image: url('/images/backgrounds/circle.svg'),url('/images/backgrounds/page-title.webp');background-size: cover;">
    <div class="container-xl">
        <div class="row">
            <div class="col-12">
                <p class="h1">
                    博客
                </p>
                <p class="page-description">
                    Jimmy Song 的原创博客及译文。
                </p>
                
            </div>
        </div>
    </div>
</section>

        


<section class="section-sm book-list-section bg-gray">
  <div class="container-xl">
    <div class="row">
      <div class="col-lg-8 order-2 order-lg-1">
        <div class="row">
          
          
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/ebpf-sidecar-and-service-mesh/">请暂时抛弃使用 eBPF 取代服务网格和 sidecar 模式的幻想</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/06/11</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('请暂时抛弃使用 eBPF 取代服务网格和 sidecar 模式的幻想', '不管有没有 eBPF，在可预见的未来，服务网格都会基于运行在用户空间的 sidecar 代理（proxyless 模式除外）。', '\n最近 eBPF 技术在云原生社区中持续火热，在我翻译了《[什么是 eBPF](https:\/\/jimmysong.io\/book\/what-is-ebpf\/)》之后，当阅读“云原生环境中的 eBPF”之后就一直在思考 eBPF 在云原生环境中究竟处于什么地位，发挥什么样的作用。当时我评论说“eBPF 开启了上帝视角，可以看到主机上所有的活动，而 sidecar 只能观测到 pod 内的活动，只要搞好进程隔离，基于 eBPF 的 proxy per-node 才是最佳选择”，再看到 William Morgan 的[这篇文章](https:\/\/buoyant.io\/2022\/06\/07\/ebpf-sidecars-and-the-future-of-the-service-mesh\/) [^1]之后，让我恍然大悟。下面节选翻译了文章我比统同意的观点，即 eBPF 无法替代服务网格和 sidecar，感兴趣的读者可以阅读 William 的原文。\n\n## 什么是 eBPF\n\n在过去，如果你想让应用程序处理网络数据包，那是不可能的。因为应用程序运行在 Linux 用户空间，它是不能直接访问主机的网络缓冲区。缓冲区是由内核管理的，受到内核保护，内核需要确保进程隔离，进程之间不能直接读取对方的网络数据包。正确的做法是，应用程序通过系统调用（syscall）来请求网络数据包信息，这本质上是内核 API 调用——应用程序调用 syscall，内核检查应用程序是否有权限获得其请求的数据包；如果有，就把返回数据包。\n\n有了 eBPF 之后，应用程序不再需要 syscall，数据包不需要在内核空间和用户空间之间来回交互传递。而是我们将代码直接交给内核，让内核自己执行，这样就可以让代码全速运行，效率更高。eBPF 允许应用程序和内核以安全的方式共享内存，eBPF 允许应用程序直接向内核提交代码，目标都是通过超越系统调用的方式来实现性能提升。\n\neBPF 不是银弹，你不能用 eBPF 运行任意程序，实际上 eBPF 可以做的事情是非常有限的。\n\n## eBPF 的局限性\n\neBPF 的局限性也是因为内核造成的。内核中运行的应用程序应当有自己的租户，这些租户之间会争抢系统的内存、磁盘和网络，内核的职责就是隔离和调度这些应用程序的资源，同时内核还要保护确认应用程序的权限，保护其不被其他程序破坏。\n\n因为我们直接将 eBPF 代码交给内核执行，这绕过了内核安全保护（如 syscall），内核将面临直接的安全风险。为了保护内核，所有 eBPF 程序要想运行都必须先通过一个**验证器**。但是要想自动验证程序是很困难的，验证器可能会过度限制程序的功能。比如 eBPF 程序不能是阻塞的，不能有无限循环，不能超过预定的大小；其复杂性也受到限制，验证器会评估所有可能的执行路径，如果 eBPF 程序不能在某些范围内完成，或者不能证明每个循环都有一个退出条件，那么验证器就不会允许该程序运行。有很多应用程序都违反了这些限制，要想将它们作为 eBPF 程序来运行的话，要么重写以满足验证器的需求，要么给内核打补丁，来绕过一些验证（这可能比较困难）。不过随着内核版本的升级，这些验证器也变得更加智能，限制也逐渐变得宽松，也有一些创造性的方法来绕过这些限制。\n\n但总的来说，eBPF 程序能做的事情非常有限。对于一些重量级事件的处理，例如处理全局范围内的 HTTP\/2 流量，或者 TLS 握手协商不能在纯 eBPF 环境中完成。充其量，eBPF 可以做其中的一小部分工作，然后调用用户空间应用程序来处理对于 eBPF 来说过于复杂而无法处理的部分。\n\n## eBPF 与服务网格的关系\n\n因为上文所述的 eBPF 的各项限制，七层流量仍然需要用户空间的网络代理来完成，eBPF 并不能替代服务网格。eBPF 可以与 CNI（容器网络接口）一起运行，处理三层\/四层流量，而服务网格处理七层流量。\n\n## 每个主机一个代理的模式比 sidecar 更糟\n\n对于每个主机一个代理（per-host）的模式，服务网格的早期实践者 Linkerd 1.x 就是这么用的，笔者也是从那个时候开始关注服务网格，Linkerd 1.x 还使用了 JVM 虚拟机！但是经过 Linkerd 1.x 的用户实践证明，这种模式相对于 sidecar 模式，对于运维和安全来说会更糟糕。\n\n为什么说 sidecar 模式比 per-host 模式更好呢？因为 sidecar 模式有以下几个优势，这是 per-host 模式所不具备的：\n\n1. 代理的资源消耗随着应用程序的负载而变化。随着实例流量的增加，sidecar 会消耗更多的资源，就像应用程序一样。如果应用程序的流量非常小，那么 sidecar 就不需要消耗很多资源。Kubernetes 现有的管理资源消耗的机制，如资源请求和限制以及 OOM kill，都会继续工作。\n2. 代理失败的爆炸半径只限于一个 pod。代理失败与应用失败相同，由 Kubernetes 负责处理失败的 pod。\n3. 代理维护。例如代理版本的升级，是通过如滚动更新，灰度发布等应用程序本身相同的机制完成的。\n4. 安全边界很清楚（而且很小）：在 pod 级别。Sidecar 在应用程序实例的同一安全上下文中运行。它是 pod 的一部分，与应用程序具有一样的 IP 地址。Sidecar 执行策略，并将 mTLS 应用于进出该 pod 的流量，而且它只需要该 pod 的密钥。\n\n而对于 per-host 模式，就没有上述好处了。代理与应用程序 pod 完全解耦，处理主机上所有 pod 的流量，这样会代理各种问题：\n\n1. 代理消耗的资源是高度可变的，这取决于在某个时间点 Kubernetes 调度了多少个 pod 在该主机上。你无法有效的预测特定代理的资源消耗情况，这样代理就有崩溃的风险（原文是这么说的，这点笔者还是存疑的，希望有点读者能解帮忙解释下）。\n2. 主机上 pod 之间的流量争抢问题。因为主机上的所有流量都经过同一个代理，如果有一个应用程序 pod 的流量极高，消耗了代理的所有资源，主机上的其他应用程序就有被饿死的危险。\n3. 代理的爆炸半径很大，而且是不断变化的。代理的故障和升级现在影响到随机的应用程序集合中的一个随机的 pod 子集，意味着任何故障或维护任务都有难以预测的风险。\n4. 使得安全问题更加复杂。以 TLS 为例，主机上的代理必须包含该主机上所有应用程序的密钥，这使得它成为一个新的攻击媒介，容易受到[混淆代理](https:\/\/en.wikipedia.org\/wiki\/Confused_deputy_problem)问题的影响——代理中的任何 CVE 或漏洞都是潜在的密钥泄露风险。\n\n简而言之，sidecar 模式继续贯彻了容器级别的隔离保护——内核可以在容器级别执行所有安全保护和公平的多租户调度。容器的隔离仍然可以完美的运行，而 per-host 模式却破坏了这一切，重新引入了争抢式的多租户隔离问题。\n\n当然 per-host 也不是一无是处，该模式最大的好处是可以成数量级的减少代理的数量，减少网络跳数，这也就减少了资源消耗和网络延迟。但是与该模式带来的运维和安全性问题相比，这些优势都是次要的。我们也可以通过持续优化 sidecar 来弥补 sidecar 模式在这方面的不足，而 per-host 模式的缺陷确是致命性的。\n\n其实归根结底还是回到了争抢式多租户问题上，那么能否利用现有的内核解决方案，改进一下 per-host 模式中的代理，让其支持多租户呢？比如改造 Envoy 代理，使其支持多租户模式。虽然从理论来说这是可行的，但是工作量巨大，Matt Klein 也觉得不值得这样做 [^2]，还不如使用容器来实现租户隔离。而且即使让 per-host 模式中的代理支持了多租户，仍然还有爆炸半径和安全问题需要解决。\n\n## 总结\n\n不管有没有 eBPF，在可预见的未来，服务网格都会基于运行在用户空间的 sidecar 代理（proxyless 模式除外）。Sidecar 模式虽然也有弊端，但它依然是既能保持容器隔离和操作的优势，又能处理云原生网络复杂性的最优方案。eBPF 的能力将来是否会发展到可以处理七层网络流量，从而替代服务网格和 sidecar，也许吧，但那一天可能很遥远。\n\n## 参考\n\n[^1]: William Morgan 的 [eBPF, sidecars, and the future of the service mesh](https:\/\/buoyant.io\/2022\/06\/07\/ebpf-sidecars-and-the-future-of-the-service-mesh\/) 这篇文章正好回答了我的关于 eBPF、sidecar 的疑问。\n[^2]: 关于 per-host 模式中的代理改造问题，Twitter 上有一个精彩的[讨论](https:\/\/twitter.com\/mattklein123\/status\/1522925333053272065)。\n', '\/blog\/ebpf-sidecar-and-service-mesh\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">不管有没有 eBPF，在可预见的未来，服务网格都会基于运行在用户空间的 sidecar 代理（proxyless 模式除外）。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/oss-insight/">开源项目千千万，如何发现好项目？</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/06/02</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e9%9a%8f%e7%ac%94"> 
             随笔
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('开源项目千千万，如何发现好项目？', '推荐一个 PingCAP 推出的 OSSInsight.io 网站，可以根据 GitHub 上的事件，提供开源软件洞察，这个项目本身也开源在 GitHub 上。', '\n不知道大家听说没有 PingCAP 推出的一个 OSSInsight.io 网站，可以根据 GitHub 上的事件，提供开源软件洞察，这个项目也开源在 [GitHub](https:\/\/github.com\/pingcap\/ossinsight) 上。它可以提供以下方面的洞察能力，有点类似于 Google Analytics、Trends：\n\n- 比较 GitHub 仓库历史 Star 趋势图\n- 开发者地理位置分布\n- 开发者贡献时间热力图\n- 编码活力，如每月 PR 数量、代码行数变化\n- 分类趋势排名\n\n## 网站截图\n\n以下图片来自 [OSSInsight 博客](https:\/\/ossinsight.io\/blog\/explore-deep-in-4.6-billion-github-events\/)，展示了该网站的一些功能。\n\n![Kubernetes 和 Moby 的标记 star 的人员地理分布](e6c9d24ely1h2trup1v5bj20k00c5my9.jpg)\n\n![K8s（上）和 Moby（下）的月度推送和提交](e6c9d24ely1h2trw4iqpyj20wn0gvgnp.jpg)\n\n![分类排名](e6c9d24ely1h2ts5cig5kj21mw0u00xv.jpg)\n\n你可以在首页输入一个 GitHub 仓库，查看该仓库的一些洞察信息。我查看了我的 [\u0060rootsongjc\/kubernetes-handbook\u0060](https:\/\/github.com\/rootsongjc\/kubernetes-handbook\/) 之后，发现它还以获得关注者的公司信息，如下图。\n\n![rootsongjc\/kubernetes-handbook 关注者的公司分布](e6c9d24ely1h2trz8bpqfj21di0u0gq4.jpg)\n\n这个网站有点类似于 CNCF 推出的 [DevStats](https:\/\/devstats.cncf.io\/)，不过 DevStats 只能洞察 CNCF 托管的项目。\n\n![DevStats 页面](e6c9d24ely1h2ts2o2rirj21mw0u00zv.jpg)\n\n## 评论\n\nOSSInsight 也可以算是 CHAOSS 类软件的一种，比如 Linux 基金会下的 CHAOSS（Community Health Analytics Open Source Software）工作组有一个开源项目 [GrimoireLab](https:\/\/chaoss.github.io\/grimoirelab\/) 就是做软件开发分析的。\n\n![GrimoireLab 网站页面](e6c9d24ely1h2ts7e6aiuj21ml0u078o.jpg)\n\n如果你关注开源和技术趋势的话，网上还有一些类似的 GitHub 趋势网站，大家可以根据自己的需要选用。\n', '\/blog\/oss-insight\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">推荐一个 PingCAP 推出的 OSSInsight.io 网站，可以根据 GitHub 上的事件，提供开源软件洞察，这个项目本身也开源在 GitHub 上。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/goodbye-katacoda/">再见 KataCoda！</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/06/01</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e9%9a%8f%e7%ac%94"> 
             随笔
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('再见 KataCoda！', 'O\u0027Reilly 宣布将于 6 月 15 日关闭在线学习网站 KataCoda。', '\n{{\u003cfigure src=\u0022katacoda-logo.webp\u0022 title=\u0022Katacoda Logo\u0022 class=\u0022mx-auto text-center\u0022\u003e}}\n\n近日听闻 O\u0027Reilly 将永久关闭在线学习网站 KataCoda，对于广大程序员和学习者来说，这无疑是一件痛心疾首的事情，以后我们再也看不到那只会变成的功夫猫了。\n\n## KataCoda 简介\n\nKataCoda 成立于 2016 年，它是一个在线学习平台，提供了上百个交互课程，用户可以登录免费学习。另外用户还可以基于 KataCoda 提供的基础镜像来构建和发布自己的在线课程，这一切都是免费的。\n\n你可以根据提示，在一个临时的容器环境中操作，输入命令、观察结果，这种实时的反馈式学习方式，让你不需要再为准备环境而操心，大大降低了众多技术的上手门槛，可以说这种方式对于计算机技术教育来说是一种“革命式”的。\n\n![KataCoda 网站界面](katacoda-ui.jpg)\n\n这些交互环境没有任何网络限制，你可以访问任何网站，还可以构建临时的公开网站让互联网中的所有用户访问。这种便利可以说是云原生或者容器时代赋予我们的，\n\n## O\u0027Reilly 为什么关闭 KataCoda？\n\nO\u0027Reilly 与 2019 年底收购了 KataCoda，如今关闭该网站应该也实属无奈。在 O\u0027Reilly 官网发布的 [仅在 O\u0027Reilly 内部利用 Katacoda 技术以及关闭  katacoda.com 的决定](https:\/\/www.oreilly.com\/online-learning\/leveraging-katacoda-technology.html) 这篇博客中，我们可以获得以下数据：\n\n- KataCoda 有 28 万会员\n- KataCoda 上有超过 387,866 名独立用户已花费超过 74,711 小时在平台上学习\n- O\u0027Reilly 有 280 万会员\n\n以上数据仍然无法支撑 KataCoda 高昂的运营成本，主要是因为免费课程被滥用，比如用来挖矿，发送不良信息（所有免费课程连接互联网没有任何限制而且网速极快）。\n\n## KataCoda 关闭之后怎么办？\n\nKataCoda 上的很多免费课程其实都有在 GitHub 上开源，只有有另一个平台来托管，这些课程就可以继续使用。KataCoda 关闭后，还有众多交互式课程平台可以选择，比如下面这两个：\n\n- [Killercoda](https:\/\/killercoda.com\/)\n- [CloudYuga](https:\/\/cloudyuga.guru\/)\n- [Instruqt](https:\/\/instruqt.com\/)\n\n关于 O\u0027Reilly 关闭 KataCoda 你有什么想法，欢迎在下面留言评论。\n', '\/blog\/goodbye-katacoda\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">O&#39;Reilly 宣布将于 6 月 15 日关闭在线学习网站 KataCoda。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/how-to-build-istio/">如何编译 Istio？</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/05/15</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('如何编译 Istio？', '本文将指导你如何在 macOS 上编译 Istio。', '\n本文将指导你如何在 macOS 上编译 Istio 二进制文件和 Docker 镜像。\n\n## 构建前的准备\n\n在正式开始构建前，[参考这篇文档](https:\/\/github.com\/istio\/istio\/wiki\/Preparing-for-Development-Mac) ，以下是我的构建环境信息：\n\n- macOS 12.3.1 Darwin AMD64\n- Docker Desktop 4.8.1(78998)\n- Docker Engine v20.10.14\n\n## 开始构建\n\n参考[这篇文档](https:\/\/github.com\/istio\/istio\/wiki\/Using-the-Code-Base) 编译 Istio。\n\n首先在 [GitHub 上](https:\/\/github.com\/istio\/istio) 下载 Istio 代码，将代码下载到 \u0060$GOPATH\/src\/istio.io\/istio\u0060 目录下，下文中的命令都在该根目录下执行。\n\n### 编译成二进制文件\n\n执行下面的命令下载 Istio 依赖的包，这些包将下载到 \u0060vendor\u0060 目录下：\n\n\u0060\u0060\u0060bash\ngo mod vendor\n\u0060\u0060\u0060\n\n然后执行下面的命令构建 Istio：\n\n\u0060\u0060\u0060bash\nsudo make build\n\u0060\u0060\u0060\n\n如果你没有在命令前加 \u0060sudo\u0060，你可能遇到下面的错误：\n\n\u0060\u0060\u0060bash\nfatal: unsafe repository (\u0027\/work\u0027 is owned by someone else)\nTo add an exception for this directory, call:\n\n\tgit config --global --add safe.directory \/work\nfatal: unsafe repository (\u0027\/work\u0027 is owned by someone else)\nTo add an exception for this directory, call:\n\n\tgit config --global --add safe.directory \/work\nMakefile.core.mk:170: *** \u0022TAG cannot be empty\u0022.  Stop.\nmake: *** [build] Error 2\n\u0060\u0060\u0060\n\n即使你按照提示执行了 \u0060git config --global --add safe.directory \/work\u0060 在编译过程中还是会出现错误。\n\n构建完的二进制文件将保存在 \u0060out\u0060 目录下，其目录结构如下：\n\n\u0060\u0060\u0060bash\nout\n├── darwin_amd64\n│   ├── bug-report\n│   ├── client\n│   ├── envoy\n│   ├── extauthz\n│   ├── install-cni\n│   ├── istio-cni\n│   ├── istio-cni-taint\n│   ├── istio-iptables\n│   ├── istio_is_init\n│   ├── istioctl\n│   ├── logs\n│   ├── operator\n│   ├── pilot-agent\n│   ├── pilot-discovery\n│   ├── release\n│   └── server\n└── linux_amd64\n    ├── envoy\n    ├── envoy-centos\n    ├── logs\n    └── release\n\u0060\u0060\u0060\n\n同时构建出了 \u0060linux_amd64\u0060 和 \u0060darwin_amd64\u0060 架构的二进制文件。\n\n### 编译成 Docker 镜像\n\n执行下面的将 Istio 编译成 Docker 镜像：\n\n\u0060\u0060\u0060bash\nsudo make docker\n\u0060\u0060\u0060\n\n编译根据你的网络情况，大概耗时 3 到 5 分钟。编译完成后，执行下面的命令你将看到 Istio 的 Docker 镜像。\n\n\u0060\u0060\u0060bash\n$ docker images\nREPOSITORY                                         TAG                          IMAGE ID       CREATED              SIZE\nlocalhost:5000\/app_sidecar_centos_7                latest                       2044037df94b   51 seconds ago       524MB\nlocalhost:5000\/app_sidecar_ubuntu_jammy            latest                       5d8ae5ed55b7   About a minute ago   362MB\nlocalhost:5000\/proxyv2                             latest                       d4679412385f   About a minute ago   243MB\nlocalhost:5000\/install-cni                         latest                       78f46d5771d2   About a minute ago   270MB\nlocalhost:5000\/istioctl                            latest                       c38130a5adc8   About a minute ago   190MB\nlocalhost:5000\/pilot                               latest                       2aa9185ec202   About a minute ago   190MB\nlocalhost:5000\/app                                 latest                       473adafaeb8d   About a minute ago   188MB\nlocalhost:5000\/operator                            latest                       9ac1fedcdd12   About a minute ago   191MB\nlocalhost:5000\/ext-authz                           latest                       1fb5aaf20791   About a minute ago   117MB\nlocalhost:5000\/app_sidecar_debian_11               latest                       61376a02b95d   2 minutes ago        407MB\nlocalhost:5000\/app_sidecar_ubuntu_xenial           latest                       7e8efe666611   2 minutes ago        418MB\n\u0060\u0060\u0060\n\n编译出镜像以后，你就可以修改镜像名字并推送到自己的镜像仓库里了。\n\n## 总结\n\n以上就是在 macOS 上构建 Istio 的过程，如果你已经下载好了构建所需要的的 Docker 镜像，那么构建时间将不超过一分钟，构建 Docker 镜像也只需要几分钟时间。\n\n## 参考\n\n- [Using the Code Base - github.com](https:\/\/github.com\/istio\/istio\/wiki\/Using-the-Code-Base)\n', '\/blog\/how-to-build-istio\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文将指导你如何在 macOS 上编译 Istio。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/validating-a-request-payload-with-wasm/">[译] 使用 WebAssembly 验证请求负载</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/05/13</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://www.tetrate.io/blog/validating-a-request-payload-with-wasm/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('使用 WebAssembly 验证请求负载', '本文是一个开发 Wasm 插件验证请求负载的教程。', '\n## 什么是 Wasm 插件？\n\n你可以使用 Wasm 插件在数据路径上添加自定义代码，轻松地扩展服务网格的功能。可以用你选择的语言编写插件。目前，有 AssemblyScript（TypeScript-ish）、C\u002b\u002b、Rust、Zig 和 Go 语言的 Proxy-Wasm SDK。\n\n在这篇博文中，我们描述了如何使用 Wasm 插件来验证一个请求的有效载荷。这是 Wasm 与 Istio 的一个重要用例，也是你可以使用 Wasm 扩展 Istio 的许多方法的一个例子。您可能有兴趣阅读我们关于[在 Istio 中使用 Wasm 的博文](https:\/\/www.tetrate.io\/blog\/category\/wasm\/)，并观看我们关于在 Istio 和 Envoy 中使用 Wasm 的免费研讨会的录音。\n\n## 何时使用 Wasm 插件？\n\n当你需要添加 Envoy 或 Istio 不支持的自定义功能时，你应该使用 Wasm 插件。使用 Wasm 插件来添加自定义验证、认证、日志或管理配额。\n\n在这个例子中，我们将构建和运行一个 Wasm 插件，验证请求 body 是 JSON，并包含两个必要的键 ——\u0060id\u0060 和 \u0060token\u0060。\n\n## 编写 Wasm 插件\n\n这个示例使用 [tinygo](https:\/\/tinygo.org\/) 来编译成 Wasm。确保你已经安装了 [tinygo 编译器](https:\/\/tinygo.org\/getting-started\/install\/)。\n\n### 配置 Wasm 上下文\n\n首先配置 Wasm 上下文，这样 tinygo 文件才能操作 HTTP 请求：\n\n\u0060\u0060\u0060go\npackage main\n\nimport (\n\t\u0022github.com\/tetratelabs\/proxy-wasm-go-sdk\/proxywasm\u0022\n\t\u0022github.com\/tetratelabs\/proxy-wasm-go-sdk\/proxywasm\/types\u0022\n\t\u0022github.com\/tidwall\/gjson\u0022\n)\n\nfunc main() {\n\t\/\/ SetVMContext 是配置整个 Wasm VM 的入口。请确保该入口在 main 函数中调用，否则 VM 将启动失败。\n\tproxywasm.SetVMContext(\u0026vmContext{})\n}\n\n\/\/ vmContext 实现 proxy-wasm-go SDK 的 types.VMContext 接口。\ntype vmContext struct {\n\t\/\/ 在这里嵌入默认的虚拟机环境，我们不需要实现所有方法。\n\ttypes.DefaultVMContext\n}\n\n\/\/ 复写 types.DefaultVMContext\nfunc (*vmContext) NewPluginContext(contextID uint32) types.PluginContext {\n\treturn \u0026pluginContext{}\n}\n\n\/\/ pluginContext 实现 proxy-wasm-go SDK 的 types.PluginContext 接口\ntype pluginContext struct {\n\t\/\/ 在这里侵入默认的插件上下文，我们不需要实现所有方法。\n\ttypes.DefaultPluginContext\n}\n\n\/\/ 复写 types.DefaultPluginContext\nfunc (ctx *pluginContext) NewHttpContext(contextID uint32) types.HttpContext {\n\treturn \u0026payloadValidationContext{}\n}\n\n\/\/ payloadValidationContext 实现 proxy-wasm-go SDK 的 types.HttpContext 接口\ntype payloadValidationContext struct {\n\t\/\/ 在这里嵌入默认的根 http 上下文，我们不需要实现所有方法。\n\ttypes.DefaultHttpContext\n\ttotalRequestBodySize int\n}\n\u0060\u0060\u0060\n\n### 验证负载\n\n内容类型头是通过实现 \u0060OnHttpRequestHeaders\u0060 来验证的，一旦从客户端收到请求头，就会调用该头。\n\n\u0060proxywasm.SendHttpResponse\u0060 用于响应 403 forbidden 的错误代码和信息，如果内容类型丢失的话。\n\n\u0060\u0060\u0060go\nfunc (ctx *payloadValidationContext) OnHttpRequestHeaders(numHeaders int, endOfStream bool) types.Action {\n\tcontentType, err := proxywasm.GetHttpRequestHeader(\u0022content-type\u0022)\n\tif err != nil || contentType != \u0022application\/json\u0022 {\n\t\t\/\/ 如果 header 没有期望的 content type，返回 403 响应\n\t\tif err := proxywasm.SendHttpResponse(403, nil, []byte(\u0022content-type must be provided\u0022), -1); err != nil {\n\t\t\tproxywasm.LogErrorf(\u0022failed to send the 403 response: %v\u0022, err)\n\t\t}\n\t\t\/\/ 终止 ActionPause 对流量的进一步处理\n\t\treturn types.ActionPause\n\t}\n\n\t\/\/ ActionContinue 让主机继续处理 body\n\treturn types.ActionContinue\n}\n\u0060\u0060\u0060\n\n请求主体是通过实现 \u0060OnHttpRequestBody\u0060 来验证的，每次从客户端接收到请求的一个块时，都会调用该请求。这是通过等待直到 \u0060endOfStream\u0060 为真并记录所有收到的块的总大小来完成的。一旦收到整个主体，就会使用 \u0060proxywasm.GetHttpRequestBody\u0060 读取，然后可以使用 golang 进行验证。\n\n这个例子使用 \u0060gjson\u0060，因为 tinygo 不支持 golang 的默认 JSON 库。它检查有效载荷是否是有效的 JSON，以及键 \u0060id\u0060 和 \u0060token\u0060 是否存在。\n\n\u0060\u0060\u0060go\nfunc (ctx *payloadValidationContext) OnHttpRequestBody(bodySize int, endOfStream bool) types.Action {\n\tctx.totalRequestBodySize \u002b= bodySize\n\tif !endOfStream {\n\t\t\/\/ OnHttpRequestBody 等待收到到 body 的全部才开始处理。\n\t\treturn types.ActionPause\n\t}\n\n\tbody, err := proxywasm.GetHttpRequestBody(0, ctx.totalRequestBodySize)\n\tif err != nil {\n\t\tproxywasm.LogErrorf(\u0022failed to get request body: %v\u0022, err)\n\t\treturn types.ActionContinue\n\t}\n\n\tif !validatePayload(body) {\n\t\t\/\/ 如果验证失败，发送 403 响应。\n\t\tif err := proxywasm.SendHttpResponse(403, nil, []byte(\u0022invalid payload\u0022), -1); err != nil {\n\t\t\tproxywasm.LogErrorf(\u0022failed to send the 403 response: %v\u0022, err)\n\t\t}\n\t\t\/\/ 终止流量\n\t\treturn types.ActionPause\n\t}\n\n\treturn types.ActionContinue\n}\n\n\/\/ validatePayload 验证给定的 json 负载\n\/\/ 注意该函数使用 gjson 解析 json，因为 TinyGo 不支持 encoding\/json\nfunc validatePayload(body []byte) bool {\n\tif !gjson.ValidBytes(body) {\n\t\tproxywasm.LogErrorf(\u0022body is not a valid json: %v\u0022, body)\n\t\treturn false\n\t}\n\tjsonData := gjson.ParseBytes(body)\n\n\t\/\/ 验证 json。检查示例中是否存在必须的键\n\tfor _, requiredKey := range []string{\u0022id\u0022, \u0022token\u0022} {\n\t\tif !jsonData.Get(requiredKey).Exists() {\n\t\t\tproxywasm.LogErrorf(\u0022required key (%v) is missing: %v\u0022, requiredKey, jsonData)\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\u0060\u0060\u0060\n\n### 编译成 Wasm\n\n使用 tinygo 编译器编译成 Wasm：\n\n\u0060\u0060\u0060bash\ntinygo build -o main.wasm -scheduler=none -target=wasi main.go\n\u0060\u0060\u0060\n\n## 部署 Wasm 插件\n\n### 打包到 Docker 中部署到 Envoy\n\n对于开发，这个插件可以在 Docker 中部署到 Envoy。下面的 Envoy 配置文件将设置 Envoy 监听 \u0060localhost:18000\u0060，运行所提供的 Wasm 插件，并在成功后响应 HTTP 200 和文本 \u0060hello from server\u0060。突出显示的部分是配置 Wasm 插件。\n\n\u0060\u0060\u0060yaml\nstatic_resources:\n  listeners:\n    - name: main\n      address:\n        socket_address:\n          address: 0.0.0.0\n          port_value: 18000\n      filter_chains:\n        - filters:\n            - name: envoy.http_connection_manager\n              typed_config:\n                \u0022@type\u0022: type.googleapis.com\/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager\n                stat_prefix: ingress_http\n                codec_type: auto\n                route_config:\n                  name: local_route\n                  virtual_hosts:\n                    - name: local_service\n                      domains:\n                        - \u0022*\u0022\n                      routes:\n                        - match:\n                            prefix: \u0022\/\u0022\n                          route:\n                            cluster: web_service\n \n                http_filters:\n                 - name: envoy.filters.http.wasm\n                    typed_config:\n                      \u0022@type\u0022: type.googleapis.com\/udpa.type.v1.TypedStruct\n                      type_url: type.googleapis.com\/envoy.extensions.filters.http.wasm.v3.Wasm\n                      value:\n                        config:\n                          vm_config:\n                            runtime: \u0022envoy.wasm.runtime.v8\u0022\n                            code:\n                              local:\n                                filename: \u0022.\/main.wasm\u0022\n                  - name: envoy.filters.http.router\n\n    - name: staticreply\n      address:\n        socket_address:\n          address: 127.0.0.1\n          port_value: 8099\n      filter_chains:\n        - filters:\n            - name: envoy.http_connection_manager\n              typed_config:\n                \u0022@type\u0022: type.googleapis.com\/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager\n                stat_prefix: ingress_http\n                codec_type: auto\n                route_config:\n                  name: local_route\n                  virtual_hosts:\n                    - name: local_service\n                      domains:\n                        - \u0022*\u0022\n                      routes:\n                        - match:\n                            prefix: \u0022\/\u0022\n                          direct_response:\n                            status: 200\n                            body:\n                              inline_string: \u0022hello from the server\\n\u0022\n                http_filters:\n                  - name: envoy.filters.http.router\n                    typed_config: {}\n\n  clusters:\n    - name: web_service\n      connect_timeout: 0.25s\n      type: STATIC\n      lb_policy: ROUND_ROBIN\n      load_assignment:\n        cluster_name: mock_service\n        endpoints:\n          - lb_endpoints:\n              - endpoint:\n                  address:\n                    socket_address:\n                      address: 127.0.0.1\n                      port_value: 8099\n\nadmin:\n  access_log_path: \u0022\/dev\/null\u0022\n  address:\n    socket_address:\n      address: 0.0.0.0\n      port_value: 8001\n\u0060\u0060\u0060\n\n运行 Docker 容器：\n\n\u0060\u0060\u0060bash\ndocker run --rm -p 18000:18000 \\\n  -v $PWD\/envoy.yaml:\/envoy.yaml \\\n  -v $PWD\/main.wasm:\/main.wasm \\\n  --entrypoint envoy containers.istio.tetratelabs.com\/proxyv2:1.9.7-tetrate-v0 \\\n  -l debug \\\n  -c \/envoy.yaml\n\u0060\u0060\u0060\n\n通过 curl 测试。首先，没有设置内容类型，将返回 403：\n\n\u0060\u0060\u0060bash\n% curl -i -X POST localhost:18000\nHTTP\/1.1 403 Forbidden\ncontent-length: 29\ncontent-type: text\/plain\ndate: Sun, 13 Mar 2022 22:13:37 GMT\nserver: envoy\n\ncontent-type must be provided\n\u0060\u0060\u0060\n\n然后，请求 body 不是 JSON，同样返回 403。\n\n\u0060\u0060\u0060bash\n% curl -i -X POST localhost:18000 -H \u0027Content-Type: application\/json\u0027 --data \u0027not JSON\u0027\nHTTP\/1.1 403 Forbidden\ncontent-length: 15\ncontent-type: text\/plain\ndate: Sun, 13 Mar 2022 22:15:53 GMT\nserver: envoy\n\ninvalid payload\n\u0060\u0060\u0060\n\nJSON 负载中没有 \u0060token\u0060 字段，还是返回 403。\n\n\u0060\u0060\u0060bash\n% curl -i -X POST localhost:18000 -H \u0027Content-Type: application\/json\u0027 --data \u0027{\u0022id\u0022: \u0022xxx\u0022}\u0027\nHTTP\/1.1 403 Forbidden\ncontent-length: 15\ncontent-type: text\/plain\ndate: Sun, 13 Mar 2022 22:17:18 GMT\nserver: envoy\n\ninvalid payload\n\u0060\u0060\u0060\n\n当 id 和 token 字段都被提供时，将返回一个成功的响应。\n\n\u0060\u0060\u0060bash\n% curl -i -X POST localhost:18000 -H \u0027Content-Type: application\/json\u0027 --data \u0027{\u0022id\u0022: \u0022xxx\u0022, \u0022token\u0022: \u0022xxx\u0022, \u0022anotherField\u0022: \u0022yyy\u0022}\u0027\nHTTP\/1.1 200 OK\ncontent-length: 22\ncontent-type: text\/plain\ndate: Sun, 13 Mar 2022 22:18:37 GMT\nserver: envoy\nx-envoy-upstream-service-time: 1\n\nhello from the server\n\u0060\u0060\u0060\n\n## 部署到 Istio\n\n### 部署 Istio 和 httpbin 示例应用\n\n我们使用 [kind](https:\/\/kind.sigs.k8s.io\/) 来创建测试集群，对于其他方式创建的 Kubernetes 集群同样适用。\n\n\u0060\u0060\u0060bash\nkind create cluster\n\u0060\u0060\u0060\n\n集群创建完毕后，安装 Istio，我们使用的是 Istio 1.12.3，安装 [Istio httpbin 示例应用](https:\/\/github.com\/istio\/istio\/tree\/master\/samples\/httpbin)。\n\n\u0060\u0060\u0060bash\nistioctl install --set profile=demo\nkubectl label namespace default istio-injection=enabled\nkubectl apply -f https:\/\/raw.githubusercontent.com\/istio\/istio\/release-1.12\/samples\/httpbin\/httpbin.yaml\nkubectl apply -f https:\/\/raw.githubusercontent.com\/istio\/istio\/release-1.12\/samples\/httpbin\/httpbin-gateway.yaml\n\u0060\u0060\u0060\n\n在另一个终端中，将 Ingress 网关的 80 端口转发到你本地机器的 8080 端口上。\n\n\u0060\u0060\u0060bash\nkubectl port-forward -n istio-system svc\/istio-ingressgateway 8080:80\n\u0060\u0060\u0060\n\n发送 curl 请求，检查服务是否正常启动，你应该应该看到成功的响应。\n\n\u0060\u0060\u0060bash\ncurl -X POST -i http:\/\/localhost:8080\/post\n\u0060\u0060\u0060\n\n有两种方式在 Istio 中安装 Wasm 模块：\n\n1. 对于 Istio 1.12 和更新版本的 Istio，支持 [WasmPlugin](https:\/\/istio.io\/latest\/docs\/reference\/config\/proxy_extensions\/wasm-plugin\/) 资源\n2. 对于老版本的 Istio，可以使用 [EnvoyFilter](https:\/\/istio.io\/latest\/docs\/reference\/config\/networking\/envoy-filter\/)\n\n### 使用 WasmPlugin 安装\n\nWasmPlugin 资源从镜像仓库中提取 wasm 模块。因此，让我们首先为我们的 wasm 模块构建并推送一个 Docker 镜像。下面的 Docker 文件允许从你的 wasm 模块建立一个 Docker 镜像。\n\n\u0060\u0060\u0060Docker\nFROM scratch\n\nCOPY main.wasm .\/\n\u0060\u0060\u0060\n\n构建镜像，推送到镜像仓库。\n\n\u0060\u0060\u0060bash\nexport HUB=your_registry # e.g. docker.io\/tetrate\ndocker build . -t $HUB\/json-validation:v1\ndocker push $HUB\/json-validation:v1\n\u0060\u0060\u0060\n\n现在我们创建 [WasmPlugin](https:\/\/istio.io\/latest\/docs\/reference\/config\/proxy_extensions\/wasm-plugin\/) 资源。这将适用于所有通过 Istio Ingress 网关暴露的路由，并对其应用我们的验证。确保你把 \u0060{your_registry}\u0060 替换为你上传 wasm 镜像的镜像仓库。\n\n\u0060\u0060\u0060yaml\napiVersion: extensions.istio.io\/v1alpha1\nkind: WasmPlugin\nmetadata:\n  name: json-validation\n  namespace: istio-system\nspec:\n  selector:\n    matchLabels:\n      istio: ingressgateway\n  url: oci:\/\/{your_registry}\/json-validation:v3\n  imagePullPolicy: IfNotPresent\n  phase: AUTHN\n\u0060\u0060\u0060\n\n### 使用 EnvoyFilter 安装\n\n为了使用 EnvoyFilter，我们创建一个包含已编译的 Wasm 插件的 ConfigMap，将 ConfigMap 挂载到网关 pod 中，然后通过 EnvoyFilter 配置 Envoy，从本地文件加载 Wasm 插件。这种方法的限制是，更大和更复杂的 Wasm 模块可能超出 ConfigMap 1MB 的大小限制。\n\n首先，创建一个包含编译好的 Wasm 模块的 ConfigMap：\n\n\u0060\u0060\u0060bash\nkubectl -n istio-system create configmap wasm-plugins --from-file=main.wasm\n\u0060\u0060\u0060\n\n然后在 Istio Ingress 网关部署中打补丁，挂载这个 ConfigMap。\n\n\u0060\u0060\u0060bash\nkubectl -n istio-system patch deployment istio-ingressgateway --patch=\u0027\nspec:\n  template:\n    spec:\n      containers:\n        - name: istio-proxy\n          volumeMounts:\n            - name: wasm-plugins\n              mountPath: \/var\/local\/lib\/wasm-plugins\n              readOnly: true\n      volumes:\n        - name: wasm-plugins\n          configMap:\n            name: wasm-plugins\u0027\n\u0060\u0060\u0060\n\n现在 Wasm 模块就挂载到了网关 Pod 中，应用这个 EnvoyFilter。\n\n\u0060\u0060\u0060yaml\napiVersion: networking.istio.io\/v1alpha3\nkind: EnvoyFilter\nmetadata:\n  name: json-validation\n  namespace: istio-system\nspec:\n  configPatches:\n  - applyTo: HTTP_FILTER\n    match:\n      context: GATEWAY\n    patch:\n      operation: INSERT_BEFORE\n      value:\n        name: json-validation\n        typed_config:\n          \u0027@type\u0027: type.googleapis.com\/envoy.extensions.filters.http.wasm.v3.Wasm\n          config:\n            vm_config:\n              code:\n                local:\n                  filename: \/var\/local\/lib\/wasm-plugins\/main.wasm\n              runtime: envoy.wasm.runtime.v8\n              vm_id: json-validation\n\u0060\u0060\u0060\n\n### 测试 Wasm 插件\n\n重复之前的 curl 请求。\n\n\u0060\u0060\u0060bash\n% curl -X POST -i http:\/\/localhost:8080\/post\nHTTP\/1.1 403 Forbidden\ncontent-length: 29\ncontent-type: text\/plain\ndate: Tue, 15 Mar 2022 22:04:35 GMT\nserver: istio-envoy\n\ncontent-type must be provided\n\u0060\u0060\u0060\n\n如果提供了内容类型和 json 负载的话，请求将会成功。\n\n\u0060\u0060\u0060bash\ncurl -i http:\/\/localhost:8080\/post  -H \u0027Content-Type: application\/json\u0027 --data \u0027{\u0022id\u0022: \u0022xxx\u0022, \u0022token\u0022: \u0022xxx\u0022}\u0027\n\u0060\u0060\u0060\n\n## 让必填字段可配置\n\n与其在编译的 golang 代码中硬编码所需的 JSON 字段，不如允许通过 Envoy 配置来配置这些字段。\n\n当在 Docker 中运行 Envoy 时，可以通过向之前创建的 Wasm \u0060http_filter\u0060 添加配置来实现。\n\n\u0060\u0060\u0060yaml\n  http_filters:\n                  - name: envoy.filters.http.wasm\n                    typed_config:\n                      \u0022@type\u0022: type.googleapis.com\/udpa.type.v1.TypedStruct\n                      type_url: type.googleapis.com\/envoy.extensions.filters.http.wasm.v3.Wasm\n                      value:\n                        config:\n                          configuration:\n                            \u0022@type\u0022: type.googleapis.com\/google.protobuf.StringValue\n                            value: |\n                                                            { \u0022requiredKeys\u0022: [\u0022id\u0022, \u0022token\u0022] }\n                          vm_config:\n                            runtime: \u0022envoy.wasm.runtime.v8\u0022\n                            code:\n                              local:\n                                filename: \u0022.\/main.wasm\u0022\n\u0060\u0060\u0060\n\n当使用 WasmPlugin，在 \u0060pluginConfig\u0060 字段中配置。\n\n\u0060\u0060\u0060yaml\napiVersion: extensions.istio.io\/v1alpha1\nkind: WasmPlugin\nmetadata:\n  name: json-validation\n  namespace: istio-system\nspec:\n  selector:\n    matchLabels:\n      istio: ingressgateway\n  url: oci:\/\/{your_registry}\/json-validation:v3\n  imagePullPolicy: IfNotPresent\n  phase: AUTHN\n  pluginConfig:\n    requiredKeys: [\u0022id\u0022, \u0022token\u0022]\n\u0060\u0060\u0060\n\n最后，当使用 EnvoyFilter 时，将它添加到 filter 配置中。\n\n\u0060\u0060\u0060yaml\n   value:\n        name: json-validation\n        typed_config:\n          \u0027@type\u0027: type.googleapis.com\/envoy.extensions.filters.http.wasm.v3.Wasm\n          config:\n            configuration:\n              \u0022@type\u0022: type.googleapis.com\/google.protobuf.StringValue\n              value: |\n                                { \u0022requiredKeys\u0022: [\u0022id\u0022, \u0022token\u0022] }\n            vm_config:\n              code:\n                local:\n                  filename: \/var\/local\/lib\/wasm-plugins\/main.wasm\n              runtime: envoy.wasm.runtime.v8\n              vm_id: json-validation\n\u0060\u0060\u0060\n\n在代码中，实现 \u0060OnPluginStart\u0060，使用 \u0060proxywasm.GetPluginConfiguration\u0060 加载。\n\n\u0060\u0060\u0060go\n\/\/ pluginContext 实现 proxy-wasm-go SDK 中的 types.PluginContext 接口\ntype pluginContext struct {\n\t\/\/ 在这里嵌入默认的 plugin 上下文，这样就不用实现所有方法\n\ttypes.DefaultPluginContext\n\tconfiguration *pluginConfiguration\n}\n\n\/\/ pluginConfiguration 代表这个 wasm 插件中的示例配置\ntype pluginConfiguration struct {\n\t\/\/ 示例配置字段，插件将验证 json 负载中是否存在这些字段。\n\trequiredKeys []string\n}\n\n\/\/ 复写 types.DefaultPluginContext\nfunc (ctx *pluginContext) OnPluginStart(pluginConfigurationSize int) types.OnPluginStartStatus {\n\tdata, err := proxywasm.GetPluginConfiguration()\n\tif err != nil {\n\t\tproxywasm.LogCriticalf(\u0022error reading plugin configuration: %v\u0022, err)\n\t\treturn types.OnPluginStartStatusFailed\n\t}\n\tconfig, err := parsePluginConfiguration(data)\n\tif err != nil {\n\t\tproxywasm.LogCriticalf(\u0022error parsing plugin configuration: %v\u0022, err)\n\t\treturn types.OnPluginStartStatusFailed\n\t}\n\tctx.configuration = config\n\treturn types.OnPluginStartStatusOK\n}\n\n\/\/ parsePluginConfiguration 解析 json 插件配置并返回 pluginConfiguration\n\/\/ 注意使用 gjson 解析 json，因为 TinyGo 不支持 encoding\/json\n\/\/ 你也可以使用 https:\/\/github.com\/mailru\/easyjson，支持解析为结构体\nfunc parsePluginConfiguration(data []byte) (*pluginConfiguration, error) {\n\tconfig := \u0026pluginConfiguration{}\n\tif !gjson.ValidBytes(data) {\n\t\treturn nil, fmt.Errorf(\u0022the plugin configuration is not a valid json: %v\u0022, data)\n\t}\n\n\tjsonData := gjson.ParseBytes(data)\n\trequiredKeys := jsonData.Get(\u0022requiredKeys\u0022).Array()\n\tfor _, requiredKey := range requiredKeys {\n\t\tconfig.requiredKeys = append(config.requiredKeys, requiredKey.Str)\n\t}\n\n\treturn config, nil\n}\n\u0060\u0060\u0060\n\n现在它们被包含在 \u0060pluginConfiguration\u0060 结构中，它们可以像其他字段一样在验证过程中被使用。\n\n\u0060\u0060\u0060go\n\/\/ validatePayload 验证给定的 json 负载\n\/\/ 注意该函数使用 gjson 解析 json，因为 TinyGo 不支持 encoding\/json\nfunc (ctx *payloadValidationContext) validatePayload(body []byte) bool {\n\tif !gjson.ValidBytes(body) {\n\t\tproxywasm.LogErrorf(\u0022body is not a valid json: %v\u0022, body)\n\t\treturn false\n\t}\n\tjsonData := gjson.ParseBytes(body)\n\n\t\/\/ 验证 json。检查示例中是否包含必须的键。\n\t\/\/ 必须的键通过插件配置。\n\tfor _, requiredKey := range ctx.requiredKeys {\n\t\tif !jsonData.Get(requiredKey).Exists() {\n\t\t\tproxywasm.LogErrorf(\u0022required key (%v) is missing: %v\u0022, requiredKey, jsonData)\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\u0060\u0060\u0060\n\n然后可以使用与之前相同的命令对其进行编译和测试。\n\n## 总结\n\n总而言之，要在 Istio 1.12 和更新的版本上使用 Wasm 插件，需要三个步骤：\n\n1. 在你选择的语言中实现插件的功能。我在本教程中使用 Golang。\n2. 编译 Wasm 插件并推送到镜像仓库。\n3. 配置 Istio 以加载和使用镜像仓库中的插件。\n\n该教程还详细介绍了如何使用 Docker 在 Envoy 容器中运行 Wasm 插件，以加快开发速度，以及如何将其部署到旧的 Istio 版本。\n', '\/trans\/validating-a-request-payload-with-wasm\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文是一个开发 Wasm 插件验证请求负载的教程。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/sidecar-injection-iptables-and-traffic-routing/">Istio 中的 Sidecar 注入、透明流量劫持及流量路由过程详解</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/05/12</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio 中的 Sidecar 注入、透明流量劫持及流量路由过程详解', '本文基于 Istio 1.13 版本，介绍了 sidecar 模式及其优势 sidecar 如何注入到数据平面，Envoy 如何做流量劫持和路由转发的，包括 Inbound 流量和 Outbound 流量。', '\n本文最早是基于 Istio 1.11 撰写，之后随着 Istio 的版本陆续更新，最新更新时间为 2022 年 5 月 12 日，关于本文历史版本的更新说明请见文章最后。本文记录了详细的实践过程，力图能够让读者复现，因此事无巨细，想要理解某个部分过程的读者可以使用目录跳转到对应的小节阅读。\n\n为了使读者能够更加直观的了解本文中执行的操作，在阅读本文前你也可以先观看下 [Istio Workshop 第八讲视频](https:\/\/bilibili.com\/video\/BV1cF411T72o\/)。\n\n{{\u003cfigure title=\u0022观看视频\u0022 alt=\u0022图片\u0022 attr=\u0022[点击观看](https:\/\/bilibili.com\/video\/BV1cF411T72o\/)\u0022 src=\u0022bilibili.jpg\u0022 link=\u0022https:\/\/bilibili.com\/video\/BV1cF411T72o\/\u0022\u003e}}\n\n为了理解本文希望你先阅读以下内容：\n\n- [理解 iptables](\/blog\/understanding-iptables\/)\n- [Istio 数据平面 Pod 启动过程详解](\/blog\/istio-pod-process-lifecycle\/)\n\n## 内容介绍\n\n本文基于 Istio 1.13 版本，将为大家介绍以下内容：\n\n- 什么是 sidecar 模式和它的优势在哪里。\n- Istio 中是如何做 sidecar 注入的。\n- Sidecar 代理是如何做透明流量劫持的。\n- iptables 的路由规则。\n- Envoy 代理是如何路由流量到上游的。\n\n请大家结合下图理解本文中的内容，本图基于 Istio 官方提供的 Bookinfo 示例绘制，展示的是 \u0060reviews\u0060 Pod 的内部结构，包括 Linux Kernel 空间中的 iptables 规则、Sidecar 容器、应用容器。\n\n![Istio 流量劫持示意图](istio-iptables.svg)\n\n\u0060productpage\u0060 访问 \u0060reviews\u0060 Pod，入站流量处理过程对应于图示上的步骤：1、2、3、4、Envoy Inbound Handler、5、6、7、8、应用容器。\n\n\u0060reviews\u0060 Pod 访问 \u0060rating\u0060 服务的出站流量处理过程对应于图示上的步骤是：9、10、11、12、Envoy Outbound Handler、13、14、15。\n\n注意：图中的路径 16 近用于路由规则说明，它不不出现在当前示例中。实际上仅当 Pod 内发出的对当前 Pod 内的服务访问的时候才会途径它。\n\n上图中关于流量路由部分，包含：\n\n-  \u0060productpage\u0060 服务请求访问 \u0060http:\/\/reviews.default.svc.cluster.local:9080\/\u0060，当流量进入 \u0060reviews\u0060 Pod 内部时，流量是如何被 iptables 劫持到 Envoy 代理被 Inbound Handler 处理的；\n- \u0060reviews\u0060 请求访问 \u0060ratings\u0060 服务的 Pod，应用程序发出的出站流量被 iptables 劫持到 Envoy 代理的 Outbound Handler 的处理。\n\n在阅读下文时，请大家确立以下已知点：\n\n- 首先，\u0060productpage\u0060 发出的对 \u0060reivews\u0060 的访问流量，是在 Envoy 已经通过 EDS 选择出了要请求的 \u0060reviews\u0060 服务的某个 Pod，知晓了其 IP 地址，直接向该 IP 发送的 TCP 连接请求。\n- \u0060reviews\u0060 服务有三个版本，每个版本有一个实例，三个版本中的 sidecar 工作步骤类似，下文只以其中一个 Pod 中的 sidecar 流量转发步骤来说明。\n- 所有进入 \u0060reviews\u0060 Pod 的 TCP 流量都根据 Pod 中的 iptables 规则转发到了 Envoy 代理的 15006 端口，然后经过 Envoy 的处理确定转发给 Pod 内的应用容器还是透传。\n\n## Sidecar 模式\n\n将应用程序的功能划分为单独的进程运行在同一个最小调度单元中（例如 Kubernetes 中的 Pod）可以被视为 **sidecar 模式**。如下图所示，sidecar 模式允许您在应用程序旁边添加更多功能，而无需额外第三方组件配置或修改应用程序代码。\n\n![Sidecar 模式示意图](sidecar-pattern.svg)\n\n就像连接了 Sidecar 的三轮摩托车一样，在软件架构中，Sidecar 连接到父应用并且为其添加扩展或者增强功能。Sidecar 应用与主应用程序松散耦合。它可以屏蔽不同编程语言的差异，统一实现微服务的可观测性、监控、日志记录、配置、断路器等功能。\n\n### 使用 Sidecar 模式的优势\n\n使用 sidecar 模式部署服务网格时，无需在节点上运行代理，但是集群中将运行多个相同的 sidecar 副本。在 sidecar 部署方式中，每个应用的容器旁都会部署一个伴生容器（如 Envoy 或 MOSN），这个容器称之为 sidecar 容器。Sidecar 接管进出应用容器的所有流量。在 Kubernetes 的 Pod 中，在原有的应用容器旁边注入一个 Sidecar 容器，两个容器共享存储、网络等资源，可以广义的将这个包含了 sidecar 容器的 Pod 理解为一台主机，两个容器共享主机资源。\n\n因其独特的部署结构，使得 sidecar 模式具有以下优势：\n\n- 将与应用业务逻辑无关的功能抽象到共同基础设施，降低了微服务代码的复杂度。\n- 因为不再需要编写相同的第三方组件配置文件和代码，所以能够降低微服务架构中的代码重复度。\n- Sidecar 可独立升级，降低应用程序代码和底层平台的耦合度。\n\n## Sidecar 注入示例分析\n\n以 Istio 官方提供的 \u0060bookinfo\u0060 中 \u0060productpage\u0060 的 YAML 为例，关于 \u0060bookinfo\u0060 应用的详细 YAML 配置请参考 [bookinfo.yaml](https:\/\/github.com\/istio\/istio\/blob\/master\/samples\/bookinfo\/platform\/kube\/bookinfo.yaml)。\n\n下文将从以下几个方面讲解：\n\n- Sidecar 容器的注入\n- iptables 规则的创建\n- 路由的详细过程\n\n\u0060\u0060\u0060yaml\napiVersion: apps\/v1\nkind: Deployment\nmetadata:\n  name: productpage-v1\n  labels:\n    app: productpage\n    version: v1\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: productpage\n      version: v1\n  template:\n    metadata:\n      labels:\n        app: productpage\n        version: v1\n    spec:\n      serviceAccountName: bookinfo-productpage\n      containers:\n      - name: productpage\n        image: docker.io\/istio\/examples-bookinfo-productpage-v1:1.15.0\n        imagePullPolicy: IfNotPresent\n        ports:\n        - containerPort: 9080\n        volumeMounts:\n        - name: tmp\n          mountPath: \/tmp\n      volumes:\n      - name: tmp\n        emptyDir: {}\n\u0060\u0060\u0060\n\n再查看下 \u0060productpage\u0060 容器的 [Dockerfile](https:\/\/github.com\/istio\/istio\/blob\/master\/samples\/bookinfo\/src\/productpage\/Dockerfile)。\n\n\u0060\u0060\u0060docker\nFROM python:3.7.4-slim\n\nCOPY requirements.txt .\/\nRUN pip install --no-cache-dir -r requirements.txt\n\nCOPY test-requirements.txt .\/\nRUN pip install --no-cache-dir -r test-requirements.txt\n\nCOPY productpage.py \/opt\/microservices\/\nCOPY tests\/unit\/* \/opt\/microservices\/\nCOPY templates \/opt\/microservices\/templates\nCOPY static \/opt\/microservices\/static\nCOPY requirements.txt \/opt\/microservices\/\n\nARG flood_factor\nENV FLOOD_FACTOR ${flood_factor:-0}\n\nEXPOSE 9080\nWORKDIR \/opt\/microservices\nRUN python -m unittest discover\n\nUSER 1\n\nCMD [\u0022python\u0022, \u0022productpage.py\u0022, \u00229080\u0022]\n\u0060\u0060\u0060\n\n我们看到 \u0060Dockerfile\u0060 中没有配置 \u0060ENTRYPOINT\u0060，所以 \u0060CMD\u0060 的配置 \u0060python productpage.py 9080\u0060 将作为默认的 \u0060ENTRYPOINT\u0060，记住这一点，再看下注入 sidecar 之后的配置。\n\n\u0060\u0060\u0060bash\n$ istioctl kube-inject -f samples\/bookinfo\/platform\/kube\/bookinfo.yaml\n\u0060\u0060\u0060\n\n我们只截取其中与 \u0060productpage\u0060 相关的 \u0060Deployment\u0060 配置中的部分 YAML 配置。\n\n\u0060\u0060\u0060yaml\n      containers:\n      - image: docker.io\/istio\/examples-bookinfo-productpage-v1:1.15.0 # 应用镜像\n        name: productpage\n        ports:\n        - containerPort: 9080\n      - args:\n        - proxy\n        - sidecar\n        - --domain\n        - $(POD_NAMESPACE).svc.cluster.local\n        - --configPath\n        - \/etc\/istio\/proxy\n        - --binaryPath\n        - \/usr\/local\/bin\/envoy\n        - --serviceCluster\n        - productpage.$(POD_NAMESPACE)\n        - --drainDuration\n        - 45s\n        - --parentShutdownDuration\n        - 1m0s\n        - --discoveryAddress\n        - istiod.istio-system.svc:15012\n        - --zipkinAddress\n        - zipkin.istio-system:9411\n        - --proxyLogLevel=warning\n        - --proxyComponentLogLevel=misc:error\n        - --connectTimeout\n        - 10s\n        - --proxyAdminPort\n        - \u002215000\u0022\n        - --concurrency\n        - \u00222\u0022\n        - --controlPlaneAuthPolicy\n        - NONE\n        - --dnsRefreshRate\n        - 300s\n        - --statusPort\n        - \u002215020\u0022\n        - --trust-domain=cluster.local\n        - --controlPlaneBootstrap=false\n        image: docker.io\/istio\/proxyv2:1.5.1 # sidecar proxy\n        name: istio-proxy\n        ports:\n        - containerPort: 15090\n          name: http-envoy-prom\n          protocol: TCP\n      initContainers:\n      - command:\n        - istio-iptables\n        - -p\n        - \u002215001\u0022\n        - -z\n        - \u002215006\u0022\n        - -u\n        - \u00221337\u0022\n        - -m\n        - REDIRECT\n        - -i\n        - \u0027*\u0027\n        - -x\n        - \u0022\u0022\n        - -b\n        - \u0027*\u0027\n        - -d\n        - 15090,15020\n        image: docker.io\/istio\/proxyv2:1.5.1 # init 容器\n        name: istio-init\n\u0060\u0060\u0060\n\nIstio 给应用 Pod 注入的配置主要包括：\n\n- Init 容器 \u0060istio-init\u0060：用于 pod 中设置 iptables 端口转发\n- Sidecar 容器 \u0060istio-proxy\u0060：运行 sidecar 代理，如 Envoy 或 MOSN。\n\n## iptables 规则注入解析\n\n为了查看 iptables 配置，我们需要登陆到 sidecar 容器中使用 root 用户来查看，因为 \u0060kubectl\u0060 无法使用特权模式来远程操作 docker 容器，所以我们需要登陆到 \u0060productpage\u0060 pod 所在的主机上使用 \u0060docker\u0060 命令登陆容器中查看。\n\n如果您使用 minikube 部署的 Kubernetes，可以直接登录到 minikube 的虚拟机中并切换为 root 用户。查看 iptables 配置，列出 NAT（网络地址转换）表的所有规则，因为在 Init 容器启动的时候选择给 \u0060istio-iptables\u0060 传递的参数中指定将入站流量重定向到 sidecar 的模式为 \u0060REDIRECT\u0060，因此在 iptables 中将只有 NAT 表的规格配置，如果选择 \u0060TPROXY\u0060 还会有 \u0060mangle\u0060 表配置。\u0060iptables\u0060 命令的详细用法请参考 [iptables](https:\/\/wangchujiang.com\/linux-command\/c\/iptables.html) 命令。\n\n我们仅查看与 \u0060productpage\u0060 有关的 iptables 规则如下，因为这些规则是运行在该容器特定的网络空间下，因此需要使用 \u0060nsenter\u0060 命令进入其网络空间。进入的时候需要指定进程 ID（PID），因此首先我们需要找到 \u0060productpage\u0060 容器的 PID。对于在不同平台上安装的 Kubernetes，查找容器的方式会略有不同，例如在 GKE 上，执行 \u0060docker ps -a\u0060 命令是查看不到任何容器进程的。下面已 minikube 和 GKE 两个典型的平台为例，指导你如何进入容器的网络空间。\n\n### 在 minikube 中查看容器中的 iptabes 规则\n\n对于 minikube，因为所有的进程都运行在单个节点上，因此你只需要登录到 minikube 虚拟机，切换为 root 用户然后查找 \u0060productpage\u0060 进程即可，参考下面的步骤。\n\n\u0060\u0060\u0060bash\n# 进入 minikube 并切换为 root 用户，minikube 默认用户为 docker\n$ minikube ssh\n$ sudo -i\n\n# 查看 productpage pod 的 istio-proxy 容器中的进程\n$ docker top \u0060docker ps|grep \u0022istio-proxy_productpage\u0022|cut -d \u0022 \u0022 -f1\u0060\nUID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD\n1337                10576               10517               0                   08:09               ?                   00:00:07            \/usr\/local\/bin\/pilot-agent proxy sidecar --domain default.svc.cluster.local --configPath \/etc\/istio\/proxy --binaryPath \/usr\/local\/bin\/envoy --serviceCluster productpage.default --drainDuration 45s --parentShutdownDuration 1m0s --discoveryAddress istiod.istio-system.svc:15012 --zipkinAddress zipkin.istio-system:9411 --proxyLogLevel=warning --proxyComponentLogLevel=misc:error --connectTimeout 10s --proxyAdminPort 15000 --concurrency 2 --controlPlaneAuthPolicy NONE --dnsRefreshRate 300s --statusPort 15020 --trust-domain=cluster.local --controlPlaneBootstrap=false\n1337                10660               10576               0                   08:09               ?                   00:00:33            \/usr\/local\/bin\/envoy -c \/etc\/istio\/proxy\/envoy-rev0.json --restart-epoch 0 --drain-time-s 45 --parent-shutdown-time-s 60 --service-cluster productpage.default --service-node sidecar~172.17.0.16~productpage-v1-7f44c4d57c-ksf9b.default~default.svc.cluster.local --max-obj-name-len 189 --local-address-ip-version v4 --log-format [Envoy (Epoch 0)] [%Y-%m-%d %T.%e][%t][%l][%n] %v -l warning --component-log-level misc:error --concurrency 2\n\n# 使用 nsenter 进入 sidecar 容器的命名空间（以上任何一个都可以）\n$ nsenter -n --target 10660\n\n# 查看 NAT 表中规则配置的详细信息。\n$ iptables -t nat -L\n\u0060\u0060\u0060\n\n### 在 GKE 中查看容器的 iptables 规则\n\n如果你在 GKE 中安装的多节点的 Kubernetes 集群，首先你需要确定这个 Pod 运行在哪个节点上，然后登陆到那台主机，使用下面的命令查找进程的 PID，你会得到类似下面的输出。\n\n\u0060\u0060\u0060bash\n$ ps aux|grep \u0022productpage\u0022\nchronos     4268  0.0  0.6  43796 24856 ?        Ss   Apr22   0:00 python productpage.py 9080\nchronos     4329  0.9  0.6 117524 24616 ?        Sl   Apr22  13:43 \/usr\/local\/bin\/python \/opt\/microservices\/productpage.py 9080\nroot      361903  0.0  0.0   4536   812 pts\/0    S\u002b   01:54   0:00 grep --colour=auto productpage\n\u0060\u0060\u0060\n\n在本示例中，productpage 进程的 PID 是 \u00604329\u0060，使用 \u0060nsenter -n --target 4329\u0060 进入该进程的命名空间，然后在终端中输入 \u0060iptables -t nat -L\u0060 即可查看 iptables 规则。\n\n## iptables 流量劫持过程详解\n\n经过上面的步骤，你已经可以查看到 init 容器向 Pod 中注入的 iptables 规则，如下所示。\n\n\u0060\u0060\u0060bash\n# PREROUTING 链：用于目标地址转换（DNAT），将所有入站 TCP 流量跳转到 ISTIO_INBOUND 链上。\nChain PREROUTING (policy ACCEPT 2701 packets, 162K bytes)\n pkts bytes target     prot opt in     out     source               destination\n 2701  162K ISTIO_INBOUND  tcp  --  any    any     anywhere             anywhere\n\n# INPUT 链：处理输入数据包，非 TCP 流量将继续 OUTPUT 链。\nChain INPUT (policy ACCEPT 2701 packets, 162K bytes)\n pkts bytes target     prot opt in     out     source               destination\n\n# OUTPUT 链：将所有出站数据包跳转到 ISTIO_OUTPUT 链上。\nChain OUTPUT (policy ACCEPT 79 packets, 6761 bytes)\n pkts bytes target     prot opt in     out     source               destination\n   15   900 ISTIO_OUTPUT  tcp  --  any    any     anywhere             anywhere\n\n# POSTROUTING 链：所有数据包流出网卡时都要先进入 POSTROUTING 链，内核根据数据包目的地判断是否需要转发出去，我们看到此处未做任何处理。\nChain POSTROUTING (policy ACCEPT 79 packets, 6761 bytes)\n pkts bytes target     prot opt in     out     source               destination\n\n# ISTIO_INBOUND 链：将所有入站流量重定向到 ISTIO_IN_REDIRECT 链上。目的地为 15090（Prometheus 使用）和 15020（Ingress gateway 使用，用于 Pilot 健康检查）端口的流量除外，发送到以上两个端口的流量将返回 iptables 规则链的调用点，即 PREROUTING 链的后继 INPUT 后直接调用原始目的地。\nChain ISTIO_INBOUND (1 references)\n pkts bytes target     prot opt in     out     source               destination\n    0     0 RETURN     tcp  --  any    any     anywhere             anywhere             tcp dpt:ssh\n    2   120 RETURN     tcp  --  any    any     anywhere             anywhere             tcp dpt:15090\n 2699  162K RETURN     tcp  --  any    any     anywhere             anywhere             tcp dpt:15020\n    0     0 ISTIO_IN_REDIRECT  tcp  --  any    any     anywhere             anywhere\n\n# ISTIO_IN_REDIRECT 链：将所有的入站流量跳转到本地的 15006 端口，至此成功的拦截了流量到 sidecar 代理的 Inbound Handler 中。\nChain ISTIO_IN_REDIRECT (3 references)\n pkts bytes target     prot opt in     out     source               destination\n    0     0 REDIRECT   tcp  --  any    any     anywhere             anywhere             redir ports 15006\n\n# ISTIO_OUTPUT 链：规则比较复杂，将在下文解释\nChain ISTIO_OUTPUT (1 references)\n pkts bytes target     prot opt in     out     source               destination\n    0     0 RETURN     all  --  any    lo      127.0.0.6            anywhere #规则1\n    0     0 ISTIO_IN_REDIRECT  all  --  any    lo      anywhere            !localhost            owner UID match 1337 #规则2\n    0     0 RETURN     all  --  any    lo      anywhere             anywhere             ! owner UID match 1337 #规则3\n   15   900 RETURN     all  --  any    any     anywhere             anywhere             owner UID match 1337 #规则4\n    0     0 ISTIO_IN_REDIRECT  all  --  any    lo      anywhere            !localhost            owner GID match 1337 #规则5\n    0     0 RETURN     all  --  any    lo      anywhere             anywhere             ! owner GID match 1337 #规则6\n    0     0 RETURN     all  --  any    any     anywhere             anywhere             owner GID match 1337 #规则7\n    0     0 RETURN     all  --  any    any     anywhere             localhost #规则8\n    0     0 ISTIO_REDIRECT  all  --  any    any     anywhere             anywhere #规则9\n\n# ISTIO_REDIRECT 链：将所有流量重定向到 Envoy 代理的 15001 端口。\nChain ISTIO_REDIRECT (1 references)\n pkts bytes target     prot opt in     out     source               destination\n    0     0 REDIRECT   tcp  --  any    any     anywhere             anywhere             redir ports 15001\n\u0060\u0060\u0060\n\n这里着重需要解释的是 \u0060ISTIO_OUTPUT\u0060 链中的 9 条规则，为了便于阅读，我将以上规则中的部分内容使用表格的形式来展示如下：\n\n{{\u003ctable \u0022ISTIO_OUTPUT 链中的路由规则\u0022\u003e}}\n| **规则** | **target**        | **in** | **out** | **source** | **destination**                 |\n| -------- | ----------------- | ------ | ------- | ---------- | ------------------------------- |\n| 1        | RETURN            | any    | lo      | 127.0.0.6  | anywhere                        |\n| 2        | ISTIO_IN_REDIRECT | any    | lo      | anywhere   | !localhost owner UID match 1337 |\n| 3        | RETURN            | any    | lo      | anywhere   | anywhere !owner UID match 1337  |\n| 4        | RETURN            | any    | any     | anywhere   | anywhere owner UID match 1337   |\n| 5        | ISTIO_IN_REDIRECT | any    | lo      | anywhere   | !localhost owner GID match 1337 |\n| 6        | RETURN            | any    | lo      | anywhere   | anywhere !owner GID match 1337  |\n| 7        | RETURN            | any    | any     | anywhere   | anywhere owner GID match 1337   |\n| 8        | RETURN            | any    | any     | anywhere   | localhost                       |\n| 9        | ISTIO_REDIRECT    | any    | any     | anywhere   | anywhere                        |\n{{\u003c\/table\u003e}}\n\n下图展示了 \u0060ISTIO_ROUTE\u0060 规则的详细流程。\n\n![Istio_ROUTE iptalbes 规则判断流程图](istio-route-iptables.svg)\n\n我将按照规则的出现顺序来解释每条规则的目的、对应文章开头图示中的步骤及详情。其中规则 5、6、7 是分别对规则 2、3、4 的应用范围扩大（从 UID 扩大为 GID），作用是类似的，将合并解释。注意，其中的规则是按顺序执行的，也就是说排序越靠后的规则将作为默认值。出站网卡（out）为 \u0060lo\u0060 （本地回环地址，loopback 接口）时，表示流量的目的地是本地 Pod，对于 Pod 向外部发送的流量就不会经过这个接口。所有 \u0060review\u0060 Pod 的出站流量只适用于规则 4、7、8、9。\n\n**规则 1**\n\n- 目的：**透传** Envoy 代理发送到本地应用容器的流量，使其绕过 Envoy 代理，直达应用容器。\n- 对应图示中的步骤：6 到 7。\n- 详情：该规则使得所有来自 \u0060127.0.0.6\u0060（该 IP 地址将在下文解释）的请求，跳出该链，返回 iptables 的调用点（即 \u0060OUTPUT\u0060）后继续执行其余路由规则，即 \u0060POSTROUTING\u0060 规则，把流量发送到任意目的地址，如本地 Pod 内的应用容器。如果没有这条规则，由 Pod 内 Envoy 代理发出的对 Pod 内容器访问的流量将会执行下一条规则，即规则 2，流量将再次进入到了 Inbound Handler 中，从而形成了死循环。将这条规则放在第一位可以避免流量在 Inbound Handler 中死循环的问题。\n\n**规则 2、5**\n\n- 目的：处理 Envoy 代理发出的站内流量（Pod 内部的流量），但不是对 localhost 的请求，通过后续规则将其转发给 Envoy 代理的 Inbound Handler。该规则适用于 Pod 对自身 IP 地址调用的场景，即 Pod 内服务之间的访问。\n- 详情：如果流量的目的地非 localhost，且数据包是由 1337 UID（即 \u0060istio-proxy\u0060 用户，Envoy 代理）发出的，流量将被经过 \u0060ISTIO_IN_REDIRECT\u0060 最终转发到 Envoy 的 Inbound Handler。\n\n**规则 3、6**\n\n- 目的：**透传** Pod 内的应用容器的站内流量。该规则适用于容器内部的流量。例如在 Pod 内对 Pod IP 或 localhost 的访问。\n- 对应图示中的步骤：6 到 7。\n- 详情：如果流量不是由 Envoy 用户发出的，那么就跳出该链，返回 \u0060OUTPUT\u0060 调用 \u0060POSTROUTING\u0060，直达目的地。\n\n**规则 4、7**\n\n- 目的：**透传**  Envoy 代理发出的出站请求。\n- 对应图示中的步骤：14 到 15。\n- 详情：如果请求是由 Envoy 代理发出的，则返回 \u0060OUTPUT\u0060 继续调用 \u0060POSTROUTING\u0060 规则，最终直接访问目的地。\n\n**规则 8**\n\n- 目的：**透传** Pod 内部对 localhost 的请求。\n- 详情：如果请求的目的地是 localhost，则返回 OUTPUT 调用 \u0060POSTROUTING\u0060，直接访问 localhost。\n\n**规则 9**\n\n- 目的：所有其他的流量将被转发到 \u0060ISTIO_REDIRECT\u0060 后，最终达到 Envoy 代理的 Outbound Handler。\n- 对应图示中的步骤：10 到 11。\n\n以上规则避免了 Envoy 代理到应用程序的路由在 iptables 规则中的死循环，保障了流量可以被正确的路由到 Envoy 代理上，也可以发出真正的出站请求。\n\n**关于 RETURN target**\n\n你可能留意到上述规则中有很多 RETURN target，它的意思是，指定到这条规则时，跳出该规则链，返回 iptables 的调用点（在我们的例子中即 \u0060OUTPUT\u0060）后继续执行其余路由规则，在我们的例子中即 \u0060POSTROUTING\u0060 规则，把流量发送到任意目的地址，你可以把它直观的理解为**透传**。\n\n**关于 127.0.0.6 IP 地址**\n\n127.0.0.6 这个 IP 是 Istio 中默认的 \u0060InboundPassthroughClusterIpv4\u0060，在 Istio 的代码中指定。即流量在进入 Envoy 代理后被绑定的 IP 地址，作用是让 Outbound 流量重新发送到  Pod 中的应用容器，即 **Passthought（透传），绕过 Outbound Handler**。该流量是对 Pod 自身的访问，而不是真正的对外流量。至于为什么选择这个 IP 作为流量透传，请参考 [Istio Issue-29603](https:\/\/github.com\/istio\/istio\/issues\/29603)。\n\n## 流量路由过程详解\n\n通过上文，你已经了解了 Istio 是如何在 Pod 中做透明流量劫持的，那么流量被劫持到 Envoy 代理中之后是如何被处理的呢？流量路由分为 Inbound 和 Outbound 两个过程，下面将根据上文中的示例及 sidecar 的配置为读者详细分析此过程。\n\n### 理解 Inbound Handler\n\nInbound Handler 的作用是将 iptables 拦截到的 downstream 的流量转发给 Pod 内的应用程序容器。在我们的实例中，假设其中一个 Pod 的名字是 \u0060reviews-v1-545db77b95-jkgv2\u0060，运行 \u0060istioctl proxy-config listener reviews-v1-545db77b95-jkgv2 --port 15006\u0060 查看该 Pod 中 15006 端口上的监听器情况，你将看到下面的输出。\n\n\u0060\u0060\u0060ini\nADDRESS PORT  MATCH                                                                                           DESTINATION\n0.0.0.0 15006 Addr: *:15006                                                                                   Non-HTTP\/Non-TCP\n0.0.0.0 15006 Trans: tls; App: istio-http\/1.0,istio-http\/1.1,istio-h2; Addr: 0.0.0.0\/0                        InboundPassthroughClusterIpv4\n0.0.0.0 15006 Trans: raw_buffer; App: http\/1.1,h2c; Addr: 0.0.0.0\/0                                           InboundPassthroughClusterIpv4\n0.0.0.0 15006 Trans: tls; App: TCP TLS; Addr: 0.0.0.0\/0                                                       InboundPassthroughClusterIpv4\n0.0.0.0 15006 Trans: raw_buffer; Addr: 0.0.0.0\/0                                                              InboundPassthroughClusterIpv4\n0.0.0.0 15006 Trans: tls; Addr: 0.0.0.0\/0                                                                     InboundPassthroughClusterIpv4\n0.0.0.0 15006 Trans: tls; App: istio,istio-peer-exchange,istio-http\/1.0,istio-http\/1.1,istio-h2; Addr: *:9080 Cluster: inbound|9080||\n0.0.0.0 15006 Trans: raw_buffer; Addr: *:9080                                                                 Cluster: inbound|9080||\n\u0060\u0060\u0060\n\n下面列出了以上输出中各字段的含义：\n\n- ADDRESS：下游地址\n- PORT：Envoy 监听器监听的端口\n- MATCH：请求使用的传输协议或匹配的下游地址\n- DESTINATION：路由目的地\n\n\u0060reviews\u0060 Pod 中的 Iptables 将入站流量劫持到 15006 端口上，从上面的输出我们可以看到 Envoy 的 Inbound Handler 在 15006 端口上监听，对目的地为任何 IP 的 9080 端口的请求将路由到 \u0060inbound|9080||\u0060 Cluster 上。\n\n从该 Pod 的 Listener 列表的最后两行中可以看到，\u00600.0.0.0:15006\/TCP\u0060 的 Listener（其实际名字是 \u0060virtualInbound\u0060）监听所有的 Inbound 流量，其中包含了匹配规则，来自任意 IP 的对 \u00609080\u0060 端口的访问流量，将会路由到 \u0060inbound|9080||\u0060 Cluster，如果你想以 Json 格式查看该 Listener 的详细配置，可以执行 \u0060istioctl proxy-config listeners reviews-v1-545db77b95-jkgv2 --port 15006 -o json\u0060 命令，你将获得类似下面的输出。\n\n\u0060\u0060\u0060json\n[\n    \/*省略部分内容*\/\n    {\n        \u0022name\u0022: \u0022virtualInbound\u0022,\n        \u0022address\u0022: {\n            \u0022socketAddress\u0022: {\n                \u0022address\u0022: \u00220.0.0.0\u0022,\n                \u0022portValue\u0022: 15006\n            }\n        },\n        \u0022filterChains\u0022: [\n            \/*省略部分内容*\/\n            {\n                \u0022filterChainMatch\u0022: {\n                    \u0022destinationPort\u0022: 9080,\n                    \u0022transportProtocol\u0022: \u0022tls\u0022,\n                    \u0022applicationProtocols\u0022: [\n                        \u0022istio\u0022,\n                        \u0022istio-peer-exchange\u0022,\n                        \u0022istio-http\/1.0\u0022,\n                        \u0022istio-http\/1.1\u0022,\n                        \u0022istio-h2\u0022\n                    ]\n                },\n                \u0022filters\u0022: [\n                    \/*省略部分内容*\/\n                    {\n                        \u0022name\u0022: \u0022envoy.filters.network.http_connection_manager\u0022,\n                        \u0022typedConfig\u0022: {\n                            \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager\u0022,\n                            \u0022statPrefix\u0022: \u0022inbound_0.0.0.0_9080\u0022,\n                            \u0022routeConfig\u0022: {\n                                \u0022name\u0022: \u0022inbound|9080||\u0022,\n                                \u0022virtualHosts\u0022: [\n                                    {\n                                        \u0022name\u0022: \u0022inbound|http|9080\u0022,\n                                        \u0022domains\u0022: [\n                                            \u0022*\u0022\n                                        ],\n                                        \u0022routes\u0022: [\n                                            {\n                                                \u0022name\u0022: \u0022default\u0022,\n                                                \u0022match\u0022: {\n                                                    \u0022prefix\u0022: \u0022\/\u0022\n                                                },\n                                                \u0022route\u0022: {\n                                                    \u0022cluster\u0022: \u0022inbound|9080||\u0022,\n                                                    \u0022timeout\u0022: \u00220s\u0022,\n                                                    \u0022maxStreamDuration\u0022: {\n                                                        \u0022maxStreamDuration\u0022: \u00220s\u0022,\n                                                        \u0022grpcTimeoutHeaderMax\u0022: \u00220s\u0022\n                                                    }\n                                                },\n                                                \u0022decorator\u0022: {\n                                                    \u0022operation\u0022: \u0022reviews.default.svc.cluster.local:9080\/*\u0022\n                                                }\n                                            }\n                                        ]\n                                    }\n                                ],\n                                \u0022validateClusters\u0022: false\n                            },\n                            \/*省略部分内容*\/\n                        }\n                    }\n                ],\n            \/*省略部分内容*\/\n        ],\n        \u0022listenerFilters\u0022: [\n        \/*省略部分内容*\/\n        ],\n        \u0022listenerFiltersTimeout\u0022: \u00220s\u0022,\n        \u0022continueOnListenerFiltersTimeout\u0022: true,\n        \u0022trafficDirection\u0022: \u0022INBOUND\u0022\n    }\n]\n\u0060\u0060\u0060\n\n既然 Inbound Handler 的流量中将来自任意地址的对该 Pod \u00609080\u0060 端口的流量路由到 \u0060inbound|9080||\u0060 Cluster，那么我们运行 \u0060istioctl pc cluster reviews-v1-545db77b95-jkgv2 --port 9080 --direction inbound -o json\u0060 查看下该 Cluster 配置，你将获得类似下面的输出。\n\n\u0060\u0060\u0060json\n[\n    {\n        \u0022name\u0022: \u0022inbound|9080||\u0022,\n        \u0022type\u0022: \u0022ORIGINAL_DST\u0022,\n        \u0022connectTimeout\u0022: \u002210s\u0022,\n        \u0022lbPolicy\u0022: \u0022CLUSTER_PROVIDED\u0022,\n        \u0022circuitBreakers\u0022: {\n            \u0022thresholds\u0022: [\n                {\n                    \u0022maxConnections\u0022: 4294967295,\n                    \u0022maxPendingRequests\u0022: 4294967295,\n                    \u0022maxRequests\u0022: 4294967295,\n                    \u0022maxRetries\u0022: 4294967295,\n                    \u0022trackRemaining\u0022: true\n                }\n            ]\n        },\n        \u0022cleanupInterval\u0022: \u002260s\u0022,\n        \u0022upstreamBindConfig\u0022: {\n            \u0022sourceAddress\u0022: {\n                \u0022address\u0022: \u0022127.0.0.6\u0022,\n                \u0022portValue\u0022: 0\n            }\n        },\n        \u0022metadata\u0022: {\n            \u0022filterMetadata\u0022: {\n                \u0022istio\u0022: {\n                    \u0022services\u0022: [\n                        {\n                            \u0022host\u0022: \u0022reviews.default.svc.cluster.local\u0022,\n                            \u0022name\u0022: \u0022reviews\u0022,\n                            \u0022namespace\u0022: \u0022default\u0022\n                        }\n                    ]\n                }\n            }\n        }\n    }\n]\n\u0060\u0060\u0060\n\n我们看其中的 \u0060TYPE\u0060 为 \u0060ORIGINAL_DST\u0060，将流量发送到原始目标地址（Pod IP），因为原始目标地址即当前 Pod，你还应该注意到 \u0060upstreamBindConfig.sourceAddress.address\u0060 的值被改写为了 \u0060127.0.0.6\u0060，而且对于 Pod 内流量是通过 \u0060lo\u0060 网卡发送的，这刚好呼应了上文中的 iptables \u0060ISTIO_OUTPUT\u0060 链中的第一条规则，根据该规则，流量将被透传到 Pod 内的应用容器。\n\n### 理解 Outbound Handler\n\n在本示例中 \u0060reviews\u0060 会向 \u0060ratings\u0060 服务发送 HTTP 请求，请求的地址是：\u0060http:\/\/ratings.default.svc.cluster.local:9080\/\u0060，Outbound Handler 的作用是将 iptables 拦截到的本地应用程序向外发出的流量，经由 Envoy 代理路由到上游。\n\nEnvoy 监听在 15001 端口上监听所有 Outbound 流量，Outbound Handler 处理，然后经过 \u0060virtualOutbound\u0060 Listener、\u00600.0.0.0_9080\u0060 Listener，然后通过 Route 9080 找到上游的 cluster，进而通过 EDS 找到 Endpoint 执行路由动作。\n\n**\u0060ratings.default.svc.cluster.local:9080\u0060 路由**\n\n运行 \u0060istioctl proxy-config routes reviews-v1-545db77b95-jkgv2 --name 9080 -o json\u0060 查看 route 配置，因为 sidecar 会根据 HTTP header 中的 domains 来匹配 VirtualHost，所以下面只列举了 \u0060ratings.default.svc.cluster.local:9080\u0060 这一个 VirtualHost。\n\n\u0060\u0060\u0060json\n[\n  {\n    \u0022name\u0022: \u00229080\u0022,\n    \u0022virtualHosts\u0022: [\n       {\n           \u0022name\u0022: \u0022ratings.default.svc.cluster.local:9080\u0022,\n           \u0022domains\u0022: [\n               \u0022ratings.default.svc.cluster.local\u0022,\n               \u0022ratings.default.svc.cluster.local:9080\u0022,\n               \u0022ratings\u0022,\n               \u0022ratings:9080\u0022,\n               \u0022ratings.default.svc\u0022,\n               \u0022ratings.default.svc:9080\u0022,\n               \u0022ratings.default\u0022,\n               \u0022ratings.default:9080\u0022,\n               \u002210.8.8.106\u0022,\n               \u002210.8.8.106:9080\u0022\n           ],\n           \u0022routes\u0022: [\n               {\n                   \u0022name\u0022: \u0022default\u0022,\n                   \u0022match\u0022: {\n                       \u0022prefix\u0022: \u0022\/\u0022\n                   },\n                   \u0022route\u0022: {\n                       \u0022cluster\u0022: \u0022outbound|9080||ratings.default.svc.cluster.local\u0022,\n                       \u0022timeout\u0022: \u00220s\u0022,\n                       \u0022retryPolicy\u0022: {\n                           \u0022retryOn\u0022: \u0022connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes\u0022,\n                           \u0022numRetries\u0022: 2,\n                           \u0022retryHostPredicate\u0022: [\n                               {\n                                   \u0022name\u0022: \u0022envoy.retry_host_predicates.previous_hosts\u0022\n                               }\n                           ],\n                           \u0022hostSelectionRetryMaxAttempts\u0022: \u00225\u0022,\n                           \u0022retriableStatusCodes\u0022: [\n                               503\n                           ]\n                       },\n                       \u0022maxStreamDuration\u0022: {\n                           \u0022maxStreamDuration\u0022: \u00220s\u0022,\n                           \u0022grpcTimeoutHeaderMax\u0022: \u00220s\u0022\n                       }\n                   },\n                   \u0022decorator\u0022: {\n                       \u0022operation\u0022: \u0022ratings.default.svc.cluster.local:9080\/*\u0022\n                   }\n               }\n           ],\n           \u0022includeRequestAttemptCount\u0022: true\n       },\n       \/*省略部分内容*\/\n     ],\n     \u0022validateClusters\u0022: false\n    }\n]\n\u0060\u0060\u0060\n\n从该 Virtual Host 配置中可以看到将流量路由到\u0060outbound|9080||ratings.default.svc.cluster.local\u0060 集群。\n\n**\u0060outbound|9080||ratings.default.svc.cluster.local\u0060 集群的端点**\n\n运行 \u0060istioctl proxy-config endpoint reviews-v1-545db77b95-jkgv2 --port 9080 -o json --cluster \u0022outbound|9080||ratings.default.svc.cluster.local\u0022\u0060 查看集群的 Endpoint 配置，结果如下。\n\n\u0060\u0060\u0060json\n[\n    {\n        \u0022name\u0022: \u0022outbound|9080||ratings.default.svc.cluster.local\u0022,\n        \u0022addedViaApi\u0022: true,\n        \u0022hostStatuses\u0022: [\n            {\n                \u0022address\u0022: {\n                    \u0022socketAddress\u0022: {\n                        \u0022address\u0022: \u002210.4.1.12\u0022,\n                        \u0022portValue\u0022: 9080\n                    }\n                },\n                \u0022stats\u0022: [\n                    {\n                        \u0022name\u0022: \u0022cx_connect_fail\u0022\n                    },\n                    {\n                        \u0022name\u0022: \u0022cx_total\u0022\n                    },\n                    {\n                        \u0022name\u0022: \u0022rq_error\u0022\n                    },\n                    {\n                        \u0022name\u0022: \u0022rq_success\u0022\n                    },\n                    {\n                        \u0022name\u0022: \u0022rq_timeout\u0022\n                    },\n                    {\n                        \u0022name\u0022: \u0022rq_total\u0022\n                    },\n                    {\n                        \u0022type\u0022: \u0022GAUGE\u0022,\n                        \u0022name\u0022: \u0022cx_active\u0022\n                    },\n                    {\n                        \u0022type\u0022: \u0022GAUGE\u0022,\n                        \u0022name\u0022: \u0022rq_active\u0022\n                    }\n                ],\n                \u0022healthStatus\u0022: {\n                    \u0022edsHealthStatus\u0022: \u0022HEALTHY\u0022\n                },\n                \u0022weight\u0022: 1,\n                \u0022locality\u0022: {\n                    \u0022region\u0022: \u0022us-west2\u0022,\n                    \u0022zone\u0022: \u0022us-west2-a\u0022\n                }\n            }\n        ],\n        \u0022circuitBreakers\u0022: {\n            \u0022thresholds\u0022: [\n                {\n                    \u0022maxConnections\u0022: 4294967295,\n                    \u0022maxPendingRequests\u0022: 4294967295,\n                    \u0022maxRequests\u0022: 4294967295,\n                    \u0022maxRetries\u0022: 4294967295\n                },\n                {\n                    \u0022priority\u0022: \u0022HIGH\u0022,\n                    \u0022maxConnections\u0022: 1024,\n                    \u0022maxPendingRequests\u0022: 1024,\n                    \u0022maxRequests\u0022: 1024,\n                    \u0022maxRetries\u0022: 3\n                }\n            ]\n        },\n        \u0022observabilityName\u0022: \u0022outbound|9080||ratings.default.svc.cluster.local\u0022\n    }\n]\n\u0060\u0060\u0060\n\n我们看到端点的地址是 \u006010.4.1.12\u0060。实际上，Endpoint 可以是一个或多个，sidecar 将根据一定规则选择适当的 Endpoint 来路由。至此 \u0060review\u0060 Pod 找到了它上游服务 \u0060rating\u0060 的 Endpoint。\n\n## 小结\n\n本文使用了 Istio 官方提供的 bookinfo 示例，按图索骥得带领读者了解了 sidecar 注入、iptables 透明流量劫持及 sidecar 中流量路由背后的实现细节。Sidecar 模式和流量透明劫持是 Istio 服务网格的特色和基础功能，理解该功能的背后过程及实现细节，将有助于大家理解 Service Mesh 的原理，因此希望读者可以在自己的环境中从头来试验一遍以加深理解。\n\n使用 iptables 做流量劫持只是 service mesh 的数据平面中做流量劫持的方式之一，还有更多的流量劫持方案，下面引用自 [云原生网络代理 MOSN 官网中给出的流量劫持](https:\/\/mosn.io\/docs\/products\/structure\/traffic-hijack\/)部分的描述。\n\n### 使用 iptables 做流量劫持时存在的问题\n\n目前 Istio 使用 iptables 实现透明劫持，主要存在以下三个问题：\n\n1. 需要借助于 conntrack 模块实现连接跟踪，在连接数较多的情况下，会造成较大的消耗，同时可能会造成 track 表满的情况，为了避免这个问题，业内有关闭 conntrack 的做法。\n1. iptables 属于常用模块，全局生效，不能显式的禁止相关联的修改，可管控性比较差。\n1. iptables 重定向流量本质上是通过 loopback 交换数据，outbond 流量将两次穿越协议栈，在大并发场景下会损失转发性能。\n\n上述几个问题并非在所有场景中都存在，比方说某些场景下，连接数并不多，且 NAT 表未被使用到的情况下，iptables 是一个满足要求的简单方案。为了适配更加广泛的场景，透明劫持需要解决上述三个问题。\n\n### 透明劫持方案优化\n\n为了优化 Istio 中的透明流量劫持的性能，业界提出了以下方案。\n\n**使用 Merbridge 开源项目利用 eBPF 劫持流量**\n\n[Merbridge](https:\/\/github.com\/merbridge\/merbridge) 是由 DaoCloud 在 2022 年初开源的的一款利用 eBPF 加速 Istio 服务网格的插件。使用 Merbridge 可以在一定程度上优化数据平面的网络性能。\n\nMerbridge 利用 eBPF 的 \u0060sockops\u0060 和 \u0060redir\u0060 能力，可以直接将数据包从 inbound socket 传输到 outbound socket。eBPF 提供了 \u0060bpf_msg_redirect_hash\u0060 函数可以直接转发应用程序的数据包。\n\n详见 [Istio 服务网格 —— 云原生应用网络构建指南](https:\/\/jimmysong.io\/istio-handbook\/ecosystem\/merbridge.html)。\n\n**使用 tproxy 处理 inbound 流量**\n\ntproxy 可以用于 inbound 流量的重定向，且无需改变报文中的目的 IP\/端口，不需要执行连接跟踪，不会出现 conntrack 模块创建大量连接的问题。受限于内核版本，tproxy 应用于 outbound 存在一定缺陷。目前 Istio 支持通过 tproxy 处理 inbound 流量。\n\n**使用 hook connect 处理 outbound 流量**\n\n为了适配更多应用场景，outbound 方向通过 hook connect 来实现，实现原理如下：\n\n![hook-connect 原理示意图](hook-connect.svg)\n\n无论采用哪种透明劫持方案，均需要解决获取真实目的 IP\/端口的问题，使用 iptables 方案通过 getsockopt 方式获取，tproxy 可以直接读取目的地址，通过修改调用接口，hook connect 方案读取方式类似于 tproxy。\n\n实现透明劫持后，在内核版本满足要求（4.16 以上）的前提下，通过 sockmap 可以缩短报文穿越路径，进而改善 outbound 方向的转发性能。\n\n## 更新说明\n\n下面是本文的几次更新说明。\n\n**2020 年 4 月 27 日，第一版，基于 Istio 1.5**\n\n本文的第一版，基于 Istio 1.5 创作，在此之前，我曾写过基于 Istio 1.1 版本的[理解 Istio Service Mesh 中 Envoy 代理 Sidecar 注入及流量劫持](\/blog\/envoy-sidecar-injection-in-istio-service-mesh-deep-dive\/)，为了更细致的理解 Istio 中透明流量劫持的全过程，专门创作本文。\n\n**2022 年  1 月 17 日，第二版，基于 Istio 1.11**\n\n本文第一版发布后，在社区里获得了比较大的反响，收到了很多读者的评论和留言。基于这些评论，我也发现了第一版中的很多错误，在加上 Istio 版本发布频繁，在近两年的时间内，Istio 已经作出了众多更新，其中不乏重大更新。因此笔者撰写了本文的第二版，修改了之前版本中的纰漏并根据时下 Istio 的最新版本更新了本文。\n\nIstio 1.11 与 Istio 1.1 中的 sidecar 注入和流量劫持环节最大的变化是：\n\n- iptables 改用命令行工具，不再使用 shell 脚本。\n- sidecar inbound 和 outbound 分别指定了端口，而之前是使用同一个端口（15001）。\n\n**2022 年 4 月 24，第三版，基于 Istio  1.13**\n\n这个版本的文章主要是根据当时 Istio 的最新版本更新了文章的部分内容，并重新排版，增加更新说明。\n\nIstio 1.13 相比 Istio 1.11 的变化是 \u0060istioctl proxy-config\u0060 命令的输出有了较大变化。\n\n**2022 年 5 月 6 日，第四版，基于 Istio 1.13**\n\n- 修改了对 \u0060ISTIO_ROUTE\u0060 iptables 规则 2、5 的解释\n- 在示意图中增加了路径 16\n\n**2022 年 5 月 12 日，第五版，基于 Istio 1.13**\n\n- 将 iptables 说明和 sidecar 注入、init 容器部分独立成了两篇单独的博客，以缩减博客的篇幅，见 [Istio 数据平面 Pod 启动过程详解](\/blog\/istio-pod-process-lifecycle\/)和[理解 iptables](\/blog\/understanding-iptables\/)。\n\n**2023 年 7 月 17 日，第六版，基于 Istio 1.13**\n\n- 修改了对 ISTIO_INBOUND 链的说明\n\n## 参考\n\n- [Debugging Envoy and Istiod - istio.io](https:\/\/istio.io\/latest\/docs\/ops\/diagnostic-tools\/proxy-cmd\/)\n- [揭开 Istio Sidecar 注入模型的神秘面纱 - istio.io](https:\/\/istio.io\/latest\/zh\/blog\/2019\/data-plane-setup\/)\n- [MOSN 作为 Sidecar 使用时的流量劫持方案 - mosn.io](https:\/\/mosn.io\/docs\/products\/structure\/traffic-hijack\/)\n', '\/blog\/sidecar-injection-iptables-and-traffic-routing\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文基于 Istio 1.13 版本，介绍了 sidecar 模式及其优势 sidecar 如何注入到数据平面，Envoy 如何做流量劫持和路由转发的，包括 Inbound 流量和 Outbound 流量。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-pod-process-lifecycle/">Istio 数据平面 Pod 启动过程详解</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/05/12</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio 数据平面 Pod 启动过程详解', '本文将为你讲解 Istio 的 Init 容器、Pod 内部进程及启动过程。', '\n本文将为你讲解：\n\n- Istio 中 sidecar 自动注入过程\n- Istio 中的 init 容器启动过程\n- 启用了 Sidecar 自动注入的 Pod 的启动流程\n\n下图中展示了 Istio 数据平面中的 Pod 启动完后的组件。\n\n![Istio 数据平面 Pod 内部组件](istio-pod-lifecycle.webp)\n\n## Istio 中的 sidecar 注入\n\nIstio 中提供了以下两种 sidecar 注入方式：\n\n- 使用 \u0060istioctl\u0060 手动注入。\n- 基于 Kubernetes 的 [突变 webhook 准入控制器（mutating webhook addmission controller](https:\/\/kubernetes.io\/docs\/reference\/access-authn-authz\/admission-controllers\/) 的自动 sidecar 注入方式。\n\n不论是手动注入还是自动注入，sidecar 的注入过程都需要遵循如下步骤：\n\n1. Kubernetes 需要了解待注入的 sidecar 所连接的 Istio 集群及其配置；\n1. Kubernetes 需要了解待注入的 sidecar 容器本身的配置，如镜像地址、启动参数等；\n1. Kubernetes 根据 sidecar 注入模板和以上配置填充 sidecar 的配置参数，将以上配置注入到应用容器的一侧；\n\n使用下面的命令可以手动注入 sidecar。\n\n\u0060\u0060\u0060bash\nistioctl kube-inject -f ${YAML_FILE} | kuebectl apply -f -\n\u0060\u0060\u0060\n\n该命令会使用 Istio 内置的 sidecar 配置来注入，下面使用 Istio 详细配置请参考 [Istio 官网](https:\/\/istio.io\/latest\/docs\/setup\/additional-setup\/sidecar-injection\/#manual-sidecar-injection)。\n\n注入完成后您将看到 Istio 为原有 pod template 注入了 \u0060initContainer\u0060 及 sidecar proxy 相关的配置。\n\n### Init 容器\n\nInit 容器是一种专用容器，它在应用程序容器启动之前运行，用来包含一些应用镜像中不存在的实用工具或安装脚本。\n\n一个 Pod 中可以指定多个 Init 容器，如果指定了多个，那么 Init 容器将会按顺序依次运行。只有当前面的 Init 容器必须运行成功后，才可以运行下一个 Init 容器。当所有的 Init 容器运行完成后，Kubernetes 才初始化 Pod 和运行应用容器。\n\nInit 容器使用 Linux Namespace，所以相对应用程序容器来说具有不同的文件系统视图。因此，它们能够具有访问 Secret 的权限，而应用程序容器则不能。\n\n在 Pod 启动过程中，Init 容器会按顺序在网络和数据卷初始化之后启动。每个容器必须在下一个容器启动之前成功退出。如果由于运行时或失败退出，将导致容器启动失败，它会根据 Pod 的 \u0060restartPolicy\u0060 指定的策略进行重试。然而，如果 Pod 的 \u0060restartPolicy\u0060 设置为 Always，Init 容器失败时会使用 \u0060RestartPolicy\u0060 策略。\n\n在所有的 Init 容器没有成功之前，Pod 将不会变成 \u0060Ready\u0060 状态。Init 容器的端口将不会在 Service 中进行聚集。正在初始化中的 Pod 处于 \u0060Pending\u0060 状态，但应该会将 \u0060Initializing\u0060 状态设置为 true。Init 容器运行完成以后就会自动终止。\n\n关于 Init 容器的详细信息请参考 [Init 容器 - Kubernetes 中文指南\/云原生应用架构实践手册](\/book\/kubernetes-handbook\/objects\/init-containers\/)。\n\n## Init 容器解析\n\nIstio 在 pod 中注入的 Init 容器名为 \u0060istio-init\u0060，我们在上面 Istio 注入完成后的 YAML 文件中看到了该容器的启动命令是：\n\n\u0060\u0060\u0060bash\nistio-iptables -p 15001 -z 15006 -u 1337 -m REDIRECT -i \u0027*\u0027 -x \u0022\u0022 -b \u0027*\u0027 -d 15090,15020\n\u0060\u0060\u0060\n\n我们再检查下该容器的 [Dockerfile](https:\/\/github.com\/istio\/istio\/blob\/master\/pilot\/docker\/Dockerfile.proxyv2) 看看 \u0060ENTRYPOINT\u0060 是怎么确定启动时执行的命令。\n\n\u0060\u0060\u0060docker\n# 前面的内容省略\n# The pilot-agent will bootstrap Envoy.\nENTRYPOINT [\u0022\/usr\/local\/bin\/pilot-agent\u0022]\n\u0060\u0060\u0060\n\n我们看到 \u0060istio-init\u0060 容器的入口是 \u0060\/usr\/local\/bin\/istio-iptables\u0060 命令行，该命令行工具的代码的位置在 Istio 源码仓库的 [tools\/istio-iptables](https:\/\/github.com\/istio\/istio\/tree\/master\/tools\/istio-iptables) 目录。\n\n注意：在 Istio 1.1 版本时还是使用 \u0060isito-iptables.sh\u0060 命令行来操作 IPtables。\n\n### Init 容器启动入口\n\nInit 容器的启动入口是 \u0060istio-iptables\u0060 命令行，该命令行工具的用法如下：\n\n\u0060\u0060\u0060bash\n$ istio-iptables [flags]\n  -p: 指定重定向所有 TCP 流量的 sidecar 端口（默认为 $ENVOY_PORT = 15001）\n  -m: 指定入站连接重定向到 sidecar 的模式，“REDIRECT” 或 “TPROXY”（默认为 $ISTIO_INBOUND_INTERCEPTION_MODE)\n  -b: 逗号分隔的入站端口列表，其流量将重定向到 Envoy（可选）。使用通配符 “*” 表示重定向所有端口。为空时表示禁用所有入站重定向（默认为 $ISTIO_INBOUND_PORTS）\n  -d: 指定要从重定向到 sidecar 中排除的入站端口列表（可选），以逗号格式分隔。使用通配符“*” 表示重定向所有入站流量（默认为 $ISTIO_LOCAL_EXCLUDE_PORTS）\n  -o：逗号分隔的出站端口列表，不包括重定向到 Envoy 的端口。\n  -i: 指定重定向到 sidecar 的 IP 地址范围（可选），以逗号分隔的 CIDR 格式列表。使用通配符 “*” 表示重定向所有出站流量。空列表将禁用所有出站重定向（默认为 $ISTIO_SERVICE_CIDR）\n  -x: 指定将从重定向中排除的 IP 地址范围，以逗号分隔的 CIDR 格式列表。使用通配符 “*” 表示重定向所有出站流量（默认为 $ISTIO_SERVICE_EXCLUDE_CIDR）。\n  -k：逗号分隔的虚拟接口列表，其入站流量（来自虚拟机的）将被视为出站流量。\n  -g：指定不应用重定向的用户的 GID。(默认值与 -u param 相同)\n  -u：指定不应用重定向的用户的 UID。通常情况下，这是代理容器的 UID（默认值是 1337，即 istio-proxy 的 UID）。\n  -z: 所有进入 pod\/VM 的 TCP 流量应被重定向到的端口（默认 $INBOUND_CAPTURE_PORT = 15006）。\n\u0060\u0060\u0060\n\n以上传入的参数都会重新组装成 [\u0060iptables\u0060 ](https:\/\/wangchujiang.com\/linux-command\/c\/iptables.html)规则，关于该命令的详细用法请访问 [tools\/istio-iptables\/pkg\/cmd\/root.go](https:\/\/github.com\/istio\/istio\/blob\/master\/tools\/istio-iptables\/pkg\/cmd\/root.go)。\n\n该容器存在的意义就是让 sidecar 代理可以拦截所有的进出 pod 的流量，15090 端口（Mixer 使用）和 15092 端口（Ingress Gateway）除外的所有入站（inbound）流量重定向到 15006 端口（sidecar），再拦截应用容器的出站（outbound）流量经过 sidecar 处理（通过 15001 端口监听）后再出站。关于 Istio 中端口用途请参考 [Istio 官方文档](https:\/\/istio.io\/latest\/zh\/docs\/ops\/deployment\/requirements\/)。\n\n**命令解析**\n\n这条启动命令的作用是：\n\n- 将应用容器的所有流量都转发到 sidecar 的 15006 端口。\n- 使用 \u0060istio-proxy\u0060 用户身份运行，UID 为 1337，即 sidecar 所处的用户空间，这也是 \u0060istio-proxy\u0060 容器默认使用的用户，见 YAML 配置中的 \u0060runAsUser\u0060 字段。\n- 使用默认的 \u0060REDIRECT\u0060 模式来重定向流量。\n- 将所有出站流量都重定向到 sidecar 代理（通过 15001 端口）。\n\n因为 Init 容器初始化完毕后就会自动终止，因为我们无法登陆到容器中查看 iptables 信息，但是 Init 容器初始化结果会保留到应用容器和 sidecar 容器中。\n\n## Pod 启动流程\n\n启用了 Sidecar 自动注入的 Pod 启动流程如下：\n\n1. Init 容器先启动，向 Pod 中注入 iptables 规则，进行透明流量拦截。\n2. 随后，Kubernetes 会根据 Pod Spec 中容器的声明顺序依次启动容器，但这是非阻塞的，无法保证第一个容器启动完成后才启动下一个。\u0060istio-proxy\u0060 容器启动时，\u0060pilot-agent\u0060 将作为 PID 1 号进程，它是 Linux 用户空间的第一个进程，负责拉起其他进程和处理僵尸进程。\u0060pilot-agent\u0060 将生成 Envoy bootstrap 配置并拉起 \u0060envoy\u0060 进程；应用容器几乎跟 \u0060istio-proxy\u0060 容器同时启动，为了防止 Pod 内的容器在还没启动好的情况而接收到外界流量，这时候就绪探针就派上用场了。Kubernetes 会在 \u0060istio-proxy\u0060 容器的 15021 端口进行就绪检查，直到 \u0060isito-proxy\u0060 启动完成后 kubelet 才会将流量路由到 Pod 内。\n3. 在 Pod 启动完成后，\u0060pilot-agent\u0060  将变为守护进程监视系统其他进程，除此之外，该进程还为 Envoy 提供 Bootstrap 配置、证书、健康检查、配置热加载、身份支持及进程生命周期管理等。\n\n## Pod 内容器启动顺序问题\n\n在 Pod 启动的过程中存在容器启动顺序问题，假设下面这种情况，应用容器先启动，请求其他服务，这时候 \u0060istio-proxy\u0060 容器还没启动完成，那么该请求将会失败，如果你的应用的健壮性不足，甚至可能导致应用容器崩溃，进而 Pod 重启。对于这种情况的解决方案是：\n\n- 修改应用程序，增加超时重试。\n- 增加应用容器中进程的启动延迟，比如增加 \u0060sleep\u0060 时间。\n- 在应用容器中增加一个 [\u0060postStart\u0060](https:\/\/kubernetes.io\/zh\/docs\/tasks\/configure-pod-container\/attach-handler-lifecycle-event\/) 配置，检测应用进程是否启动完成，只有当检测成功时，Kubernetes 才会将 Pod 的状态标记为 \u0060Running\u0060。\n\n## 总结\n\n这篇文章带领大家了解了 Istio 数据平面中的 Pod 启动过程，还有因为 Pod 内容器启动顺序带来的问题。\n\n## 参考\n\n- istio 常见问题：Sidecar 启动顺序问题 - imroc.cc\n', '\/blog\/istio-pod-process-lifecycle\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文将为你讲解 Istio 的 Init 容器、Pod 内部进程及启动过程。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/understanding-iptables/">理解 iptables</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/05/12</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('理解 iptables', '本文将为大家简单介绍下 iptables，其中的表及执行顺序。', '\niptables 作为 Linux 内核中的重要功能，有着广泛的应用，在 Istio 中默认就是利用 iptables 做透明流量劫持的。理解 iptables，对于我们理解 Istio 的运作有十分重要的作用。本文将为大家简单介绍下 iptbles。\n\n## iptables 简介\n\n\u0060iptables\u0060 是 Linux 内核中的防火墙软件 netfilter 的管理工具，位于用户空间，同时也是 netfilter 的一部分。Netfilter 位于内核空间，不仅有网络地址转换的功能，也具备数据包内容修改、以及数据包过滤等防火墙功能。\n\n在了解 Init 容器初始化的 iptables 之前，我们先来了解下 iptables 和规则配置。\n\n下图展示了 iptables 调用链。\n\n![iptables 调用链](iptables.jpg)\n\n[图片来源](https:\/\/stuffphilwrites.com\/wp-content\/uploads\/2014\/09\/FW-IDS-iptables-Flowchart-v2019-04-30-1.png)\n\n## iptables 中的表\n\nInit 容器中使用的的 iptables 版本是 \u0060v1.6.0\u0060，共包含 5 张表：\n\n1. \u0060raw\u0060 用于配置数据包，\u0060raw\u0060 中的数据包不会被系统跟踪。\n1. \u0060filter\u0060 是用于存放所有与防火墙相关操作的默认表。\n1. \u0060nat\u0060 用于 [网络地址转换](https:\/\/en.wikipedia.org\/wiki\/Network_address_translation)（例如：端口转发）。\n1. \u0060mangle\u0060 用于对特定数据包的修改（参考[损坏数据包](https:\/\/en.wikipedia.org\/wiki\/Mangled_packet)）。\n1. \u0060security\u0060 用于[强制访问控制](https:\/\/wiki.archlinux.org\/index.php\/Security#Mandatory_access_control) 网络规则。\n\n**注**：在本示例中只用到了 \u0060nat\u0060 表。\n\n不同的表中的具有的链类型如下表所示：\n\n| 规则名称    | raw  | filter | nat  | mangle | security |\n| ----------- | ---- | ------ | ---- | ------ | -------- |\n| PREROUTING  | ✓    |        | ✓    | ✓      |          |\n| INPUT       |      | ✓      |      | ✓      | ✓        |\n| OUTPUT      | ✓    | ✓      | ✓    | ✓      | ✓        |\n| POSTROUTING |      |        | ✓    | ✓      |          |\n| FORWARD     |      | ✓      |      | ✓      | ✓        |\n\n## 理解 iptables 规则\n\n查看 \u0060istio-proxy\u0060 容器中的默认的 iptables 规则，默认查看的是 filter 表中的规则。\n\n\u0060\u0060\u0060bash\n$ iptables -L -v\nChain INPUT (policy ACCEPT 350K packets, 63M bytes)\n pkts bytes target     prot opt in     out     source               destination\n\nChain FORWARD (policy ACCEPT 0 packets, 0 bytes)\n pkts bytes target     prot opt in     out     source               destination\n\nChain OUTPUT (policy ACCEPT 18M packets, 1916M bytes)\n pkts bytes target     prot opt in     out     source               destination\n\u0060\u0060\u0060\n\n我们看到三个默认的链，分别是 INPUT、FORWARD 和 OUTPUT，每个链中的第一行输出表示链名称（在本例中为 INPUT\/FORWARD\/OUTPUT），后跟默认策略（ACCEPT）。\n\n每条链中都可以添加多条规则，规则是按照顺序从前到后执行的。我们来看下规则的表头定义。\n\n- **pkts**：处理过的匹配的报文数量\n- **bytes**：累计处理的报文大小（字节数）\n- **target**：如果报文与规则匹配，指定目标就会被执行。\n- **prot**：协议，例如 \u0060tdp\u0060、\u0060udp\u0060、\u0060icmp\u0060 和 \u0060all\u0060。\n- **opt**：很少使用，这一列用于显示 IP 选项。\n- **in**：入站网卡。\n- **out**：出站网卡。\n- **source**：流量的源 IP 地址或子网，或者是 \u0060anywhere\u0060。\n- **destination**：流量的目的地 IP 地址或子网，或者是 \u0060anywhere\u0060。\n\n还有一列没有表头，显示在最后，表示规则的选项，作为规则的扩展匹配条件，用来补充前面的几列中的配置。\u0060prot\u0060、\u0060opt\u0060、\u0060in\u0060、\u0060out\u0060、\u0060source\u0060 和 \u0060destination\u0060 和显示在 \u0060destination\u0060 后面的没有表头的一列扩展条件共同组成匹配规则。当流量匹配这些规则后就会执行 \u0060target\u0060。\n\n**target 支持的类型**\n\n\u0060target\u0060 类型包括 ACCEPT\u0060、REJECT\u0060、\u0060DROP\u0060、\u0060LOG\u0060 、\u0060SNAT\u0060、\u0060MASQUERADE\u0060、\u0060DNAT\u0060、\u0060REDIRECT\u0060、\u0060RETURN\u0060 或者跳转到其他规则等。只要执行到某一条链中只有按照顺序有一条规则匹配后就可以确定报文的去向了，除了 \u0060RETURN\u0060 类型，类似编程语言中的 \u0060return\u0060 语句，返回到它的调用点，继续执行下一条规则。\u0060target\u0060 支持的配置详解请参考 [iptables 详解（1）：iptables 概念](http:\/\/www.zsythink.net\/archives\/1199)。\n\n## 总结\n\n以上就是对 iptables 的简要介绍，你已经了解了 iptables 是怎样运行的，规则链及其执行顺序。\n', '\/blog\/understanding-iptables\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文将为大家简单介绍下 iptables，其中的表及执行顺序。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-components-and-ports/">Istio 中的各组件端口及功能详解</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/05/08</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio 中的各组件端口及功能详解', '本文将向你介绍 Istio 控制平面和数据平面的各个端口及功能。', '\n在我的前两篇博客中：\n\n- [Istio 中的 Sidecar 注入、透明流量劫持及流量路由过程详解](https:\/\/jimmysong.io\/blog\/sidecar-injection-iptables-and-traffic-routing\/)\n- [Sidecar 中的流量类型及 iptables 规则详解](https:\/\/jimmysong.io\/blog\/istio-sidecar-traffic-types\/)\n\n我向你详细介绍了 Istio 数据平面中的流量，但数据平面并不能孤立的存在，本文将向你展示 Istio 中的控制平面和数据平面各组件的端口及其功能，有助于你了解这些流量之间的关系及故障排查。\n\n## Istio 中的组件及端口示意图\n\n按照习惯，我们首先展示一个全局示意图。下图展示的是 Istio 数据平面中 sidecar 的组成，以及与其交互的对象。\n\n![Istio sidecar 组成示意图](istio-ports-components.webp)\n\n我们可以使用 \u0060nsenter\u0060 命令进入 Bookinfo 示例的 \u0060productpage\u0060  Pod 的网络空间，查看其内部监听的端口信息。\n\n![Istio sidecar 中监听的端口信息](sidecar-ports.webp)\n\n从图中我们可以看到除了 \u0060productpage\u0060 应用本身监听的 9080 端口以外，Sidecar 容器还有监听大量的其他端口，如 \u006015000\u0060、\u006015001\u0060、\u006015004\u0060、\u006015006\u0060、\u006015021\u0060、\u006015090\u0060 等，你可以在 Istio 文档上了解 Istio 中使用的端口。\n\n我们再进入 \u0060productpage\u0060 Pod 中，使用 \u0060lsof -i\u0060 命令查看它打开的端口，如下图所示。\n\n![Productpage Pod 中打开的端口](product-pod-ports.webp)\n\n我们可以看到其中有 \u0060pilot-agent\u0060 与 \u0060istiod\u0060 建立了 TCP 连接，上文中所述的监听中的端口，还有在 Pod 内部建立的 TCP 连接，这些连接对应了文章开头的示意图。\n\nSidecar 容器（\u0060istio-proxy\u0060 ）的根进程是 \u0060pilot-agent\u0060，启动命令如下图所示：\n\n![Sidecar 中的进程](sidecar-procecces.webp)\n\n从图中我们可以看到，它 \u0060pilot-agent\u0060 进程的 PID 是 1，是它拉起了 \u0060envoy\u0060 进程。\n\n在 \u0060istiod\u0060 的 Pod 中查看它打开的端口，如下图所示。\n\n![Istiod 中的端口](sidecar-lsof.webp)\n\n我们可以看到其中的监听的端口、进程间和远程通信连接。\n\n## Istio 中各端口的功能概述\n\n这些端口在你进行问题排查时可以起着举足轻重的作用。下面将根据端口所在的组件和功能分类描述。\n\n## Istiod 中的端口\n\nIstiod 中的端口相对比较少且功能单一：\n\n- 9876：ControlZ 用户界面，暴露 \u0060istiod\u0060 的进程信息\n- 8080：\u0060istiod\u0060 调试端口，通过该端口可以查询网格的配置和状态信息\n- 15010：暴露 xDS API 和颁发纯文本证书\n- 15012：功能同 15010 端口，但使用 TLS 通信\n- 15014：暴露控制平面的指标给 Prometheus\n- 15017：Sidecar 注入和配置校验端口\n\n## Sidecar 中的端口\n\n从上文中，我们看到 sidecar 中有众多端口：\n\n- 15000：Envoy [管理接口](https:\/\/jimmysong.io\/envoy-handbook\/admin-interface\/enabling-admin-interface.html)，你可以用它来查询和修改 Envoy 代理的的配置，详情请参考 [Envoy 文档](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/operations\/admin)。\n- 15001：用于处理出站流量。\n- 15004：调试端口，将在下文中解释。\n- 15006：用于处理入站流量。\n- 15020：汇总统计数据，对 Envoy 和 DNS 代理进行健康检查，调试 \u0060pilot-agent\u0060  进程，将在下文中详细解释。\n- 15021：用于 sidecar 健康检查，以判断已注入 Pod 是否准备好接收流量。我们在该端口的 \u0060\/healthz\/ready\u0060 路径上设置了就绪探针，Istio 把 sidecar 的就绪检测交给了 \u0060kubelet\u0060，最大化利用 Kubernetes 平台自身的功能。\u0060envoy\u0060  进程将健康检查路由到 \u0060pilot-agent\u0060 进程的 15020 端口，实际的健康检查将发生在那里。\n- 15053：本地 DNS 代理，用于解析 Kubernetes DNS 解析不了的集群内部域名的场景。\n- 15090：Envoy Prometheus 查询端口，\u0060pilot-agent\u0060 将通过此端口收集统计信息。\n\n以上端口可以分为以下几类：\n\n- 负责进程间通信，例如 15001、15006、15053\n- 负责健康检查和信息统计，例如 150021、15090\n- 调试：15000、15004\n\n下文将对几个重点端口详解。\n\n## 15000 端口\n\n15000 是 Envoy 的 Admin 接口，该接口允许我们修改 Envoy，并获得一个视图和查询指标和配置。\n\n管理接口由一个具有多个端点的 REST API 和一个简单的用户界面组成，你可以使用下面的命令开启 \u0060productpage\u0060 Pod 中的 Envoy 管理接口视图。\n\n\u0060\u0060\u0060bash\nkubectl -n default port-forward deploy\/productpage-v1 15000\n\u0060\u0060\u0060\n\n在浏览器中访问 \u0060http:\/\/localhost:15000\u0060，你将看到 Envoy Admin 界面如下图所示。\n\n![Envoy Admin 界面](envoy-admin.webp)\n\n## 15004 端口\n\n通过 \u0060pilot-agent\u0060 代理 \u0060istiod\u0060 8080 端口上的调试端点，你可以进入数据平面 Pod 中访问 localhost 的 15004 端口查询网格信息，其效果与下面的 8080 端口等同。\n\n## 8080 端口\n\n你还可以在本地转发 \u0060istiod\u0060  8080 端口，请运行下面的命令。\n\n\u0060\u0060\u0060bash\nkubectl -n istio-system port-forward deploy\/istiod 8080\n\u0060\u0060\u0060\n\n在浏览器中访问 \u0060http:\/\/localhost:8080\/debug\u0060，你将看到调试端点，如下图所示。\n\n![Pilot 调试控制台](pilot-debug-console.webp)\n\n当然，这只是一种获取网格信息和调试网格的方式，你还可以使用 \u0060istioctl\u0060 命令或 Kiali 来调试，那样将更加高效和直观。\n\n## 15020 端口\n\n15020 端口有三大功能：\n\n1. 汇总统计数据：查询 15090 端口获取 \u0060envoy\u0060 的指标，也可以配置查询应用程序的指标，将 \u0060envoy\u0060、应用程序和自身的指标汇总以供 Prometheus 收集。对应的调试端点是 \u0060\/stats\/prometheus\u0060。\n2. 对 Envoy 和 DNS 代理进行健康检查：对应的调试端点是 \u0060\/healthz\/ready\u0060 和 \u0060\/app-health\u0060。\n3. 调试 \u0060pilot-agent\u0060  进程：对应的调试端点是 \u0060\/quitquitquit\u0060、\u0060debug\/ndsz\u0060 和 \u0060\/debug\/pprof\u0060。\n\n下图展示的是使用本地端口转发后，在浏览器中打开 \u0060http:\/\/localhost:15020\/debug\/pprof\u0060 看到的调试信息。\n\n![pprof 端点](pprof.webp)\n\n图中信息展示的是 \u0060pilot-agent\u0060 的堆栈信息。\n\n## 总结\n\n通过对 Istio 中各组件端口的了解，你应该对 Istio 中各组件的关系及其内部流量有了更进一步的认识，熟悉这些端口的功能，有助于对网格的故障排除。\n', '\/blog\/istio-components-and-ports\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文将向你介绍 Istio 控制平面和数据平面的各个端口及功能。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-sidecar-traffic-types/">Istio sidecar 中的流量类型及 iptables 规则详解</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/05/07</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio sidecar 中的流量类型及 iptables 规则详解', '本文将向你展示 Istio sidecar 中的六种流量类型及其 iptables 规则，并以示意图的形式带你一览其全貌。', '\n我在[之前的一篇博客中](https:\/\/jimmysong.io\/blog\/sidecar-injection-iptables-and-traffic-routing\/)讲解过 Istio 中 sidecar 的注入、使用 iptables 进行透明流量拦截及流量路由的详细过程，并以 Bookinfo 示例中的 \u0060productpage\u0060 服务访问 \u0060reviews\u0060 服务，和 \u0060reviews\u0060 服务访问 \u0060ratings\u0060 服务为例绘制了透明流量劫持示意图。在那个示意图中仅展示了 \u0060reviews\u0060 pod 接收流量和对外访问的路由，实际上 sidecar 内的流量远不止于此。\n\n## ISTIO_OUTPUT 规则\n\n在所有的 iptables 调用链中最复杂的一个是 \u0060ISTIO_OUTPUT\u0060，其中共有 9 条规则如下：\n\n| **Rule** | **Target**        | **In** | **Out** | **Source** | **Destination**                 |\n| -------- | ----------------- | ------ | ------- | ---------- | ------------------------------- |\n| 1        | RETURN            | any    | lo      | 127.0.0.6  | anywhere                        |\n| 2        | ISTIO_IN_REDIRECT | any    | lo      | anywhere   | !localhost owner UID match 1337 |\n| 3        | RETURN            | any    | lo      | anywhere   | anywhere !owner UID match 1337  |\n| 4        | RETURN            | any    | any     | anywhere   | anywhere owner UID match 1337   |\n| 5        | ISTIO_IN_REDIRECT | any    | lo      | anywhere   | !localhost owner GID match 1337 |\n| 6        | RETURN            | any    | lo      | anywhere   | anywhere !owner GID match 1337  |\n| 7        | RETURN            | any    | any     | anywhere   | anywhere owner GID match 1337   |\n| 8        | RETURN            | any    | any     | anywhere   | localhost                       |\n| 9        | ISTIO_REDIRECT    | any    | any     | anywhere   | anywhere                        |\n\n本文将向你展示 Istio sidecar 中的六种流量类型及其 iptables 规则，以示意图的形式带你一览其全貌，其中详细指出了路由具体使用的是 \u0060ISTIO_OUTPUT\u0060 中的哪一条规则。\n\n## Sidecar 中的 iptables 流量路由\n\nSidecar 中的流量可以划分为以下几类：\n\n- 远程服务访问本地服务：Remote Pod -\u003e Local Pod\n- 本地服务访问远程服务：Local Pod -\u003e Remote Pod\n- Prometheus 抓取本地服务的 metrics：Prometheus -\u003e Local Pod\n- 本地 Pod 服务间的流量：Local Pod -\u003e Local Pod\n- Envoy 内部的进程间 TCP 流量\n- Sidecar 到 Istiod 的流量\n\n下面将依次解释每个场景下 Sidecar 内的 iptables 路由规则。\n\n## 类型一：Remote Pod -\u003e Local Pod\n\n以下是远程服务、应用或客户端访问数据平面本地 Pod IP 的 iptables 规则。\n\nRemote Pod -\u003e \u0060RREROUTING\u0060 -\u003e \u0060ISTIO_INBOUND\u0060 -\u003e \u0060ISTIO_IN_REDIRECT\u0060 -\u003e Envoy 15006（Inbound）-\u003e \u0060OUTPUT\u0060 -\u003e **\u0060ISTIO_OUTPUT\u0060 RULE 1** -\u003e \u0060POSTROUTING\u0060 -\u003e Local Pod\n\n我们看到流量只经过一次 Envoy 15006 Inbound 端口。这种场景下的 iptables 规则的示意图如下。\n\n![Remote Pod 到 Local Pod](remote-pod-local-pod.svg)\n\n## 类型二：Local Pod -\u003e Remote Pod\n\n以下是本地 Pod IP 访问远程服务经过的 iptables 规则。\n\nLocal Pod-\u003e \u0060OUTPUT\u0060 -\u003e **\u0060ISTIO_OUTPUT\u0060 RULE 9** -\u003e ISTIO_REDIRECT -\u003e Envoy 15001 (Outbound)-\u003e \u0060OUTPUT\u0060 -\u003e **\u0060ISTIO_OUTPUT\u0060 RULE 4** -\u003e \u0060POSTROUTING\u0060 -\u003e Remote Pod\n\n我们看到流量只经过 Envoy 15001 Outbound 端口。\n\n![Local Pod 到 Remote Pod](local-pod-remote-pod.svg)\n\n以上两种场景中的流量都只经过一次 Envoy，因为该 Pod 中只有发出或接受请求一种场景发生。\n\n## 类型三：Prometheus -\u003e Local Pod\n\nPrometheus 抓取数据平面 metrics 的流量不会也无须经过 Envoy 代理。\n\n这些流量通过的 iptables 规则如下。\n\nPrometheus-\u003e \u0060RREROUTING\u0060 -\u003e \u0060ISTIO_INBOUND\u0060（对目的地为 15020、15090 端口流量将转到 \u0060INPUT\u0060）-\u003e \u0060INPUT\u0060 -\u003e  Local Pod\n\n这种场景下的 iptables 规则的示意图如下。\n\n![Prometheus 到 Local Pod](prometheus-local-pod.svg)\n\n## 类型四：Local Pod -\u003e Local Pod\n\n一个 Pod 可能同时存在两个或多个服务，如果 Local Pod 访问的服务也在该当前 Pod 上，流量会依次经过 Envoy 15001 和 Envoy 15006 端口最后到达本地 Pod 的服务端口上。\n\n这些流量通过的 iptables 规则如下。\n\nLocal Pod-\u003e \u0060OUTPUT\u0060 -\u003e **\u0060ISTIO_OUTPUT\u0060 RULE 9** -\u003e \u0060ISTIO_REDIRECT\u0060 -\u003e Envoy 15001（Outbound）-\u003e \u0060OUTPUT\u0060 -\u003e **\u0060ISTIO_OUTPUT\u0060 RULE 2** -\u003e \u0060ISTIO_IN_REDIRECT\u0060 -\u003e Envoy 15006（Inbound）-\u003e \u0060OUTPUT\u0060 -\u003e **\u0060ISTIO_OUTPUT\u0060 RULE 1** -\u003e \u0060POSTROUTING\u0060 -\u003e Local Pod\n\n![Local Pod 到 Local Pod](local-pod-local-pod.svg)\n\n## 类型五：Envoy 内部的进程间 TCP 流量\n\nEnvoy 内部进程的 UID 和 GID 为 1337，它们之间的流量将使用 lo 网卡，使用 localhost 域名来通信。\n\n这些流量通过的 iptables 规则如下。\n\nEnvoy 进程（Localhost） -\u003e \u0060OUTPUT\u0060 -\u003e **\u0060ISTIO_OUTPUT\u0060 RULE 8** -\u003e \u0060POSTROUTING\u0060 -\u003e Envoy 进程（Localhost）\n\n![Envoy 内部的进程间 TCP 流量](envoy-internal-tcp-traffic.svg)\n\n## 类型六：Sidecar 到 Istiod 的流量\n\nSidecar 需要访问 Istiod 以同步配置，\u0060pilot-agent\u0060 进程会向 Istiod 发送请求，以同步配置。\n\n这些流量通过的 iptables 规则如下。\n\n\u0060pilot-agent\u0060 进程 -\u003e \u0060OUTPUT\u0060 -\u003e **\u0060Istio_OUTPUT\u0060 RULE 9** -\u003e Envoy 15001 (Outbound Handler) -\u003e OUTPUT -\u003e **\u0060ISTIO_OUTPUT\u0060 RULE 4** -\u003e \u0060POSTROUTING\u0060  -\u003e Istiod\n\n![Sidecar 到 Istiod 的流量](sidecar-istiod.svg)\n\n## 总结\n\nIstio 注入在 Pod 内或虚拟机中安装的所有 sidecar 代理组成了服务网格的数据平面，也是 Istio 的主要工作负载所在地，通过 [Istio 中的透明流量劫持](https:\/\/jimmysong.io\/blog\/sidecar-injection-iptables-and-traffic-routing\/) 及这篇博客，相信你一定对 sidecar 代理中的流量有了一个深刻的了解，但这还只是管中窥豹，略见一斑，在我的[下一篇博客](https:\/\/jimmysong.io\/blog\/istio-components-and-ports\/)中，我将带你了解 Envoy 中各个组件的端口及其功能，这样可以让我们对 Istio 中的流量有一个更全面的了解。\n', '\/blog\/istio-sidecar-traffic-types\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文将向你展示 Istio sidecar 中的六种流量类型及其 iptables 规则，并以示意图的形式带你一览其全貌。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
          <div class="col-12">
 
 
 
 
 
 
 
 
 
 
 
 <nav aria-label="Page navigation">
   <ul class="pagination justify-content-center">
     
     
     <li class="page-item">
       <a class="page-link" href="/blog/">
         ««
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a href="/blog/page/14/" class="page-link">
         «
       </a>
     </li>
     
     
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item">
           <a href="/blog/page/13/" class="page-link">
             13
           </a>
         </li>
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item">
           <a href="/blog/page/14/" class="page-link">
             14
           </a>
         </li>
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item page-item active ">
           <a href="/blog/page/15/" class="page-link">
             15
           </a>
         </li>
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item">
           <a href="/blog/page/16/" class="page-link">
             16
           </a>
         </li>
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item">
           <a href="/blog/page/17/" class="page-link">
             17
           </a>
         </li>
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
     
     
     <li class="page-item">
       <a href="/blog/page/16/" class="page-link">
         »
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a class="page-link" href="/blog/page/25/">
         »»
       </a>
     </li>
     
   </ul>
 </nav>
 
</div>

        </div>
      </div>
      <!-- sidebar -->
      <aside class="col-lg-4 order-1 order-lg-2 d-none d-sm-block">
          <div class="sidebar">
          <!-- categories -->
<div class="blog-categories mb-4">
  <p class="sidebar-title">
      专栏
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/istio" class="sidebar-item">
            <span>Istio</span>
            <span>(69)</span>
        </a>
      
        <a href="/categories/service-mesh" class="sidebar-item">
            <span>Service Mesh</span>
            <span>(38)</span>
        </a>
      
        <a href="/categories/kubernetes" class="sidebar-item">
            <span>Kubernetes</span>
            <span>(24)</span>
        </a>
      
        <a href="/categories/%e9%9a%8f%e7%ac%94" class="sidebar-item">
            <span>随笔</span>
            <span>(20)</span>
        </a>
      
        <a href="/categories/%e4%b8%9a%e6%80%81" class="sidebar-item">
            <span>业态</span>
            <span>(17)</span>
        </a>
      
        <a href="/categories/envoy" class="sidebar-item">
            <span>Envoy</span>
            <span>(15)</span>
        </a>
      
        <a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f" class="sidebar-item">
            <span>云原生</span>
            <span>(13)</span>
        </a>
      
        <a href="/categories/%e5%85%b6%e4%bb%96" class="sidebar-item">
            <span>其他</span>
            <span>(13)</span>
        </a>
      
        <a href="/categories/ai" class="sidebar-item">
            <span>AI</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%ae%89%e5%85%a8" class="sidebar-item">
            <span>安全</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%bc%80%e6%ba%90" class="sidebar-item">
            <span>开源</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%8f%af%e8%a7%82%e6%b5%8b%e6%80%a7" class="sidebar-item">
            <span>可观测性</span>
            <span>(5)</span>
        </a>
      
        <a href="/categories/%e5%ae%b9%e5%99%a8" class="sidebar-item">
            <span>容器</span>
            <span>(4)</span>
        </a>
      
        <a href="/categories/%e6%97%85%e8%a1%8c" class="sidebar-item">
            <span>旅行</span>
            <span>(4)</span>
        </a>
  </div>
</div>

<div class="blog-categories mb-4">
  <p class="sidebar-title">
      资料
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/%e5%87%ba%e7%89%88%e7%89%a9" class="sidebar-item">
            <span>出版物</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e7%94%b5%e5%ad%90%e4%b9%a6" class="sidebar-item">
            <span>翻译电子书</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e6%96%87%e6%a1%a3" class="sidebar-item">
            <span>翻译文档</span>
            <span>(7)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>翻译图书</span>
            <span>(6)</span>
        </a>
      
        <a href="/categories/%e5%8e%9f%e5%88%9b%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>原创图书</span>
            <span>(2)</span>
        </a>
      
        <a href="/categories/%e6%95%99%e7%a8%8b%e6%89%8b%e5%86%8c" class="sidebar-item">
            <span>教程手册</span>
            <span>(1)</span>
        </a>
  </div>
</div>





          </div>
      </aside>
      <!-- /sidebar -->
    </div>
  </div>
</section>




<footer>
  
  <div class="footer bg-footer section-sm border-bottom overlay ">
    <div class="container-xl">
      <div class="row">
        <div class="col col-xl-4 d-sm-none mb-2 mb-lg-0 d-xl-block d-none">
          
          <p class="h3 text-white mb-4 text-uppercase">联系</p>
          
          <ul class="list-unstyled">
            
            
            <li class="mb-4 text-color">微信公众号</li>
            
            
            <li class="mb-4"><img src="/images/servicemesher-wechat.webp" width="118px" height="118px" alt="footer image"></li>
            
            
            
          
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">博客</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/blog/istio-configuration-safety-common-misconfigurations/">Istio 配置安全：如何避免错误配置</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/securing-istio-addressing-critical-security-gaps-and-best-practices/">保障 Istio 安全：解决关键安全漏洞及最佳实践</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/ulanqab-trip/">乌兰察布之旅：探索火山与失落的村庄</a></li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">链接</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://istio.io/latest/zh/" target="_blank" rel="noopener noreferrer">
                  Istio 服务网格
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://tetrate.io/?jimmysong" target="_blank" rel="noopener noreferrer">
                  Tetrate 公司
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener noreferrer">
                  云原生学院|Bilibili
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/awesome-cloud-native/" target="_blank" rel="noopener noreferrer">
                  云原生开源项目大全
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://cloudnative.to" target="_blank" rel="noopener noreferrer">
                  云原生社区（中国）
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">教程</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/envoy-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Envoy 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/istio-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Istio 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/kubernetes-handbook/" >
                  Kubernetes 基础教程
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">通知</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/notice/kubecon-china-2024-panel/">KubeCon China 2024 圆桌论坛预告：Istio 和现代 API 网关——引领服务网格的未来</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/website-revamp-notice/">网站改版通知</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/cloud-native-meetup-dalian-2024/">2024 大连云原生技术开放日</a></li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>

  
  <div class="copyright py-4 bg-footer overlay">
    <div class="container-xl">
      <div class="row">
        <div class="col-sm-6 text-sm-left text-center">
          <p class="mb-0 text-color">© 2017-2024 Jimmy Song 保留所有权利</p>
        </div>
        <div class="col-sm-6 text-sm-right text-center">
          <ul class="list-inline">
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://twitter.com/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-x-twitter text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/contact/" >
                    <i class="fa-brands fa-weixin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://github.com/rootsongjc" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-github text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://linkedin.com/in/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-linkedin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="mailto:rootsongjc@gmail.com" >
                    <i class="fa-solid fa-envelope text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/blog/index.xml" >
                    <i class="fa-solid fa-rss text-white"></i>
              </a>
            </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>


<!-- JS Plugins -->

<script src="/plugins/popper/popper.min.js"></script>

<script src="/plugins/bootstrap/bootstrap.min.js"></script>

<script src="/plugins/slick/slick.min.js"></script>

<script src="/plugins/filterizr/jquery.filterizr.min.js"></script>

<script src="/plugins/search/fuse.min.js"></script>

<script src="/plugins/search/mark.js"></script>

<script src="/plugins/hex_md5/hex_md5.js"></script>

<script src="/plugins/anchor/anchor.min.js"></script>

<script src="/plugins/tocbot/tocbot.min.js"></script>

<script src="/plugins/bigger-picture/bigger-picture.min.js"></script>


<!-- Main Script -->

<script src="/js/script.min.f94c22b1d478bfc9e2e0a7d954429e47b7e6d36edd423758482e04154ae1842e.js"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-ESY906ZWZ0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ESY906ZWZ0');
</script>


<!-- Baidu analysis -->
<meta name="baidu-site-verification" content="g8IYR9SNLF" />


<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?11f7d254cfa4e0ca44b175c66d379ecc";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>




<script>
    anchors.add();
</script>






<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>










<script src="/js/wowchemy-search.min.7a37268e7bbe4a9160c2e4c33b749816.js" type="module"></script>
<script id="search-hit-fuse-template" type="text/x-template">
  <div class="search-hit" id="summary-{{key}}">
    <div class="search-hit-content border-bottom">
      <div class="search-hit-name">
        <div class='search-hit-link'><a href="{{relpermalink}}">{{title}}</a></div>
        <div class="search-hit-metadata d-flex">
            <span class="mr-1"><i class="fa-regular fa-calendar mr-1"></i>{{date}}</span>
            <span class="mr-1"><i class="fa-regular fa-folder-open mr-1"></i>{{section}}</span>
            <span class="d-sm-block d-none"><i class="fa-solid fa-link mr-1"></i>{{relpermalink}}</span>
        </div>
        <div class="search-hit-description">{{snippet}}</div>
      </div>
    </div>
  </div>
</script>



    </body>
</html>
